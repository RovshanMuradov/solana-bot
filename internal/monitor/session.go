// internal/monitor/session.go
package monitor

import (
	"context"
	"errors"
	"math"
	"sync"
	"time"

	"github.com/gagliardetto/solana-go"
	"github.com/rovshanmuradov/solana-bot/internal/dex"
	"github.com/rovshanmuradov/solana-bot/internal/task"
	"go.uber.org/zap"
)

// SessionConfig contains configuration for a monitoring session
type SessionConfig struct {
	Task            *task.Task    // —Å—Å—ã–ª–∫–∞ –Ω–∞ –∏—Å—Ö–æ–¥–Ω—É—é –∑–∞–¥–∞—á—É
	TokenBalance    uint64        // Raw token balance in smallest units
	InitialPrice    float64       // Initial token price
	DEX             dex.DEX       // DEX adapter
	Logger          *zap.Logger   // Logger
	MonitorInterval time.Duration // –ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω—ã
}

// MonitoringSession –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–µ—Å—Å–∏—é –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π –Ω–∞ DEX.
type MonitoringSession struct {
	config       *SessionConfig
	priceMonitor *PriceMonitor
	wg           sync.WaitGroup
	ctx          context.Context
	cancel       context.CancelFunc
	logger       *zap.Logger
	priceUpdates chan PriceUpdate
	errChan      chan error
}

// NewMonitoringSession —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞.
func NewMonitoringSession(parentCtx context.Context, config *SessionConfig) *MonitoringSession {
	ctx, cancel := context.WithCancel(parentCtx)
	return &MonitoringSession{
		config:       config,
		logger:       config.Logger,
		ctx:          ctx,
		cancel:       cancel,
		priceUpdates: make(chan PriceUpdate),
		errChan:      make(chan error),
	}
}

// Start –∑–∞–ø—É—Å–∫–∞–µ—Ç —Å–µ—Å—Å–∏—é –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞.
func (ms *MonitoringSession) Start() error {
	t := ms.config.Task // üëà –ø—Ä–æ—Å—Ç–æ –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏

	ms.logger.Info("Preparing monitoring session",
		zap.String("token", t.TokenMint),
		zap.Float64("initial_investment_sol", t.AmountSol))

	initialPrice := ms.config.InitialPrice

	// 1. Get token balance through the DEX adapter
	ctx, cancel := context.WithTimeout(ms.ctx, 5*time.Second)
	raw, err := ms.config.DEX.GetTokenBalance(ctx, t.TokenMint)
	if err != nil {
		ms.logger.Error("Failed to fetch token balance", zap.Error(err))
	} else {
		ms.config.TokenBalance = raw
	}

	var minTokenDecimals uint8 = 6 // DefaultTokenDecimals

	// 2. Calculate actual token amount with correct decimals through DEX
	initialTokens := 0.0
	if ms.config.TokenBalance > 0 {
		// Get token decimals from the blockchain
		tokenPK := solana.MustPublicKeyFromBase58(t.TokenMint)
		dec, err := getTokenDecimals(ctx, ms.config.DEX, tokenPK, minTokenDecimals)
		if err != nil {
			ms.logger.Warn("Failed to get token decimals, using default", zap.Error(err), zap.Uint8("default_decimals", minTokenDecimals))
			dec = minTokenDecimals
		}

		initialTokens = float64(ms.config.TokenBalance) / math.Pow10(int(dec))
	}
	cancel()

	// 3. Calculate real purchase price from SOL spent / tokens received
	if initialTokens > 0 {
		initialPrice = t.AmountSol / initialTokens
	}

	ms.logger.Info("Monitor start",
		zap.String("token", t.TokenMint),
		zap.Float64("initial_price", initialPrice),
		zap.Float64("initial_tokens", initialTokens),
		zap.Uint64("initial_tokens_raw", ms.config.TokenBalance))

	ms.config.InitialPrice = initialPrice

	// Only update AutosellAmount if we've determined a valid token amount
	if initialTokens > 0 {
		t.AutosellAmount = initialTokens
	}

	// –°–æ–∑–¥–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä —Ü–µ–Ω
	ms.priceMonitor = NewPriceMonitor(
		ms.ctx,
		ms.config.DEX,
		t.TokenMint,
		initialPrice,
		initialTokens,
		t.AmountSol,
		ms.config.MonitorInterval,
		ms.logger.Named("price"),
		ms.onPriceUpdate,
	)

	// Start the price monitor in a goroutine
	ms.wg.Add(1)
	go func() {
		defer ms.wg.Done()
		ms.priceMonitor.Start()
	}()

	return nil
}

// Wait –æ–∂–∏–¥–∞–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞.
func (ms *MonitoringSession) Wait() error {
	ms.wg.Wait()
	return nil
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–µ—Å—Å–∏—é –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞.
func (ms *MonitoringSession) Stop() {
	ms.logger.Debug("Stopping monitoring session...")

	// Stop the price monitor (cancels its context)
	if ms.priceMonitor != nil {
		ms.priceMonitor.Stop()
		ms.logger.Debug("Price monitor stop signal sent.")
	}

	// Cancel the main session context
	if ms.cancel != nil {
		ms.cancel()
		ms.logger.Debug("Main session context cancelled.")
	}

	// –ñ–¥–µ–º, –ø–æ–∫–∞ –≥–æ—Ä—É—Ç–∏–Ω–∞, –∑–∞–ø—É—â–µ–Ω–Ω–∞—è –≤ Start –¥–ª—è priceMonitor.Start(),
	// –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –ø–æ—Å–ª–µ –æ—Ç–º–µ–Ω—ã –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.
	doneChan := make(chan struct{})
	go func() {
		ms.wg.Wait() // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –≥–æ—Ä—É—Ç–∏–Ω –≤ –≥—Ä—É–ø–ø–µ
		close(doneChan)
	}()

	// –î–∞–µ–º –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ, –Ω–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º –Ω–∞–≤—Å–µ–≥–¥–∞
	select {
	case <-doneChan:
		ms.logger.Debug("Monitoring goroutine finished gracefully.")
	case <-time.After(5 * time.Second): // –¢–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è
		ms.logger.Warn("Timeout waiting for monitoring goroutine to finish.")
	}

	// –ó–∞–∫—Ä—ã–≤–∞–µ–º –∫–∞–Ω–∞–ª—ã –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –∏ –æ—à–∏–±–æ–∫
	close(ms.priceUpdates)
	close(ms.errChan)

	ms.logger.Debug("Monitoring session Stop completed.")
}

// PriceUpdates –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞–Ω–∞–ª –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —Ü–µ–Ω—ã
func (ms *MonitoringSession) PriceUpdates() <-chan PriceUpdate {
	return ms.priceUpdates
}

// Err –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞–Ω–∞–ª –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—à–∏–±–æ–∫
func (ms *MonitoringSession) Err() <-chan error {
	return ms.errChan
}

// onPriceUpdate –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ü–µ–Ω—ã —Ç–æ–∫–µ–Ω–∞.
//
// –ú–µ—Ç–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ü–µ–Ω–µ –≤ –∫–∞–Ω–∞–ª priceUpdates.
func (ms *MonitoringSession) onPriceUpdate(update PriceUpdate) {
	// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–µ—Å—Å–∏–∏ –ø–µ—Ä–µ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º –æ–ø–µ—Ä–∞—Ü–∏–π
	select {
	case <-ms.ctx.Done():
		ms.logger.Debug("Session context is done, skipping onPriceUpdate logic")
		return
	default:
		// –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –∞–∫—Ç–∏–≤–µ–Ω
	}

	// –°–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π –≤ —ç—Ç–æ–º –º–µ—Ç–æ–¥–µ,
	// —É–Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–Ω—ã–π –æ—Ç –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å–µ—Å—Å–∏–∏
	ctx, cancel := context.WithTimeout(ms.ctx, 5*time.Second)
	defer cancel()

	// –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω–æ–≤, –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
	updatedBalance, err := ms.updateTokenBalance(ctx, update.Tokens)
	if err != nil {
		if !errors.Is(err, context.Canceled) {
			// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—à–∏–±–∫—É –≤ –∫–∞–Ω–∞–ª, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ –æ—Ç–º–µ–Ω–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
			select {
			case ms.errChan <- err:
				ms.logger.Debug("Sent balance update error to error channel")
			case <-ms.ctx.Done():
				ms.logger.Debug("Context canceled while trying to send error")
			default:
				ms.logger.Warn("Error channel blocked, dropping error", zap.Error(err))
			}
		}
		return
	}

	// –°–æ–∑–¥–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π PriceUpdate —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º –±–∞–ª–∞–Ω—Å–æ–º
	updatedPriceUpdate := PriceUpdate{
		Current: update.Current,
		Initial: update.Initial,
		Percent: update.Percent,
		Tokens:  updatedBalance,
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤ –∫–∞–Ω–∞–ª
	select {
	case ms.priceUpdates <- updatedPriceUpdate:
		ms.logger.Debug("Sent price update to channel")
	case <-ms.ctx.Done():
		ms.logger.Debug("Context canceled while trying to send price update")
	default:
		ms.logger.Warn("Price update channel blocked, dropping update")
	}
}

// getTokenDecimals –æ–±–µ—Ä—Ç–∫–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Å—è—Ç–∏—á–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤ —Ç–æ–∫–µ–Ω–∞ –æ—Ç DEX
func getTokenDecimals(ctx context.Context, dexAdapter dex.DEX, tokenMint solana.PublicKey, defaultDecimals uint8) (uint8, error) {
	// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø DEX
	switch d := dexAdapter.(type) {
	case interface {
		getTokenDecimals(context.Context, solana.PublicKey, uint8) uint8
	}:
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
		return d.getTokenDecimals(ctx, tokenMint, defaultDecimals), nil
	default:
		return defaultDecimals, errors.New("DEX adapter does not support getTokenDecimals")
	}
}

// updateTokenBalance –æ–±–Ω–æ–≤–ª—è–µ—Ç –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω–æ–≤.
//
// –§—É–Ω–∫—Ü–∏—è –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω–æ–≤ –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –µ–≥–æ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.
// –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –æ—Ç –≤—ã–∑—ã–≤–∞—é—â–µ–π —Ñ—É–Ω–∫—Ü–∏–∏.
func (ms *MonitoringSession) updateTokenBalance(ctx context.Context, currentAmount float64) (float64, error) {
	t := ms.config.Task

	// –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω–∞
	tokenBalanceRaw, err := ms.config.DEX.GetTokenBalance(ctx, t.TokenMint)
	if err != nil {
		ms.logger.Error("Failed to get token balance", zap.Error(err))
		return currentAmount, err
	}

	// –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–∏ ‚Äî –æ–±–Ω–æ–≤–∏–º –ª–æ–∫–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
	updatedBalance := currentAmount
	if tokenBalanceRaw > 0 {
		// –ü–æ–ª—É—á–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –¥–µ—Å—è—Ç–∏—á–Ω—É—é —Ç–æ—á–Ω–æ—Å—Ç—å
		tokenPK := solana.MustPublicKeyFromBase58(t.TokenMint)
		var defaultDecimals uint8 = 6
		dec, err := getTokenDecimals(ctx, ms.config.DEX, tokenPK, defaultDecimals)
		if err != nil {
			ms.logger.Warn("Using default decimals for balance update", zap.Error(err))
			dec = defaultDecimals
		}

		newBalance := float64(tokenBalanceRaw) / math.Pow10(int(dec))
		if math.Abs(newBalance-currentAmount) > 0.000001 && newBalance > 0 {
			ms.logger.Debug("Token balance changed",
				zap.Float64("old_balance", currentAmount),
				zap.Float64("new_balance", newBalance),
				zap.Uint8("decimals", dec))
			ms.config.TokenBalance = tokenBalanceRaw
			updatedBalance = newBalance
		}
	}

	return updatedBalance, nil
}
