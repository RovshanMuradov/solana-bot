// internal/dex/raydium/client.go - это пакет, который содержит в себе реализацию клиента для работы с декстером Raydium
package raydium

import (
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"time"

	"github.com/gagliardetto/solana-go"
	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
	solanarpc "github.com/gagliardetto/solana-go/rpc"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
	"go.uber.org/zap"
)

// NewRaydiumClient создает новый экземпляр клиента Raydium с дефолтными настройками
func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*Client, error) {
	logger = logger.Named("raydium-client")

	// Создаем базового клиента через фабрику
	solClient, err := solbc.NewClient(
		[]string{rpcEndpoint},
		wallet,
		logger,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create solana client: %w", err)
	}

	// Создаем кэш пулов
	poolCache := NewPoolCache(logger)

	// Пытаемся загрузить пулы из файла
	if err := poolCache.LoadPoolsFromFile("mainnet.json"); err != nil {
		// Логируем ошибку, но не прерываем создание клиента
		// так как мы всё равно можем искать пулы on-chain
		logger.Warn("Failed to load pools from mainnet.json",
			zap.Error(err),
			zap.String("fallback", "will use on-chain lookup"))
	} else {
		logger.Info("Successfully loaded pools from mainnet.json",
			zap.Int("pools_count", poolCache.GetPoolsCount()))
	}

	// Создаем клиент с дефолтными настройками
	client := &Client{
		client:      solClient,
		logger:      logger,
		privateKey:  wallet,
		timeout:     30 * time.Second,
		retries:     3,
		priorityFee: 1000,
		commitment:  solanarpc.CommitmentConfirmed,
		poolCache:   poolCache,
	}

	// Если файл не загружен, пытаемся получить данные о пулах on-chain
	if !poolCache.IsLoaded() {
		logger.Info("Starting initial pool sync from chain...")
		if err := client.syncPoolsFromChain(context.Background()); err != nil {
			logger.Warn("Failed to sync pools from chain",
				zap.Error(err),
				zap.String("impact", "pool discovery may be slower"))
		}
	}

	return client, nil
}

// syncPoolsFromChain получает информацию о пулах из блокчейна
func (c *Client) syncPoolsFromChain(ctx context.Context) error {
	// Получаем все аккаунты программы Raydium V4
	accounts, err := c.client.GetProgramAccounts(
		ctx,
		RaydiumV4ProgramID,
		solanarpc.GetProgramAccountsOpts{
			Filters: []solanarpc.RPCFilter{
				{
					DataSize: 388, // Размер данных аккаунта пула
				},
			},
		},
	)
	if err != nil {
		return fmt.Errorf("failed to get program accounts: %w", err)
	}

	c.logger.Info("Found pool accounts", zap.Int("count", len(accounts)))

	// Обрабатываем каждый аккаунт
	for _, acc := range accounts {
		pool, err := c.parsePoolAccount(acc)
		if err != nil {
			c.logger.Debug("Failed to parse pool account",
				zap.String("pubkey", acc.Pubkey.String()),
				zap.Error(err))
			continue
		}

		// Сохраняем пул в кэш
		if err := c.poolCache.AddPool(pool); err != nil {
			c.logger.Debug("Failed to cache pool",
				zap.String("pool_id", pool.ID.String()),
				zap.Error(err))
		}
	}

	return nil
}

// Добавим также вспомогательный метод для получения публичного ключа
func (c *Client) GetPublicKey() solana.PublicKey {
	return c.privateKey.PublicKey()
}

// Добавим метод для подписания транзакций
func (c *Client) SignTransaction(tx *solana.Transaction) error {
	_, err := tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
		if key.Equals(c.GetPublicKey()) {
			return &c.privateKey
		}
		return nil
	})
	return err
}

// Добавим метод для проверки баланса кошелька
func (c *Client) CheckWalletBalance(ctx context.Context) (uint64, error) {
	balance, err := c.client.GetBalance(
		ctx,
		c.GetPublicKey(),
		solanarpc.CommitmentConfirmed,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to get wallet balance: %w", err)
	}
	return balance, nil
}

// Добавим метод для получения ATA (Associated Token Account)
func (c *Client) GetAssociatedTokenAccount(mint solana.PublicKey) (solana.PublicKey, error) {
	ata, _, err := solana.FindAssociatedTokenAddress(
		c.GetPublicKey(),
		mint,
	)
	if err != nil {
		return solana.PublicKey{}, fmt.Errorf("failed to find associated token address: %w", err)
	}
	return ata, nil
}

// GetPool реализует полную логику поиска пула:
// 1. Проверяет кэш (использует pc.GetPool)
// 2. Проверяет JSON файл (использует pc.findPoolInJson)
// 3. Ищет в блокчейне (использует c.findPoolOnChain)
func (c *Client) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*Pool, error) {
	c.logger.Debug("getting raydium pool info",
		zap.String("baseMint", baseMint.String()),
		zap.String("quoteMint", quoteMint.String()),
	)

	// Сначала проверяем кэш
	if pool := c.poolCache.GetPool(baseMint, quoteMint); pool != nil {
		c.logger.Debug("pool found in cache",
			zap.String("poolId", pool.ID.String()))
		return pool, nil
	}

	// Если в кэше нет, ищем в блокчейне
	c.logger.Debug("pool not found in cache, searching on-chain")

	// Получаем программные аккаунты через интерфейс
	accounts, err := c.client.GetProgramAccounts(
		ctx,
		RaydiumV4ProgramID,
		solanarpc.GetProgramAccountsOpts{
			Filters: []solanarpc.RPCFilter{
				{
					DataSize: 388,
				},
				{
					Memcmp: &solanarpc.RPCFilterMemcmp{
						Offset: 8,
						Bytes:  baseMint.Bytes(),
					},
				},
				{
					Memcmp: &solanarpc.RPCFilterMemcmp{
						Offset: 40,
						Bytes:  quoteMint.Bytes(),
					},
				},
			},
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get program accounts: %w", err)
	}

	if len(accounts) == 0 {
		// Пробуем поменять порядок токенов и поискать снова
		accounts, err = c.client.GetProgramAccounts(
			ctx,
			RaydiumV4ProgramID,
			solanarpc.GetProgramAccountsOpts{
				Filters: []solanarpc.RPCFilter{
					{
						DataSize: 388,
					},
					{
						Memcmp: &solanarpc.RPCFilterMemcmp{
							Offset: 8,
							Bytes:  quoteMint.Bytes(),
						},
					},
					{
						Memcmp: &solanarpc.RPCFilterMemcmp{
							Offset: 40,
							Bytes:  baseMint.Bytes(),
						},
					},
				},
			},
		)
		if err != nil {
			return nil, fmt.Errorf("failed to get program accounts with reversed tokens: %w", err)
		}
	}

	if len(accounts) == 0 {
		return nil, fmt.Errorf("pool not found for tokens %s and %s",
			baseMint.String(), quoteMint.String())
	}

	// Парсим найденный пул
	pool, err := c.parsePoolAccount(accounts[0])
	if err != nil {
		return nil, fmt.Errorf("failed to parse pool account: %w", err)
	}

	// Сохраняем в кэш для будущих запросов
	if err := c.poolCache.AddPool(pool); err != nil {
		c.logger.Warn("failed to cache pool",
			zap.String("pool_id", pool.ID.String()),
			zap.Error(err))
	}

	return pool, nil
}

// parsePoolAccount вынесен в отдельный метод для переиспользования
func (c *Client) parsePoolAccount(account solanarpc.KeyedAccount) (*Pool, error) {
	// Получаем authority пула через PDA
	authority, _, err := solana.FindProgramAddress(
		[][]byte{[]byte("amm_authority")},
		RaydiumV4ProgramID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to derive authority: %w", err)
	}

	// Парсим данные аккаунта
	data := account.Account.Data.GetBinary()
	if len(data) < 388 {
		return nil, fmt.Errorf("invalid pool account data length: %d", len(data))
	}

	// Извлекаем mint адреса из данных
	baseMint := solana.PublicKeyFromBytes(data[8:40])
	quoteMint := solana.PublicKeyFromBytes(data[40:72])

	pool := &Pool{
		ID:            account.Pubkey,
		Authority:     authority,
		BaseMint:      baseMint,
		QuoteMint:     quoteMint,
		BaseVault:     solana.PublicKeyFromBytes(data[72:104]),
		QuoteVault:    solana.PublicKeyFromBytes(data[104:136]),
		BaseDecimals:  data[136],
		QuoteDecimals: data[137],
		DefaultFeeBps: binary.LittleEndian.Uint16(data[138:140]),
	}

	c.logger.Debug("parsed pool info",
		zap.String("poolId", pool.ID.String()),
		zap.String("baseVault", pool.BaseVault.String()),
		zap.String("quoteVault", pool.QuoteVault.String()))

	return pool, nil
}

// GetPoolState получает текущее состояние пула
func (c *Client) GetPoolState(pool *Pool) (*PoolState, error) {
	c.logger.Debug("getting pool state",
		zap.String("poolId", pool.ID.String()),
	)

	// Получаем данные аккаунта пула
	account, err := c.client.GetAccountInfo(context.Background(), pool.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get pool account: %w", err)
	}

	// Парсим данные в структуру состояния
	state := &PoolState{
		BaseReserve:  binary.LittleEndian.Uint64(account.Value.Data.GetBinary()[64:72]), // пример смещения
		QuoteReserve: binary.LittleEndian.Uint64(account.Value.Data.GetBinary()[72:80]), // пример смещения
		Status:       account.Value.Data.GetBinary()[88],                                // пример смещения
	}

	return state, nil
}

// TODO:
// Для полноценной работы нужно добавить:
// Корректную сериализацию инструкций (согласно протоколу Raydium)
// Детальную обработку различных типов ошибок
// Валидацию параметров свапа
// Обработку разных версий пулов
// Расчет слиппажа и проверку лимитов

// NewSwapInstructionBuilder создает новый билдер для SwapInstruction
func NewSwapInstructionBuilder() *SwapInstruction {
	return &SwapInstruction{
		AccountMetaSlice: make(solana.AccountMetaSlice, 7), // 7 обязательных аккаунтов
	}
}

// Методы для установки параметров, следуя паттерну из SDK
func (inst *SwapInstruction) SetAmount(amount uint64) *SwapInstruction {
	inst.Amount = &amount
	return inst
}

func (inst *SwapInstruction) SetMinimumOut(minimumOut uint64) *SwapInstruction {
	inst.MinimumOut = &minimumOut
	return inst
}

// Методы для установки аккаунтов
func (inst *SwapInstruction) SetAccounts(
	pool solana.PublicKey,
	authority solana.PublicKey,
	userWallet solana.PublicKey,
	sourceToken solana.PublicKey,
	destToken solana.PublicKey,
	baseVault solana.PublicKey,
	quoteVault solana.PublicKey,
) *SwapInstruction {
	inst.AccountMetaSlice[0] = solana.Meta(pool).WRITE()
	inst.AccountMetaSlice[1] = solana.Meta(authority)
	inst.AccountMetaSlice[2] = solana.Meta(userWallet).WRITE().SIGNER()
	inst.AccountMetaSlice[3] = solana.Meta(sourceToken).WRITE()
	inst.AccountMetaSlice[4] = solana.Meta(destToken).WRITE()
	inst.AccountMetaSlice[5] = solana.Meta(baseVault).WRITE()
	inst.AccountMetaSlice[6] = solana.Meta(quoteVault).WRITE()
	return inst
}

// Добавляем метод для установки направления
func (inst *SwapInstruction) SetDirection(direction SwapDirection) *SwapInstruction {
	inst.Direction = &direction
	return inst
}

// Validate проверяет все необходимые параметры
func (inst *SwapInstruction) Validate() error {
	if inst.Amount == nil {
		return errors.New("amount is not set")
	}
	if inst.MinimumOut == nil {
		return errors.New("minimumOut is not set")
	}
	if inst.Direction == nil {
		return errors.New("direction is not set")
	}

	// Проверка всех аккаунтов
	for i, acc := range inst.AccountMetaSlice {
		if acc == nil {
			return fmt.Errorf("account at index %d is not set", i)
		}
	}
	return nil
}

// ProgramID возвращает ID программы Raydium
func (i *ExecutableSwapInstruction) ProgramID() solana.PublicKey {
	return i.programID
}

// Accounts возвращает список аккаунтов
func (i *ExecutableSwapInstruction) Accounts() []*solana.AccountMeta {
	return i.accounts
}

// Data возвращает сериализованные данные инструкции
func (i *ExecutableSwapInstruction) Data() ([]byte, error) {
	return i.data, nil
}

// Build создает инструкцию
func (inst *SwapInstruction) Build() (solana.Instruction, error) {
	if err := inst.Validate(); err != nil {
		return nil, err
	}

	// Сериализация данных инструкции
	data := make([]byte, 17) // 16 байт для amount и minimumOut + 1 байт для direction
	binary.LittleEndian.PutUint64(data[0:8], *inst.Amount)
	binary.LittleEndian.PutUint64(data[8:16], *inst.MinimumOut)
	if *inst.Direction == SwapDirectionIn {
		data[16] = 0
	} else {
		data[16] = 1
	}

	instruction := &ExecutableSwapInstruction{
		programID: RaydiumV4ProgramID,
		accounts:  inst.AccountMetaSlice,
		data:      data,
	}

	return instruction, nil
}

// CreateSwapInstructions создает инструкции для свапа
func (c *Client) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
	if err := validateSwapParams(params); err != nil {
		return nil, err
	}

	instructions := make([]solana.Instruction, 0)

	// Добавляем инструкцию compute budget если указан приоритетный fee
	if params.PriorityFeeLamports > 0 {
		computeLimitIx, err := computebudget.NewSetComputeUnitLimitInstructionBuilder().
			SetUnits(MaxComputeUnitLimit).
			ValidateAndBuild()
		if err != nil {
			return nil, fmt.Errorf("failed to build compute limit instruction: %w", err)
		}
		instructions = append(instructions, computeLimitIx)

		computePriceIx, err := computebudget.NewSetComputeUnitPriceInstructionBuilder().
			SetMicroLamports(params.PriorityFeeLamports).
			ValidateAndBuild()
		if err != nil {
			return nil, fmt.Errorf("failed to build compute price instruction: %w", err)
		}
		instructions = append(instructions, computePriceIx)
	}

	// Создаем инструкцию свапа
	swapIx, err := NewSwapInstructionBuilder().
		SetAmount(params.AmountIn).
		SetMinimumOut(params.MinAmountOut).
		SetAccounts(
			params.Pool.ID,
			params.Pool.Authority,
			params.UserWallet,
			params.SourceTokenAccount,
			params.DestinationTokenAccount,
			params.Pool.BaseVault,
			params.Pool.QuoteVault,
		).
		Build()
	if err != nil {
		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
	}

	instructions = append(instructions, swapIx)

	return instructions, nil
}

// validateSwapParams проверяет входные параметры
func validateSwapParams(params *SwapParams) error {
	if params == nil {
		return errors.New("params cannot be nil")
	}
	if params.Pool == nil {
		return errors.New("pool cannot be nil")
	}
	if params.UserWallet.IsZero() {
		return errors.New("user wallet is required")
	}
	if params.SourceTokenAccount.IsZero() {
		return errors.New("source token account is required")
	}
	if params.DestinationTokenAccount.IsZero() {
		return errors.New("destination token account is required")
	}
	if params.AmountIn == 0 {
		return errors.New("amount in must be greater than 0")
	}
	if params.MinAmountOut == 0 {
		return errors.New("minimum amount out must be greater than 0")
	}
	return nil
}

// SimulateSwap выполняет симуляцию транзакции свапа
func (c *Client) SimulateSwap(ctx context.Context, params *SwapParams) error {
	c.logger.Debug("simulating swap transaction",
		zap.String("userWallet", params.UserWallet.String()),
		zap.Uint64("amountIn", params.AmountIn),
		zap.Uint64("minAmountOut", params.MinAmountOut),
		zap.String("pool", params.Pool.ID.String()),
	)

	// Получаем инструкции для свапа
	instructions, err := c.CreateSwapInstructions(params)
	if err != nil {
		return fmt.Errorf("failed to create swap instructions: %w", err)
	}

	// Получаем последний блокхеш
	recent, err := c.client.GetRecentBlockhash(ctx)
	if err != nil {
		return fmt.Errorf("failed to get recent blockhash: %w", err)
	}

	// Создаем транзакцию
	tx, err := solana.NewTransaction(
		instructions,
		recent,
		solana.TransactionPayer(params.UserWallet),
	)
	if err != nil {
		return fmt.Errorf("failed to create transaction: %w", err)
	}

	// Подписываем транзакцию если есть приватный ключ
	if params.PrivateKey != nil {
		signatures, err := tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
			if key.Equals(params.UserWallet) {
				return params.PrivateKey
			}
			return nil
		})
		if err != nil {
			return fmt.Errorf("failed to sign transaction: %w", err)
		}

		// Опционально: можно добавить логирование подписей
		c.logger.Debug("transaction signed",
			zap.Int("signatures_count", len(signatures)),
			zap.String("first_signature", signatures[0].String()),
		)
	}

	// Симулируем транзакцию
	simResult, err := c.client.SimulateTransaction(ctx, tx)
	if err != nil {
		return fmt.Errorf("failed to simulate transaction: %w", err)
	}

	// Проверяем результат симуляции
	if simResult.Err != nil {
		return fmt.Errorf("simulation failed: %s", simResult.Err)
	}

	// Анализируем логи симуляции
	for _, log := range simResult.Logs {
		c.logger.Debug("simulation log", zap.String("log", log))
	}

	c.logger.Info("swap simulation successful",
		zap.Uint64("unitsConsumed", simResult.UnitsConsumed),
		zap.String("sourceToken", params.SourceTokenAccount.String()),
		zap.String("destinationToken", params.DestinationTokenAccount.String()),
		zap.Uint64("priorityFee", params.PriorityFeeLamports),
	)

	return nil
}

// TODO:
// Основные улучшения, которые можно добавить:
// Retry логика для случаев временных сбоев
// Более детальная валидация результатов транзакции
// Механизм отмены операции по таймауту
// Сохранение истории транзакций
// Метрики выполнения свапов

// ExecuteSwap выполняет свап и возвращает signature транзакции
func (c *Client) ExecuteSwap(params *SwapParams) (string, error) {
	c.logger.Debug("starting swap execution",
		zap.String("userWallet", params.UserWallet.String()),
		zap.Uint64("amountIn", params.AmountIn),
		zap.Uint64("minAmountOut", params.MinAmountOut),
		zap.String("pool", params.Pool.ID.String()),
		zap.Uint64("priorityFee", params.PriorityFeeLamports),
	)

	// Базовая валидация параметров
	if err := validateSwapParams(params); err != nil {
		return "", fmt.Errorf("invalid swap parameters: %w", err)
	}

	// Проверяем баланс кошелька
	ctx := context.Background()
	balance, err := c.client.GetBalance(ctx, params.UserWallet, solanarpc.CommitmentConfirmed)
	if err != nil {
		return "", fmt.Errorf("failed to get wallet balance: %w", err)
	}

	// Учитываем приоритетную комиссию и обычную комиссию транзакции
	requiredBalance := params.AmountIn + params.PriorityFeeLamports + 5000
	if balance < requiredBalance {
		return "", fmt.Errorf("insufficient balance: required %d, got %d", requiredBalance, balance)
	}

	// Создаем все необходимые инструкции для свапа
	instructions, err := c.CreateSwapInstructions(params)
	if err != nil {
		return "", fmt.Errorf("failed to create swap instructions: %w", err)
	}

	// Получаем последний блокхеш
	recent, err := c.client.GetRecentBlockhash(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to get recent blockhash: %w", err)
	}

	// Создаем транзакцию
	tx, err := solana.NewTransaction(
		instructions,
		recent,
		solana.TransactionPayer(params.UserWallet),
	)
	if err != nil {
		return "", fmt.Errorf("failed to create transaction: %w", err)
	}

	// Подписываем транзакцию
	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
		if key.Equals(params.UserWallet) {
			if params.PrivateKey != nil {
				return params.PrivateKey
			}
			return &c.privateKey
		}
		return nil
	})
	if err != nil {
		return "", fmt.Errorf("failed to sign transaction: %w", err)
	}

	// Отправляем транзакцию
	sig, err := c.client.SendTransactionWithOpts(ctx, tx, blockchain.TransactionOptions{
		SkipPreflight:       true,
		PreflightCommitment: c.commitment, // используем commitment напрямую из клиента
	})
	if err != nil {
		return "", fmt.Errorf("failed to send transaction: %w", err)
	}

	c.logger.Info("swap executed successfully",
		zap.String("signature", sig.String()),
		zap.String("explorer", fmt.Sprintf("https://explorer.solana.com/tx/%s", sig.String())),
	)

	return sig.String(), nil
}

// TODO: этот метод нигде пока не используется, надо добавить его в код
// logUpdatedBalances вспомогательный метод для логирования балансов после свапа
// func (c *Client) logUpdatedBalances(params *SwapParams) error {
// 	ctx := context.Background()

// 	// Получаем баланс SOL
// 	solBalance, err := c.client.GetBalance(
// 		ctx,
// 		params.UserWallet,
// 		solanarpc.CommitmentConfirmed,
// 	)
// 	if err != nil {
// 		return fmt.Errorf("failed to get SOL balance: %w", err)
// 	}

// 	// Получаем баланс токена
// 	tokenBalance, err := c.client.GetTokenAccountBalance(
// 		ctx,
// 		params.DestinationTokenAccount,
// 		solanarpc.CommitmentConfirmed,
// 	)
// 	if err != nil {
// 		return fmt.Errorf("failed to get token balance: %w", err)
// 	}

// 	c.logger.Info("updated balances",
// 		zap.Float64("solBalance", float64(solBalance)/float64(solana.LAMPORTS_PER_SOL)),
// 		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
// 	)

// 	return nil
// }

// GetBaseClient возвращает базовый blockchain.Client
func (c *Client) GetBaseClient() blockchain.Client {
	return c.client
}

// findPoolOnChain используется для поиска пула в блокчейне
func (c *Client) findPoolOnChain(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*Pool, error) {
	accounts, err := c.client.GetProgramAccounts(
		ctx,
		RaydiumV4ProgramID,
		solanarpc.GetProgramAccountsOpts{
			Filters: []solanarpc.RPCFilter{
				{
					DataSize: 388,
				},
				{
					Memcmp: &solanarpc.RPCFilterMemcmp{
						Offset: 8,
						Bytes:  baseMint.Bytes(),
					},
				},
				{
					Memcmp: &solanarpc.RPCFilterMemcmp{
						Offset: 40,
						Bytes:  quoteMint.Bytes(),
					},
				},
			},
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get program accounts: %w", err)
	}

	if len(accounts) == 0 {
		return nil, fmt.Errorf("pool not found for tokens %s and %s",
			baseMint.String(), quoteMint.String())
	}

	return c.parsePoolAccount(accounts[0])
}
// internal/dex/raydium/constants.go
package raydium

import (
	"fmt"

	"github.com/gagliardetto/solana-go"
)

// Program IDs
var (
	// Используем MPK для краткости, так как это константы
	TokenProgramID     = solana.MPK("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
	RaydiumV4ProgramID = solana.MPK("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8")
	SystemProgramID    = solana.MPK("11111111111111111111111111111111")
	SysvarRentPubkey   = solana.MPK("SysvarRent111111111111111111111111111111111")
	WrappedSolMint     = solana.MPK("So11111111111111111111111111111111111111112")
)

// Compute budget constants
const (
	MaxComputeUnitLimit = 300000
	DefaultComputePrice = 1000
	MinComputePrice     = 0
	MaxComputePrice     = 100000
)

// Pool account layout constants
const (
	PoolAccountSize     = 388
	PoolVersionOffset   = 0
	StatusOffset        = 1
	BaseMintOffset      = 8
	QuoteMintOffset     = 40
	LpMintOffset        = 72
	BaseVaultOffset     = 104
	QuoteVaultOffset    = 136
	DecimalsOffset      = 168
	FeeBpsOffset        = 170
	PoolStatusOffset    = 188
	AmmOpenOrders       = 196
	MarketIDOffset      = 228
	TargetOrdersOffset  = 260
	WithdrawQueueOffset = 292
)

// Pool status
const (
	PoolStatusUninitialized uint8 = 0
	PoolStatusInitialized   uint8 = 1
	PoolStatusDisabled      uint8 = 2
	PoolStatusActive        uint8 = 3
)

// PDA seeds
const (
	AmmAuthorityLayout = "amm_authority"
	PoolTempLpLayout   = "pool_temp_lp"
	PoolWithdrawQueue  = "withdraw_queue"
	TargetOrdersSeed   = "target_orders"
	OpenOrdersSeed     = "open_orders"
)

// Swap constants
const (
	DefaultSlippagePercent = 0.5
	MaxSlippagePercent     = 5.0
	MinSwapAmount          = 1000
	MaxTokensInPool        = 100000
	TradeDirectionIn       = "in"
	TradeDirectionOut      = "out"
)

// Error codes
const (
	ErrPoolNotFound      = "POOL_NOT_FOUND"
	ErrInvalidPoolStatus = "INVALID_POOL_STATUS"
	ErrInsufficientFunds = "INSUFFICIENT_FUNDS"
	ErrSlippageExceeded  = "SLIPPAGE_EXCEEDED"
	ErrInvalidMint       = "INVALID_MINT"
	ErrInvalidAmount     = "INVALID_AMOUNT"
	ErrPoolDisabled      = "POOL_DISABLED"
	ErrInvalidDirection  = "INVALID_DIRECTION"
)

// Account size constants
const (
	TokenAccountSize = 165
	MintAccountSize  = 82
)

func (e *Error) Error() string {
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// Добавляем конструктор для RaydiumError
func NewRaydiumError(code string, message string, details map[string]interface{}) *Error {
	return &Error{
		Code:    code,
		Message: message,
		Details: details,
	}
}
// internal/dex/raydium/pool_cache.go
package raydium

import (
	"encoding/json"
	"fmt"
	"os"
	"sync"

	"github.com/gagliardetto/solana-go"
	"go.uber.org/zap"
)

type PoolCache struct {
	pools     map[string]*Pool
	jsonPools *PoolList
	mu        sync.RWMutex
	logger    *zap.Logger
}

func NewPoolCache(logger *zap.Logger) *PoolCache {
	return &PoolCache{
		pools:  make(map[string]*Pool),
		logger: logger,
	}
}

func (pc *PoolCache) LoadPoolsFromFile(path string) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read pools file: %w", err)
	}

	var poolList PoolList
	if err := json.Unmarshal(data, &poolList); err != nil {
		return fmt.Errorf("failed to unmarshal pools: %w", err)
	}

	pc.mu.Lock()
	pc.jsonPools = &poolList
	pc.mu.Unlock()

	return nil
}

// GetPoolsCount возвращает количество пулов в кэше
func (pc *PoolCache) GetPoolsCount() int {
	pc.mu.RLock()
	defer pc.mu.RUnlock()

	if pc.jsonPools == nil {
		return len(pc.pools)
	}
	return len(pc.jsonPools.Official) + len(pc.jsonPools.Unofficial)
}

// IsLoaded проверяет загружены ли пулы из файла
func (pc *PoolCache) IsLoaded() bool {
	pc.mu.RLock()
	defer pc.mu.RUnlock()
	return pc.jsonPools != nil
}

// AddPool добавляет пул в кэш
func (pc *PoolCache) AddPool(pool *Pool) error {
	if pool == nil {
		return fmt.Errorf("cannot add nil pool")
	}
	if !pc.isValidPool(pool) {
		return fmt.Errorf("invalid pool data")
	}

	cacheKey := fmt.Sprintf("%s-%s", pool.BaseMint.String(), pool.QuoteMint.String())
	pc.mu.Lock()
	pc.pools[cacheKey] = pool
	pc.mu.Unlock()
	return nil
}

// GetPool получает пул из кэша
func (pc *PoolCache) GetPool(baseMint, quoteMint solana.PublicKey) *Pool {
	cacheKey := fmt.Sprintf("%s-%s", baseMint.String(), quoteMint.String())
	pc.mu.RLock()
	pool := pc.pools[cacheKey]
	pc.mu.RUnlock()
	return pool
}

// findPoolInJson ищет пул в загруженном JSON файле
func (pc *PoolCache) findPoolInJson(baseMint, quoteMint solana.PublicKey) *Pool {
	pc.mu.RLock()
	defer pc.mu.RUnlock()

	if pc.jsonPools == nil {
		return nil
	}

	// Ищем в официальных пулах
	for _, info := range pc.jsonPools.Official {
		if (info.BaseMint == baseMint.String() && info.QuoteMint == quoteMint.String()) ||
			(info.BaseMint == quoteMint.String() && info.QuoteMint == baseMint.String()) {
			// Конвертируем JSON в структуру Pool
			return pc.convertJsonToPool(info)
		}
	}
	return nil
}

func (pc *PoolCache) convertJsonToPool(info PoolJsonInfo) *Pool {
	defer func() {
		if r := recover(); r != nil {
			pc.logger.Error("failed to convert pool info",
				zap.String("id", info.Id),
				zap.Any("panic", r))
		}
	}()

	return &Pool{
		ID:            solana.MustPublicKeyFromBase58(info.Id),
		Authority:     solana.MustPublicKeyFromBase58(info.Authority),
		BaseMint:      solana.MustPublicKeyFromBase58(info.BaseMint),
		QuoteMint:     solana.MustPublicKeyFromBase58(info.QuoteMint),
		BaseVault:     solana.MustPublicKeyFromBase58(info.BaseVault),
		QuoteVault:    solana.MustPublicKeyFromBase58(info.QuoteVault),
		BaseDecimals:  uint8(info.BaseDecimals),
		QuoteDecimals: uint8(info.QuoteDecimals),
		Version:       PoolVersion(info.Version),
	}
}

func (pc *PoolCache) isValidPool(pool *Pool) bool {
	return !pool.ID.IsZero() &&
		!pool.Authority.IsZero() &&
		!pool.BaseMint.IsZero() &&
		!pool.QuoteMint.IsZero() &&
		!pool.BaseVault.IsZero() &&
		!pool.QuoteVault.IsZero()
}
// internal/dex/raydium/pool.go - это пакет, который содержит в себе реализацию работы с пулами Raydium
package raydium

import (
	"context"
	"encoding/binary"
	"fmt"

	"github.com/gagliardetto/solana-go"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
	"go.uber.org/zap"
)

// NewPoolManager создает новый менеджер пула
func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *Pool) *PoolManager {
	return &PoolManager{
		client: client,
		logger: logger,
		pool:   pool,
	}
}

// TODO: В дальнейшем этот код можно расширить:
// 1. Добавить более сложную формулу расчета с учетом комиссий
// 2. Реализовать кэширование состояния пула
// 3. Добавить больше проверок валидации
// 4. Улучшить обработку ошибок и логирование

// GetPoolState получает актуальное состояние пула
func (pm *PoolManager) GetPoolState(ctx context.Context) (*PoolState, error) {
	pm.logger.Debug("getting pool state",
		zap.String("poolId", pm.pool.ID.String()),
	)

	// Получаем данные аккаунта пула
	account, err := pm.client.GetAccountInfo(ctx, pm.pool.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get pool account: %w", err)
	}

	// Проверяем что аккаунт существует и содержит данные
	if account == nil || account.Value == nil || account.Value.Data.GetBinary() == nil {
		return nil, fmt.Errorf("pool account data is empty")
	}

	// Получаем бинарные данные аккаунта
	data := account.Value.Data.GetBinary()

	// Проверяем достаточную длину данных
	if len(data) < 89 { // минимальная длина для наших полей
		return nil, fmt.Errorf("invalid pool data length: %d", len(data))
	}

	// Парсим данные в структуру состояния
	state := &PoolState{
		BaseReserve:  binary.LittleEndian.Uint64(data[64:72]), // резервы base токена
		QuoteReserve: binary.LittleEndian.Uint64(data[72:80]), // резервы quote токена
		Status:       data[88],                                // статус пула
	}

	return state, nil
}

// CalculateAmounts рассчитывает количество выходных токенов и минимальный выход
func (pm *PoolManager) CalculateAmounts(ctx context.Context) (*SwapAmounts, error) {
	// Получаем текущее состояние пула
	state, err := pm.GetPoolState(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get pool state: %w", err)
	}

	// Проверяем, что пул активен
	if state.Status != 1 { // предполагаем, что 1 = активный статус
		return nil, fmt.Errorf("pool is not active")
	}

	// Расчет по формуле: amountOut = (amountIn * outputReserve) / (inputReserve + amountIn)
	// Это упрощенная формула для начала
	amountIn := uint64(1000000) // пример входного количества
	amountOut := (amountIn * state.QuoteReserve) / (state.BaseReserve + amountIn)

	// Учитываем проскальзывание (например, 1%)
	slippage := uint64(100) // 1%
	minAmountOut := amountOut - (amountOut * slippage / 10000)

	return &SwapAmounts{
		AmountIn:     amountIn,
		AmountOut:    amountOut,
		MinAmountOut: minAmountOut,
	}, nil
}

// ValidatePool проверяет валидность параметров пула
func (pm *PoolManager) ValidatePool(ctx context.Context) error {
	// Проверяем существование всех необходимых аккаунтов
	accounts := []solana.PublicKey{
		pm.pool.ID,
		pm.pool.Authority,
		pm.pool.BaseMint,
		pm.pool.QuoteMint,
		pm.pool.BaseVault,
		pm.pool.QuoteVault,
	}

	for _, acc := range accounts {
		if acc.IsZero() {
			return fmt.Errorf("invalid pool account: %s is zero", acc.String())
		}
	}

	// Проверяем состояние пула
	state, err := pm.GetPoolState(ctx)
	if err != nil {
		return fmt.Errorf("failed to get pool state: %w", err)
	}

	// Проверяем резервы
	if state.BaseReserve == 0 || state.QuoteReserve == 0 {
		return fmt.Errorf("pool reserves are empty: base=%d, quote=%d",
			state.BaseReserve, state.QuoteReserve)
	}

	// Проверяем статус
	if state.Status != 1 { // предполагаем, что 1 = активный статус
		return fmt.Errorf("pool is not active")
	}

	return nil
}
// internal/dex/raydium/sniper.go - это пакет, который содержит в себе реализацию снайпинга на декстере Raydium
package raydium

import (
	"context"
	"fmt"
	"math"
	"time"

	"github.com/gagliardetto/solana-go"
	solanarpc "github.com/gagliardetto/solana-go/rpc"
	"go.uber.org/zap"
)

// TODO: можно добавить:

// 1. Проверку цены перед свапом
// 2. Мониторинг состояния пула в реальном времени
// 3. Более сложную логику расчета суммы свапа
// 4. Обработку различных ошибок и ретраи
// 5. Асинхронное выполнение свапа

func (s *Sniper) ExecuteSnipe() error {
	ctx := context.Background()
	s.logger.Debug("starting snipe execution")

	// 1. Валидация параметров
	if err := s.ValidateAndPrepare(); err != nil {
		return fmt.Errorf("failed to validate parameters: %w", err)
	}

	// 2. Получение информации о пуле через кэш или on-chain поиск
	pool, err := s.client.GetPool(ctx, s.config.BaseMint, s.config.QuoteMint)
	if err != nil {
		// Пробуем в обратном порядке
		pool, err = s.client.GetPool(ctx, s.config.QuoteMint, s.config.BaseMint)
		if err != nil {
			return fmt.Errorf("failed to get pool in both directions: %w", err)
		}
	}

	// 3. Проверка состояния пула
	poolManager := NewPoolManager(s.client.client, s.logger, pool)
	if err := poolManager.ValidatePool(ctx); err != nil {
		return fmt.Errorf("pool validation failed: %w", err)
	}

	// 4. Получаем или создаем Associated Token Accounts
	sourceATA, _, err := solana.FindAssociatedTokenAddress(
		s.client.privateKey.PublicKey(),
		s.config.BaseMint,
	)
	if err != nil {
		return fmt.Errorf("failed to get source ATA: %w", err)
	}

	destinationATA, _, err := solana.FindAssociatedTokenAddress(
		s.client.privateKey.PublicKey(),
		s.config.QuoteMint,
	)
	if err != nil {
		return fmt.Errorf("failed to get destination ATA: %w", err)
	}

	// 5. Расчет параметров свапа с учетом slippage
	amounts, err := poolManager.CalculateAmounts(ctx)
	if err != nil {
		return fmt.Errorf("failed to calculate swap amounts: %w", err)
	}

	// Проверяем минимальные и максимальные лимиты
	if amounts.AmountIn < s.config.MinAmountSOL {
		return fmt.Errorf("amount too small: %d < %d", amounts.AmountIn, s.config.MinAmountSOL)
	}
	if amounts.AmountIn > s.config.MaxAmountSOL {
		return fmt.Errorf("amount too large: %d > %d", amounts.AmountIn, s.config.MaxAmountSOL)
	}

	// 6. Проверяем баланс
	balance, err := s.client.CheckWalletBalance(ctx)
	if err != nil {
		return fmt.Errorf("failed to check balance: %w", err)
	}

	requiredBalance := amounts.AmountIn + s.config.PriorityFee + 5000 // 5000 lamports для комиссии
	if balance < requiredBalance {
		return fmt.Errorf("insufficient balance: required %d, got %d", requiredBalance, balance)
	}

	// 7. Подготовка параметров для свапа
	swapParams := &SwapParams{
		UserWallet:              s.client.privateKey.PublicKey(),
		PrivateKey:              &s.client.privateKey,
		AmountIn:                amounts.AmountIn,
		MinAmountOut:            amounts.MinAmountOut,
		Pool:                    pool,
		SourceTokenAccount:      sourceATA,
		DestinationTokenAccount: destinationATA,
		PriorityFeeLamports:     s.config.PriorityFee,
		Direction:               SwapDirectionIn,
		SlippageBps:             s.config.MaxSlippageBps,
		Deadline:                time.Now().Add(30 * time.Second),
	}

	// 8. Симуляция свапа
	if err := s.client.SimulateSwap(ctx, swapParams); err != nil {
		return fmt.Errorf("swap simulation failed: %w", err)
	}

	// 9. Выполнение свапа
	signature, err := s.client.ExecuteSwap(swapParams)
	if err != nil {
		return fmt.Errorf("swap execution failed: %w", err)
	}

	// 10. Ждем подтверждения если настроено
	if s.config.WaitConfirmation {
		s.logger.Info("waiting for confirmation...",
			zap.String("signature", signature))

		status, err := s.waitForConfirmation(ctx, signature)
		if err != nil {
			return fmt.Errorf("confirmation failed: %w", err)
		}
		if status != "confirmed" && status != "finalized" {
			return fmt.Errorf("transaction failed with status: %s", status)
		}
	}

	// Логируем успешное выполнение
	s.logger.Info("snipe executed successfully",
		zap.String("signature", signature),
		zap.Uint64("amountIn", amounts.AmountIn),
		zap.Uint64("amountOut", amounts.AmountOut),
		zap.Uint64("minAmountOut", amounts.MinAmountOut),
		zap.String("explorer", fmt.Sprintf("https://explorer.solana.com/tx/%s", signature)),
	)

	return nil
}

// Вспомогательный метод для ожидания подтверждения транзакции
func (s *Sniper) waitForConfirmation(ctx context.Context, signature string) (string, error) {
	sig, err := solana.SignatureFromBase58(signature)
	if err != nil {
		return "", fmt.Errorf("invalid signature: %w", err)
	}

	for i := 0; i < 30; i++ { // максимум 30 попыток
		select {
		case <-ctx.Done():
			return "", ctx.Err()
		default:
			status, err := s.client.client.GetSignatureStatuses(ctx, sig)
			if err != nil {
				return "", fmt.Errorf("failed to get status: %w", err)
			}
			if status != nil && len(status.Value) > 0 && status.Value[0] != nil {
				if status.Value[0].Err != nil {
					return "failed", fmt.Errorf("transaction failed: %v", status.Value[0].Err)
				}
				return string(status.Value[0].ConfirmationStatus), nil // Используем напрямую без разыменования
			}
			time.Sleep(500 * time.Millisecond)
		}
	}
	return "", fmt.Errorf("confirmation timeout")
}

// TODO: Потенциальные улучшения на основе TS версии:
// 1. Добавить проверку и создание associated token accounts
// 2. Добавить проверку балансов SOL и токенов
// 3. Добавить валидацию параметров compute budget
// 4. Добавить проверку версии пула (V4)
// 5. Добавить расчет приоритетной комиссии на основе последних блоков
// 6. Добавить проверку и обработку wrapped SOL
func (s *Sniper) ValidateAndPrepare() error {
	s.logger.Debug("validating and preparing snipe parameters")

	// Проверяем базовые параметры конфигурации
	if s.config.MaxSlippageBps == 0 || s.config.MaxSlippageBps > 10000 { // 10000 = 100%
		return fmt.Errorf("invalid slippage: must be between 0 and 10000")
	}

	if s.config.MinAmountSOL <= 0 || s.config.MaxAmountSOL <= 0 {
		return fmt.Errorf("invalid amount parameters")
	}

	if s.config.MaxAmountSOL < s.config.MinAmountSOL {
		return fmt.Errorf("maxAmount cannot be less than minAmount")
	}

	// Проверяем mint addresses
	if s.config.BaseMint.IsZero() || s.config.QuoteMint.IsZero() {
		return fmt.Errorf("invalid mint addresses")
	}

	// Проверяем наличие достаточного баланса
	balance, err := s.client.client.GetBalance(
		context.Background(),
		s.client.privateKey.PublicKey(),
		solanarpc.CommitmentConfirmed,
	)
	if err != nil {
		return fmt.Errorf("failed to get wallet balance: %w", err)
	}

	if balance/solana.LAMPORTS_PER_SOL < s.config.MinAmountSOL {
		return fmt.Errorf("insufficient balance")
	}

	// Проверяем параметры мониторинга
	if s.config.MonitorInterval < time.Second {
		return fmt.Errorf("monitor interval too small")
	}

	if s.config.MaxRetries < 1 {
		return fmt.Errorf("invalid max retries value")
	}

	return nil
}

// TODO: Потенциальные улучшения на основе TS версии:
// 1. Добавить отслеживание изменений цены
// 2. Добавить отслеживание объема ликвидности
// 3. Добавить механизм подписки на события пула
// 4. Добавить отслеживание транзакций в мемпуле
// 5. Добавить механизм websocket подключения
// 6. Добавить механизм агрегации данных по нескольким RPC
func (s *Sniper) MonitorPoolChanges(ctx context.Context) error {
	s.logger.Debug("starting pool monitoring")

	ticker := time.NewTicker(s.config.MonitorInterval)
	defer ticker.Stop()

	// Получаем начальное состояние пула
	pool, err := s.client.GetPool(ctx, s.config.BaseMint, s.config.QuoteMint)
	if err != nil {
		return fmt.Errorf("failed to get initial pool state: %w", err)
	}

	poolManager := NewPoolManager(s.client.client, s.logger, pool)
	initialState, err := poolManager.GetPoolState(ctx)
	if err != nil {
		return fmt.Errorf("failed to get initial pool state: %w", err)
	}

	var retryCount int
	for range ticker.C {
		// Проверяем контекст перед каждой итерацией
		if err := ctx.Err(); err != nil {
			return fmt.Errorf("monitoring stopped: %w", err)
		}

		// Получаем текущее состояние пула
		currentState, err := poolManager.GetPoolState(ctx)
		if err != nil {
			retryCount++
			s.logger.Error("failed to get current pool state",
				zap.Error(err),
				zap.Int("retry", retryCount),
			)
			if retryCount >= s.config.MaxRetries {
				return fmt.Errorf("max retries exceeded while monitoring pool")
			}
			continue
		}
		retryCount = 0

		// Проверяем изменения в пуле
		if s.hasSignificantChanges(initialState, currentState) {
			s.logger.Info("detected significant pool changes",
				zap.Uint64("oldBaseReserve", initialState.BaseReserve),
				zap.Uint64("newBaseReserve", currentState.BaseReserve),
				zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
				zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
			)

			// Если пул неактивен, прекращаем мониторинг
			if currentState.Status != 1 {
				return fmt.Errorf("pool became inactive")
			}

			// Обновляем начальное состояние
			initialState = currentState
		}
	}

	return nil
}

// Вспомогательный метод для определения значительных изменений в пуле
func (s *Sniper) hasSignificantChanges(old, new *PoolState) bool {
	// Рассчитываем процент изменения для базового резерва
	baseChange := math.Abs(float64(new.BaseReserve)-float64(old.BaseReserve)) / float64(old.BaseReserve)

	// Рассчитываем процент изменения для котируемого резерва
	quoteChange := math.Abs(float64(new.QuoteReserve)-float64(old.QuoteReserve)) / float64(old.QuoteReserve)

	// Определяем порог значительных изменений (например, 1%)
	threshold := 0.01

	return baseChange > threshold || quoteChange > threshold || new.Status != old.Status
}
// inernal/dex/raydium/types.go - это пакет, который содержит в себе реализацию работы с декстерами Raydium
package raydium

import (
	"time"

	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
	"go.uber.org/zap"
)

// Нужно добавить
type TokenAmount struct {
	Raw      uint64
	Decimals uint8
}

// Нужно добавить
type SwapDirection string

const (
	SwapDirectionIn  SwapDirection = "in"
	SwapDirectionOut SwapDirection = "out"
)

// Нужно добавить
type PoolVersion uint8

const (
	PoolVersionV4 PoolVersion = 4
	PoolVersionV3 PoolVersion = 3
)

type Pool struct {
	ID            solana.PublicKey // Идентификатор пула
	Authority     solana.PublicKey // Публичный ключ, который имеет полномочия управлять пулом
	BaseMint      solana.PublicKey // Публичный ключ базового токена
	QuoteMint     solana.PublicKey // Публичный ключ котируемого токена
	BaseVault     solana.PublicKey // Публичный ключ хранилища базового токена
	QuoteVault    solana.PublicKey // Публичный ключ хранилища котируемого токена
	BaseDecimals  uint8            // Количество десятичных знаков базового токена
	QuoteDecimals uint8            // Количество десятичных знаков котируемого токена
	DefaultFeeBps uint16           // Комиссия по умолчанию в базисных пунктах (bps)
	// Только необходимые поля для V4

	Version PoolVersion
	State   PoolState // встроенное состояние
}

type PoolJsonInfo struct {
	Id            string `json:"id"`
	BaseMint      string `json:"baseMint"`
	QuoteMint     string `json:"quoteMint"`
	LpMint        string `json:"lpMint"`
	BaseDecimals  int    `json:"baseDecimals"`
	QuoteDecimals int    `json:"quoteDecimals"`
	LpDecimals    int    `json:"lpDecimals"`
	Version       int    `json:"version"`
	ProgramId     string `json:"programId"`
	Authority     string `json:"authority"`
	BaseVault     string `json:"baseVault"`
	QuoteVault    string `json:"quoteVault"`
	MarketId      string `json:"marketId"`
	OpenOrders    string `json:"openOrders"`
	TargetOrders  string `json:"targetOrders"`
	Status        string `json:"status"`
}

type PoolList struct {
	Official   []PoolJsonInfo `json:"official"`
	Unofficial []PoolJsonInfo `json:"unofficial"`
}

type PoolState struct {
	BaseReserve  uint64 // Резерв базового токена в пуле
	QuoteReserve uint64 // Резерв котируемого токена в пуле
	Status       uint8  // Статус пула (например, активен или неактивен)
}

type SwapParams struct {
	UserWallet              solana.PublicKey   // Публичный ключ кошелька пользователя
	PrivateKey              *solana.PrivateKey // Приватный ключ для подписания транзакции
	AmountIn                uint64             // Количество входного токена для обмена
	MinAmountOut            uint64             // Минимальное количество выходного токена
	Pool                    *Pool              // Указатель на пул для обмена
	SourceTokenAccount      solana.PublicKey   // Аккаунт исходного токена
	DestinationTokenAccount solana.PublicKey   // Аккаунт целевого токена
	PriorityFeeLamports     uint64             // Приоритетная комиссия в лампортах

	Direction   SwapDirection
	SlippageBps uint16
	Deadline    time.Time // таймаут для транзакции
}

type Client struct {
	client      blockchain.Client
	logger      *zap.Logger
	privateKey  solana.PrivateKey
	timeout     time.Duration
	retries     int
	priorityFee uint64
	commitment  rpc.CommitmentType
	poolCache   *PoolCache
}

// type clientOptions struct {
// 	timeout     time.Duration      // Таймаут для операций
// 	retries     int                // Количество повторных попыток
// 	priorityFee uint64             // Приоритетная комиссия в лампортах
// 	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
// }

type SwapInstruction struct {
	Amount     *uint64
	MinimumOut *uint64
	Direction  *SwapDirection // добавляем как указатель для консистентности

	// Slice для хранения аккаунтов, следуя паттерну из SDK
	solana.AccountMetaSlice `bin:"-" borsh_skip:"true"`
}

// RaydiumSwapInstruction реализует интерфейс solana.Instruction
type ExecutableSwapInstruction struct {
	programID solana.PublicKey
	accounts  []*solana.AccountMeta
	data      []byte
}

// RaydiumError represents a custom error type
type Error struct {
	Code    string
	Message string
	Stage   string
	Details map[string]interface{}
	Err     error
}

type SwapAmounts struct {
	AmountIn     uint64 // Количество входных токенов
	AmountOut    uint64 // Ожидаемое количество выходных токенов
	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
}

type PoolManager struct {
	client blockchain.Client
	logger *zap.Logger
	pool   *Pool
}

type Sniper struct {
	client *Client
	logger *zap.Logger
	config *SniperConfig // Конфигурация снайпинга
}
type SniperConfig struct {
	// Существующие поля
	MaxSlippageBps   uint16 // экспортируемые поля
	MinAmountSOL     uint64 // использовать lamports вместо float64
	MaxAmountSOL     uint64
	PriorityFee      uint64
	WaitConfirmation bool
	MonitorInterval  time.Duration
	MaxRetries       int

	// Добавляем новые необходимые поля
	BaseMint  solana.PublicKey // Mint address базового токена
	QuoteMint solana.PublicKey // Mint address котируемого токена
}
