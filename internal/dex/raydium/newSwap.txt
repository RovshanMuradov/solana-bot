// internal/dex/raydium/client.go - это пакет, который содержит в себе реализацию клиента для работы с декстером Raydium
package raydium

import (
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"time"

	"github.com/gagliardetto/solana-go"
	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
	solanarpc "github.com/gagliardetto/solana-go/rpc"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
	"go.uber.org/zap"
)

// NewRaydiumClient создает новый экземпляр клиента Raydium с дефолтными настройками
func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*RaydiumClient, error) {
	logger = logger.Named("raydium-client")

	// Создаем базового клиента через фабрику
	solClient, err := solbc.NewClient([]string{rpcEndpoint}, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create solana client: %w", err)
	}

	// Создаем клиент с дефолтными настройками
	return &RaydiumClient{
		client:      solClient,
		logger:      logger,
		privateKey:  wallet,
		timeout:     30 * time.Second,
		retries:     3,
		priorityFee: 1000,
		commitment:  solanarpc.CommitmentConfirmed,
	}, nil
}

// GetPool получает информацию о пуле по базовому и котируемому токенам
func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
	c.logger.Debug("getting raydium pool info",
		zap.String("baseMint", baseMint.String()),
		zap.String("quoteMint", quoteMint.String()),
	)

	// Получаем программные аккаунты через интерфейс
	accounts, err := c.client.GetProgramAccounts(
		ctx,
		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
		solanarpc.GetProgramAccountsOpts{
			Filters: []solanarpc.RPCFilter{
				{
					DataSize: 388, // Размер данных аккаунта пула
				},
				{
					Memcmp: &solanarpc.RPCFilterMemcmp{
						Offset: 8,
						Bytes:  baseMint.Bytes(),
					},
				},
				{
					Memcmp: &solanarpc.RPCFilterMemcmp{
						Offset: 40,
						Bytes:  quoteMint.Bytes(),
					},
				},
			},
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get program accounts: %w", err)
	}

	if len(accounts) == 0 {
		return nil, fmt.Errorf("pool not found for base mint %s and quote mint %s",
			baseMint.String(), quoteMint.String())
	}

	// Берем первый найденный пул
	poolAccount := accounts[0]

	// Получаем authority пула через PDA
	authority, _, err := solana.FindProgramAddress(
		[][]byte{[]byte("amm_authority")},
		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to derive authority: %w", err)
	}

	// Парсим данные аккаунта
	data := poolAccount.Account.Data.GetBinary()
	if len(data) < 388 {
		return nil, fmt.Errorf("invalid pool account data length: %d", len(data))
	}

	// Извлекаем данные из бинарного представления
	// Офсеты взяты из документации Raydium и SDK
	pool := &RaydiumPool{
		ID:        poolAccount.Pubkey, // Исправлено с PublicKey на Pubkey
		Authority: authority,
		BaseMint:  baseMint,
		QuoteMint: quoteMint,
		// Извлекаем адреса vault'ов (смещения могут отличаться, нужно сверить с документацией)
		BaseVault:  solana.PublicKeyFromBytes(data[72:104]),
		QuoteVault: solana.PublicKeyFromBytes(data[104:136]),
		// Извлекаем decimals
		BaseDecimals:  uint8(data[136]),
		QuoteDecimals: uint8(data[137]),
		// Извлекаем fee в базисных пунктах (2 байта)
		DefaultFeeBps: binary.LittleEndian.Uint16(data[138:140]),
	}

	c.logger.Debug("pool info retrieved successfully",
		zap.String("poolId", pool.ID.String()),
		zap.String("baseVault", pool.BaseVault.String()),
		zap.String("quoteVault", pool.QuoteVault.String()),
		zap.Uint8("baseDecimals", pool.BaseDecimals),
		zap.Uint8("quoteDecimals", pool.QuoteDecimals),
		zap.Uint16("defaultFeeBps", pool.DefaultFeeBps),
	)

	return pool, nil
}

// GetPoolState получает текущее состояние пула
func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
	c.logger.Debug("getting pool state",
		zap.String("poolId", pool.ID.String()),
	)

	// Получаем данные аккаунта пула
	account, err := c.client.GetAccountInfo(context.Background(), pool.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get pool account: %w", err)
	}

	// Парсим данные в структуру состояния
	state := &PoolState{
		BaseReserve:  binary.LittleEndian.Uint64(account.Value.Data.GetBinary()[64:72]), // пример смещения
		QuoteReserve: binary.LittleEndian.Uint64(account.Value.Data.GetBinary()[72:80]), // пример смещения
		Status:       account.Value.Data.GetBinary()[88],                                // пример смещения
	}

	return state, nil
}

// TODO:
// Для полноценной работы нужно добавить:
// Корректную сериализацию инструкций (согласно протоколу Raydium)
// Детальную обработку различных типов ошибок
// Валидацию параметров свапа
// Обработку разных версий пулов
// Расчет слиппажа и проверку лимитов

// NewSwapInstructionBuilder создает новый билдер для SwapInstruction
func NewSwapInstructionBuilder() *SwapInstruction {
	return &SwapInstruction{
		AccountMetaSlice: make(solana.AccountMetaSlice, 7), // 7 обязательных аккаунтов
	}
}

// Методы для установки параметров, следуя паттерну из SDK
func (inst *SwapInstruction) SetAmount(amount uint64) *SwapInstruction {
	inst.Amount = &amount
	return inst
}

func (inst *SwapInstruction) SetMinimumOut(minimumOut uint64) *SwapInstruction {
	inst.MinimumOut = &minimumOut
	return inst
}

// Методы для установки аккаунтов
func (inst *SwapInstruction) SetAccounts(
	pool solana.PublicKey,
	authority solana.PublicKey,
	userWallet solana.PublicKey,
	sourceToken solana.PublicKey,
	destToken solana.PublicKey,
	baseVault solana.PublicKey,
	quoteVault solana.PublicKey,
) *SwapInstruction {
	inst.AccountMetaSlice[0] = solana.Meta(pool).WRITE()
	inst.AccountMetaSlice[1] = solana.Meta(authority)
	inst.AccountMetaSlice[2] = solana.Meta(userWallet).WRITE().SIGNER()
	inst.AccountMetaSlice[3] = solana.Meta(sourceToken).WRITE()
	inst.AccountMetaSlice[4] = solana.Meta(destToken).WRITE()
	inst.AccountMetaSlice[5] = solana.Meta(baseVault).WRITE()
	inst.AccountMetaSlice[6] = solana.Meta(quoteVault).WRITE()
	return inst
}

// Добавляем метод для установки направления
func (inst *SwapInstruction) SetDirection(direction SwapDirection) *SwapInstruction {
	inst.Direction = &direction
	return inst
}

// Validate проверяет все необходимые параметры
func (inst *SwapInstruction) Validate() error {
	if inst.Amount == nil {
		return errors.New("Amount is not set")
	}
	if inst.MinimumOut == nil {
		return errors.New("MinimumOut is not set")
	}
	if inst.Direction == nil {
		return errors.New("Direction is not set")
	}

	// Проверка всех аккаунтов
	for i, acc := range inst.AccountMetaSlice {
		if acc == nil {
			return fmt.Errorf("account at index %d is not set", i)
		}
	}
	return nil
}

// ProgramID возвращает ID программы Raydium
func (i *RaydiumSwapInstruction) ProgramID() solana.PublicKey {
	return i.programID
}

// Accounts возвращает список аккаунтов
func (i *RaydiumSwapInstruction) Accounts() []*solana.AccountMeta {
	return i.accounts
}

// Data возвращает сериализованные данные инструкции
func (i *RaydiumSwapInstruction) Data() ([]byte, error) {
	return i.data, nil
}

// Build создает инструкцию
func (inst *SwapInstruction) Build() (solana.Instruction, error) {
	if err := inst.Validate(); err != nil {
		return nil, err
	}

	// Сериализация данных инструкции
	data := make([]byte, 17) // 16 байт для amount и minimumOut + 1 байт для direction
	binary.LittleEndian.PutUint64(data[0:8], *inst.Amount)
	binary.LittleEndian.PutUint64(data[8:16], *inst.MinimumOut)
	if *inst.Direction == SwapDirectionIn {
		data[16] = 0
	} else {
		data[16] = 1
	}

	instruction := &RaydiumSwapInstruction{
		programID: solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
		accounts:  inst.AccountMetaSlice,
		data:      data,
	}

	return instruction, nil
}

// CreateSwapInstructions создает инструкции для свапа
func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
	if err := validateSwapParams(params); err != nil {
		return nil, err
	}

	instructions := make([]solana.Instruction, 0)

	// Добавляем инструкцию compute budget если указан приоритетный fee
	if params.PriorityFeeLamports > 0 {
		computeLimitIx, err := computebudget.NewSetComputeUnitLimitInstructionBuilder().
			SetUnits(MAX_COMPUTE_UNIT_LIMIT).
			ValidateAndBuild()
		if err != nil {
			return nil, fmt.Errorf("failed to build compute limit instruction: %w", err)
		}
		instructions = append(instructions, computeLimitIx)

		computePriceIx, err := computebudget.NewSetComputeUnitPriceInstructionBuilder().
			SetMicroLamports(params.PriorityFeeLamports).
			ValidateAndBuild()
		if err != nil {
			return nil, fmt.Errorf("failed to build compute price instruction: %w", err)
		}
		instructions = append(instructions, computePriceIx)
	}

	// Создаем инструкцию свапа
	swapIx, err := NewSwapInstructionBuilder().
		SetAmount(params.AmountIn).
		SetMinimumOut(params.MinAmountOut).
		SetAccounts(
			params.Pool.ID,
			params.Pool.Authority,
			params.UserWallet,
			params.SourceTokenAccount,
			params.DestinationTokenAccount,
			params.Pool.BaseVault,
			params.Pool.QuoteVault,
		).
		Build()
	if err != nil {
		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
	}

	instructions = append(instructions, swapIx)

	return instructions, nil
}

// validateSwapParams проверяет входные параметры
func validateSwapParams(params *SwapParams) error {
	if params == nil {
		return errors.New("params cannot be nil")
	}
	if params.Pool == nil {
		return errors.New("pool cannot be nil")
	}
	if params.UserWallet.IsZero() {
		return errors.New("user wallet is required")
	}
	if params.SourceTokenAccount.IsZero() {
		return errors.New("source token account is required")
	}
	if params.DestinationTokenAccount.IsZero() {
		return errors.New("destination token account is required")
	}
	if params.AmountIn == 0 {
		return errors.New("amount in must be greater than 0")
	}
	if params.MinAmountOut == 0 {
		return errors.New("minimum amount out must be greater than 0")
	}
	return nil
}

// SimulateSwap выполняет симуляцию транзакции свапа
func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) error {
	c.logger.Debug("simulating swap transaction",
		zap.String("userWallet", params.UserWallet.String()),
		zap.Uint64("amountIn", params.AmountIn),
		zap.Uint64("minAmountOut", params.MinAmountOut),
		zap.String("pool", params.Pool.ID.String()),
	)

	// Получаем инструкции для свапа
	instructions, err := c.CreateSwapInstructions(params)
	if err != nil {
		return fmt.Errorf("failed to create swap instructions: %w", err)
	}

	// Получаем последний блокхеш
	recent, err := c.client.GetRecentBlockhash(ctx)
	if err != nil {
		return fmt.Errorf("failed to get recent blockhash: %w", err)
	}

	// Создаем транзакцию
	tx, err := solana.NewTransaction(
		instructions,
		recent,
		solana.TransactionPayer(params.UserWallet),
	)
	if err != nil {
		return fmt.Errorf("failed to create transaction: %w", err)
	}

	// Подписываем транзакцию если есть приватный ключ
	if params.PrivateKey != nil {
		tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
			if key.Equals(params.UserWallet) {
				return params.PrivateKey
			}
			return nil
		})
	}

	// Симулируем транзакцию
	simResult, err := c.client.SimulateTransaction(ctx, tx)
	if err != nil {
		return fmt.Errorf("failed to simulate transaction: %w", err)
	}

	// Проверяем результат симуляции
	if simResult.Err != nil {
		return fmt.Errorf("simulation failed: %s", simResult.Err)
	}

	// Анализируем логи симуляции
	for _, log := range simResult.Logs {
		c.logger.Debug("simulation log", zap.String("log", log))
	}

	c.logger.Info("swap simulation successful",
		zap.Uint64("unitsConsumed", simResult.UnitsConsumed),
		zap.String("sourceToken", params.SourceTokenAccount.String()),
		zap.String("destinationToken", params.DestinationTokenAccount.String()),
		zap.Uint64("priorityFee", params.PriorityFeeLamports),
	)

	return nil
}

// TODO:
// Основные улучшения, которые можно добавить:
// Retry логика для случаев временных сбоев
// Более детальная валидация результатов транзакции
// Механизм отмены операции по таймауту
// Сохранение истории транзакций
// Метрики выполнения свапов

// ExecuteSwap выполняет свап и возвращает signature транзакции
func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
	c.logger.Debug("starting swap execution",
		zap.String("userWallet", params.UserWallet.String()),
		zap.Uint64("amountIn", params.AmountIn),
		zap.Uint64("minAmountOut", params.MinAmountOut),
		zap.String("pool", params.Pool.ID.String()),
		zap.Uint64("priorityFee", params.PriorityFeeLamports),
	)

	// Базовая валидация параметров
	if err := validateSwapParams(params); err != nil {
		return "", fmt.Errorf("invalid swap parameters: %w", err)
	}

	// Проверяем баланс кошелька
	ctx := context.Background()
	balance, err := c.client.GetBalance(ctx, params.UserWallet, solanarpc.CommitmentConfirmed)
	if err != nil {
		return "", fmt.Errorf("failed to get wallet balance: %w", err)
	}

	// Учитываем приоритетную комиссию и обычную комиссию транзакции
	requiredBalance := params.AmountIn + params.PriorityFeeLamports + 5000
	if balance < requiredBalance {
		return "", fmt.Errorf("insufficient balance: required %d, got %d", requiredBalance, balance)
	}

	// Создаем все необходимые инструкции для свапа
	instructions, err := c.CreateSwapInstructions(params)
	if err != nil {
		return "", fmt.Errorf("failed to create swap instructions: %w", err)
	}

	// Получаем последний блокхеш
	recent, err := c.client.GetRecentBlockhash(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to get recent blockhash: %w", err)
	}

	// Создаем транзакцию
	tx, err := solana.NewTransaction(
		instructions,
		recent,
		solana.TransactionPayer(params.UserWallet),
	)
	if err != nil {
		return "", fmt.Errorf("failed to create transaction: %w", err)
	}

	// Подписываем транзакцию
	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
		if key.Equals(params.UserWallet) {
			if params.PrivateKey != nil {
				return params.PrivateKey
			}
			return &c.privateKey
		}
		return nil
	})
	if err != nil {
		return "", fmt.Errorf("failed to sign transaction: %w", err)
	}

	// Отправляем транзакцию
	sig, err := c.client.SendTransactionWithOpts(ctx, tx, blockchain.TransactionOptions{
		SkipPreflight:       true,
		PreflightCommitment: c.commitment, // используем commitment напрямую из клиента
	})
	if err != nil {
		return "", fmt.Errorf("failed to send transaction: %w", err)
	}

	c.logger.Info("swap executed successfully",
		zap.String("signature", sig.String()),
		zap.String("explorer", fmt.Sprintf("https://explorer.solana.com/tx/%s", sig.String())),
	)

	return sig.String(), nil
}

// logUpdatedBalances вспомогательный метод для логирования балансов после свапа
func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
	ctx := context.Background()

	// Получаем баланс SOL
	solBalance, err := c.client.GetBalance(
		ctx,
		params.UserWallet,
		solanarpc.CommitmentConfirmed,
	)
	if err != nil {
		return fmt.Errorf("failed to get SOL balance: %w", err)
	}

	// Получаем баланс токена
	tokenBalance, err := c.client.GetTokenAccountBalance(
		ctx,
		params.DestinationTokenAccount,
		solanarpc.CommitmentConfirmed,
	)
	if err != nil {
		return fmt.Errorf("failed to get token balance: %w", err)
	}

	c.logger.Info("updated balances",
		zap.Float64("solBalance", float64(solBalance)/float64(solana.LAMPORTS_PER_SOL)),
		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
	)

	return nil
}

// internal/dex/raydium/constants.go
package raydium

import "fmt"

// Program IDs
const (
	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
	TOKEN_PROGRAM_ID      = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
	SYSTEM_PROGRAM_ID     = "11111111111111111111111111111111"
	SYSVAR_RENT_PUBKEY    = "SysvarRent111111111111111111111111111111111"
	WRAPPED_SOL_MINT      = "So11111111111111111111111111111111111111112" // Добавлено
)

// Compute budget constants
const (
	MAX_COMPUTE_UNIT_LIMIT = 300000
	DEFAULT_COMPUTE_PRICE  = 1000
	MIN_COMPUTE_PRICE      = 0      // Добавлено
	MAX_COMPUTE_PRICE      = 100000 // Добавлено
)

// Pool account layout constants
const (
	POOL_ACCOUNT_SIZE     = 388
	POOL_VERSION_OFFSET   = 0 // Добавлено
	STATUS_OFFSET         = 1 // Добавлено
	BASE_MINT_OFFSET      = 8
	QUOTE_MINT_OFFSET     = 40
	LP_MINT_OFFSET        = 72 // Добавлено
	BASE_VAULT_OFFSET     = 104
	QUOTE_VAULT_OFFSET    = 136
	DECIMALS_OFFSET       = 168
	FEE_BPS_OFFSET        = 170
	POOL_STATUS_OFFSET    = 188
	AMM_OPEN_ORDERS       = 196
	MARKET_ID_OFFSET      = 228
	TARGET_ORDERS_OFFSET  = 260 // Добавлено
	WITHDRAW_QUEUE_OFFSET = 292 // Добавлено
)

// Pool status
const (
	POOL_STATUS_UNINITIALIZED uint8 = 0
	POOL_STATUS_INITIALIZED   uint8 = 1
	POOL_STATUS_DISABLED      uint8 = 2
	POOL_STATUS_ACTIVE        uint8 = 3
)

// PDA seeds
const (
	AMM_AUTHORITY_LAYOUT = "amm_authority"
	POOL_TEMP_LP_LAYOUT  = "pool_temp_lp"
	POOL_WITHDRAW_QUEUE  = "withdraw_queue"
	TARGET_ORDERS_SEED   = "target_orders" // Добавлено
	OPEN_ORDERS_SEED     = "open_orders"   // Добавлено
)

// Swap constants
const (
	DEFAULT_SLIPPAGE_PERCENT = 0.5
	MAX_SLIPPAGE_PERCENT     = 5.0
	MIN_SWAP_AMOUNT          = 1000   // Добавлено: минимальная сумма для свапа в лампортах
	MAX_TOKENS_IN_POOL       = 100000 // Добавлено: максимальное количество токенов в пуле
	TRADE_DIRECTION_IN       = "in"   // Добавлено
	TRADE_DIRECTION_OUT      = "out"  // Добавлено
)

// Error codes
const (
	ERR_POOL_NOT_FOUND      = "POOL_NOT_FOUND" // Изменено на uppercase
	ERR_INVALID_POOL_STATUS = "INVALID_POOL_STATUS"
	ERR_INSUFFICIENT_FUNDS  = "INSUFFICIENT_FUNDS"
	ERR_SLIPPAGE_EXCEEDED   = "SLIPPAGE_EXCEEDED"
	ERR_INVALID_MINT        = "INVALID_MINT"
	ERR_INVALID_AMOUNT      = "INVALID_AMOUNT"    // Добавлено
	ERR_POOL_DISABLED       = "POOL_DISABLED"     // Добавлено
	ERR_INVALID_DIRECTION   = "INVALID_DIRECTION" // Добавлено
)

// Account size constants
const (
	TOKEN_ACCOUNT_SIZE = 165 // Добавлено
	MINT_ACCOUNT_SIZE  = 82  // Добавлено
)

func (e *RaydiumError) Error() string {
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// Добавляем конструктор для RaydiumError
func NewRaydiumError(code string, message string, details map[string]interface{}) *RaydiumError {
	return &RaydiumError{
		Code:    code,
		Message: message,
		Details: details,
	}
}
// internal/dex/raydium/pool.go - это пакет, который содержит в себе реализацию работы с пулами Raydium
package raydium

import (
	"context"
	"encoding/binary"
	"fmt"

	"github.com/gagliardetto/solana-go"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
	"go.uber.org/zap"
)

// NewPoolManager создает новый менеджер пула
func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *RaydiumPool) *PoolManager {
	return &PoolManager{
		client: client,
		logger: logger,
		pool:   pool,
	}
}

// TODO: В дальнейшем этот код можно расширить:
// 1. Добавить более сложную формулу расчета с учетом комиссий
// 2. Реализовать кэширование состояния пула
// 3. Добавить больше проверок валидации
// 4. Улучшить обработку ошибок и логирование

// GetPoolState получает актуальное состояние пула
func (pm *PoolManager) GetPoolState(ctx context.Context) (*PoolState, error) {
	pm.logger.Debug("getting pool state",
		zap.String("poolId", pm.pool.ID.String()),
	)

	// Получаем данные аккаунта пула
	account, err := pm.client.GetAccountInfo(ctx, pm.pool.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get pool account: %w", err)
	}

	// Проверяем что аккаунт существует и содержит данные
	if account == nil || account.Value == nil || account.Value.Data.GetBinary() == nil {
		return nil, fmt.Errorf("pool account data is empty")
	}

	// Получаем бинарные данные аккаунта
	data := account.Value.Data.GetBinary()

	// Проверяем достаточную длину данных
	if len(data) < 89 { // минимальная длина для наших полей
		return nil, fmt.Errorf("invalid pool data length: %d", len(data))
	}

	// Парсим данные в структуру состояния
	state := &PoolState{
		BaseReserve:  binary.LittleEndian.Uint64(data[64:72]), // резервы base токена
		QuoteReserve: binary.LittleEndian.Uint64(data[72:80]), // резервы quote токена
		Status:       data[88],                                // статус пула
	}

	return state, nil
}

// CalculateAmounts рассчитывает количество выходных токенов и минимальный выход
func (pm *PoolManager) CalculateAmounts(ctx context.Context) (*SwapAmounts, error) {
	// Получаем текущее состояние пула
	state, err := pm.GetPoolState(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get pool state: %w", err)
	}

	// Проверяем, что пул активен
	if state.Status != 1 { // предполагаем, что 1 = активный статус
		return nil, fmt.Errorf("pool is not active")
	}

	// Расчет по формуле: amountOut = (amountIn * outputReserve) / (inputReserve + amountIn)
	// Это упрощенная формула для начала
	amountIn := uint64(1000000) // пример входного количества
	amountOut := (amountIn * state.QuoteReserve) / (state.BaseReserve + amountIn)

	// Учитываем проскальзывание (например, 1%)
	slippage := uint64(100) // 1%
	minAmountOut := amountOut - (amountOut * slippage / 10000)

	return &SwapAmounts{
		AmountIn:     amountIn,
		AmountOut:    amountOut,
		MinAmountOut: minAmountOut,
	}, nil
}

// ValidatePool проверяет валидность параметров пула
func (pm *PoolManager) ValidatePool(ctx context.Context) error {
	// Проверяем существование всех необходимых аккаунтов
	accounts := []solana.PublicKey{
		pm.pool.ID,
		pm.pool.Authority,
		pm.pool.BaseMint,
		pm.pool.QuoteMint,
		pm.pool.BaseVault,
		pm.pool.QuoteVault,
	}

	for _, acc := range accounts {
		if acc.IsZero() {
			return fmt.Errorf("invalid pool account: %s is zero", acc.String())
		}
	}

	// Проверяем состояние пула
	state, err := pm.GetPoolState(ctx)
	if err != nil {
		return fmt.Errorf("failed to get pool state: %w", err)
	}

	// Проверяем резервы
	if state.BaseReserve == 0 || state.QuoteReserve == 0 {
		return fmt.Errorf("pool reserves are empty: base=%d, quote=%d",
			state.BaseReserve, state.QuoteReserve)
	}

	// Проверяем статус
	if state.Status != 1 { // предполагаем, что 1 = активный статус
		return fmt.Errorf("pool is not active")
	}

	return nil
}
// internal/dex/raydium/sniper.go - это пакет, который содержит в себе реализацию снайпинга на декстере Raydium
package raydium

import (
	"context"
	"fmt"
	"math"
	"time"

	"github.com/gagliardetto/solana-go"
	solanarpc "github.com/gagliardetto/solana-go/rpc"
	"go.uber.org/zap"
)

// TODO: можно добавить:

// 1. Проверку цены перед свапом
// 2. Мониторинг состояния пула в реальном времени
// 3. Более сложную логику расчета суммы свапа
// 4. Обработку различных ошибок и ретраи
// 5. Асинхронное выполнение свапа

func (s *Sniper) ExecuteSnipe() error {
	s.logger.Debug("starting snipe execution")

	// 1. Получение пула и валидация параметров
	if err := s.ValidateAndPrepare(); err != nil {
		return fmt.Errorf("failed to validate parameters: %w", err)
	}

	// 2. Получение информации о пуле и проверка его состояния
	pool, err := s.client.GetPool(context.Background(), s.config.BaseMint, s.config.QuoteMint)
	if err != nil {
		return fmt.Errorf("failed to get pool: %w", err)
	}

	poolManager := NewPoolManager(s.client.client, s.logger, pool)
	if err := poolManager.ValidatePool(context.Background()); err != nil {
		return fmt.Errorf("pool validation failed: %w", err)
	}

	// 3. Расчет параметров свапа
	amounts, err := poolManager.CalculateAmounts(context.Background())
	if err != nil {
		return fmt.Errorf("failed to calculate swap amounts: %w", err)
	}

	// 4. Подготовка параметров для свапа
	swapParams := &SwapParams{
		UserWallet:          s.client.privateKey.PublicKey(),
		AmountIn:            amounts.AmountIn,
		MinAmountOut:        amounts.MinAmountOut,
		Pool:                pool,
		PriorityFeeLamports: s.config.PriorityFee,
		// Здесь нужно добавить source и destination token accounts
	}

	// 5. Выполнение свапа
	signature, err := s.client.ExecuteSwap(swapParams)
	if err != nil {
		return fmt.Errorf("swap execution failed: %w", err)
	}

	// Логируем успешное выполнение
	s.logger.Info("snipe executed successfully",
		zap.String("signature", signature),
		zap.Uint64("amountIn", amounts.AmountIn),
		zap.Uint64("amountOut", amounts.AmountOut),
		zap.Uint64("minAmountOut", amounts.MinAmountOut),
	)

	return nil
}

// TODO: Потенциальные улучшения на основе TS версии:
// 1. Добавить проверку и создание associated token accounts
// 2. Добавить проверку балансов SOL и токенов
// 3. Добавить валидацию параметров compute budget
// 4. Добавить проверку версии пула (V4)
// 5. Добавить расчет приоритетной комиссии на основе последних блоков
// 6. Добавить проверку и обработку wrapped SOL
func (s *Sniper) ValidateAndPrepare() error {
	s.logger.Debug("validating and preparing snipe parameters")

	// Проверяем базовые параметры конфигурации
	if s.config.MaxSlippageBps == 0 || s.config.MaxSlippageBps > 10000 { // 10000 = 100%
		return fmt.Errorf("invalid slippage: must be between 0 and 10000")
	}

	if s.config.MinAmountSOL <= 0 || s.config.MaxAmountSOL <= 0 {
		return fmt.Errorf("invalid amount parameters")
	}

	if s.config.MaxAmountSOL < s.config.MinAmountSOL {
		return fmt.Errorf("maxAmount cannot be less than minAmount")
	}

	// Проверяем mint addresses
	if s.config.BaseMint.IsZero() || s.config.QuoteMint.IsZero() {
		return fmt.Errorf("invalid mint addresses")
	}

	// Проверяем наличие достаточного баланса
	balance, err := s.client.client.GetBalance(
		context.Background(),
		s.client.privateKey.PublicKey(),
		solanarpc.CommitmentConfirmed,
	)
	if err != nil {
		return fmt.Errorf("failed to get wallet balance: %w", err)
	}

	if balance/solana.LAMPORTS_PER_SOL < s.config.MinAmountSOL {
		return fmt.Errorf("insufficient balance")
	}

	// Проверяем параметры мониторинга
	if s.config.MonitorInterval < time.Second {
		return fmt.Errorf("monitor interval too small")
	}

	if s.config.MaxRetries < 1 {
		return fmt.Errorf("invalid max retries value")
	}

	return nil
}

// TODO: Потенциальные улучшения на основе TS версии:
// 1. Добавить отслеживание изменений цены
// 2. Добавить отслеживание объема ликвидности
// 3. Добавить механизм подписки на события пула
// 4. Добавить отслеживание транзакций в мемпуле
// 5. Добавить механизм websocket подключения
// 6. Добавить механизм агрегации данных по нескольким RPC
func (s *Sniper) MonitorPoolChanges() error {
	s.logger.Debug("starting pool monitoring")

	ticker := time.NewTicker(s.config.MonitorInterval)
	defer ticker.Stop()

	// Получаем начальное состояние пула
	pool, err := s.client.GetPool(context.Background(), s.config.BaseMint, s.config.QuoteMint)
	if err != nil {
		return fmt.Errorf("failed to get initial pool state: %w", err)
	}

	poolManager := NewPoolManager(s.client.client, s.logger, pool)
	initialState, err := poolManager.GetPoolState(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get initial pool state: %w", err)
	}

	var retryCount int
	for {
		select {
		case <-ticker.C:
			// Получаем текущее состояние пула
			currentState, err := poolManager.GetPoolState(context.Background())
			if err != nil {
				retryCount++
				s.logger.Error("failed to get current pool state",
					zap.Error(err),
					zap.Int("retry", retryCount),
				)
				if retryCount >= s.config.MaxRetries {
					return fmt.Errorf("max retries exceeded while monitoring pool")
				}
				continue
			}
			retryCount = 0

			// Проверяем изменения в пуле
			if s.hasSignificantChanges(initialState, currentState) {
				s.logger.Info("detected significant pool changes",
					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
					zap.Uint64("newBaseReserve", currentState.BaseReserve),
					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
				)

				// Если пул неактивен, прекращаем мониторинг
				if currentState.Status != 1 {
					return fmt.Errorf("pool became inactive")
				}

				// Обновляем начальное состояние
				initialState = currentState
			}
		}
	}
}

// Вспомогательный метод для определения значительных изменений в пуле
func (s *Sniper) hasSignificantChanges(old, new *PoolState) bool {
	// Рассчитываем процент изменения для базового резерва
	baseChange := math.Abs(float64(new.BaseReserve)-float64(old.BaseReserve)) / float64(old.BaseReserve)

	// Рассчитываем процент изменения для котируемого резерва
	quoteChange := math.Abs(float64(new.QuoteReserve)-float64(old.QuoteReserve)) / float64(old.QuoteReserve)

	// Определяем порог значительных изменений (например, 1%)
	threshold := 0.01

	return baseChange > threshold || quoteChange > threshold || new.Status != old.Status
}
// inernal/dex/raydium/types.go - это пакет, который содержит в себе реализацию работы с декстерами Raydium
package raydium

import (
	"time"

	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
	"go.uber.org/zap"
)

// Нужно добавить
type TokenAmount struct {
	Raw      uint64
	Decimals uint8
}

// Нужно добавить
type SwapDirection string

const (
	SwapDirectionIn  SwapDirection = "in"
	SwapDirectionOut SwapDirection = "out"
)

// Нужно добавить
type PoolVersion uint8

const (
	PoolVersionV4 PoolVersion = 4
	PoolVersionV3 PoolVersion = 3
)

type RaydiumPool struct {
	ID            solana.PublicKey // Идентификатор пула
	Authority     solana.PublicKey // Публичный ключ, который имеет полномочия управлять пулом
	BaseMint      solana.PublicKey // Публичный ключ базового токена
	QuoteMint     solana.PublicKey // Публичный ключ котируемого токена
	BaseVault     solana.PublicKey // Публичный ключ хранилища базового токена
	QuoteVault    solana.PublicKey // Публичный ключ хранилища котируемого токена
	BaseDecimals  uint8            // Количество десятичных знаков базового токена
	QuoteDecimals uint8            // Количество десятичных знаков котируемого токена
	DefaultFeeBps uint16           // Комиссия по умолчанию в базисных пунктах (bps)
	// Только необходимые поля для V4

	Version PoolVersion
	State   PoolState // встроенное состояние
}

type PoolState struct {
	BaseReserve  uint64 // Резерв базового токена в пуле
	QuoteReserve uint64 // Резерв котируемого токена в пуле
	Status       uint8  // Статус пула (например, активен или неактивен)
}

type SwapParams struct {
	UserWallet              solana.PublicKey   // Публичный ключ кошелька пользователя
	PrivateKey              *solana.PrivateKey // Приватный ключ для подписания транзакции
	AmountIn                uint64             // Количество входного токена для обмена
	MinAmountOut            uint64             // Минимальное количество выходного токена
	Pool                    *RaydiumPool       // Указатель на пул для обмена
	SourceTokenAccount      solana.PublicKey   // Аккаунт исходного токена
	DestinationTokenAccount solana.PublicKey   // Аккаунт целевого токена
	PriorityFeeLamports     uint64             // Приоритетная комиссия в лампортах

	Direction   SwapDirection
	SlippageBps uint16
	Deadline    time.Time // таймаут для транзакции
}

type RaydiumClient struct {
	client      blockchain.Client
	logger      *zap.Logger
	privateKey  solana.PrivateKey
	timeout     time.Duration
	retries     int
	priorityFee uint64
	commitment  rpc.CommitmentType
}

// type clientOptions struct {
// 	timeout     time.Duration      // Таймаут для операций
// 	retries     int                // Количество повторных попыток
// 	priorityFee uint64             // Приоритетная комиссия в лампортах
// 	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
// }

type SwapInstruction struct {
	Amount     *uint64
	MinimumOut *uint64
	Direction  *SwapDirection // добавляем как указатель для консистентности

	// Slice для хранения аккаунтов, следуя паттерну из SDK
	solana.AccountMetaSlice `bin:"-" borsh_skip:"true"`
}

// RaydiumSwapInstruction реализует интерфейс solana.Instruction
type RaydiumSwapInstruction struct {
	programID solana.PublicKey
	accounts  []*solana.AccountMeta
	data      []byte
}

// RaydiumError represents a custom error type
type RaydiumError struct {
	Code    string
	Message string
	Stage   string
	Details map[string]interface{}
	Err     error
}

type SwapAmounts struct {
	AmountIn     uint64 // Количество входных токенов
	AmountOut    uint64 // Ожидаемое количество выходных токенов
	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
}

type PoolManager struct {
	client blockchain.Client
	logger *zap.Logger
	pool   *RaydiumPool
}

type Sniper struct {
	client *RaydiumClient
	logger *zap.Logger
	config *SniperConfig // Конфигурация снайпинга
}
type SniperConfig struct {
	// Существующие поля
	MaxSlippageBps   uint16 // экспортируемые поля
	MinAmountSOL     uint64 // использовать lamports вместо float64
	MaxAmountSOL     uint64
	PriorityFee      uint64
	WaitConfirmation bool
	MonitorInterval  time.Duration
	MaxRetries       int

	// Добавляем новые необходимые поля
	BaseMint  solana.PublicKey // Mint address базового токена
	QuoteMint solana.PublicKey // Mint address котируемого токена
}
