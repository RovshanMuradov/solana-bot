// internal/dex/raydium/client.go - это пакет, который содержит в себе реализацию клиента для работы с декстером Raydium
package raydium

import (
	"encoding/binary"
	"fmt"
	"time"

	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
	"go.uber.org/zap"
)

const (
	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
)

type RaydiumClient struct {
	client  blockchain.Client
	logger  *zap.Logger
	options *clientOptions // Базовые настройки таймаутов и retry
}
type clientOptions struct {
	timeout     time.Duration      // Таймаут для операций
	retries     int                // Количество повторных попыток
	priorityFee uint64             // Приоритетная комиссия в лампортах
	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
}

// Вспомогательные структуры для инструкций
type ComputeBudgetInstruction struct {
	Units         uint32
	MicroLamports uint64
}

type SwapInstruction struct {
	Amount     uint64
	MinimumOut uint64
}

// NewRaydiumClient создает новый экземпляр клиента Raydium
func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) *RaydiumClient {
	// Инициализация с базовыми настройками

	opts := &clientOptions{
		timeout:     30 * time.Second,
		retries:     3,
		priorityFee: 1000, // базовое значение в лампортах
		commitment:  rpc.CommitmentConfirmed,
	}

	client := blockchain.NewSolanaClient(rpcEndpoint, wallet)

	return &RaydiumClient{
		client:  client,
		logger:  logger,
		options: opts,
	}
}

// GetPool получает информацию о пуле по базовому и котируемому токенам
func (c *RaydiumClient) GetPool(baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
	// Получение информации о пуле

	c.logger.Debug("getting raydium pool info",
		zap.String("baseMint", baseMint.String()),
		zap.String("quoteMint", quoteMint.String()),
	)

	// Получаем программные аккаунты по фильтрам
	accounts, err := c.client.GetProgramAccounts(
		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
		rpc.GetProgramAccountsOpts{
			Filters: []rpc.RPCFilter{
				{
					DataSize: 388, // размер аккаунта пула v4
				},
				{
					Memcmp: &rpc.RPCFilterMemcmp{
						Offset: 8, // смещение для baseMint
						Bytes:  baseMint.Bytes(),
					},
				},
				{
					Memcmp: &rpc.RPCFilterMemcmp{
						Offset: 40, // смещение для quoteMint
						Bytes:  quoteMint.Bytes(),
					},
				},
			},
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get program accounts: %w", err)
	}

	if len(accounts) == 0 {
		return nil, fmt.Errorf("pool not found")
	}

	// Берем первый найденный пул
	poolAccount := accounts[0]

	// Парсим данные аккаунта в структуру пула
	pool := &RaydiumPool{
		ID:        poolAccount.PublicKey,
		BaseMint:  baseMint,
		QuoteMint: quoteMint,
		// ... заполнение остальных полей из данных аккаунта
	}

	return pool, nil
}

// GetPoolState получает текущее состояние пула
func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
	c.logger.Debug("getting pool state",
		zap.String("poolId", pool.ID.String()),
	)

	// Получаем данные аккаунта пула
	account, err := c.client.GetAccountInfo(pool.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get pool account: %w", err)
	}

	// Парсим данные в структуру состояния
	state := &PoolState{
		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // пример смещения
		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // пример смещения
		Status:       account.Data[88],                                // пример смещения
	}

	return state, nil
}

// TODO:
// Для полноценной работы нужно добавить:
// Корректную сериализацию инструкций (согласно протоколу Raydium)
// Детальную обработку различных типов ошибок
// Валидацию параметров свапа
// Обработку разных версий пулов
// Расчет слиппажа и проверку лимитов

// CreateSwapInstructions создает набор инструкций для свапа
func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
	c.logger.Debug("creating swap instructions",
		zap.String("userWallet", params.UserWallet.String()),
		zap.Uint64("amountIn", params.AmountIn),
		zap.Uint64("minAmountOut", params.MinAmountOut),
	)

	// Создаем базовый массив инструкций
	instructions := make([]solana.Instruction, 0)

	// Создаем инструкцию для установки приоритета комиссии
	if params.PriorityFeeLamports > 0 {
		computeBudgetIx := solana.NewInstruction(
			solana.ComputeBudget,
			&ComputeBudgetInstruction{
				Units:         300000, // базовые compute units как в typescript
				MicroLamports: params.PriorityFeeLamports,
			},
		)
		instructions = append(instructions, computeBudgetIx)
	}

	// Создаем основную инструкцию свапа
	swapIx := solana.NewInstruction(
		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
		&SwapInstruction{
			Amount:     params.AmountIn,
			MinimumOut: params.MinAmountOut,
		},
		// Добавляем необходимые аккаунты
		[]solana.AccountMeta{
			{PublicKey: params.Pool.ID, IsWritable: true, IsSigner: false},
			{PublicKey: params.Pool.Authority, IsWritable: false, IsSigner: false},
			{PublicKey: params.UserWallet, IsWritable: true, IsSigner: true},
			{PublicKey: params.SourceTokenAccount, IsWritable: true, IsSigner: false},
			{PublicKey: params.DestinationTokenAccount, IsWritable: true, IsSigner: false},
			{PublicKey: params.Pool.BaseVault, IsWritable: true, IsSigner: false},
			{PublicKey: params.Pool.QuoteVault, IsWritable: true, IsSigner: false},
			// Добавляем остальные необходимые аккаунты
		},
	)
	instructions = append(instructions, swapIx)

	return instructions, nil
}

// SimulateSwap выполняет симуляцию транзакции свапа
func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
	c.logger.Debug("simulating swap transaction")

	// Получаем инструкции для свапа
	instructions, err := c.CreateSwapInstructions(params)
	if err != nil {
		return fmt.Errorf("failed to create swap instructions: %w", err)
	}

	// Создаем транзакцию
	recent, err := c.client.GetRecentBlockhash()
	if err != nil {
		return fmt.Errorf("failed to get recent blockhash: %w", err)
	}

	tx := solana.NewTransaction(
		instructions,
		recent.Value.Blockhash,
		solana.TransactionPayer(params.UserWallet),
	)

	// Симулируем транзакцию
	sim, err := c.client.SimulateTransaction(tx, &rpc.SimulateTransactionOpts{
		SigVerify:              false,
		Commitment:             c.options.commitment,
		ReplaceRecentBlockhash: true,
	})
	if err != nil {
		return fmt.Errorf("failed to simulate transaction: %w", err)
	}

	// Проверяем результат симуляции
	if sim.Value.Err != nil {
		return fmt.Errorf("simulation failed: %s", sim.Value.Err)
	}

	// Анализируем логи симуляции
	for _, log := range sim.Value.Logs {
		c.logger.Debug("simulation log", zap.String("log", log))
	}

	c.logger.Info("swap simulation successful",
		zap.Uint64("unitsConsumed", sim.Value.UnitsConsumed),
	)

	return nil
}

// TODO:
// Основные улучшения, которые можно добавить:
// Retry логика для случаев временных сбоев
// Более детальная валидация результатов транзакции
// Механизм отмены операции по таймауту
// Сохранение истории транзакций
// Метрики выполнения свапов

// ExecuteSwap выполняет свап и возвращает signature транзакции
func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
	c.logger.Debug("executing swap",
		zap.String("userWallet", params.UserWallet.String()),
		zap.Uint64("amountIn", params.AmountIn),
		zap.Uint64("minAmountOut", params.MinAmountOut),
	)

	// Сначала симулируем транзакцию
	if err := c.SimulateSwap(params); err != nil {
		return "", fmt.Errorf("swap simulation failed: %w", err)
	}

	// Получаем инструкции для свапа
	instructions, err := c.CreateSwapInstructions(params)
	if err != nil {
		return "", fmt.Errorf("failed to create swap instructions: %w", err)
	}

	// Получаем последний блокхэш
	recent, err := c.client.GetRecentBlockhash()
	if err != nil {
		return "", fmt.Errorf("failed to get recent blockhash: %w", err)
	}

	// Создаем транзакцию
	tx := solana.NewTransaction(
		instructions,
		recent.Value.Blockhash,
		solana.TransactionPayer(params.UserWallet),
	)

	// Подписываем транзакцию
	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
		if key.Equals(params.UserWallet) {
			return &c.client.PrivateKey
		}
		return nil
	})
	if err != nil {
		return "", fmt.Errorf("failed to sign transaction: %w", err)
	}

	// Отправляем транзакцию
	sig, err := c.client.SendTransaction(tx, &rpc.SendTransactionOpts{
		SkipPreflight:       true,
		PreflightCommitment: c.options.commitment,
	})
	if err != nil {
		return "", fmt.Errorf("failed to send transaction: %w", err)
	}

	// Ждем подтверждения транзакции
	confirmationStrategy := rpc.TransactionConfirmationStrategy{
		Signature:            sig,
		Commitment:           c.options.commitment,
		LastValidBlockHeight: recent.Value.LastValidBlockHeight,
	}

	startTime := time.Now()
	confirmation, err := c.client.ConfirmTransaction(
		confirmationStrategy,
		&rpc.ConfirmTransactionOpts{
			MaxRetries: c.options.retries,
			Timeout:    c.options.timeout,
		},
	)
	if err != nil {
		return sig, fmt.Errorf("failed to confirm transaction: %w", err)
	}

	// Проверяем статус подтверждения
	if confirmation.Value.Err != nil {
		return sig, fmt.Errorf("transaction confirmed with error: %v", confirmation.Value.Err)
	}

	c.logger.Info("swap executed successfully",
		zap.String("signature", sig),
		zap.Duration("duration", time.Since(startTime)),
	)

	// Опционально: получаем и логируем новые балансы
	if err := c.logUpdatedBalances(params); err != nil {
		c.logger.Warn("failed to get updated balances", zap.Error(err))
	}

	return sig, nil
}

// logUpdatedBalances вспомогательный метод для логирования балансов после свапа
func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
	// Получаем баланс SOL
	solBalance, err := c.client.GetBalance(
		params.UserWallet,
		rpc.CommitmentConfirmed,
	)
	if err != nil {
		return fmt.Errorf("failed to get SOL balance: %w", err)
	}

	// Получаем баланс токена
	tokenBalance, err := c.client.GetTokenAccountBalance(
		params.DestinationTokenAccount,
		rpc.CommitmentConfirmed,
	)
	if err != nil {
		return fmt.Errorf("failed to get token balance: %w", err)
	}

	c.logger.Info("updated balances",
		zap.Float64("solBalance", float64(solBalance.Value)/float64(solana.LAMPORTS_PER_SOL)),
		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
	)

	return nil
}

// internal/dex/raydium/pool.go - это пакет, который содержит в себе реализацию работы с пулами Raydium
package raydium

import (
	"encoding/binary"
	"fmt"

	"github.com/gagliardetto/solana-go"
	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
	"go.uber.org/zap"
)

type SwapAmounts struct {
	AmountIn     uint64 // Количество входных токенов
	AmountOut    uint64 // Ожидаемое количество выходных токенов
	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
}

type PoolManager struct {
	client blockchain.Client
	logger *zap.Logger
	pool   *RaydiumPool
}

// NewPoolManager создает новый менеджер пула
func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *RaydiumPool) *PoolManager {
	return &PoolManager{
		client: client,
		logger: logger,
		pool:   pool,
	}
}

// TODO: В дальнейшем этот код можно расширить:
// 1. Добавить более сложную формулу расчета с учетом комиссий
// 2. Реализовать кэширование состояния пула
// 3. Добавить больше проверок валидации
// 4. Улучшить обработку ошибок и логирование

// GetPoolState получает актуальное состояние пула
func (pm *PoolManager) GetPoolState() (*PoolState, error) {
	pm.logger.Debug("getting pool state",
		zap.String("poolId", pm.pool.ID.String()),
	)

	// Получаем данные аккаунта пула
	account, err := pm.client.GetAccountInfo(pm.pool.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get pool account: %w", err)
	}

	// Парсим данные в структуру состояния
	state := &PoolState{
		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // резервы base токена
		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // резервы quote токена
		Status:       account.Data[88],                                // статус пула
	}

	return state, nil
}

// CalculateAmounts рассчитывает количество выходных токенов и минимальный выход
func (pm *PoolManager) CalculateAmounts() (*SwapAmounts, error) {
	// Получаем текущее состояние пула
	state, err := pm.GetPoolState()
	if err != nil {
		return nil, fmt.Errorf("failed to get pool state: %w", err)
	}

	// Проверяем, что пул активен
	if state.Status != 1 { // предполагаем, что 1 = активный статус
		return nil, fmt.Errorf("pool is not active")
	}

	// Расчет по формуле: amountOut = (amountIn * outputReserve) / (inputReserve + amountIn)
	// Это упрощенная формула для начала
	amountIn := uint64(1000000) // пример входного количества
	amountOut := (amountIn * state.QuoteReserve) / (state.BaseReserve + amountIn)

	// Учитываем проскальзывание (например, 1%)
	slippage := uint64(100) // 1%
	minAmountOut := amountOut - (amountOut * slippage / 10000)

	return &SwapAmounts{
		AmountIn:     amountIn,
		AmountOut:    amountOut,
		MinAmountOut: minAmountOut,
	}, nil
}

// ValidatePool проверяет валидность параметров пула
func (pm *PoolManager) ValidatePool() error {
	// Проверяем существование всех необходимых аккаунтов
	accounts := []solana.PublicKey{
		pm.pool.ID,
		pm.pool.Authority,
		pm.pool.BaseMint,
		pm.pool.QuoteMint,
		pm.pool.BaseVault,
		pm.pool.QuoteVault,
	}

	for _, acc := range accounts {
		if acc.IsZero() {
			return fmt.Errorf("invalid pool account: %s is zero", acc.String())
		}
	}

	// Проверяем состояние пула
	state, err := pm.GetPoolState()
	if err != nil {
		return fmt.Errorf("failed to get pool state: %w", err)
	}

	// Проверяем резервы
	if state.BaseReserve == 0 || state.QuoteReserve == 0 {
		return fmt.Errorf("pool reserves are empty: base=%d, quote=%d",
			state.BaseReserve, state.QuoteReserve)
	}

	// Проверяем статус
	if state.Status != 1 { // предполагаем, что 1 = активный статус
		return fmt.Errorf("pool is not active")
	}

	return nil
}

// internal/dex/raydium/sniper.go - это пакет, который содержит в себе реализацию снайпинга на декстере Raydium
package raydium

import (
	"fmt"
	"math"
	"time"

	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
	"go.uber.org/zap"
)

type Sniper struct {
	client *RaydiumClient
	logger *zap.Logger
	config *SniperConfig // Конфигурация снайпинга
}
type SniperConfig struct {
	// Существующие поля
	maxSlippageBps   uint16
	minAmountSOL     float64
	maxAmountSOL     float64
	priorityFee      uint64
	waitConfirmation bool
	monitorInterval  time.Duration
	maxRetries       int

	// Добавляем новые необходимые поля
	baseMint  solana.PublicKey // Mint address базового токена
	quoteMint solana.PublicKey // Mint address котируемого токена
}

// TODO: можно добавить:

// 1. Проверку цены перед свапом
// 2. Мониторинг состояния пула в реальном времени
// 3. Более сложную логику расчета суммы свапа
// 4. Обработку различных ошибок и ретраи
// 5. Асинхронное выполнение свапа

func (s *Sniper) ExecuteSnipe() error {
	s.logger.Debug("starting snipe execution")

	// 1. Получение пула и валидация параметров
	if err := s.ValidateAndPrepare(); err != nil {
		return fmt.Errorf("failed to validate parameters: %w", err)
	}

	// 2. Получение информации о пуле и проверка его состояния
	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
	if err != nil {
		return fmt.Errorf("failed to get pool: %w", err)
	}

	poolManager := NewPoolManager(s.client.client, s.logger, pool)
	if err := poolManager.ValidatePool(); err != nil {
		return fmt.Errorf("pool validation failed: %w", err)
	}

	// 3. Расчет параметров свапа
	amounts, err := poolManager.CalculateAmounts()
	if err != nil {
		return fmt.Errorf("failed to calculate swap amounts: %w", err)
	}

	// 4. Подготовка параметров для свапа
	swapParams := &SwapParams{
		UserWallet:          s.client.client.PrivateKey.PublicKey(),
		AmountIn:            amounts.AmountIn,
		MinAmountOut:        amounts.MinAmountOut,
		Pool:                pool,
		PriorityFeeLamports: s.config.priorityFee,
		// Здесь нужно добавить source и destination token accounts,
		// которые должны быть получены или созданы заранее
	}

	// 5. Выполнение свапа
	signature, err := s.client.ExecuteSwap(swapParams)
	if err != nil {
		return fmt.Errorf("swap execution failed: %w", err)
	}

	// Логируем успешное выполнение
	s.logger.Info("snipe executed successfully",
		zap.String("signature", signature),
		zap.Uint64("amountIn", amounts.AmountIn),
		zap.Uint64("amountOut", amounts.AmountOut),
		zap.Uint64("minAmountOut", amounts.MinAmountOut),
	)

	return nil
}

// TODO: Потенциальные улучшения на основе TS версии:
// 1. Добавить проверку и создание associated token accounts
// 2. Добавить проверку балансов SOL и токенов
// 3. Добавить валидацию параметров compute budget
// 4. Добавить проверку версии пула (V4)
// 5. Добавить расчет приоритетной комиссии на основе последних блоков
// 6. Добавить проверку и обработку wrapped SOL
func (s *Sniper) ValidateAndPrepare() error {
	s.logger.Debug("validating and preparing snipe parameters")

	// Проверяем базовые параметры конфигурации
	if s.config.maxSlippageBps == 0 || s.config.maxSlippageBps > 10000 { // 10000 = 100%
		return fmt.Errorf("invalid slippage: must be between 0 and 10000")
	}

	if s.config.minAmountSOL <= 0 || s.config.maxAmountSOL <= 0 {
		return fmt.Errorf("invalid amount parameters")
	}

	if s.config.maxAmountSOL < s.config.minAmountSOL {
		return fmt.Errorf("maxAmount cannot be less than minAmount")
	}

	// Проверяем mint addresses
	if s.config.baseMint.IsZero() || s.config.quoteMint.IsZero() {
		return fmt.Errorf("invalid mint addresses")
	}

	// Проверяем наличие достаточного баланса
	balance, err := s.client.client.GetBalance(
		s.client.client.PrivateKey.PublicKey(),
		rpc.CommitmentConfirmed,
	)
	if err != nil {
		return fmt.Errorf("failed to get wallet balance: %w", err)
	}

	if float64(balance.Value)/float64(solana.LAMPORTS_PER_SOL) < s.config.minAmountSOL {
		return fmt.Errorf("insufficient balance")
	}

	// Проверяем параметры мониторинга
	if s.config.monitorInterval < time.Second {
		return fmt.Errorf("monitor interval too small")
	}

	if s.config.maxRetries < 1 {
		return fmt.Errorf("invalid max retries value")
	}

	return nil
}

// TODO: Потенциальные улучшения на основе TS версии:
// 1. Добавить отслеживание изменений цены
// 2. Добавить отслеживание объема ликвидности
// 3. Добавить механизм подписки на события пула
// 4. Добавить отслеживание транзакций в мемпуле
// 5. Добавить механизм websocket подключения
// 6. Добавить механизм агрегации данных по нескольким RPC
func (s *Sniper) MonitorPoolChanges() error {
	s.logger.Debug("starting pool monitoring")

	ticker := time.NewTicker(s.config.monitorInterval)
	defer ticker.Stop()

	// Получаем начальное состояние пула
	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
	if err != nil {
		return fmt.Errorf("failed to get initial pool state: %w", err)
	}

	poolManager := NewPoolManager(s.client.client, s.logger, pool)
	initialState, err := poolManager.GetPoolState()
	if err != nil {
		return fmt.Errorf("failed to get initial pool state: %w", err)
	}

	var retryCount int
	for {
		select {
		case <-ticker.C:
			// Получаем текущее состояние пула
			currentState, err := poolManager.GetPoolState()
			if err != nil {
				retryCount++
				s.logger.Error("failed to get current pool state",
					zap.Error(err),
					zap.Int("retry", retryCount),
				)
				if retryCount >= s.config.maxRetries {
					return fmt.Errorf("max retries exceeded while monitoring pool")
				}
				continue
			}
			retryCount = 0

			// Проверяем изменения в пуле
			if s.hasSignificantChanges(initialState, currentState) {
				s.logger.Info("detected significant pool changes",
					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
					zap.Uint64("newBaseReserve", currentState.BaseReserve),
					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
				)

				// Если пул неактивен, прекращаем мониторинг
				if currentState.Status != 1 {
					return fmt.Errorf("pool became inactive")
				}

				// Обновляем начальное состояние
				initialState = currentState
			}
		}
	}
}

// Вспомогательный метод для определения значительных изменений в пуле
func (s *Sniper) hasSignificantChanges(old, new *PoolState) bool {
	// Рассчитываем процент изменения для базового резерва
	baseChange := math.Abs(float64(new.BaseReserve)-float64(old.BaseReserve)) / float64(old.BaseReserve)

	// Рассчитываем процент изменения для котируемого резерва
	quoteChange := math.Abs(float64(new.QuoteReserve)-float64(old.QuoteReserve)) / float64(old.QuoteReserve)

	// Определяем порог значительных изменений (например, 1%)
	threshold := 0.01

	return baseChange > threshold || quoteChange > threshold || new.Status != old.Status
}

// inernal/dex/raydium/types.go - это пакет, который содержит в себе реализацию работы с декстерами Raydium
package raydium

import "github.com/gagliardetto/solana-go"

type RaydiumPool struct {
	ID            solana.PublicKey // Идентификатор пула
	Authority     solana.PublicKey // Публичный ключ, который имеет полномочия управлять пулом
	BaseMint      solana.PublicKey // Публичный ключ базового токена
	QuoteMint     solana.PublicKey // Публичный ключ котируемого токена
	BaseVault     solana.PublicKey // Публичный ключ хранилища базового токена
	QuoteVault    solana.PublicKey // Публичный ключ хранилища котируемого токена
	BaseDecimals  uint8            // Количество десятичных знаков базового токена
	QuoteDecimals uint8            // Количество десятичных знаков котируемого токена
	DefaultFeeBps uint16           // Комиссия по умолчанию в базисных пунктах (bps)
	// Только необходимые поля для V4
}

type PoolState struct {
	BaseReserve  uint64 // Резерв базового токена в пуле
	QuoteReserve uint64 // Резерв котируемого токена в пуле
	Status       uint8  // Статус пула (например, активен или неактивен)
}

type SwapParams struct {
	UserWallet              solana.PublicKey // Публичный ключ кошелька пользователя
	AmountIn                uint64           // Количество входного токена для обмена
	MinAmountOut            uint64           // Минимальное количество выходного токена, которое пользователь готов принять
	Pool                    *RaydiumPool     // Указатель на пул, в котором происходит обмен
	SourceTokenAccount      solana.PublicKey // Публичный ключ аккаунта исходного токена
	DestinationTokenAccount solana.PublicKey // Публичный ключ аккаунта целевого токена
	PriorityFeeLamports     uint64           // Приоритетная комиссия в лампортах
}

// Основные ошибки
type SwapError struct {
	Stage   string // Этап, на котором произошла ошибка
	Message string // Сообщение об ошибке
	Err     error  // Вложенная ошибка
}
