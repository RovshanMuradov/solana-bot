## Этап 1: Детальный план

### 1.1 Создание пакета `protocol`

**Структура каталогов:**
```
internal/
├── protocol/
│   ├── types.go        # базовые интерфейсы
│   ├── registry.go     # реестр протоколов
│   └── adapter.go      # адаптер для старых DEX
```

**Базовый интерфейс Protocol:**
- Более общий чем DEX
- Поддерживает разные типы активов (tokens, NFTs, etc)
- Методы: `GetCapabilities()`, `CreateOperation()`, `GetAssetInfo()`

**ProtocolAdapter:**
- Оборачивает существующие DEX в Protocol интерфейс
- Позволяет постепенную миграцию
- DEX продолжают работать как раньше

**Registry:**
- Централизованное место регистрации протоколов
- Поиск по имени/типу
- Автоматическая регистрация при запуске

### 1.2 Event Bus

**Структура:**
```
internal/
├── events/
│   ├── bus.go          # основная реализация
│   ├── types.go        # типы событий
│   └── handler.go      # интерфейс обработчиков
```

**Типы событий:**
```
- OperationStarted
- OperationCompleted  
- OperationFailed
- PriceUpdated
- BalanceChanged
- MonitoringStarted/Stopped
```

**Реализация:**
- Простая in-memory реализация на channels
- Подписка по типу события
- Async публикация (non-blocking)
- Graceful shutdown

**Интеграция в существующий код:**
- Добавить публикацию событий в key points:
  - После Execute в worker.go
  - При обновлении цены в monitor
  - При изменении баланса
- Не меняет логику, только добавляет уведомления

### 1.3 Рефакторинг Task

**Новые поля в Task:**
```
Protocol     string   // "dex", "nft", "staking"
AssetType    string   // "token", "nft", "lp"
Metadata     map[string]interface{} // для расширяемости
```

**Обратная совместимость:**
- Если Protocol пустой - используем Module (старая логика)
- Маппинг: pump.fun → protocol="dex"
- YAML reader автоматически заполняет новые поля

**TaskV2 интерфейс:**
- Подготовка к будущему
- Методы: `GetProtocol()`, `GetOperationType()`, `GetParameters()`
- Старый Task имплементирует TaskV2

### 1.4 Пошаговая интеграция

1. **Event Bus**
  - Создать базовую реализацию
  - Добавить в main.go инициализацию
  - Написать простые тесты

2. **События в существующем коде**
  - Добавить публикацию в worker.go (5-6 мест)
  - Добавить в monitor.go при обновлении цены
  - Создать простой logger подписчик для дебага

3. **Тестирование**
  - Убедиться что ничего не сломалось
  - Проверить производительность
  - Event Bus не должен блокировать основной flow

4. **Protocol пакет**
  - Создать интерфейсы
  - Реализовать ProtocolAdapter для DEX
  - Registry с auto-registration

5. **Интеграция Protocol**
  - В factory.go добавить регистрацию DEX как протоколов
  - Worker может использовать как DEX напрямую, так и через Protocol
  - A/B тестирование: часть задач через новый путь

6. **Task рефакторинг**
  - Добавить новые поля
  - Обновить Yaml reader
  - Backward compatibility тесты

### 1.5 Критерии успеха этапа

✅ **Ничего не сломалось:**
- Все существующие тесты проходят
- Бот работает как раньше
- Производительность не упала

✅ **Подготовлен фундамент:**
- Event Bus работает и публикует события
- Protocol интерфейс готов для NFT
- Task расширяем для новых типов операций

✅ **Можно начать Этап 2:**
- Есть куда добавлять Operation интерфейс
- События можно использовать для API
- Protocol registry готов для новых протоколов

### 1.6 Риски и их митигация

**Риск**: Event Bus может стать bottleneck
- **Митигация**: Buffered channels, метрики производительности

**Риск**: Сложность с backward compatibility
- **Митигация**: Постепенная миграция, feature flags

**Риск**: Много boilerplate кода
- **Митигация**: Код-генерация для событий

### 1.7 Подготовка к следующим этапам

После этого этапа у вас будет:
- Место для добавления Operation (Этап 2)
- События для API real-time updates (Этап 3)
- Protocol интерфейс для NFT (Этап 4)

Главное - не спешить и тестировать каждое изменение. Этот этап закладывает фундамент для всей дальнейшей работы.