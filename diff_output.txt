diff --git a/configs/tasks.csv b/configs/tasks.csv
index bbc2c6d..2823e89 100644
--- a/configs/tasks.csv
+++ b/configs/tasks.csv
@@ -1,2 +1,2 @@
-TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,MinAmountOut,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
-buyTokens,Raydium,1,wallet1,100,0.0001,58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
\ No newline at end of file
+TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,SlippageConfig,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
+buyTokens,Raydium,1,wallet1,100,0.001,58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0.5,0,0,0,100,0.0003
\ No newline at end of file
diff --git a/go.mod b/go.mod
index f342265..6c586dc 100644
--- a/go.mod
+++ b/go.mod
@@ -4,11 +4,13 @@ go 1.23.2
 
 require (
 	github.com/cenkalti/backoff/v4 v4.3.0
+	github.com/gagliardetto/binary v0.8.0
 	github.com/gagliardetto/solana-go v1.11.0
 	github.com/gobwas/ws v1.4.0
 	github.com/google/uuid v1.6.0
 	github.com/mr-tron/base58 v1.2.0
 	github.com/prometheus/client_golang v1.20.5
+	github.com/sirupsen/logrus v1.9.3
 	github.com/spf13/viper v1.19.0
 	go.uber.org/zap v1.27.0
 	gopkg.in/natefinch/lumberjack.v2 v2.2.1
@@ -25,7 +27,6 @@ require (
 	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
 	github.com/fatih/color v1.17.0 // indirect
 	github.com/fsnotify/fsnotify v1.7.0 // indirect
-	github.com/gagliardetto/binary v0.8.0 // indirect
 	github.com/gagliardetto/treeout v0.1.4 // indirect
 	github.com/gobwas/httphead v0.1.0 // indirect
 	github.com/gobwas/pool v0.2.1 // indirect
diff --git a/go.sum b/go.sum
index 4ff8611..6a9097a 100644
--- a/go.sum
+++ b/go.sum
@@ -27,6 +27,8 @@ github.com/fsnotify/fsnotify v1.7.0 h1:8JEhPFa5W2WU7YfeZzPNqzMP6Lwt7L2715Ggo0nos
 github.com/fsnotify/fsnotify v1.7.0/go.mod h1:40Bi/Hjc2AVfZrqy+aj+yEI+/bRxZnMJyTJwOpGvigM=
 github.com/gagliardetto/binary v0.8.0 h1:U9ahc45v9HW0d15LoN++vIXSJyqR/pWw8DDlhd7zvxg=
 github.com/gagliardetto/binary v0.8.0/go.mod h1:2tfj51g5o9dnvsc+fL3Jxr22MuWzYXwx9wEoN0XQ7/c=
+github.com/gagliardetto/gofuzz v1.2.2 h1:XL/8qDMzcgvR4+CyRQW9UGdwPRPMHVJfqQ/uMvSUuQw=
+github.com/gagliardetto/gofuzz v1.2.2/go.mod h1:bkH/3hYLZrMLbfYWA0pWzXmi5TTRZnu4pMGZBkqMKvY=
 github.com/gagliardetto/solana-go v1.11.0 h1:g6mR7uRNVT0Y0LVR0bvJNfKV6TyO6oUzBYu03ZmkEmY=
 github.com/gagliardetto/solana-go v1.11.0/go.mod h1:afBEcIRrDLJst3lvAahTr63m6W2Ns6dajZxe2irF7Jg=
 github.com/gagliardetto/treeout v0.1.4 h1:ozeYerrLCmCubo1TcIjFiOWTTGteOOHND1twdFpgwaw=
@@ -139,6 +141,8 @@ github.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6g
 github.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=
 github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8=
 github.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=
+github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
+github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
 github.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=
 github.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=
 github.com/spf13/afero v1.11.0 h1:WJQKhtpdm3v2IzqG8VMqrr6Rf3UYpEF239Jy9wNepM8=
@@ -231,6 +235,7 @@ golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7w
 golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=
diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
index bcfeacc..b28a72a 100644
--- a/internal/blockchain/solbc/client.go
+++ b/internal/blockchain/solbc/client.go
@@ -7,6 +7,7 @@ import (
 
 	"github.com/gagliardetto/solana-go"
 	solanarpc "github.com/gagliardetto/solana-go/rpc"
+	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
 	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
 	"go.uber.org/zap"
 )
@@ -60,6 +61,18 @@ func (c *Client) SendTransaction(ctx context.Context, tx *solana.Transaction) (s
 	return signature, nil
 }
 
+func (c *Client) SendTransactionWithOpts(
+	ctx context.Context,
+	tx *solana.Transaction,
+	opts blockchain.TransactionOptions,
+) (solana.Signature, error) {
+	rpcOpts := rpc.SendTransactionOpts{
+		SkipPreflight:       opts.SkipPreflight,
+		PreflightCommitment: opts.PreflightCommitment,
+	}
+	return c.rpc.SendTransactionWithOpts(ctx, tx, rpcOpts)
+}
+
 func (c *Client) Close() error {
 	c.rpc.Close()
 	return nil
diff --git a/internal/blockchain/solbc/rpc/rpc.go b/internal/blockchain/solbc/rpc/rpc.go
index ac6f2c4..71fbdc2 100644
--- a/internal/blockchain/solbc/rpc/rpc.go
+++ b/internal/blockchain/solbc/rpc/rpc.go
@@ -25,6 +25,12 @@ var (
 	ErrTimeout    = fmt.Errorf("request timeout")
 )
 
+// SendTransactionOpts определяет опции для отправки транзакции
+type SendTransactionOpts struct {
+	SkipPreflight       bool
+	PreflightCommitment solanarpc.CommitmentType
+}
+
 // RPCClient представляет упрощенный RPC клиент
 type RPCClient struct {
 	nodes   []*solanarpc.Client
@@ -52,6 +58,27 @@ func NewClient(urls []string, logger *zap.Logger) (*RPCClient, error) {
 	}, nil
 }
 
+// SendTransactionWithOpts отправляет транзакцию с опциями
+func (c *RPCClient) SendTransactionWithOpts(
+	ctx context.Context,
+	tx *solana.Transaction,
+	opts SendTransactionOpts,
+) (solana.Signature, error) {
+	var signature solana.Signature
+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
+		var err error
+		signature, err = client.SendTransactionWithOpts(ctx, tx, solanarpc.TransactionOpts{
+			SkipPreflight:       opts.SkipPreflight,
+			PreflightCommitment: opts.PreflightCommitment,
+		})
+		return err
+	})
+	if err != nil {
+		return solana.Signature{}, fmt.Errorf("failed to send transaction: %w", err)
+	}
+	return signature, nil
+}
+
 // ExecuteWithRetry выполняет RPC-запрос с автоматическим переключением узлов при ошибке
 func (c *RPCClient) ExecuteWithRetry(ctx context.Context, operation func(*solanarpc.Client) error) error {
 	timeoutCtx, cancel := context.WithTimeout(ctx, reqTimeout)
diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
index 202b59a..03c15ac 100644
--- a/internal/blockchain/types.go
+++ b/internal/blockchain/types.go
@@ -8,10 +8,17 @@ import (
 	"github.com/gagliardetto/solana-go/rpc"
 )
 
+// TransactionOptions определяет опции для отправки транзакции
+type TransactionOptions struct {
+	SkipPreflight       bool
+	PreflightCommitment rpc.CommitmentType
+}
+
 // Client определяет общий интерфейс для клиентов блокчейна
 type Client interface {
 	GetRecentBlockhash(ctx context.Context) (solana.Hash, error)
 	SendTransaction(ctx context.Context, tx *solana.Transaction) (solana.Signature, error)
 	GetAccountInfo(ctx context.Context, pubkey solana.PublicKey) (*rpc.GetAccountInfoResult, error)
 	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
+	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
 }
diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
index 8e2c6c3..48baf94 100644
--- a/internal/dex/raydium/raydium.go
+++ b/internal/dex/raydium/raydium.go
@@ -14,6 +14,7 @@ import (
 	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
 	"github.com/gagliardetto/solana-go/programs/token"
+
 	solanarpc "github.com/gagliardetto/solana-go/rpc"
 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
 	"github.com/rovshanmuradov/solana-bot/internal/types"
@@ -46,6 +47,8 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
 	opCtx, cancel := context.WithTimeout(ctx, defaultTimeout)
 	defer cancel()
 
+	r.slippage = task.SlippageConfig.Value
+
 	logger := r.logger.With(
 		zap.String("task", task.TaskName),
 		zap.String("wallet", userWallet.PublicKey.String()),
@@ -350,10 +353,9 @@ func (r *DEX) PrepareSwapInstruction(
 		return nil, fmt.Errorf("failed to get expected output: %w", err)
 	}
 
-	// Используем безопасное значение minAmountOut по умолчанию (99% от ожидаемого выхода)
-	minAmountOut := uint64(float64(expectedOut) * 0.99)
+	// Используем slippage из структуры DEX
+	minAmountOut := calculateMinimumOut(expectedOut, r.slippage)
 
-	// Создаем инструкцию свапа с помощью внутреннего метода createSwapInstruction
 	return r.createSwapInstruction(
 		wallet,
 		sourceATA,
@@ -412,53 +414,76 @@ func (r *DEX) sendTransactionWithRetryAndConfirmation(
 	instructions []solana.Instruction,
 	logger *zap.Logger,
 ) (solana.Signature, error) {
+	const (
+		maxRetries          = 3
+		sendTimeout         = 15 * time.Second
+		confirmationTimeout = 60 * time.Second
+	)
+
 	var lastErr error
 	for attempt := 0; attempt < maxRetries; attempt++ {
 		select {
 		case <-ctx.Done():
 			return solana.Signature{}, ctx.Err()
 		default:
-			signature, err := r.sendTransaction(ctx, wallet, instructions)
+			// Создаем контекст с таймаутом для отправки
+			sendCtx, cancel := context.WithTimeout(ctx, sendTimeout)
+			signature, err := r.sendTransaction(sendCtx, wallet, instructions)
+			cancel()
+
 			if err != nil {
 				lastErr = err
 				logger.Warn("Retrying transaction send",
 					zap.Int("attempt", attempt+1),
 					zap.Error(err))
-				time.Sleep(retryDelay)
+				time.Sleep(time.Second * time.Duration(attempt+1))
 				continue
 			}
 
-			// Ждем подтверждения транзакции
-			logger.Debug("Waiting for transaction confirmation",
-				zap.String("signature", signature.String()))
-
-			// Ждем подтверждения с таймаутом
-			confirmCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
+			// Создаем отдельный контекст для подтверждения
+			confirmCtx, cancel := context.WithTimeout(ctx, confirmationTimeout)
 			defer cancel()
 
+			// Ждем подтверждения с периодическими проверками
+			ticker := time.NewTicker(time.Second)
+			defer ticker.Stop()
+
 			for {
 				select {
 				case <-confirmCtx.Done():
-					return signature, fmt.Errorf("timeout waiting for transaction confirmation")
-				case <-time.After(time.Second):
-					// Проверяем статус транзакции
+					return signature, fmt.Errorf("confirmation timeout exceeded: %v", confirmCtx.Err())
+				case <-ticker.C:
 					status, err := r.getTransactionStatus(ctx, signature)
 					if err != nil {
-						logger.Debug("Failed to get transaction status", zap.Error(err))
+						logger.Debug("Failed to get transaction status",
+							zap.Error(err),
+							zap.String("signature", signature.String()))
 						continue
 					}
 
+					// Проверяем ошибки в транзакции
+					if status.Error != "" {
+						return signature, fmt.Errorf("transaction failed: %s", status.Error)
+					}
+
 					// Проверяем подтверждение
 					if status.Confirmations >= 1 || status.Status == "finalized" {
 						logger.Debug("Transaction confirmed",
+							zap.String("signature", signature.String()),
 							zap.String("status", status.Status),
 							zap.Uint64("confirmations", status.Confirmations))
 						return signature, nil
 					}
+
+					logger.Debug("Waiting for confirmation",
+						zap.String("signature", signature.String()),
+						zap.String("status", status.Status),
+						zap.Uint64("confirmations", status.Confirmations))
 				}
 			}
 		}
 	}
+
 	return solana.Signature{}, fmt.Errorf("failed after %d attempts: %w", maxRetries, lastErr)
 }
 
@@ -491,7 +516,17 @@ func (r *DEX) sendTransaction(
 		return solana.Signature{}, fmt.Errorf("failed to sign transaction: %w", err)
 	}
 
-	return r.client.SendTransaction(ctx, tx)
+	opts := blockchain.TransactionOptions{
+		SkipPreflight:       true,
+		PreflightCommitment: solanarpc.CommitmentProcessed,
+	}
+
+	signature, err := r.client.SendTransactionWithOpts(ctx, tx, opts)
+	if err != nil {
+		return solana.Signature{}, fmt.Errorf("failed to send transaction: %w", err)
+	}
+
+	return signature, nil
 }
 
 func validateDEXParams(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) error {
@@ -558,9 +593,23 @@ func (r *DEX) getExpectedOutput(
 	return expectedOut, nil
 }
 
+// Определяем смещения для чтения данных пула Raydium
+const (
+	// Смещения в байтах для различных полей в структуре пула
+	DISCRIMINATOR_SIZE = 8
+	STATUS_SIZE        = 1
+	NONCE_SIZE         = 1
+	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 байт
+
+	// Смещения для резервов
+	baseVaultOffset    = BASE_SIZE + 32 + 32 + 32 // После discriminator, status, nonce и трех pubkeys
+	quoteVaultOffset   = baseVaultOffset + 32
+	baseReserveOffset  = quoteVaultOffset + 32 + 8 // +8 для uint64
+	quoteReserveOffset = baseReserveOffset + 8
+)
+
 // getPoolState получает текущее состояние пула
 func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
-	// Получаем аккаунт пула
 	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
 	if err != nil {
 		return nil, fmt.Errorf("failed to get pool account: %w", err)
@@ -570,47 +619,57 @@ func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, err
 		return nil, fmt.Errorf("pool account not found")
 	}
 
-	// Парсим данные аккаунта
 	data := poolAccount.Value.Data.GetBinary()
-	if len(data) < 8+32*2 { // Минимальный размер для резервов
-		return nil, fmt.Errorf("invalid pool account data size")
+
+	// Debug полных данных
+	r.logger.Debug("Full pool data",
+		zap.Binary("data", data),
+		zap.Int("length", len(data)))
+
+	if len(data) < quoteReserveOffset+8 {
+		return nil, fmt.Errorf("invalid pool data length: got %d, need at least %d",
+			len(data), quoteReserveOffset+8)
 	}
 
-	// Извлекаем резервы из данных аккаунта
-	// Обратите внимание: это упрощенная версия, реальная структура данных может отличаться
-	tokenAReserve := binary.LittleEndian.Uint64(data[8:16])
-	tokenBReserve := binary.LittleEndian.Uint64(data[16:24])
+	// Читаем резервы
+	baseReserve := binary.LittleEndian.Uint64(data[baseReserveOffset : baseReserveOffset+8])
+	quoteReserve := binary.LittleEndian.Uint64(data[quoteReserveOffset : quoteReserveOffset+8])
 
-	// Получаем информацию о комиссии пула
-	swapFee := 0.25 // 0.25% это стандартная комиссия Raydium
+	r.logger.Debug("Pool reserves offsets",
+		zap.Int("base_offset", baseReserveOffset),
+		zap.Int("quote_offset", quoteReserveOffset))
+
+	r.logger.Debug("Pool reserves raw bytes",
+		zap.Binary("base_bytes", data[baseReserveOffset:baseReserveOffset+8]),
+		zap.Binary("quote_bytes", data[quoteReserveOffset:quoteReserveOffset+8]))
 
 	return &PoolState{
-		TokenAReserve: tokenAReserve,
-		TokenBReserve: tokenBReserve,
-		SwapFee:       swapFee,
+		TokenAReserve: baseReserve,
+		TokenBReserve: quoteReserve,
+		SwapFee:       0.25,
 	}, nil
 }
 
 // calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
 func (r *DEX) calculateExpectedOutput(amountIn uint64, state *PoolState) float64 {
-	// Константа k = x * y, где x и y - резервы токенов
-	k := float64(state.TokenAReserve) * float64(state.TokenBReserve)
-
-	// Вычисляем amount_in после комиссии
-	amountInAfterFee := float64(amountIn) * (1 - state.SwapFee/100)
+	// Конвертируем все в float64 для точных вычислений
+	amountInF := float64(amountIn)
+	reserveInF := float64(state.TokenAReserve)
+	reserveOutF := float64(state.TokenBReserve)
 
-	// Новый резерв входного токена
-	newSourceReserve := float64(state.TokenAReserve) + amountInAfterFee
+	// Учитываем комиссию (0.25%)
+	amountInWithFee := amountInF * (1 - state.SwapFee/100)
 
-	// Вычисляем новый резерв выходного токена используя формулу k = x * y
-	newTargetReserve := k / newSourceReserve
+	// Используем формулу Raydium: dy = y * dx / (x + dx)
+	// где dx - входная сумма с учетом комиссии
+	// x, y - резервы токенов
+	numerator := reserveOutF * amountInWithFee
+	denominator := reserveInF + amountInWithFee
 
-	// Ожидаемый выход это разница между старым и новым резервом
-	expectedOut := float64(state.TokenBReserve) - newTargetReserve
+	expectedOut := numerator / denominator
 
-	// Применяем дополнительный запас надежности
-	safetyFactor := 0.995 // 0.5% запас для учета изменения цены
-	return expectedOut * safetyFactor
+	// Применяем дополнительный запас надежности 0.5%
+	return expectedOut * 0.995
 }
 
 // GetAmountOutQuote получает котировку для свапа
@@ -636,25 +695,12 @@ func (r *DEX) GetAmountOutQuote(
 
 // TransactionStatus представляет статус транзакции
 type TransactionStatus struct {
-	Status        string
-	Confirmations uint64
-	Error         interface{}
-	Slot          uint64
-}
-
-// getConfirmations получает количество подтверждений из результата статуса
-func getConfirmations(status *solanarpc.SignatureStatusesResult) uint64 {
-	if status == nil {
-		return 0
-	}
-
-	if status.Confirmations == nil {
-		if status.ConfirmationStatus == solanarpc.ConfirmationStatusFinalized {
-			return math.MaxUint64 // Максимальное значение для финализированных транзакций
-		}
-		return 0
-	}
-	return *status.Confirmations
+	Signature     string    `json:"signature"`
+	Status        string    `json:"status"`
+	Confirmations uint64    `json:"confirmations"`
+	Slot          uint64    `json:"slot"`
+	Error         string    `json:"error,omitempty"`
+	Timestamp     time.Time `json:"timestamp"` // Время проверки статуса
 }
 
 // getTransactionStatus получает полный статус транзакции
@@ -664,19 +710,45 @@ func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signatu
 		return nil, fmt.Errorf("failed to get signature status: %w", err)
 	}
 
-	if result == nil || len(result.Value) == 0 || result.Value[0] == nil {
-		return &TransactionStatus{
-			Status: "pending",
-		}, nil
+	now := time.Now()
+	status := &TransactionStatus{
+		Signature: signature.String(),
+		Status:    "pending",
+		Timestamp: now,
 	}
 
-	status := result.Value[0]
-	confirmations := getConfirmations(status)
+	if len(result.Value) == 0 || result.Value[0] == nil {
+		return status, nil
+	}
 
-	return &TransactionStatus{
-		Status:        string(status.ConfirmationStatus),
-		Confirmations: confirmations,
-		Error:         status.Err,
-		Slot:          status.Slot,
-	}, nil
+	statusInfo := result.Value[0]
+	if statusInfo.Err != nil {
+		status.Error = fmt.Sprintf("%v", statusInfo.Err)
+		status.Status = "failed"
+		return status, nil
+	}
+
+	if statusInfo.Confirmations != nil {
+		status.Confirmations = *statusInfo.Confirmations
+	}
+
+	if statusInfo.Slot > 0 {
+		status.Slot = statusInfo.Slot
+	}
+
+	switch statusInfo.ConfirmationStatus {
+	case solanarpc.ConfirmationStatusFinalized:
+		status.Status = "finalized"
+	case solanarpc.ConfirmationStatusConfirmed:
+		status.Status = "confirmed"
+	}
+
+	return status, nil
 }
+
+// GetSignatureStatus получает детальный статус подписи
+func (r *DEX) GetSignatureStatus(ctx context.Context, signature solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
+	return r.client.GetSignatureStatuses(ctx, signature)
+}
+
+// Удалены неиспользуемые функции getConfirmations и waitForTransactionConfirmation
diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
index cf37967..2063598 100644
--- a/internal/dex/raydium/transaction.go
+++ b/internal/dex/raydium/transaction.go
@@ -4,30 +4,71 @@ import (
 	"context"
 	"encoding/binary"
 	"fmt"
+	"math"
 	"testing"
 
 	"github.com/gagliardetto/solana-go"
 	"github.com/rovshanmuradov/solana-bot/internal/types"
 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
+	"github.com/sirupsen/logrus"
 	"go.uber.org/zap"
 )
 
 // Serialize сериализует данные инструкции свапа
 func (s *SwapInstructionData) Serialize() ([]byte, error) {
+	if err := s.Validate(); err != nil {
+		return nil, err
+	}
+
 	data := make([]byte, 17)
 
-	// Instruction (1 byte)
+	// Write instruction discriminator
 	data[0] = s.Instruction
 
-	// AmountIn (8 bytes)
+	// Write amount in
 	binary.LittleEndian.PutUint64(data[1:9], s.AmountIn)
 
-	// MinAmountOut (8 bytes)
+	// Write minimum out
 	binary.LittleEndian.PutUint64(data[9:17], s.MinAmountOut)
 
 	return data, nil
 }
 
+func (s *SwapInstructionData) Validate() error {
+	if s.Instruction != 1 {
+		return fmt.Errorf("invalid instruction type: expected 1, got %d", s.Instruction)
+	}
+
+	if s.AmountIn == 0 {
+		return fmt.Errorf("amount_in cannot be zero")
+	}
+
+	// MinimumOut может быть 0, но логируем это как предупреждение
+	if s.MinAmountOut == 0 {
+		logrus.Warn("minimum_out is set to zero, this may result in high slippage")
+	}
+
+	return nil
+}
+
+// Обновляем вычисление минимального выхода
+func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
+	if expectedOut <= 0 {
+		return 1 // Минимальное безопасное значение
+	}
+
+	// Учитываем слиппаж
+	minOut := expectedOut * (1 - slippagePercent/100)
+
+	// Конвертируем в uint64 и проверяем на минимальное значение
+	result := uint64(math.Floor(minOut))
+	if result == 0 {
+		return 1
+	}
+
+	return result
+}
+
 // TestSwapInstructionDataSerialization тест для проверки сериализации
 func TestSwapInstructionDataSerialization(t *testing.T) {
 	inst := &SwapInstructionData{
diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
index 4cc1b1e..001489f 100644
--- a/internal/dex/raydium/types.go
+++ b/internal/dex/raydium/types.go
@@ -36,6 +36,7 @@ type DEX struct {
 	client   blockchain.Client // изменяем тип на интерфейс.
 	logger   *zap.Logger
 	poolInfo *Pool
+	slippage float64 // Добавляем поле для slippage
 }
 
 func (r *Pool) GetProgramID() string {
diff --git a/internal/sniping/strategy.go b/internal/sniping/strategy.go
index aa5b32c..6803b8d 100644
--- a/internal/sniping/strategy.go
+++ b/internal/sniping/strategy.go
@@ -60,12 +60,10 @@ func parseTask(record []string) (*types.Task, error) {
 		return nil, fmt.Errorf("invalid AmountIn value: %v", err)
 	}
 
-	slippageValue := 1.0 // Значение по умолчанию
-	if record[10] != "" {
-		slippageValue, err = strconv.ParseFloat(record[10], 64)
-		if err != nil {
-			return nil, fmt.Errorf("invalid Slippage value: %v", err)
-		}
+	// Парсим слиппаж
+	slippageConfig, err := types.NewSlippageConfig(record[10])
+	if err != nil {
+		return nil, fmt.Errorf("invalid slippage configuration: %w", err)
 	}
 
 	autosellPercent, err := strconv.ParseFloat(record[11], 64)
@@ -116,9 +114,6 @@ func parseTask(record []string) (*types.Task, error) {
 		TransactionDelay:    transactionDelay,
 		AutosellPriorityFee: autosellPriorityFee,
 		DEXName:             dexName,
-		SlippageConfig: types.SlippageConfig{
-			Type:  types.SlippagePercent, // Используем процентное проскальзывание по умолчанию
-			Value: slippageValue,
-		},
+		SlippageConfig:      slippageConfig,
 	}, nil
 }
diff --git a/internal/types/slippage.go b/internal/types/slippage.go
index b877e8c..2a7139f 100644
--- a/internal/types/slippage.go
+++ b/internal/types/slippage.go
@@ -1,7 +1,12 @@
 // internal/types/slippage.go
 package types
 
-import "math"
+import (
+	"fmt"
+	"math"
+	"strconv"
+	"strings"
+)
 
 // SlippageType определяет тип политики проскальзывания
 type SlippageType string
@@ -17,30 +22,109 @@ const (
 
 // SlippageConfig конфигурирует политику проскальзывания
 type SlippageConfig struct {
-	// Type определяет тип политики проскальзывания
-	Type SlippageType `json:"type"`
-	// Value содержит значение для выбранной политики:
-	// - для SlippageFixed: точное значение minAmountOut
-	// - для SlippagePercent: процент допустимого проскальзывания (например, 1.0 = 1%)
-	// - для SlippageNone: игнорируется
-	Value float64 `json:"value"`
+	Type  SlippageType `json:"type"`
+	Value float64      `json:"value"`
+}
+
+// NewSlippageConfig создает новую конфигурацию слиппажа из строки
+func NewSlippageConfig(value string) (SlippageConfig, error) {
+	// Если значение пустое, используем процентный слиппаж 1%
+	if value == "" {
+		return SlippageConfig{
+			Type:  SlippagePercent,
+			Value: 1.0,
+		}, nil
+	}
+
+	// Проверяем специальные значения
+	value = strings.TrimSpace(strings.ToLower(value))
+	if value == "none" {
+		return SlippageConfig{
+			Type:  SlippageNone,
+			Value: 0,
+		}, nil
+	}
+
+	// Проверяем фиксированное значение
+	if strings.HasPrefix(value, "fixed:") {
+		fixedValue, err := strconv.ParseFloat(strings.TrimPrefix(value, "fixed:"), 64)
+		if err != nil {
+			return SlippageConfig{}, fmt.Errorf("invalid fixed slippage value: %w", err)
+		}
+		if fixedValue <= 0 {
+			return SlippageConfig{}, fmt.Errorf("fixed slippage value must be positive")
+		}
+		return SlippageConfig{
+			Type:  SlippageFixed,
+			Value: fixedValue,
+		}, nil
+	}
+
+	// Парсим процентное значение
+	percentValue, err := strconv.ParseFloat(value, 64)
+	if err != nil {
+		return SlippageConfig{}, fmt.Errorf("invalid slippage percentage: %w", err)
+	}
+	if percentValue <= 0 || percentValue > 100 {
+		return SlippageConfig{}, fmt.Errorf("slippage percentage must be between 0 and 100")
+	}
+
+	return SlippageConfig{
+		Type:  SlippagePercent,
+		Value: percentValue,
+	}, nil
+}
+
+// Validate проверяет корректность конфигурации
+func (c SlippageConfig) Validate() error {
+	switch c.Type {
+	case SlippageFixed:
+		if c.Value <= 0 {
+			return fmt.Errorf("fixed slippage value must be positive")
+		}
+	case SlippagePercent:
+		if c.Value <= 0 || c.Value > 100 {
+			return fmt.Errorf("slippage percentage must be between 0 and 100")
+		}
+	case SlippageNone:
+		// Для SlippageNone значение не важно
+	default:
+		return fmt.Errorf("invalid slippage type: %s", c.Type)
+	}
+	return nil
 }
 
 // CalculateMinAmountOut вычисляет minAmountOut на основе политики проскальзывания
 func CalculateMinAmountOut(expectedAmount float64, config SlippageConfig) uint64 {
+	if err := config.Validate(); err != nil {
+		// В случае ошибки возвращаем безопасное значение
+		return 1
+	}
+
 	switch config.Type {
 	case SlippageFixed:
 		return uint64(config.Value)
 	case SlippagePercent:
 		// Вычисляем минимальный выход с учетом процента проскальзывания
-		// Например, если проскальзывание 1% (value = 1.0), то минимум будет 99% от ожидаемого
 		multiplier := 1.0 - (config.Value / 100.0)
 		return uint64(math.Floor(expectedAmount * multiplier))
 	case SlippageNone:
-		// Возвращаем 1 как минимальное значение для прохождения валидации
 		return 1
 	default:
-		// По умолчанию используем максимально гибкий вариант
 		return 1
 	}
 }
+
+// String возвращает строковое представление конфигурации
+func (c SlippageConfig) String() string {
+	switch c.Type {
+	case SlippageFixed:
+		return fmt.Sprintf("fixed:%.6f", c.Value)
+	case SlippagePercent:
+		return fmt.Sprintf("%.2f%%", c.Value)
+	case SlippageNone:
+		return "none"
+	default:
+		return "invalid"
+	}
+}
