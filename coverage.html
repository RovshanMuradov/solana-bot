
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>raydium: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rovshanmuradov/solana-bot/internal/dex/raydium/raydium.go (72.7%)</option>
				
				<option value="file1">github.com/rovshanmuradov/solana-bot/internal/dex/raydium/transaction.go (76.5%)</option>
				
				<option value="file2">github.com/rovshanmuradov/solana-bot/internal/dex/raydium/types.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// internal/dex/raydium/raydium.go
package raydium

import (
        "context"
        "errors"
        "fmt"
        "math"
        "time"

        "github.com/gagliardetto/solana-go"
        solanaClient "github.com/rovshanmuradov/solana-bot/internal/blockchain/solana"
        "github.com/rovshanmuradov/solana-bot/internal/types"
        "github.com/rovshanmuradov/solana-bot/internal/wallet"
        "go.uber.org/zap"
)

func NewDEX(client *solanaClient.Client, logger *zap.Logger, poolInfo *Pool) *DEX <span class="cov0" title="0">{
        return &amp;DEX{
                client:   client,
                logger:   logger,
                poolInfo: poolInfo,
        }
}</span>

func (r *DEX) Name() string <span class="cov8" title="1">{
        return "Raydium"
}</span>

func (r *DEX) PrepareSwapInstruction(
        ctx context.Context,
        wallet solana.PublicKey,
        sourceToken solana.PublicKey,
        destinationToken solana.PublicKey,
        amountIn uint64,
        minAmountOut uint64,
        logger *zap.Logger,
) (solana.Instruction, error) <span class="cov8" title="1">{
        // Создаем канал для получения результата
        type result struct {
                instruction solana.Instruction
                err         error
        }
        resCh := make(chan result, 1)

        // Запускаем подготовку инструкции в отдельной горутине
        go func() </span><span class="cov8" title="1">{
                instruction, err := r.CreateSwapInstruction(
                        wallet,
                        sourceToken,
                        destinationToken,
                        amountIn,
                        minAmountOut,
                        logger,
                        r.poolInfo,
                )
                resCh &lt;- result{instruction, err}
        }</span>()

        // Ожидаем либо завершения операции, либо отмены контекста
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, fmt.Errorf("preparation cancelled: %w", ctx.Err())</span>
        case res := &lt;-resCh:<span class="cov8" title="1">
                if res.err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create swap instruction: %w", res.err)
                }</span>
                <span class="cov8" title="1">return res.instruction, nil</span>
        }
}

// ExecuteSwap выполняет свап токенов на Raydium
func (r *DEX) ExecuteSwap(
        ctx context.Context,
        task *types.Task,
        wallet *wallet.Wallet,
) error <span class="cov8" title="1">{
        // Создаем контекст с таймаутом для подготовки инструкции
        prepareCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        // Конвертируем float64 в uint64 с учетом десятичных знаков
        amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
        minAmountOut := uint64(task.MinAmountOut * math.Pow10(task.TargetTokenDecimals))

        // Подготавливаем инструкцию свапа
        swapInstruction, err := r.PrepareSwapInstruction(
                prepareCtx,
                wallet.PublicKey,
                task.UserSourceTokenAccount,
                task.UserDestinationTokenAccount,
                amountIn,
                minAmountOut,
                r.logger,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        return fmt.Errorf("swap instruction preparation timed out: %w", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to prepare swap instruction: %w", err)</span>
        }

        // Используем подготовленную инструкцию в транзакции
        <span class="cov8" title="1">return r.PrepareAndSendTransaction(ctx, task, wallet, r.logger, swapInstruction)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// internal/dex/raydium/transaction.go
package raydium

import (
        "bytes"
        "context"
        "encoding/binary"
        "time"

        "github.com/gagliardetto/solana-go"
        "github.com/rovshanmuradov/solana-bot/internal/blockchain/solana/programs/computebudget"
        "github.com/rovshanmuradov/solana-bot/internal/transaction"
        "github.com/rovshanmuradov/solana-bot/internal/types"
        "github.com/rovshanmuradov/solana-bot/internal/wallet"
        "go.uber.org/zap"
)

// Serialize сериализует данные инструкции свапа
func (s *SwapInstructionData) Serialize() ([]byte, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        // Пишем поля структуры в буфер в Little Endian формате
        if err := binary.Write(buf, binary.LittleEndian, s.Instruction); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := binary.Write(buf, binary.LittleEndian, s.AmountIn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := binary.Write(buf, binary.LittleEndian, s.MinAmountOut); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// CreateSwapInstruction создает инструкцию свапа для Raydium
func (r *DEX) CreateSwapInstruction(
        userWallet solana.PublicKey,
        userSourceTokenAccount solana.PublicKey,
        userDestinationTokenAccount solana.PublicKey,
        amountIn uint64,
        minAmountOut uint64,
        logger *zap.Logger,
        poolInfo *Pool,
) (solana.Instruction, error) <span class="cov8" title="1">{
        ammProgramID := solana.MustPublicKeyFromBase58(poolInfo.AmmProgramID)

        // Определение AccountMeta
        accounts := []*solana.AccountMeta{
                {PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
                {PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.AmmID), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.AmmAuthority), IsSigner: false, IsWritable: false},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.AmmOpenOrders), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.AmmTargetOrders), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.PoolCoinTokenAccount), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.PoolPcTokenAccount), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.SerumProgramID), IsSigner: false, IsWritable: false},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.SerumMarket), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.SerumBids), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.SerumAsks), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.SerumEventQueue), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.SerumCoinVaultAccount), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.SerumPcVaultAccount), IsSigner: false, IsWritable: true},
                {PublicKey: solana.MustPublicKeyFromBase58(poolInfo.SerumVaultSigner), IsSigner: false, IsWritable: false},
                {PublicKey: userWallet, IsSigner: true, IsWritable: false},
                {PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
                {PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
                {PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
        }

        // Создание данных инструкции
        instructionData := SwapInstructionData{
                Instruction:  poolInfo.RaydiumSwapInstructionCode,
                AmountIn:     amountIn,
                MinAmountOut: minAmountOut,
        }

        data, err := instructionData.Serialize()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to serialize instruction data", zap.Error(err))
                return nil, err
        }</span>

        // Создание инструкции с использованием solana.NewInstruction
        <span class="cov8" title="1">instruction := solana.NewInstruction(
                ammProgramID,
                accounts,
                data,
        )

        return instruction, nil</span>
}

// PrepareAndSendTransaction готовит и отправляет транзакцию свапа
func (r *DEX) PrepareAndSendTransaction(
        ctx context.Context,
        task *types.Task,
        userWallet *wallet.Wallet,
        logger *zap.Logger,
        swapInstruction solana.Instruction,
) error <span class="cov8" title="1">{
        // Получение последнего blockhash
        recentBlockhash, err := r.client.GetRecentBlockhash(ctx)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to get recent blockhash", zap.Error(err))
                return err
        }</span>

        // Создаем compute budget инструкции
        <span class="cov8" title="1">priorityManager := types.NewPriorityManager(logger)
        budgetInstructions, err := priorityManager.CreateCustomPriorityInstructions(
                task.PriorityFee,
                computebudget.SnipingUnits,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create compute budget instructions", zap.Error(err))
                return err
        }</span>

        // Исправляем appendAssign
        <span class="cov8" title="1">instructions := make([]solana.Instruction, 0, len(budgetInstructions)+1)
        instructions = append(instructions, budgetInstructions...)
        instructions = append(instructions, swapInstruction)

        tx, err := solana.NewTransaction(
                instructions,
                recentBlockhash,
                solana.TransactionPayer(userWallet.PublicKey),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create transaction", zap.Error(err))
                return err
        }</span>

        // Подписание транзакции
        <span class="cov8" title="1">_, err = tx.Sign(
                func(key solana.PublicKey) *solana.PrivateKey </span><span class="cov8" title="1">{
                        if key.Equals(userWallet.PublicKey) </span><span class="cov8" title="1">{
                                return &amp;userWallet.PrivateKey
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to sign transaction", zap.Error(err))
                return err
        }</span>

        // Использование функции RetryOperation из пакета transaction
        <span class="cov8" title="1">err = transaction.RetryOperation(3, time.Second, func() error </span><span class="cov8" title="1">{
                signature, err := r.client.SendTransaction(ctx, tx)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Warn("Failed to send transaction, retrying", zap.Error(err))
                        return err
                }</span>
                <span class="cov8" title="1">logger.Info("Transaction sent successfully", zap.String("signature", signature.String()))
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                logger.Error("All attempts to send transaction failed", zap.Error(err))
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// internal/dex/raydium/types.go
package raydium

import (
        "github.com/rovshanmuradov/solana-bot/internal/blockchain/solana"
        "go.uber.org/zap"
)

// RaydiumPoolInfo содержит информацию о пуле Raydium
type Pool struct {
        AmmProgramID               string
        AmmID                      string
        AmmAuthority               string
        AmmOpenOrders              string
        AmmTargetOrders            string
        PoolCoinTokenAccount       string
        PoolPcTokenAccount         string
        SerumProgramID             string
        SerumMarket                string
        SerumBids                  string
        SerumAsks                  string
        SerumEventQueue            string
        SerumCoinVaultAccount      string
        SerumPcVaultAccount        string
        SerumVaultSigner           string
        RaydiumSwapInstructionCode uint64
}

// SwapInstructionData представляет данные инструкции свапа
type SwapInstructionData struct {
        Instruction  uint64 // Код инструкции
        AmountIn     uint64 // Сумма входа
        MinAmountOut uint64 // Минимальная сумма выхода
}

// internal/dex/raydium/types.go
type DEX struct {
        client   solana.SolanaClientInterface // изменяем тип на интерфейс
        logger   *zap.Logger
        poolInfo *Pool
}

func (r *Pool) GetProgramID() string <span class="cov0" title="0">{
        return r.AmmProgramID
}</span>

func (r *Pool) GetPoolID() string <span class="cov0" title="0">{
        return r.AmmID
}</span>

func (r *Pool) GetTokenAccounts() (string, string) <span class="cov0" title="0">{
        return r.PoolCoinTokenAccount, r.PoolPcTokenAccount
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
