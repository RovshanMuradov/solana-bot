diff --git a/internal/blockchain/solbc/solana.go b/internal/blockchain/solbc/solana.go
index dec574a..cfede3e 100644
--- a/internal/blockchain/solbc/solana.go
+++ b/internal/blockchain/solbc/solana.go
@@ -5,9 +5,6 @@ import (
 	"context"
 	"fmt"
 
-	solanarpc "github.com/gagliardetto/solana-go/rpc"
-	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
-
 	"github.com/gagliardetto/solana-go"
 	"go.uber.org/zap"
 )
@@ -63,19 +60,3 @@ func (c *Client) SimulateTransaction(tx string) (string, error) {
 	// Implement the method logic here
 	return "", nil
 }
-
-func (c *Client) GetRpcClient() *solanarpc.Client {
-	if c.adapter == nil {
-		c.adapter = NewRpcAdapter(c.rpc)
-	}
-	return c.adapter
-}
-
-// RpcAdapter адаптирует наш RPCClient к интерфейсу solana-go/rpc.Client
-type RpcAdapter struct {
-	client *rpc.RPCClient
-}
-
-func NewRpcAdapter(client *rpc.RPCClient) *solanarpc.Client {
-	return solanarpc.New("") // Создаем пустой клиент
-}
diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
index 0355dc0..81e8fb2 100644
--- a/internal/blockchain/types.go
+++ b/internal/blockchain/types.go
@@ -47,6 +47,5 @@ type Client interface {
 	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
 	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
-	GetRpcClient() *rpc.Client
 	GetTokenAccountBalance(ctx context.Context, account solana.PublicKey, commitment rpc.CommitmentType) (*rpc.GetTokenAccountBalanceResult, error)
 }
diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
index 234fc23..342586c 100644
--- a/internal/dex/raydium/client.go
+++ b/internal/dex/raydium/client.go
@@ -2,6 +2,8 @@
 package raydium
 
 import (
+	"encoding/binary"
+	"fmt"
 	"time"
 
 	"github.com/gagliardetto/solana-go"
@@ -10,6 +12,10 @@ import (
 	"go.uber.org/zap"
 )
 
+const (
+	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
+)
+
 type RaydiumClient struct {
 	client  blockchain.Client
 	logger  *zap.Logger
@@ -22,26 +28,338 @@ type clientOptions struct {
 	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
 }
 
-func NewRaydiumClient() *RaydiumClient {
+// Вспомогательные структуры для инструкций
+type ComputeBudgetInstruction struct {
+	Units         uint32
+	MicroLamports uint64
+}
+
+type SwapInstruction struct {
+	Amount     uint64
+	MinimumOut uint64
+}
+
+// NewRaydiumClient создает новый экземпляр клиента Raydium
+func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) *RaydiumClient {
 	// Инициализация с базовыми настройками
+
+	opts := &clientOptions{
+		timeout:     30 * time.Second,
+		retries:     3,
+		priorityFee: 1000, // базовое значение в лампортах
+		commitment:  rpc.CommitmentConfirmed,
+	}
+
+	client := blockchain.NewSolanaClient(rpcEndpoint, wallet)
+
+	return &RaydiumClient{
+		client:  client,
+		logger:  logger,
+		options: opts,
+	}
 }
 
-func (c *RaydiumClient) GetPool() (*RaydiumPool, error) {
+// GetPool получает информацию о пуле по базовому и котируемому токенам
+func (c *RaydiumClient) GetPool(baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
 	// Получение информации о пуле
+
+	c.logger.Debug("getting raydium pool info",
+		zap.String("baseMint", baseMint.String()),
+		zap.String("quoteMint", quoteMint.String()),
+	)
+
+	// Получаем программные аккаунты по фильтрам
+	accounts, err := c.client.GetProgramAccounts(
+		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+		rpc.GetProgramAccountsOpts{
+			Filters: []rpc.RPCFilter{
+				{
+					DataSize: 388, // размер аккаунта пула v4
+				},
+				{
+					Memcmp: &rpc.RPCFilterMemcmp{
+						Offset: 8, // смещение для baseMint
+						Bytes:  baseMint.Bytes(),
+					},
+				},
+				{
+					Memcmp: &rpc.RPCFilterMemcmp{
+						Offset: 40, // смещение для quoteMint
+						Bytes:  quoteMint.Bytes(),
+					},
+				},
+			},
+		},
+	)
+	if err != nil {
+		return nil, fmt.Errorf("failed to get program accounts: %w", err)
+	}
+
+	if len(accounts) == 0 {
+		return nil, fmt.Errorf("pool not found")
+	}
+
+	// Берем первый найденный пул
+	poolAccount := accounts[0]
+
+	// Парсим данные аккаунта в структуру пула
+	pool := &RaydiumPool{
+		ID:        poolAccount.PublicKey,
+		BaseMint:  baseMint,
+		QuoteMint: quoteMint,
+		// ... заполнение остальных полей из данных аккаунта
+	}
+
+	return pool, nil
 }
 
-func (c *RaydiumClient) GetPoolState() (*PoolState, error) {
-	// Получение текущего состояния пула
+// GetPoolState получает текущее состояние пула
+func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
+	c.logger.Debug("getting pool state",
+		zap.String("poolId", pool.ID.String()),
+	)
+
+	// Получаем данные аккаунта пула
+	account, err := c.client.GetAccountInfo(pool.ID)
+	if err != nil {
+		return nil, fmt.Errorf("failed to get pool account: %w", err)
+	}
+
+	// Парсим данные в структуру состояния
+	state := &PoolState{
+		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // пример смещения
+		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // пример смещения
+		Status:       account.Data[88],                                // пример смещения
+	}
+
+	return state, nil
 }
 
-func (c *RaydiumClient) CreateSwapInstructions() ([]solana.Instruction, error) {
-	// Создание инструкций для свапа
+// TODO:
+// Для полноценной работы нужно добавить:
+// Корректную сериализацию инструкций (согласно протоколу Raydium)
+// Детальную обработку различных типов ошибок
+// Валидацию параметров свапа
+// Обработку разных версий пулов
+// Расчет слиппажа и проверку лимитов
+
+// CreateSwapInstructions создает набор инструкций для свапа
+func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
+	c.logger.Debug("creating swap instructions",
+		zap.String("userWallet", params.UserWallet.String()),
+		zap.Uint64("amountIn", params.AmountIn),
+		zap.Uint64("minAmountOut", params.MinAmountOut),
+	)
+
+	// Создаем базовый массив инструкций
+	instructions := make([]solana.Instruction, 0)
+
+	// Создаем инструкцию для установки приоритета комиссии
+	if params.PriorityFeeLamports > 0 {
+		computeBudgetIx := solana.NewInstruction(
+			solana.ComputeBudget,
+			&ComputeBudgetInstruction{
+				Units:         300000, // базовые compute units как в typescript
+				MicroLamports: params.PriorityFeeLamports,
+			},
+		)
+		instructions = append(instructions, computeBudgetIx)
+	}
+
+	// Создаем основную инструкцию свапа
+	swapIx := solana.NewInstruction(
+		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+		&SwapInstruction{
+			Amount:     params.AmountIn,
+			MinimumOut: params.MinAmountOut,
+		},
+		// Добавляем необходимые аккаунты
+		[]solana.AccountMeta{
+			{PublicKey: params.Pool.ID, IsWritable: true, IsSigner: false},
+			{PublicKey: params.Pool.Authority, IsWritable: false, IsSigner: false},
+			{PublicKey: params.UserWallet, IsWritable: true, IsSigner: true},
+			{PublicKey: params.SourceTokenAccount, IsWritable: true, IsSigner: false},
+			{PublicKey: params.DestinationTokenAccount, IsWritable: true, IsSigner: false},
+			{PublicKey: params.Pool.BaseVault, IsWritable: true, IsSigner: false},
+			{PublicKey: params.Pool.QuoteVault, IsWritable: true, IsSigner: false},
+			// Добавляем остальные необходимые аккаунты
+		},
+	)
+	instructions = append(instructions, swapIx)
+
+	return instructions, nil
 }
 
-func (c *RaydiumClient) SimulateSwap() error {
-	// Симуляция свапа
+// SimulateSwap выполняет симуляцию транзакции свапа
+func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
+	c.logger.Debug("simulating swap transaction")
+
+	// Получаем инструкции для свапа
+	instructions, err := c.CreateSwapInstructions(params)
+	if err != nil {
+		return fmt.Errorf("failed to create swap instructions: %w", err)
+	}
+
+	// Создаем транзакцию
+	recent, err := c.client.GetRecentBlockhash()
+	if err != nil {
+		return fmt.Errorf("failed to get recent blockhash: %w", err)
+	}
+
+	tx := solana.NewTransaction(
+		instructions,
+		recent.Value.Blockhash,
+		solana.TransactionPayer(params.UserWallet),
+	)
+
+	// Симулируем транзакцию
+	sim, err := c.client.SimulateTransaction(tx, &rpc.SimulateTransactionOpts{
+		SigVerify:              false,
+		Commitment:             c.options.commitment,
+		ReplaceRecentBlockhash: true,
+	})
+	if err != nil {
+		return fmt.Errorf("failed to simulate transaction: %w", err)
+	}
+
+	// Проверяем результат симуляции
+	if sim.Value.Err != nil {
+		return fmt.Errorf("simulation failed: %s", sim.Value.Err)
+	}
+
+	// Анализируем логи симуляции
+	for _, log := range sim.Value.Logs {
+		c.logger.Debug("simulation log", zap.String("log", log))
+	}
+
+	c.logger.Info("swap simulation successful",
+		zap.Uint64("unitsConsumed", sim.Value.UnitsConsumed),
+	)
+
+	return nil
+}
+
+// TODO:
+// Основные улучшения, которые можно добавить:
+// Retry логика для случаев временных сбоев
+// Более детальная валидация результатов транзакции
+// Механизм отмены операции по таймауту
+// Сохранение истории транзакций
+// Метрики выполнения свапов
+
+// ExecuteSwap выполняет свап и возвращает signature транзакции
+func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
+	c.logger.Debug("executing swap",
+		zap.String("userWallet", params.UserWallet.String()),
+		zap.Uint64("amountIn", params.AmountIn),
+		zap.Uint64("minAmountOut", params.MinAmountOut),
+	)
+
+	// Сначала симулируем транзакцию
+	if err := c.SimulateSwap(params); err != nil {
+		return "", fmt.Errorf("swap simulation failed: %w", err)
+	}
+
+	// Получаем инструкции для свапа
+	instructions, err := c.CreateSwapInstructions(params)
+	if err != nil {
+		return "", fmt.Errorf("failed to create swap instructions: %w", err)
+	}
+
+	// Получаем последний блокхэш
+	recent, err := c.client.GetRecentBlockhash()
+	if err != nil {
+		return "", fmt.Errorf("failed to get recent blockhash: %w", err)
+	}
+
+	// Создаем транзакцию
+	tx := solana.NewTransaction(
+		instructions,
+		recent.Value.Blockhash,
+		solana.TransactionPayer(params.UserWallet),
+	)
+
+	// Подписываем транзакцию
+	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+		if key.Equals(params.UserWallet) {
+			return &c.client.PrivateKey
+		}
+		return nil
+	})
+	if err != nil {
+		return "", fmt.Errorf("failed to sign transaction: %w", err)
+	}
+
+	// Отправляем транзакцию
+	sig, err := c.client.SendTransaction(tx, &rpc.SendTransactionOpts{
+		SkipPreflight:       true,
+		PreflightCommitment: c.options.commitment,
+	})
+	if err != nil {
+		return "", fmt.Errorf("failed to send transaction: %w", err)
+	}
+
+	// Ждем подтверждения транзакции
+	confirmationStrategy := rpc.TransactionConfirmationStrategy{
+		Signature:            sig,
+		Commitment:           c.options.commitment,
+		LastValidBlockHeight: recent.Value.LastValidBlockHeight,
+	}
+
+	startTime := time.Now()
+	confirmation, err := c.client.ConfirmTransaction(
+		confirmationStrategy,
+		&rpc.ConfirmTransactionOpts{
+			MaxRetries: c.options.retries,
+			Timeout:    c.options.timeout,
+		},
+	)
+	if err != nil {
+		return sig, fmt.Errorf("failed to confirm transaction: %w", err)
+	}
+
+	// Проверяем статус подтверждения
+	if confirmation.Value.Err != nil {
+		return sig, fmt.Errorf("transaction confirmed with error: %v", confirmation.Value.Err)
+	}
+
+	c.logger.Info("swap executed successfully",
+		zap.String("signature", sig),
+		zap.Duration("duration", time.Since(startTime)),
+	)
+
+	// Опционально: получаем и логируем новые балансы
+	if err := c.logUpdatedBalances(params); err != nil {
+		c.logger.Warn("failed to get updated balances", zap.Error(err))
+	}
+
+	return sig, nil
 }
 
-func (c *RaydiumClient) ExecuteSwap() (string, error) {
-	// Выполнение свапа
+// logUpdatedBalances вспомогательный метод для логирования балансов после свапа
+func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
+	// Получаем баланс SOL
+	solBalance, err := c.client.GetBalance(
+		params.UserWallet,
+		rpc.CommitmentConfirmed,
+	)
+	if err != nil {
+		return fmt.Errorf("failed to get SOL balance: %w", err)
+	}
+
+	// Получаем баланс токена
+	tokenBalance, err := c.client.GetTokenAccountBalance(
+		params.DestinationTokenAccount,
+		rpc.CommitmentConfirmed,
+	)
+	if err != nil {
+		return fmt.Errorf("failed to get token balance: %w", err)
+	}
+
+	c.logger.Info("updated balances",
+		zap.Float64("solBalance", float64(solBalance.Value)/float64(solana.LAMPORTS_PER_SOL)),
+		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
+	)
+
+	return nil
 }
diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
index 330c82d..50959de 100644
--- a/internal/dex/raydium/pool.go
+++ b/internal/dex/raydium/pool.go
@@ -2,23 +2,126 @@
 package raydium
 
 import (
+	"encoding/binary"
+	"fmt"
+
+	"github.com/gagliardetto/solana-go"
 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
 	"go.uber.org/zap"
 )
 
+type SwapAmounts struct {
+	AmountIn     uint64 // Количество входных токенов
+	AmountOut    uint64 // Ожидаемое количество выходных токенов
+	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
+}
+
 type PoolManager struct {
 	client blockchain.Client
 	logger *zap.Logger
+	pool   *RaydiumPool
+}
+
+// NewPoolManager создает новый менеджер пула
+func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *RaydiumPool) *PoolManager {
+	return &PoolManager{
+		client: client,
+		logger: logger,
+		pool:   pool,
+	}
 }
 
+// TODO: В дальнейшем этот код можно расширить:
+// 1. Добавить более сложную формулу расчета с учетом комиссий
+// 2. Реализовать кэширование состояния пула
+// 3. Добавить больше проверок валидации
+// 4. Улучшить обработку ошибок и логирование
+
+// GetPoolState получает актуальное состояние пула
 func (pm *PoolManager) GetPoolState() (*PoolState, error) {
-	// Получение состояния пула
+	pm.logger.Debug("getting pool state",
+		zap.String("poolId", pm.pool.ID.String()),
+	)
+
+	// Получаем данные аккаунта пула
+	account, err := pm.client.GetAccountInfo(pm.pool.ID)
+	if err != nil {
+		return nil, fmt.Errorf("failed to get pool account: %w", err)
+	}
+
+	// Парсим данные в структуру состояния
+	state := &PoolState{
+		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // резервы base токена
+		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // резервы quote токена
+		Status:       account.Data[88],                                // статус пула
+	}
+
+	return state, nil
 }
 
+// CalculateAmounts рассчитывает количество выходных токенов и минимальный выход
 func (pm *PoolManager) CalculateAmounts() (*SwapAmounts, error) {
-	// Расчет amount out и минимального получения
+	// Получаем текущее состояние пула
+	state, err := pm.GetPoolState()
+	if err != nil {
+		return nil, fmt.Errorf("failed to get pool state: %w", err)
+	}
+
+	// Проверяем, что пул активен
+	if state.Status != 1 { // предполагаем, что 1 = активный статус
+		return nil, fmt.Errorf("pool is not active")
+	}
+
+	// Расчет по формуле: amountOut = (amountIn * outputReserve) / (inputReserve + amountIn)
+	// Это упрощенная формула для начала
+	amountIn := uint64(1000000) // пример входного количества
+	amountOut := (amountIn * state.QuoteReserve) / (state.BaseReserve + amountIn)
+
+	// Учитываем проскальзывание (например, 1%)
+	slippage := uint64(100) // 1%
+	minAmountOut := amountOut - (amountOut * slippage / 10000)
+
+	return &SwapAmounts{
+		AmountIn:     amountIn,
+		AmountOut:    amountOut,
+		MinAmountOut: minAmountOut,
+	}, nil
 }
 
+// ValidatePool проверяет валидность параметров пула
 func (pm *PoolManager) ValidatePool() error {
-	// Валидация параметров пула
+	// Проверяем существование всех необходимых аккаунтов
+	accounts := []solana.PublicKey{
+		pm.pool.ID,
+		pm.pool.Authority,
+		pm.pool.BaseMint,
+		pm.pool.QuoteMint,
+		pm.pool.BaseVault,
+		pm.pool.QuoteVault,
+	}
+
+	for _, acc := range accounts {
+		if acc.IsZero() {
+			return fmt.Errorf("invalid pool account: %s is zero", acc.String())
+		}
+	}
+
+	// Проверяем состояние пула
+	state, err := pm.GetPoolState()
+	if err != nil {
+		return fmt.Errorf("failed to get pool state: %w", err)
+	}
+
+	// Проверяем резервы
+	if state.BaseReserve == 0 || state.QuoteReserve == 0 {
+		return fmt.Errorf("pool reserves are empty: base=%d, quote=%d",
+			state.BaseReserve, state.QuoteReserve)
+	}
+
+	// Проверяем статус
+	if state.Status != 1 { // предполагаем, что 1 = активный статус
+		return fmt.Errorf("pool is not active")
+	}
+
+	return nil
 }
diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
index 2c184ce..55c2206 100644
--- a/internal/dex/raydium/types.go
+++ b/internal/dex/raydium/types.go
@@ -1,4 +1,4 @@
-// inernal/dex/raydium - это пакет, который содержит в себе реализацию работы с декстерами Raydium
+// inernal/dex/raydium/types.go - это пакет, который содержит в себе реализацию работы с декстерами Raydium
 package raydium
 
 import "github.com/gagliardetto/solana-go"
diff --git a/newdif.txt b/newdif.txt
index 916f03e..5cdad43 100644
--- a/newdif.txt
+++ b/newdif.txt
@@ -1,6213 +0,0 @@
-diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
-index 45d076b..0355dc0 100644
---- a/internal/blockchain/types.go
-+++ b/internal/blockchain/types.go
-@@ -48,4 +48,5 @@ type Client interface {
- 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
- 	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
- 	GetRpcClient() *rpc.Client
-+	GetTokenAccountBalance(ctx context.Context, account solana.PublicKey, commitment rpc.CommitmentType) (*rpc.GetTokenAccountBalanceResult, error)
- }
-diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
-index 26e8e25..8ff9022 100644
---- a/internal/dex/raydium/pool.go
-+++ b/internal/dex/raydium/pool.go
-@@ -3,13 +3,16 @@ package raydium
- 
- import (
- 	"context"
-+	"encoding/json"
- 	"fmt"
- 	"math"
- 	"math/big"
-+	"strconv"
- 	"time"
- 
- 	"github.com/gagliardetto/solana-go"
- 	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
-+	"github.com/gagliardetto/solana-go/rpc"
- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
- 	"go.uber.org/zap"
- )
-@@ -23,6 +26,7 @@ import (
- type PoolManager struct {
- 	client blockchain.Client
- 	logger *zap.Logger
-+	pool   *RaydiumV5Pool // Текущий активный пул
- }
- 
- // NewPoolManager создает новый менеджер пула
-@@ -30,6 +34,7 @@ func NewPoolManager(client blockchain.Client, logger *zap.Logger) *PoolManager {
- 	return &PoolManager{
- 		client: client,
- 		logger: logger.Named("pool-manager"),
-+		pool:   nil,
- 	}
- }
- 
-@@ -331,27 +336,349 @@ func (pc *PoolCalculator) GetMarketPrice() float64 {
- 	return (quoteF / quoteDecimalAdj) / (baseF / baseDecimalAdj)
- }
- 
--// Добавить в pool.go:
-+// RaydiumV5Pool представляет пул Raydium версии 5
- type RaydiumV5Pool struct {
--	RaydiumPool
--	PnlOwner    solana.PublicKey
--	ModelDataId solana.PublicKey
--	RecentRoot  *big.Int
--	MaxOrders   uint64
--	OrderStates []*big.Int
--	TickSpacing uint16
--}
--
--// Методы для работы с v5 пулами
--func (pm *PoolManager) InitializeV5Pool(ctx context.Context, params *RaydiumPoolV5) error {
--	// TODO: implement
-+	RaydiumPool // Встраиваем базовую структуру пула
-+
-+	// Основные параметры V5
-+	PnlOwner    solana.PublicKey // Владелец PnL (Profit and Loss)
-+	ModelDataId solana.PublicKey // ID модели данных пула
-+	RecentRoot  *big.Int         // Последний корневой хеш состояния пула
-+	MaxOrders   uint64           // Максимальное количество ордеров
-+	OrderStates []*big.Int       // Состояния ордеров
-+	TickSpacing uint16           // Шаг тиков цены
-+
-+	// Дополнительные параметры V5
-+	LPMint       solana.PublicKey    // Минт LP токенов
-+	AdminKey     solana.PublicKey    // Ключ администратора пула
-+	ConfigParams V5ConfigParams      // Параметры конфигурации
-+	FeeAccounts  V5FeeAccounts       // Аккаунты для комиссий
-+	PoolState    V5PoolState         // Состояние пула
-+	PriceHistory []PriceHistoryPoint // История цен
-+}
-+
-+// V5ConfigParams содержит параметры конфигурации пула V5
-+type V5ConfigParams struct {
-+	MinPriceRatio  *big.Int // Минимальное соотношение цен
-+	MaxPriceRatio  *big.Int // Максимальное соотношение цен
-+	MinBaseAmount  uint64   // Минимальное количество базового токена
-+	MinQuoteAmount uint64   // Минимальное количество котируемого токена
-+	MaxSlippageBps uint16   // Максимальный проскальзывание в базисных пунктах
-+	MaxLeverage    uint16   // Максимальное плечо
-+	ProtocolFee    uint16   // Комиссия протокола в базисных пунктах
-+	MinOrderSize   uint64   // Минимальный размер ордера
-+}
-+
-+// V5FeeAccounts содержит аккаунты для комиссий
-+type V5FeeAccounts struct {
-+	ProtocolFeeAccount solana.PublicKey // Аккаунт для комиссий протокола
-+	TraderFeeAccount   solana.PublicKey // Аккаунт для комиссий трейдера
-+	LPFeeAccount       solana.PublicKey // Аккаунт для комиссий провайдеров ликвидности
-+}
-+
-+// V5PoolState содержит текущее состояние пула
-+type V5PoolState struct {
-+	BaseReserve     uint64     // Резерв базового токена
-+	QuoteReserve    uint64     // Резерв котируемого токена
-+	LPSupply        uint64     // Общее предложение LP токенов
-+	LastUpdateSlot  uint64     // Слот последнего обновления
-+	SwapEnabled     bool       // Включен ли свап
-+	PriceMultiplier *big.Int   // Мультипликатор цены
-+	CurrentPrice    *big.Float // Текущая цена
-+	TVL             *big.Float // Total Value Locked
-+}
-+
-+// PriceHistoryPoint представляет точку в истории цен
-+type PriceHistoryPoint struct {
-+	Timestamp time.Time  // Временная метка
-+	Price     *big.Float // Цена
-+	Volume    uint64     // Объем
-+}
-+
-+// Методы для работы с V5Pool
-+
-+// NewRaydiumV5Pool создает новый экземпляр V5 пула
-+func NewRaydiumV5Pool(baseParams *RaydiumPool) *RaydiumV5Pool {
-+	return &RaydiumV5Pool{
-+		RaydiumPool: *baseParams,
-+		ConfigParams: V5ConfigParams{
-+			MinPriceRatio: new(big.Int),
-+			MaxPriceRatio: new(big.Int),
-+		},
-+		PoolState: V5PoolState{
-+			PriceMultiplier: new(big.Int),
-+			CurrentPrice:    new(big.Float),
-+			TVL:             new(big.Float),
-+		},
-+		PriceHistory: make([]PriceHistoryPoint, 0),
-+	}
-+}
-+
-+// GetCurrentState возвращает текущее состояние пула
-+func (p *RaydiumV5Pool) GetCurrentState() V5PoolState {
-+	return p.PoolState
-+}
-+
-+// UpdateState обновляет состояние пула
-+func (p *RaydiumV5Pool) UpdateState(newState V5PoolState) {
-+	p.PoolState = newState
-+	// Добавляем точку в историю цен
-+	p.PriceHistory = append(p.PriceHistory, PriceHistoryPoint{
-+		Timestamp: time.Now(),
-+		Price:     newState.CurrentPrice,
-+		Volume:    0, // Нужно добавить расчет объема
-+	})
-+}
-+
-+// GetFeeAccounts возвращает аккаунты для комиссий
-+func (p *RaydiumV5Pool) GetFeeAccounts() V5FeeAccounts {
-+	return p.FeeAccounts
-+}
-+
-+// IsSwapEnabled проверяет, включен ли свап в пуле
-+func (p *RaydiumV5Pool) IsSwapEnabled() bool {
-+	return p.PoolState.SwapEnabled
-+}
-+
-+// GetTVL возвращает Total Value Locked
-+func (p *RaydiumV5Pool) GetTVL() *big.Float {
-+	return p.PoolState.TVL
-+}
-+
-+// Вспомогательный метод для валидации model data
-+func (pm *PoolManager) validateModelData(ctx context.Context, modelDataId solana.PublicKey) error {
-+	if modelDataId.IsZero() {
-+		return fmt.Errorf("model data ID cannot be zero")
-+	}
-+
-+	// Проверяем существование аккаунта
-+	account, err := pm.client.GetAccountInfo(ctx, modelDataId)
-+	if err != nil {
-+		return fmt.Errorf("failed to get model data account: %w", err)
-+	}
-+
-+	if account == nil || account.Value == nil {
-+		return fmt.Errorf("model data account not found")
-+	}
-+
-+	// Здесь можно добавить дополнительную валидацию данных модели
-+	// в зависимости от требований
-+
-+	return nil
-+}
-+
-+// SetPool устанавливает текущий активный пул
-+func (pm *PoolManager) SetPool(pool *RaydiumV5Pool) {
-+	pm.pool = pool
-+}
-+
-+// GetPool возвращает текущий активный пул
-+func (pm *PoolManager) GetPool() *RaydiumV5Pool {
-+	return pm.pool
-+}
-+
-+// InitializeV5Pool инициализирует пул версии 5 Raydium
-+func (pm *PoolManager) InitializeV5Pool(ctx context.Context, params *RaydiumV5Pool) error {
-+	logger := pm.logger.With(
-+		zap.String("base_mint", params.BaseMint.String()),
-+		zap.String("quote_mint", params.QuoteMint.String()),
-+		zap.String("pnl_owner", params.PnlOwner.String()),
-+	)
-+	logger.Debug("Initializing new V5 pool")
-+
-+	// Проверяем базовые параметры пула
-+	if err := pm.validatePoolParameters(&params.RaydiumPool); err != nil {
-+		return &PoolError{
-+			Stage:   "initialize_v5",
-+			Message: "invalid pool parameters",
-+			Err:     err,
-+		}
-+	}
-+
-+	// Дополнительная валидация параметров V5
-+	if err := pm.validateV5Parameters(params); err != nil {
-+		return &PoolError{
-+			Stage:   "initialize_v5",
-+			Message: "invalid v5 specific parameters",
-+			Err:     err,
-+		}
-+	}
-+
-+	// Загружаем lookup table если она указана
-+	if err := pm.LoadPoolLookupTable(ctx, &params.RaydiumPool); err != nil {
-+		return err
-+	}
-+
-+	// Проверяем наличие и валидность model data account
-+	if err := pm.validateModelData(ctx, params.ModelDataId); err != nil {
-+		return &PoolError{
-+			Stage:   "initialize_v5",
-+			Message: "invalid model data account",
-+			Err:     err,
-+		}
-+	}
-+
-+	return nil
-+}
-+
-+// validateV5Parameters проверяет специфичные для V5 параметры
-+func (pm *PoolManager) validateV5Parameters(pool *RaydiumV5Pool) error {
-+	if pool.PnlOwner.IsZero() {
-+		return fmt.Errorf("pnl owner cannot be zero")
-+	}
-+
-+	if pool.ModelDataId.IsZero() {
-+		return fmt.Errorf("model data id cannot be zero")
-+	}
-+
-+	if pool.MaxOrders == 0 {
-+		return fmt.Errorf("max orders must be greater than zero")
-+	}
-+
-+	if pool.TickSpacing == 0 {
-+		return fmt.Errorf("tick spacing must be greater than zero")
-+	}
-+
-+	return nil
-+}
-+
-+// UiTokenAmount представляет количество токенов с учетом десятичных знаков
-+type UiTokenAmount struct {
-+	// Точное количество токенов в виде строки для предотвращения потери точности
-+	Amount string `json:"amount"`
-+
-+	// Количество десятичных знаков токена
-+	Decimals uint8 `json:"decimals"`
-+
-+	// Форматированное количество токенов с учетом десятичных знаков
-+	UiAmount float64 `json:"uiAmount"`
-+
-+	// Форматированное количество в виде строки
-+	UiAmountString string `json:"uiAmountString"`
-+}
-+
-+// NewUiTokenAmount создает новый UiTokenAmount
-+func NewUiTokenAmount(amount uint64, decimals uint8) *UiTokenAmount {
-+	// Конвертируем amount в float64 с учетом decimals
-+	uiAmount := float64(amount) / math.Pow10(int(decimals))
-+
-+	return &UiTokenAmount{
-+		Amount:         strconv.FormatUint(amount, 10),
-+		Decimals:       decimals,
-+		UiAmount:       uiAmount,
-+		UiAmountString: fmt.Sprintf("%f", uiAmount),
-+	}
-+}
-+
-+// ToUint64 конвертирует UiAmount обратно в uint64
-+func (u *UiTokenAmount) ToUint64() (uint64, error) {
-+	return strconv.ParseUint(u.Amount, 10, 64)
-+}
-+
-+// String возвращает строковое представление количества токенов
-+func (u *UiTokenAmount) String() string {
-+	return u.UiAmountString
-+}
-+
-+// FromDecimals создает UiTokenAmount из количества и decimals
-+func FromDecimals(amount uint64, decimals uint8) *UiTokenAmount {
-+	return NewUiTokenAmount(amount, decimals)
-+}
-+
-+// Parse парсит значение из JSON
-+func (u *UiTokenAmount) UnmarshalJSON(data []byte) error {
-+	// Временная структура для парсинга
-+	type Alias UiTokenAmount
-+	aux := &struct {
-+		Amount         string  `json:"amount"`
-+		Decimals       uint8   `json:"decimals"`
-+		UiAmount       float64 `json:"uiAmount"`
-+		UiAmountString string  `json:"uiAmountString"`
-+	}{}
-+
-+	if err := json.Unmarshal(data, &aux); err != nil {
-+		return err
-+	}
-+
-+	// Просто присваиваем строковые значения
-+	u.Amount = aux.Amount
-+	u.Decimals = aux.Decimals
-+	u.UiAmount = aux.UiAmount
-+	u.UiAmountString = aux.UiAmountString
-+
- 	return nil
- }
- 
-+// MarshalJSON конвертирует в JSON
-+func (u UiTokenAmount) MarshalJSON() ([]byte, error) {
-+	// Временная структура для маршалинга
-+	return json.Marshal(&struct {
-+		Amount         string  `json:"amount"`
-+		Decimals       uint8   `json:"decimals"`
-+		UiAmount       float64 `json:"uiAmount"`
-+		UiAmountString string  `json:"uiAmountString"`
-+	}{
-+		Amount:         u.Amount,
-+		Decimals:       u.Decimals,
-+		UiAmount:       u.UiAmount,
-+		UiAmountString: u.UiAmountString,
-+	})
-+}
-+
- // Методы для работы с LP токенами
-+// GetLPTokenBalance получает баланс LP токенов для указанного владельца
- func (pm *PoolManager) GetLPTokenBalance(ctx context.Context, owner solana.PublicKey) (uint64, error) {
--	// TODO: implement
--	return 0, nil
-+	if pm.pool == nil {
-+		return 0, &PoolError{
-+			Stage:   "get_lp_balance",
-+			Message: "no active pool set",
-+		}
-+	}
-+
-+	logger := pm.logger.With(
-+		zap.String("owner", owner.String()),
-+		zap.String("lp_mint", pm.pool.LPMint.String()),
-+	)
-+	logger.Debug("Getting LP token balance")
-+
-+	// Получаем associated token address для LP токенов
-+	lpTokenATA, _, err := solana.FindAssociatedTokenAddress(owner, pm.pool.LPMint)
-+	if err != nil {
-+		return 0, &PoolError{
-+			Stage:   "get_lp_balance",
-+			Message: "failed to find LP token ATA",
-+			Err:     err,
-+		}
-+	}
-+
-+	balance, err := pm.client.GetTokenAccountBalance(
-+		ctx,
-+		lpTokenATA,
-+		rpc.CommitmentConfirmed,
-+	)
-+	if err != nil {
-+		return 0, &PoolError{
-+			Stage:   "get_lp_balance",
-+			Message: "failed to get token balance",
-+			Err:     err,
-+		}
-+	}
-+
-+	if balance == nil || balance.Value == nil {
-+		return 0, nil
-+	}
-+
-+	// Конвертируем строковое значение в uint64
-+	amount, err := strconv.ParseUint(balance.Value.Amount, 10, 64)
-+	if err != nil {
-+		return 0, &PoolError{
-+			Stage:   "get_lp_balance",
-+			Message: "failed to parse token amount",
-+			Err:     err,
-+		}
-+	}
-+
-+	return amount, nil
- }
- 
- // Улучшить кэширование в pool.go:
-diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
-index 6bb4e16..59aa82b 100644
---- a/internal/dex/raydium/types.go
-+++ b/internal/dex/raydium/types.go
-@@ -197,11 +197,6 @@ func (e *SwapError) Unwrap() error {
- 	return e.Err
- }
- 
--// Типы для v5 пулов
--type RaydiumPoolV5 struct {
--	// Новые поля v5
--}
--
- // Типы для маркет-мейкинга
- type MarketMakingParams struct {
- 	// Параметры для MM
-diff --git a/newdif.txt b/newdif.txt
-index 19f71dd..9baa9ce 100644
---- a/newdif.txt
-+++ b/newdif.txt
-@@ -1,5780 +0,0 @@
--diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
--index eafb611..612da49 100644
----- a/internal/dex/raydium/client.go
--+++ b/internal/dex/raydium/client.go
--@@ -5,6 +5,7 @@ import (
-- 	"context"
-- 	"encoding/binary"
-- 	"fmt"
--+	"sync"
-- 	"time"
-- 
-- 	"github.com/gagliardetto/solana-go"
--@@ -13,9 +14,15 @@ import (
-- 	"github.com/gagliardetto/solana-go/rpc"
-- 	"github.com/gagliardetto/solana-go/rpc/jsonrpc"
-- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
--+	"github.com/rovshanmuradov/solana-bot/internal/eventlistener"
-- 	"go.uber.org/zap"
-- )
-- 
--+// TODO: client.go:
--+// - Добавить метод для batch-запросов GetMultiplePools
--+// - Реализовать интерфейс для работы с WebSocket
--+// - Добавить кэширование с TTL для пулов
--+
-- const (
-- 	maxRetries          = 3
-- 	retryDelay          = 500 * time.Millisecond
--@@ -28,6 +35,9 @@ type clientOptions struct {
-- 	timeout         time.Duration
-- 	retries         int
-- 	commitmentLevel rpc.CommitmentType
--+
--+	cacheLifetime time.Duration
--+	wsURL         string
-- }
-- 
-- // ClientOption определяет функцию для настройки клиента
--@@ -68,6 +78,16 @@ type RaydiumClient struct {
-- 	client  blockchain.Client
-- 	logger  *zap.Logger
-- 	options *clientOptions
--+
--+	// Добавляем поля для кэширования
--+	poolCache     map[string]*poolCacheEntry
--+	cacheMutex    sync.RWMutex
--+	cacheLifetime time.Duration
--+
--+	// Добавляем поля для WebSocket
--+	eventListener *eventlistener.EventListener
--+	subscribers   map[string][]chan PoolUpdate
--+	subMutex      sync.RWMutex
-- }
-- 
-- // NewRaydiumClient создает новый экземпляр клиента с опциями
--@@ -84,11 +104,23 @@ func NewRaydiumClient(client blockchain.Client, logger *zap.Logger, opts ...Clie
-- 		opt(options)
-- 	}
-- 
---	return &RaydiumClient{
---		client:  client,
---		logger:  logger.Named("raydium-client"),
---		options: options,
---	}, nil
--+	rc := &RaydiumClient{
--+		client:        client,
--+		logger:        logger.Named("raydium-client"),
--+		options:       options,
--+		poolCache:     make(map[string]*poolCacheEntry),
--+		cacheLifetime: options.cacheLifetime,
--+		subscribers:   make(map[string][]chan PoolUpdate),
--+	}
--+
--+	// Инициализируем WebSocket если указан URL
--+	if options.wsURL != "" {
--+		if err := rc.initWebSocket(options.wsURL); err != nil {
--+			return nil, fmt.Errorf("failed to initialize websocket: %w", err)
--+		}
--+	}
--+
--+	return rc, nil
-- }
-- 
-- // GetPool получает информацию о пуле по его ID
--@@ -96,34 +128,37 @@ func (c *RaydiumClient) GetPool(ctx context.Context, poolID solana.PublicKey) (*
-- 	logger := c.logger.With(zap.String("pool_id", poolID.String()))
-- 	logger.Debug("Getting pool information")
-- 
---	ctx, cancel := context.WithTimeout(ctx, c.options.timeout)
---	defer cancel()
---
---	account, err := c.client.GetAccountInfo(ctx, poolID)
---	if err != nil {
---		return nil, &SwapError{
---			Stage:   "get_pool",
---			Message: "failed to get pool account",
---			Err:     err,
---		}
--+	// Проверяем кэш первым делом
--+	if entry, ok := c.getCached(poolID.String()); ok {
--+		logger.Debug("Pool found in cache")
--+		return entry.pool, nil
-- 	}
-- 
---	if account.Value == nil || len(account.Value.Data.GetBinary()) == 0 {
---		return nil, &SwapError{
---			Stage:   "get_pool",
---			Message: "pool account not found or empty",
---		}
---	}
---
---	pool := &RaydiumPool{
---		ID: poolID,
--+	// Если нет в кэше, получаем из блокчейна
--+	pool, err := c.fetchPoolFromChain(ctx, poolID)
--+	if err != nil {
--+		return nil, err
-- 	}
-- 
---	if err := c.decodePoolData(account.Value.Data.GetBinary(), pool); err != nil {
---		return nil, &SwapError{
---			Stage:   "get_pool",
---			Message: "failed to decode pool data",
---			Err:     err,
--+	// Получаем актуальное состояние
--+	state, err := c.GetPoolState(ctx, pool)
--+	if err != nil {
--+		logger.Warn("Failed to get pool state", zap.Error(err))
--+		// Продолжаем без состояния
--+	} else {
--+		// Обновляем кэш с состоянием
--+		c.updateCache(poolID.String(), pool, state)
--+	}
--+
--+	// Подписываемся на обновления пула через WebSocket, если есть слушатель
--+	if c.eventListener != nil {
--+		if _, exists := c.subscribers[poolID.String()]; !exists {
--+			updates := make(chan PoolUpdate, 100)
--+			c.subMutex.Lock()
--+			c.subscribers[poolID.String()] = append(c.subscribers[poolID.String()], updates)
--+			c.subMutex.Unlock()
--+
--+			logger.Debug("Subscribed to pool updates via WebSocket")
-- 		}
-- 	}
-- 
--@@ -592,3 +627,112 @@ func (c *RaydiumClient) GetPoolLookupTable(
-- 
-- 	return result, nil
-- }
--+
--+// Реализуем метод для получения множества пулов
--+func (c *RaydiumClient) GetMultiplePools(ctx context.Context, poolIDs []solana.PublicKey) ([]*RaydiumPool, error) {
--+	logger := c.logger.With(zap.Int("pool_count", len(poolIDs)))
--+	logger.Debug("Getting multiple pools")
--+
--+	type poolResult struct {
--+		pool *RaydiumPool
--+		err  error
--+		idx  int
--+	}
--+
--+	// Создаем каналы для результатов и ошибок
--+	results := make(chan poolResult, len(poolIDs))
--+	semaphore := make(chan struct{}, 10) // Ограничиваем параллельные запросы
--+
--+	// Запускаем горутины для получения пулов
--+	for i, poolID := range poolIDs {
--+		go func(index int, id solana.PublicKey) {
--+			semaphore <- struct{}{}        // Захватываем слот
--+			defer func() { <-semaphore }() // Освобождаем слот
--+
--+			// Проверяем кэш
--+			if entry, ok := c.getCached(id.String()); ok {
--+				results <- poolResult{pool: entry.pool, idx: index}
--+				return
--+			}
--+
--+			// Если нет в кэше, получаем из блокчейна
--+			pool, err := c.fetchPoolFromChain(ctx, id)
--+			results <- poolResult{pool: pool, err: err, idx: index}
--+		}(i, poolID)
--+	}
--+
--+	// Собираем результаты
--+	pools := make([]*RaydiumPool, len(poolIDs))
--+	var errors []error
--+
--+	for i := 0; i < len(poolIDs); i++ {
--+		select {
--+		case <-ctx.Done():
--+			return nil, ctx.Err()
--+		case result := <-results:
--+			if result.err != nil {
--+				errors = append(errors, fmt.Errorf("pool %s: %w", poolIDs[result.idx], result.err))
--+				continue
--+			}
--+			pools[result.idx] = result.pool
--+
--+			// Получаем состояние и обновляем кэш асинхронно
--+			go func(p *RaydiumPool) {
--+				if state, err := c.GetPoolState(ctx, p); err == nil {
--+					c.updateCache(p.ID.String(), p, state)
--+				}
--+			}(result.pool)
--+		}
--+	}
--+
--+	// Если есть ошибки, но получили хотя бы один пул
--+	if len(errors) > 0 && len(errors) < len(poolIDs) {
--+		logger.Warn("Some pools failed to load",
--+			zap.Int("error_count", len(errors)),
--+			zap.Errors("errors", errors))
--+	} else if len(errors) == len(poolIDs) {
--+		// Если все запросы завершились с ошибкой
--+		return nil, fmt.Errorf("all pool requests failed: %v", errors)
--+	}
--+
--+	logger.Debug("Successfully retrieved pools",
--+		zap.Int("success_count", len(poolIDs)-len(errors)))
--+
--+	return pools, nil
--+}
--+
--+// Реализуем вспомогательный метод для получения пула из блокчейна
--+func (c *RaydiumClient) fetchPoolFromChain(ctx context.Context, poolID solana.PublicKey) (*RaydiumPool, error) {
--+	ctx, cancel := context.WithTimeout(ctx, c.options.timeout)
--+	defer cancel()
--+
--+	account, err := c.client.GetAccountInfo(ctx, poolID)
--+	if err != nil {
--+		return nil, &SwapError{
--+			Stage:   "get_pool",
--+			Message: "failed to get pool account",
--+			Err:     err,
--+		}
--+	}
--+
--+	if account.Value == nil || len(account.Value.Data.GetBinary()) == 0 {
--+		return nil, &SwapError{
--+			Stage:   "get_pool",
--+			Message: "pool account not found or empty",
--+		}
--+	}
--+
--+	pool := &RaydiumPool{
--+		ID: poolID,
--+	}
--+
--+	if err := c.decodePoolData(account.Value.Data.GetBinary(), pool); err != nil {
--+		return nil, &SwapError{
--+			Stage:   "get_pool",
--+			Message: "failed to decode pool data",
--+			Err:     err,
--+		}
--+	}
--+
--+	return pool, nil
--+}
--diff --git a/internal/dex/raydium/instruction.go b/internal/dex/raydium/instruction.go
--index f8f7886..82754f9 100644
----- a/internal/dex/raydium/instruction.go
--+++ b/internal/dex/raydium/instruction.go
--@@ -12,6 +12,10 @@ import (
-- 	"go.uber.org/zap"
-- )
-- 
--+//TODO:instruction.go:
--+//- Упростить BuildSwapInstruction, вынести часть логики в отдельные методы
--+// - Добавить поддержку batch-инструкций
--+
-- // InstructionType определяет тип инструкции Raydium
-- type InstructionType uint8
-- 
--diff --git a/internal/dex/raydium/order_book.go b/internal/dex/raydium/order_book.go
--index 6bc8459..4e5d4d0 100644
----- a/internal/dex/raydium/order_book.go
--+++ b/internal/dex/raydium/order_book.go
--@@ -13,6 +13,10 @@ import (
-- 	"go.uber.org/zap"
-- )
-- 
--+// TODO: order_book.go:
--+// - Упростить структуру, использовать более эффективные структуры данных
--+// - Добавить методы для работы с orderbook snapshots
--+
-- // Константы для Serum OrderBook
-- const (
-- 	ORDER_BOOK_LAYOUT_SIZE = 5132
--diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
--index 2dcdd64..26e8e25 100644
----- a/internal/dex/raydium/pool.go
--+++ b/internal/dex/raydium/pool.go
--@@ -6,6 +6,7 @@ import (
-- 	"fmt"
-- 	"math"
-- 	"math/big"
--+	"time"
-- 
-- 	"github.com/gagliardetto/solana-go"
-- 	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
--@@ -13,6 +14,11 @@ import (
-- 	"go.uber.org/zap"
-- )
-- 
--+// TODO: pool.go
--+// - Добавить поддержку новых типов пулов
--+// - Реализовать методы для работы с concentrated liquidity
--+// - Добавить методы для анализа ликвидности
--+
-- // PoolManager управляет операциями с пулом ликвидности
-- type PoolManager struct {
-- 	client blockchain.Client
--@@ -347,3 +353,29 @@ func (pm *PoolManager) GetLPTokenBalance(ctx context.Context, owner solana.Publi
-- 	// TODO: implement
-- 	return 0, nil
-- }
--+
--+// Улучшить кэширование в pool.go:
--+type PoolCache struct {
--+	pool      *RaydiumPool
--+	state     *PoolState
--+	updatedAt time.Time
--+	ttl       time.Duration
--+}
--+
--+// Добавить методы для анализа ликвидности:
--+
--+func (p *PoolManager) GetLiquidityDepth(ctx context.Context, pool *RaydiumPool) (*LiquidityDepth, error) {
--+	// TODO: реализовать
--+	return nil, nil
--+}
--+
--+// Реализовать concentrated liquidity:
--+
--+type ConcentratedLiquidityPool struct {
--+	// TODO: определить структуру
--+}
--+
--+func (p *PoolManager) InitializeConcentratedPool(ctx context.Context, params *ConcentratedPoolParams) error {
--+	// TODO: реализовать
--+	return nil
--+}
--diff --git a/internal/dex/raydium/state.go b/internal/dex/raydium/state.go
--index cff0664..ed5730d 100644
----- a/internal/dex/raydium/state.go
--+++ b/internal/dex/raydium/state.go
--@@ -10,6 +10,10 @@ import (
-- 	"go.uber.org/zap"
-- )
-- 
--+// TODO: stage.go:
--+// - Добавить поддержку сериализации/десериализации для всех версий
--+// - Улучшить валидацию состояний
--+
-- // StateVersion определяет версию структуры состояния
-- type StateVersion uint8
-- 
--diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
--index 6100e4c..6bb4e16 100644
----- a/internal/dex/raydium/types.go
--+++ b/internal/dex/raydium/types.go
--@@ -11,6 +11,10 @@ import (
-- 	"go.uber.org/zap"
-- )
-- 
--+// TODO: types.go
--+// - Добавить типы для новых функций
--+// - Расширить интерфейсы для поддержки новых операций
--+
-- // Layout константы для правильного чтения данных из аккаунта пула
-- const (
-- 	// Базовые смещения
--diff --git a/internal/dex/raydium/utils.go b/internal/dex/raydium/utils.go
--index 104cc1d..57438ca 100644
----- a/internal/dex/raydium/utils.go
--+++ b/internal/dex/raydium/utils.go
--@@ -11,6 +11,7 @@ import (
-- 	"time"
-- 
-- 	"github.com/gagliardetto/solana-go"
--+	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
-- 	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
-- 	token "github.com/gagliardetto/solana-go/programs/token"
-- 	"github.com/shopspring/decimal"
--@@ -19,6 +20,10 @@ import (
-- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
-- )
-- 
--+// TODO: utils.go
--+// - Добавить больше helpers для работы с числами
--+// - Оптимизировать конвертации между типами
--+
-- // TokenAmountConfig содержит конфигурацию для работы с суммами токенов
-- type TokenAmountConfig struct {
-- 	Amount   uint64
--@@ -311,14 +316,110 @@ func ConvertBigFloatToUint64(value *big.Float) (uint64, error) {
-- }
-- 
-- // Утилиты для версионированных транзакций
---// TODO: Implement the method logic
---func CreateVersionedTransaction(instructions []solana.Instruction, lookupTables []solana.AddressLookupTable) (*solana.VersionedTransaction, error) {
---	// Создаем транзакцию
---	return nil, nil
--+// В начале файла добавим структуру для V5 комиссий
--+type V5FeeParams struct {
--+	BaseFee     uint64 // Базовая комиссия
--+	MaxFee      uint64 // Максимальная комиссия
--+	AmmFee      uint16 // Комиссия AMM в базовых пунктах
--+	PriceImpact uint16 // Максимальное влияние на цену в базовых пунктах
-- }
-- 
---// Утилиты для работы с новыми комиссиями
---// TODO: Implement the method logic
--+// CreateVersionedTransaction создает транзакцию с поддержкой lookup tables
--+func CreateVersionedTransaction(
--+	instructions []solana.Instruction,
--+	lookupTables map[solana.PublicKey]solana.PublicKeySlice,
--+) (*solana.Transaction, error) {
--+	if len(instructions) == 0 {
--+		return nil, fmt.Errorf("no instructions provided")
--+	}
--+
--+	// Создаем билдер транзакции
--+	tx := solana.NewTransactionBuilder()
--+
--+	// Добавляем все инструкции
--+	for _, instruction := range instructions {
--+		tx.AddInstruction(instruction)
--+	}
--+
--+	// Если есть lookup tables, добавляем их через опцию
--+	if len(lookupTables) > 0 {
--+		tx.WithOpt(solana.TransactionAddressTables(lookupTables))
--+	}
--+
--+	// Строим транзакцию
--+	transaction, err := tx.Build()
--+	if err != nil {
--+		return nil, fmt.Errorf("failed to build transaction: %w", err)
--+	}
--+
--+	return transaction, nil
--+}
--+
--+// CalculateV5Fees вычисляет комиссии для V5 пулов
-- func CalculateV5Fees(amount uint64, feeParams V5FeeParams) uint64 {
---	return 0
--+	// Базовая комиссия всегда взимается
--+	totalFee := feeParams.BaseFee
--+
--+	// Добавляем комиссию AMM
--+	ammFee := new(big.Float).SetUint64(amount)
--+	ammFee = ammFee.Mul(ammFee, new(big.Float).SetFloat64(float64(feeParams.AmmFee)/10000.0))
--+	ammFeeUint, _ := ammFee.Uint64()
--+	totalFee += ammFeeUint
--+
--+	// Добавляем влияние на цену, если оно есть
--+	if feeParams.PriceImpact > 0 {
--+		priceImpactFee := new(big.Float).SetUint64(amount)
--+		priceImpactFee = priceImpactFee.Mul(priceImpactFee, new(big.Float).SetFloat64(float64(feeParams.PriceImpact)/10000.0))
--+		priceImpactFeeUint, _ := priceImpactFee.Uint64()
--+		totalFee += priceImpactFeeUint
--+	}
--+
--+	// Проверяем, не превышает ли общая комиссия максимальную
--+	if totalFee > feeParams.MaxFee {
--+		return feeParams.MaxFee
--+	}
--+
--+	return totalFee
--+}
--+
--+// Вспомогательная функция для получения состояния lookup table
--+func GetAddressLookupTableState(
--+	ctx context.Context,
--+	client blockchain.Client,
--+	tableAddress solana.PublicKey,
--+) (*addresslookuptable.AddressLookupTableState, error) {
--+	// Получаем RPC клиент из blockchain.Client
--+	rpcClient := client.GetRpcClient()
--+
--+	// Получаем состояние lookup table
--+	state, err := addresslookuptable.GetAddressLookupTable(
--+		ctx,
--+		rpcClient,
--+		tableAddress,
--+	)
--+	if err != nil {
--+		return nil, fmt.Errorf("failed to get lookup table state: %w", err)
--+	}
--+
--+	return state, nil
--+}
--+
--+// Вспомогательная функция для подготовки lookup tables к транзакции
--+func PrepareLookupTables(
--+	ctx context.Context,
--+	client blockchain.Client,
--+	tableAddresses []solana.PublicKey,
--+) (map[solana.PublicKey]solana.PublicKeySlice, error) {
--+	lookupTables := make(map[solana.PublicKey]solana.PublicKeySlice)
--+
--+	for _, tableAddr := range tableAddresses {
--+		state, err := GetAddressLookupTableState(ctx, client, tableAddr)
--+		if err != nil {
--+			return nil, fmt.Errorf("failed to prepare lookup table %s: %w", tableAddr, err)
--+		}
--+
--+		lookupTables[tableAddr] = state.Addresses
--+	}
--+
--+	return lookupTables, nil
-- }
--diff --git a/internal/eventlistener/listener.go b/internal/eventlistener/listener.go
--index a63190c..1aca89b 100644
----- a/internal/eventlistener/listener.go
--+++ b/internal/eventlistener/listener.go
--@@ -1,3 +1,4 @@
--+// internal/eventlistener/listener.go
-- package eventlistener
-- 
-- import (
--diff --git a/internal/eventlistener/types.go b/internal/eventlistener/types.go
--index 62f1192..13fac2d 100644
----- a/internal/eventlistener/types.go
--+++ b/internal/eventlistener/types.go
--@@ -1,3 +1,4 @@
--+// internal/eventlistener/types.go
-- package eventlistener
-- 
-- import (
--diff --git a/newdif.txt b/newdif.txt
--index c94e4d6..67d0314 100644
----- a/newdif.txt
--+++ b/newdif.txt
--@@ -1,5243 +0,0 @@
---diff --git a/internal/dex/raydium/instruction.go b/internal/dex/raydium/instruction.go
---index ffb819e..f8f7886 100644
------ a/internal/dex/raydium/instruction.go
---+++ b/internal/dex/raydium/instruction.go
---@@ -508,7 +508,7 @@ func (b *SwapInstructionBuilder) BuildVersionedSwapInstruction(
--- 	ctx context.Context,
--- 	params SwapParams,
--- 	accounts SwapInstructionAccounts,
----) (*solana.VersionedTransaction, error) {
---+) (*solana.Transaction, error) {
--- 	logger := b.logger.With(
--- 		zap.String("user", accounts.UserAuthority.String()),
--- 		zap.Uint64("amount_in", params.AmountIn),
---@@ -522,32 +522,35 @@ func (b *SwapInstructionBuilder) BuildVersionedSwapInstruction(
--- 		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
--- 	}
--- 
----	// Создаем message для транзакции
----	message := solana.NewMessage(
----		solana.MessageV0, // используем версию 0 для версионированных транзакций
----		[]solana.Instruction{instruction},
----		accounts.UserAuthority, // fee payer
----	)
---+	// Создаем новый транзакционный билдер
---+	tx := solana.NewTransactionBuilder()
---+
---+	// Добавляем instruction
---+	tx.AddInstruction(instruction)
--- 
----	// Если есть lookup table, добавляем её
---+	// Устанавливаем fee payer
---+	tx.SetFeePayer(accounts.UserAuthority)
---+
---+	// Если у нас есть lookup table, добавляем её через TransactionAddressTables option
--- 	if !b.pool.LookupTableID.IsZero() {
----		addressLookupTable := &solana.MessageAddressTableLookup{
----			AccountKey:      b.pool.LookupTableID,
----			WritableIndexes: []uint8{}, // заполнить необходимыми индексами
----			ReadonlyIndexes: []uint8{}, // заполнить необходимыми индексами
----		}
----		message.AddressTableLookups = append(message.AddressTableLookups, addressLookupTable)
---+		// Создаем мапу с адресами для lookup table
---+		addressTables := make(map[solana.PublicKey]solana.PublicKeySlice)
---+
---+		// Получаем адреса lookup table из пула и добавляем их в мапу
---+		addressTables[b.pool.LookupTableID] = b.pool.LookupTableAddresses
---+
---+		// Добавляем опцию с address tables
---+		tx.WithOpt(solana.TransactionAddressTables(addressTables))
--- 	}
--- 
----	// Создаем версионированную транзакцию
----	tx := &solana.VersionedTransaction{
----		Message:    message,
----		Signatures: make([]solana.Signature, message.Header.NumRequiredSignatures),
---+	// Строим транзакцию
---+	transaction, err := tx.Build()
---+	if err != nil {
---+		return nil, fmt.Errorf("failed to build transaction: %w", err)
--- 	}
--- 
--- 	logger.Debug("Versioned swap transaction built successfully")
----
----	return tx, nil
---+	return transaction, nil
--- }
--- 
--- // DepositInstructionAccounts аккаунты, необходимые для депозита
---diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
---index 2851f20..2dcdd64 100644
------ a/internal/dex/raydium/pool.go
---+++ b/internal/dex/raydium/pool.go
---@@ -8,6 +8,7 @@ import (
--- 	"math/big"
--- 
--- 	"github.com/gagliardetto/solana-go"
---+	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
--- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
--- 	"go.uber.org/zap"
--- )
---@@ -26,7 +27,46 @@ func NewPoolManager(client blockchain.Client, logger *zap.Logger) *PoolManager {
--- 	}
--- }
--- 
----// InitializePool создает новый пул с заданными параметрами
---+// Добавляем метод для загрузки состояния lookup table в PoolManager
---+func (pm *PoolManager) LoadPoolLookupTable(
---+	ctx context.Context,
---+	pool *RaydiumPool,
---+) error {
---+	if pool.LookupTableID.IsZero() {
---+		return nil
---+	}
---+
---+	logger := pm.logger.With(
---+		zap.String("lookup_table_id", pool.LookupTableID.String()),
---+	)
---+	logger.Debug("Loading lookup table")
---+
---+	// Загружаем состояние lookup table
---+	rpcClient := pm.client.GetRpcClient()
---+	lookupTable, err := addresslookuptable.GetAddressLookupTable(
---+		ctx,
---+		rpcClient,
---+		pool.LookupTableID,
---+	)
---+	if err != nil {
---+		return &PoolError{
---+			Stage:   "load_lookup_table",
---+			Message: "failed to load lookup table",
---+			Err:     err,
---+		}
---+	}
---+
---+	// Сохраняем адреса
---+	pool.LookupTableAddresses = lookupTable.Addresses
---+
---+	logger.Debug("Lookup table loaded successfully",
---+		zap.Int("addresses_count", len(pool.LookupTableAddresses)),
---+	)
---+
---+	return nil
---+}
---+
---+// Модифицируем существующий метод инициализации пула
--- func (pm *PoolManager) InitializePool(ctx context.Context, params *RaydiumPool) error {
--- 	logger := pm.logger.With(
--- 		zap.String("base_mint", params.BaseMint.String()),
---@@ -42,6 +82,11 @@ func (pm *PoolManager) InitializePool(ctx context.Context, params *RaydiumPool)
--- 		}
--- 	}
--- 
---+	// Добавляем загрузку lookup table после валидации параметров
---+	if err := pm.LoadPoolLookupTable(ctx, params); err != nil {
---+		return err
---+	}
---+
--- 	return nil
--- }
--- 
---@@ -216,6 +261,14 @@ func (pm *PoolManager) validatePoolParameters(pool *RaydiumPool) error {
--- 		return fmt.Errorf("invalid market parameters")
--- 	}
--- 
---+	// Если указан lookup table ID, проверяем что он валидный
---+	if !pool.LookupTableID.IsZero() {
---+		// Проверка существования lookup table будет выполнена при загрузке
---+		logger := pm.logger.With(
---+			zap.String("lookup_table_id", pool.LookupTableID.String()),
---+		)
---+		logger.Debug("Pool has lookup table configuration")
---+	}
--- 	return nil
--- }
--- 
---diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
---index a2965fa..6100e4c 100644
------ a/internal/dex/raydium/types.go
---+++ b/internal/dex/raydium/types.go
---@@ -78,7 +78,10 @@ type RaydiumPool struct {
--- 	MarketAsks       solana.PublicKey
--- 	MarketEventQueue solana.PublicKey
--- 	MarketVersion    uint8
----	LookupTableID    solana.PublicKey
---+
---+	// Lookup Table конфигурация
---+	LookupTableID        solana.PublicKey
---+	LookupTableAddresses solana.PublicKeySlice // добавляем это поле
--- 
--- 	// Версионирование и инструкции
--- 	Version              uint8
---diff --git a/internal/dex/raydium/utils.go b/internal/dex/raydium/utils.go
---index 9739bad..104cc1d 100644
------ a/internal/dex/raydium/utils.go
---+++ b/internal/dex/raydium/utils.go
---@@ -311,12 +311,14 @@ func ConvertBigFloatToUint64(value *big.Float) (uint64, error) {
--- }
--- 
--- // Утилиты для версионированных транзакций
---+// TODO: Implement the method logic
--- func CreateVersionedTransaction(instructions []solana.Instruction, lookupTables []solana.AddressLookupTable) (*solana.VersionedTransaction, error) {
--- 	// Создаем транзакцию
--- 	return nil, nil
--- }
--- 
--- // Утилиты для работы с новыми комиссиями
---+// TODO: Implement the method logic
--- func CalculateV5Fees(amount uint64, feeParams V5FeeParams) uint64 {
--- 	return 0
--- }
---diff --git a/newdif.txt b/newdif.txt
---index 94ec35e..dd1019e 100644
------ a/newdif.txt
---+++ b/newdif.txt
---@@ -1,5048 +0,0 @@
----diff --git a/internal/blockchain/solbc/solana.go b/internal/blockchain/solbc/solana.go
----index b764d85..dec574a 100644
------- a/internal/blockchain/solbc/solana.go
----+++ b/internal/blockchain/solbc/solana.go
----@@ -1,10 +1,13 @@
-----// internal/blockchain/solbc/solana.go:
----+// internal/blockchain/solbc/solana.go
---- package solbc
---- 
---- import (
---- 	"context"
---- 	"fmt"
---- 
----+	solanarpc "github.com/gagliardetto/solana-go/rpc"
----+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
----+
---- 	"github.com/gagliardetto/solana-go"
---- 	"go.uber.org/zap"
---- )
----@@ -54,3 +57,25 @@ func (s *Blockchain) GetRecentBlockhash(ctx context.Context) (solana.Hash, error
---- 	}
---- 	return hash, nil
---- }
----+
----+// SimulateTransaction simulates a transaction on the Solana blockchain
----+func (c *Client) SimulateTransaction(tx string) (string, error) {
----+	// Implement the method logic here
----+	return "", nil
----+}
----+
----+func (c *Client) GetRpcClient() *solanarpc.Client {
----+	if c.adapter == nil {
----+		c.adapter = NewRpcAdapter(c.rpc)
----+	}
----+	return c.adapter
----+}
----+
----+// RpcAdapter адаптирует наш RPCClient к интерфейсу solana-go/rpc.Client
----+type RpcAdapter struct {
----+	client *rpc.RPCClient
----+}
----+
----+func NewRpcAdapter(client *rpc.RPCClient) *solanarpc.Client {
----+	return solanarpc.New("") // Создаем пустой клиент
----+}
----diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
----index 42debad..b3e342d 100644
------- a/internal/blockchain/solbc/types.go
----+++ b/internal/blockchain/solbc/types.go
----@@ -7,6 +7,7 @@ import (
---- 
---- 	"go.uber.org/zap"
---- 
----+	solanarpc "github.com/gagliardetto/solana-go/rpc"
---- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
---- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
---- )
----@@ -20,6 +21,7 @@ type TokenMetadataCache struct {
---- // Client представляет основной клиент Solana
---- type Client struct {
---- 	rpc     *rpc.RPCClient
----+	adapter *solanarpc.Client
---- 	logger  *zap.Logger
---- 	metrics *ClientMetrics
---- }
----diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
----index 03c15ac..45d076b 100644
------- a/internal/blockchain/types.go
----+++ b/internal/blockchain/types.go
----@@ -3,6 +3,7 @@ package blockchain
---- 
---- import (
---- 	"context"
----+	"encoding/base64"
---- 
---- 	"github.com/gagliardetto/solana-go"
---- 	"github.com/gagliardetto/solana-go/rpc"
----@@ -14,6 +15,30 @@ type TransactionOptions struct {
---- 	PreflightCommitment rpc.CommitmentType
---- }
---- 
----+// SimulationResult представляет результат симуляции транзакции
----+// Обновляем структуру SimulationResult
----+type SimulationResult struct {
----+	Err           interface{}
----+	Logs          []string
----+	UnitsConsumed uint64
----+	ReturnData    *Base64Data
----+}
----+
----+// Base64Data представляет данные в формате Base64
----+type Base64Data struct {
----+	Data string
----+}
----+
----+// EncodeBase64 кодирует данные в Base64
----+func (b *Base64Data) EncodeBase64(data []byte) {
----+	b.Data = base64.StdEncoding.EncodeToString(data)
----+}
----+
----+// DecodeBase64 декодирует данные из Base64
----+func (b *Base64Data) DecodeBase64() ([]byte, error) {
----+	return base64.StdEncoding.DecodeString(b.Data)
----+}
----+
---- // Client определяет общий интерфейс для клиентов блокчейна
---- type Client interface {
---- 	GetRecentBlockhash(ctx context.Context) (solana.Hash, error)
----@@ -21,4 +46,6 @@ type Client interface {
---- 	GetAccountInfo(ctx context.Context, pubkey solana.PublicKey) (*rpc.GetAccountInfoResult, error)
---- 	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
---- 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
----+	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
----+	GetRpcClient() *rpc.Client
---- }
----diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
----index e7de9a0..eafb611 100644
------- a/internal/dex/raydium/client.go
----+++ b/internal/dex/raydium/client.go
----@@ -12,9 +12,8 @@ import (
---- 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
---- 	"github.com/gagliardetto/solana-go/rpc"
---- 	"github.com/gagliardetto/solana-go/rpc/jsonrpc"
-----	"go.uber.org/zap"
-----
---- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
----+	"go.uber.org/zap"
---- )
---- 
---- const (
----@@ -217,7 +216,8 @@ func (c *RaydiumClient) CreateSwapInstructions(ctx context.Context, params SwapP
---- 
---- // SimulateSwap симулирует выполнение свапа
---- func (c *RaydiumClient) SimulateSwap(ctx context.Context, instructions []solana.Instruction) error {
-----	logger := c.logger.Debug("Simulating swap transaction")
----+	logger := c.logger.With(zap.String("method", "SimulateSwap"))
----+	logger.Debug("Starting swap simulation")
---- 
---- 	recent, err := c.client.GetRecentBlockhash(ctx)
---- 	if err != nil {
----@@ -246,15 +246,16 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, instructions []solana.
---- 		}
---- 	}
---- 
-----	if simulation.Value.Err != nil {
----+	if simulation.Err != nil {
---- 		return &SwapError{
---- 			Stage:   "simulate_swap",
-----			Message: fmt.Sprintf("simulation returned error: %v", simulation.Value.Err),
----+			Message: fmt.Sprintf("simulation returned error: %v", simulation.Err),
---- 		}
---- 	}
---- 
---- 	logger.Debug("Swap simulation successful",
-----		zap.Uint64("compute_units_used", simulation.Value.UnitsConsumed))
----+		zap.Uint64("compute_units_used", simulation.UnitsConsumed),
----+		zap.Strings("logs", simulation.Logs))
---- 
---- 	return nil
---- }
----@@ -294,15 +295,112 @@ func (c *RaydiumClient) GetAmountOut(pool *RaydiumPool, state *PoolState, amount
---- 
---- // createSwapInstruction создает инструкцию свапа
---- func (c *RaydiumClient) createSwapInstruction(params SwapParams) (solana.Instruction, error) {
-----	// ... реализация создания инструкции свапа
-----	// Этот метод будет реализован в следующей части
-----	return nil, nil
----+	// Проверяем входные параметры
----+	if params.Pool == nil {
----+		return nil, &SwapError{
----+			Stage:   "create_swap_instruction",
----+			Message: "pool is required",
----+		}
----+	}
----+
----+	// Создаем слайс аккаунтов для инструкции
----+	accounts := make(solana.AccountMetaSlice, 0)
----+
----+	// Добавляем основные аккаунты
----+	accounts = append(accounts,
----+		// Token Program ID
----+		solana.Meta(solana.TokenProgramID),
----+		// AMM Program ID
----+		solana.Meta(params.Pool.AmmProgramID),
----+		// User wallet (signer)
----+		solana.Meta(params.UserWallet).SIGNER(),
----+		// Pool ID
----+		solana.Meta(params.Pool.ID),
----+		// Pool Authority
----+		solana.Meta(params.Pool.Authority),
----+		// Source token account
----+		solana.Meta(params.SourceTokenAccount).WRITE(),
----+		// Destination token account
----+		solana.Meta(params.DestinationTokenAccount).WRITE(),
----+		// Pool base vault
----+		solana.Meta(params.Pool.BaseVault).WRITE(),
----+		// Pool quote vault
----+		solana.Meta(params.Pool.QuoteVault).WRITE(),
----+	)
----+
----+	// Создаем данные инструкции
----+	data := make([]byte, 9)
----+	// Команда swap (предположим, что это 1)
----+	data[0] = 1
----+	// Записываем AmountIn (8 байт, little endian)
----+	binary.LittleEndian.PutUint64(data[1:], params.AmountIn)
----+
----+	// Создаем инструкцию
----+	instruction := solana.NewInstruction(
----+		params.Pool.AmmProgramID,
----+		accounts,
----+		data,
----+	)
----+
----+	return instruction, nil
---- }
---- 
---- // decodePoolData декодирует данные аккаунта пула
---- func (c *RaydiumClient) decodePoolData(data []byte, pool *RaydiumPool) error {
-----	// ... реализация декодирования данных пула
-----	// Этот метод будет реализован в следующей части
----+	if len(data) < PoolDataSize {
----+		return &SwapError{
----+			Stage:   "decode_pool_data",
----+			Message: fmt.Sprintf("invalid data length: got %d, want at least %d", len(data), PoolDataSize),
----+		}
----+	}
----+
----+	// Декодируем данные пула используя binary.LittleEndian
----+	// Предполагаем следующую структуру данных:
----+	offset := 0
----+
----+	// Status (1 byte)
----+	pool.Status = data[offset]
----+	offset += 1
----+
----+	// Nonce (1 byte)
----+	pool.Nonce = data[offset]
----+	offset += 1
----+
----+	// AMM Program ID (32 bytes)
----+	copy(pool.AmmProgramID[:], data[offset:offset+32])
----+	offset += 32
----+
----+	// Authority (32 bytes)
----+	copy(pool.Authority[:], data[offset:offset+32])
----+	offset += 32
----+
----+	// Base Vault (32 bytes)
----+	copy(pool.BaseVault[:], data[offset:offset+32])
----+	offset += 32
----+
----+	// Quote Vault (32 bytes)
----+	copy(pool.QuoteVault[:], data[offset:offset+32])
----+	offset += 32
----+
----+	// Base Mint (32 bytes)
----+	copy(pool.BaseMint[:], data[offset:offset+32])
----+	offset += 32
----+
----+	// Quote Mint (32 bytes)
----+	copy(pool.QuoteMint[:], data[offset:offset+32])
----+	offset += 32
----+
----+	// Base Reserve (8 bytes)
----+	pool.BaseReserve = binary.LittleEndian.Uint64(data[offset : offset+8])
----+	offset += 8
----+
----+	// Quote Reserve (8 bytes)
----+	pool.QuoteReserve = binary.LittleEndian.Uint64(data[offset : offset+8])
----+	offset += 8
----+
----+	// Fee Rate (8 bytes)
----+	pool.FeeRate = binary.LittleEndian.Uint64(data[offset : offset+8])
----+
---- 	return nil
---- }
---- 
----@@ -334,13 +432,14 @@ func (c *RaydiumClient) CreateVersionedSwapInstructions(
---- 
---- 	// Создаем базовое сообщение
---- 	message := &solana.Message{
----+
---- 		AccountKeys: []solana.PublicKey{params.UserWallet}, // Начинаем с основного кошелька
---- 		Header: solana.MessageHeader{
---- 			NumRequiredSignatures:       1, // Минимум одна подпись от кошелька
---- 			NumReadonlySignedAccounts:   0,
---- 			NumReadonlyUnsignedAccounts: 0,
---- 		},
-----		RecentBlockhash: recent.Value.Blockhash,
----+		RecentBlockhash: recent,
---- 		Instructions:    make([]solana.CompiledInstruction, 0),
---- 	}
---- 
----@@ -361,8 +460,15 @@ func (c *RaydiumClient) CreateVersionedSwapInstructions(
---- 	for _, instruction := range instructions {
---- 		compiledIx := solana.CompiledInstruction{
---- 			ProgramIDIndex: uint16(len(message.AccountKeys)), // Индекс программы
-----			Data:           instruction.Data(),
-----			Accounts:       make([]uint16, len(instruction.Accounts())),
----+			Data: func() []byte {
----+				data, err := instruction.Data()
----+				if err != nil {
----+					logger.Error("failed to get instruction data", zap.Error(err))
----+					return nil
----+				}
----+				return data
----+			}(),
----+			Accounts: make([]uint16, len(instruction.Accounts())),
---- 		}
---- 
---- 		// Добавляем ProgramID в список аккаунтов, если его там еще нет
----@@ -427,10 +533,13 @@ func (c *RaydiumClient) GetPoolLookupTable(
---- 		return nil, fmt.Errorf("failed to derive lookup table address: %w", err)
---- 	}
---- 
-----	// Получаем данные таблицы
----+	// Получаем RPC клиент через GetRpcClient
----+	rpcClient := c.client.GetRpcClient()
----+
----+	// Получаем данные таблицы с помощью RPC клиента
---- 	lookupTable, err := addresslookuptable.GetAddressLookupTable(
---- 		ctx,
-----		c.client,
----+		rpcClient,
---- 		lookupTableAddr,
---- 	)
---- 	if err != nil {
----@@ -450,7 +559,6 @@ func (c *RaydiumClient) GetPoolLookupTable(
---- 		return nil, nil
---- 	}
---- 
-----	// Проверяем наличие необходимых адресов
---- 	requiredAddresses := []solana.PublicKey{
---- 		pool.ID,
---- 		pool.Authority,
----@@ -461,7 +569,6 @@ func (c *RaydiumClient) GetPoolLookupTable(
---- 		pool.MarketQuoteVault,
---- 	}
---- 
-----	// Проверяем, что все необходимые адреса есть в таблице
---- 	for _, addr := range requiredAddresses {
---- 		found := false
---- 		for _, tableAddr := range lookupTable.Addresses {
----diff --git a/internal/dex/raydium/instruction.go b/internal/dex/raydium/instruction.go
----index 6b75182..ffb819e 100644
------- a/internal/dex/raydium/instruction.go
----+++ b/internal/dex/raydium/instruction.go
----@@ -206,33 +206,160 @@ func (b *SwapInstructionBuilder) serializeInstructionData(params SwapParams) ([]
---- 	return data, nil
---- }
---- 
----+// Добавим новые параметры для инициализации пула
----+type InitializePoolParams struct {
----+	Nonce           uint8
----+	InitialLPSupply uint64
----+	UserAuthority   solana.PublicKey
----+}
----+
----+// Добавим параметры для депозита
----+type DepositParams struct {
----+	MaxBaseAmount  uint64
----+	MaxQuoteAmount uint64
----+	UserAuthority  solana.PublicKey
----+}
----+
---- // BuildInitializePoolInstruction создает инструкцию инициализации пула
---- func (b *SwapInstructionBuilder) BuildInitializePoolInstruction(
---- 	ctx context.Context,
-----	nonce uint8,
-----	initialLPSupply uint64,
----+	params InitializePoolParams,
---- ) (solana.Instruction, error) {
-----	// ... реализация создания инструкции инициализации пула
-----	return nil, nil
----+	logger := b.logger.With(
----+		zap.Uint8("nonce", params.Nonce),
----+		zap.Uint64("initial_lp_supply", params.InitialLPSupply),
----+		zap.String("user_authority", params.UserAuthority.String()),
----+	)
----+	logger.Debug("Building initialize pool instruction")
----+
----+	// Находим пользовательский LP токен аккаунт
----+	userLPAccount, _, err := solana.FindAssociatedTokenAddress(
----+		params.UserAuthority,
----+		b.pool.LPMint,
----+	)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to find user LP token account: %w", err)
----+	}
----+
----+	// Сериализуем данные инструкции
----+	data := make([]byte, 10) // 1 (тип) + 1 (nonce) + 8 (initialLPSupply)
----+	data[0] = byte(InstructionTypeInitialize)
----+	data[1] = params.Nonce
----+	binary.LittleEndian.PutUint64(data[2:], params.InitialLPSupply)
----+
----+	// Создаем список необходимых аккаунтов
----+	accountMetas := solana.AccountMetaSlice{
----+		solana.NewAccountMeta(b.pool.ID, true, false),                // AMM ID
----+		solana.NewAccountMeta(b.pool.Authority, true, false),         // AMM Authority
----+		solana.NewAccountMeta(b.pool.BaseVault, true, false),         // Base Token Vault
----+		solana.NewAccountMeta(b.pool.QuoteVault, true, false),        // Quote Token Vault
----+		solana.NewAccountMeta(b.pool.LPMint, true, false),            // LP Token Mint
----+		solana.NewAccountMeta(userLPAccount, true, false),            // User LP Token Account
----+		solana.NewAccountMeta(params.UserAuthority, true, true),      // User Authority (signer)
----+		solana.NewAccountMeta(solana.TokenProgramID, false, false),   // Token Program
----+		solana.NewAccountMeta(solana.SysVarRentPubkey, false, false), // Rent Sysvar
----+	}
----+
----+	return solana.NewInstruction(
----+		b.pool.AmmProgramID,
----+		accountMetas,
----+		data,
----+	), nil
---- }
---- 
---- // BuildDepositInstruction создает инструкцию депозита в пул
---- func (b *SwapInstructionBuilder) BuildDepositInstruction(
---- 	ctx context.Context,
-----	maxBaseAmount uint64,
-----	maxQuoteAmount uint64,
----+	params DepositParams,
---- ) (solana.Instruction, error) {
-----	// ... реализация создания инструкции депозита
-----	return nil, nil
----+	logger := b.logger.With(
----+		zap.Uint64("max_base_amount", params.MaxBaseAmount),
----+		zap.Uint64("max_quote_amount", params.MaxQuoteAmount),
----+		zap.String("user_authority", params.UserAuthority.String()),
----+	)
----+	logger.Debug("Building deposit instruction")
----+
----+	// Находим пользовательские токен аккаунты
----+	userBaseAccount, _, err := solana.FindAssociatedTokenAddress(
----+		params.UserAuthority,
----+		b.pool.BaseMint,
----+	)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to find user base token account: %w", err)
----+	}
----+
----+	userQuoteAccount, _, err := solana.FindAssociatedTokenAddress(
----+		params.UserAuthority,
----+		b.pool.QuoteMint,
----+	)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to find user quote token account: %w", err)
----+	}
----+
----+	userLPAccount, _, err := solana.FindAssociatedTokenAddress(
----+		params.UserAuthority,
----+		b.pool.LPMint,
----+	)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to find user LP token account: %w", err)
----+	}
----+
----+	// Сериализуем данные инструкции
----+	data := make([]byte, 17) // 1 (тип) + 8 (maxBaseAmount) + 8 (maxQuoteAmount)
----+	data[0] = byte(InstructionTypeDeposit)
----+	binary.LittleEndian.PutUint64(data[1:9], params.MaxBaseAmount)
----+	binary.LittleEndian.PutUint64(data[9:17], params.MaxQuoteAmount)
----+
----+	// Создаем список необходимых аккаунтов
----+	accountMetas := solana.AccountMetaSlice{
----+		solana.NewAccountMeta(b.pool.ID, true, false),              // AMM ID
----+		solana.NewAccountMeta(b.pool.Authority, false, false),      // AMM Authority
----+		solana.NewAccountMeta(b.pool.BaseVault, true, false),       // Base Token Vault
----+		solana.NewAccountMeta(b.pool.QuoteVault, true, false),      // Quote Token Vault
----+		solana.NewAccountMeta(b.pool.LPMint, true, false),          // LP Token Mint
----+		solana.NewAccountMeta(userBaseAccount, true, false),        // User Base Token Account
----+		solana.NewAccountMeta(userQuoteAccount, true, false),       // User Quote Token Account
----+		solana.NewAccountMeta(userLPAccount, true, false),          // User LP Token Account
----+		solana.NewAccountMeta(params.UserAuthority, true, true),    // User Authority (signer)
----+		solana.NewAccountMeta(solana.TokenProgramID, false, false), // Token Program
----+	}
----+
----+	// Добавим проверку существования аккаунтов
----+	if err := b.validateDepositAccounts(ctx, userBaseAccount, userQuoteAccount, userLPAccount); err != nil {
----+		return nil, fmt.Errorf("invalid accounts: %w", err)
----+	}
----+
----+	return solana.NewInstruction(
----+		b.pool.AmmProgramID,
----+		accountMetas,
----+		data,
----+	), nil
---- }
---- 
-----// BuildWithdrawInstruction создает инструкцию вывода из пула
-----func (b *SwapInstructionBuilder) BuildWithdrawInstruction(
----+// validateDepositAccounts проверяет существование необходимых аккаунтов
----+func (b *SwapInstructionBuilder) validateDepositAccounts(
---- 	ctx context.Context,
-----	lpAmount uint64,
-----) (solana.Instruction, error) {
-----	// ... реализация создания инструкции вывода
-----	return nil, nil
----+	userBaseAccount,
----+	userQuoteAccount,
----+	userLPAccount solana.PublicKey,
----+) error {
----+	for _, check := range []struct {
----+		account solana.PublicKey
----+		name    string
----+	}{
----+		{userBaseAccount, "user base token"},
----+		{userQuoteAccount, "user quote token"},
----+		{userLPAccount, "user LP token"},
----+	} {
----+		info, err := b.client.GetAccountInfo(ctx, check.account)
----+		if err != nil {
----+			return fmt.Errorf("failed to get %s account info: %w", check.name, err)
----+		}
----+		if info.Value == nil || !info.Value.Owner.Equals(solana.TokenProgramID) {
----+			return fmt.Errorf("invalid %s account", check.name)
----+		}
----+	}
----+	return nil
---- }
---- 
---- // GetRequiredAccounts собирает все необходимые аккаунты для свапа
----@@ -277,22 +404,166 @@ func (b *SwapInstructionBuilder) GetRequiredAccounts(
---- 	return accounts, nil
---- }
---- 
----+// Параметры для вывода из пула
----+type WithdrawParams struct {
----+	LPAmount      uint64
----+	UserAuthority solana.PublicKey
----+}
----+
----+// BuildWithdrawInstruction создает инструкцию вывода из пула
----+func (b *SwapInstructionBuilder) BuildWithdrawInstruction(
----+	ctx context.Context,
----+	params WithdrawParams,
----+) (solana.Instruction, error) {
----+	logger := b.logger.With(
----+		zap.Uint64("lp_amount", params.LPAmount),
----+		zap.String("user_authority", params.UserAuthority.String()),
----+	)
----+	logger.Debug("Building withdraw instruction")
----+
----+	// Находим пользовательские токен аккаунты
----+	userBaseAccount, _, err := solana.FindAssociatedTokenAddress(
----+		params.UserAuthority,
----+		b.pool.BaseMint,
----+	)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to find user base token account: %w", err)
----+	}
----+
----+	userQuoteAccount, _, err := solana.FindAssociatedTokenAddress(
----+		params.UserAuthority,
----+		b.pool.QuoteMint,
----+	)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to find user quote token account: %w", err)
----+	}
----+
----+	userLPAccount, _, err := solana.FindAssociatedTokenAddress(
----+		params.UserAuthority,
----+		b.pool.LPMint,
----+	)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to find user LP token account: %w", err)
----+	}
----+
----+	// Сериализуем данные инструкции
----+	data := make([]byte, 9) // 1 (тип) + 8 (lpAmount)
----+	data[0] = byte(InstructionTypeWithdraw)
----+	binary.LittleEndian.PutUint64(data[1:], params.LPAmount)
----+
----+	// Создаем список необходимых аккаунтов
----+	accountMetas := solana.AccountMetaSlice{
----+		solana.NewAccountMeta(b.pool.ID, true, false),              // AMM ID
----+		solana.NewAccountMeta(b.pool.Authority, false, false),      // AMM Authority
----+		solana.NewAccountMeta(b.pool.BaseVault, true, false),       // Base Token Vault
----+		solana.NewAccountMeta(b.pool.QuoteVault, true, false),      // Quote Token Vault
----+		solana.NewAccountMeta(b.pool.LPMint, true, false),          // LP Token Mint
----+		solana.NewAccountMeta(userBaseAccount, true, false),        // User Base Token Account
----+		solana.NewAccountMeta(userQuoteAccount, true, false),       // User Quote Token Account
----+		solana.NewAccountMeta(userLPAccount, true, false),          // User LP Token Account
----+		solana.NewAccountMeta(params.UserAuthority, true, true),    // User Authority (signer)
----+		solana.NewAccountMeta(solana.TokenProgramID, false, false), // Token Program
----+	}
----+
----+	// Проверяем существование аккаунтов
----+	if err := b.validateWithdrawAccounts(ctx, userBaseAccount, userQuoteAccount, userLPAccount); err != nil {
----+		return nil, fmt.Errorf("invalid accounts: %w", err)
----+	}
----+
----+	return solana.NewInstruction(
----+		b.pool.AmmProgramID,
----+		accountMetas,
----+		data,
----+	), nil
----+}
----+
----+// validateWithdrawAccounts проверяет существование необходимых аккаунтов
----+func (b *SwapInstructionBuilder) validateWithdrawAccounts(
----+	ctx context.Context,
----+	userBaseAccount,
----+	userQuoteAccount,
----+	userLPAccount solana.PublicKey,
----+) error {
----+	for _, check := range []struct {
----+		account solana.PublicKey
----+		name    string
----+	}{
----+		{userBaseAccount, "user base token"},
----+		{userQuoteAccount, "user quote token"},
----+		{userLPAccount, "user LP token"},
----+	} {
----+		info, err := b.client.GetAccountInfo(ctx, check.account)
----+		if err != nil {
----+			return fmt.Errorf("failed to get %s account info: %w", check.name, err)
----+		}
----+		if info.Value == nil || !info.Value.Owner.Equals(solana.TokenProgramID) {
----+			return fmt.Errorf("invalid %s account", check.name)
----+		}
----+	}
----+	return nil
----+}
----+
---- // BuildVersionedSwapInstruction создает версионированную инструкцию свапа
---- func (b *SwapInstructionBuilder) BuildVersionedSwapInstruction(
---- 	ctx context.Context,
---- 	params SwapParams,
---- 	accounts SwapInstructionAccounts,
---- ) (*solana.VersionedTransaction, error) {
-----	// ... реализация создания версионированной инструкции свапа
-----	return nil, nil
----+	logger := b.logger.With(
----+		zap.String("user", accounts.UserAuthority.String()),
----+		zap.Uint64("amount_in", params.AmountIn),
----+		zap.Uint64("min_amount_out", params.MinAmountOut),
----+	)
----+	logger.Debug("Building versioned swap instruction")
----+
----+	// Создаем базовую инструкцию свапа
----+	instruction, err := b.BuildSwapInstruction(ctx, params, accounts)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
----+	}
----+
----+	// Создаем message для транзакции
----+	message := solana.NewMessage(
----+		solana.MessageV0, // используем версию 0 для версионированных транзакций
----+		[]solana.Instruction{instruction},
----+		accounts.UserAuthority, // fee payer
----+	)
----+
----+	// Если есть lookup table, добавляем её
----+	if !b.pool.LookupTableID.IsZero() {
----+		addressLookupTable := &solana.MessageAddressTableLookup{
----+			AccountKey:      b.pool.LookupTableID,
----+			WritableIndexes: []uint8{}, // заполнить необходимыми индексами
----+			ReadonlyIndexes: []uint8{}, // заполнить необходимыми индексами
----+		}
----+		message.AddressTableLookups = append(message.AddressTableLookups, addressLookupTable)
----+	}
----+
----+	// Создаем версионированную транзакцию
----+	tx := &solana.VersionedTransaction{
----+		Message:    message,
----+		Signatures: make([]solana.Signature, message.Header.NumRequiredSignatures),
----+	}
----+
----+	logger.Debug("Versioned swap transaction built successfully")
----+
----+	return tx, nil
---- }
---- 
-----// BuildDepositInstruction создает инструкцию депозита
-----func (b *SwapInstructionBuilder) BuildDepositInstruction(
-----	ctx context.Context,
-----	params DepositParams,
-----	accounts DepositInstructionAccounts,
-----) (solana.Instruction, error) {
-----	// ... реализация создания инструкции депозита
-----	return nil, nil
----+// DepositInstructionAccounts аккаунты, необходимые для депозита
----+type DepositInstructionAccounts struct {
----+	// Пользовательские аккаунты
----+	UserAuthority  solana.PublicKey // Аккаунт пользователя, который делает депозит
----+	UserBaseToken  solana.PublicKey // Аккаунт base токенов пользователя
----+	UserQuoteToken solana.PublicKey // Аккаунт quote токенов пользователя
----+	UserLPToken    solana.PublicKey // Аккаунт LP токенов пользователя
----+
----+	// Аккаунты пула
----+	AmmId           solana.PublicKey // ID пула
----+	AmmAuthority    solana.PublicKey // Authority пула
----+	AmmOpenOrders   solana.PublicKey // OpenOrders аккаунт пула
----+	AmmTargetOrders solana.PublicKey // TargetOrders аккаунт пула
----+	LPMint          solana.PublicKey // Минт LP токенов
----+	PoolBaseVault   solana.PublicKey // Vault для base токенов пула
----+	PoolQuoteVault  solana.PublicKey // Vault для quote токенов пула
---- }
----diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
----index e6d2983..2851f20 100644
------- a/internal/dex/raydium/pool.go
----+++ b/internal/dex/raydium/pool.go
----@@ -47,15 +47,17 @@ func (pm *PoolManager) InitializePool(ctx context.Context, params *RaydiumPool)
---- 
---- // PoolCalculator предоставляет методы для расчетов в пуле
---- type PoolCalculator struct {
-----	pool  *RaydiumPool
-----	state *PoolState
----+	pool   *RaydiumPool
----+	state  *PoolState
----+	logger *zap.Logger // Добавляем logger в структуру
---- }
---- 
---- // NewPoolCalculator создает новый калькулятор для пула
-----func NewPoolCalculator(pool *RaydiumPool, state *PoolState) *PoolCalculator {
----+func NewPoolCalculator(pool *RaydiumPool, state *PoolState, logger *zap.Logger) *PoolCalculator {
---- 	return &PoolCalculator{
-----		pool:  pool,
-----		state: state,
----+		pool:   pool,
----+		state:  state,
----+		logger: logger.Named("pool-calculator"), // Добавляем префикс для логгера
---- 	}
---- }
---- 
----@@ -83,26 +85,24 @@ func (pc *PoolCalculator) CalculateSwapAmount(
---- 
---- 	var amountOut *big.Float
---- 	if side == SwapSideIn {
-----		// dx * y / (x + dx)
---- 		numerator := new(big.Float).Mul(amountInAfterFee, quoteReserveF)
---- 		denominator := new(big.Float).Add(baseReserveF, amountInAfterFee)
---- 		amountOut = new(big.Float).Quo(numerator, denominator)
---- 	} else {
-----		// dx * y / (x + dx)
---- 		numerator := new(big.Float).Mul(amountInAfterFee, baseReserveF)
---- 		denominator := new(big.Float).Add(quoteReserveF, amountInAfterFee)
---- 		amountOut = new(big.Float).Quo(numerator, denominator)
---- 	}
---- 
-----	// Конвертируем результат обратно в uint64
-----	var amountOutU uint64
-----	amountOut.Uint64(&amountOutU)
----+	// Исправляем конвертацию в uint64
----+	amountOutU, _ := amountOut.Uint64()
---- 
---- 	// Учитываем слиппаж для минимального выхода
---- 	slippageMultiplier := new(big.Float).SetFloat64(1 - float64(slippageBps)/10000)
---- 	minAmountOut := new(big.Float).Mul(new(big.Float).SetUint64(amountOutU), slippageMultiplier)
-----	var minAmountOutU uint64
-----	minAmountOut.Uint64(&minAmountOutU)
----+
----+	// Исправляем конвертацию в uint64
----+	minAmountOutU, _ := minAmountOut.Uint64()
---- 
---- 	return &SwapAmounts{
---- 		AmountIn:     amountIn,
----@@ -140,14 +140,15 @@ func (pc *PoolCalculator) GetOptimalSwapAmount(
---- 	targetAmount uint64,
---- 	slippageBps uint16,
---- ) (*SwapAmounts, error) {
-----	logger := pm.logger.With(
----+	// Исправляем pm на pc.pool, так как мы находимся в методе PoolCalculator
----+	logger := pc.logger.With(
---- 		zap.Uint64("available_amount", availableAmount),
---- 		zap.Uint64("target_amount", targetAmount),
---- 		zap.Uint16("slippage_bps", slippageBps),
---- 	)
---- 	logger.Debug("Calculating optimal swap amount")
---- 
-----	// Используем бинарный поиск для нахождения оптимального количества
----+	// Остальной код остается без изменений
---- 	left := uint64(1)
---- 	right := availableAmount
---- 	var bestAmount *SwapAmounts
----@@ -271,6 +272,17 @@ func (pc *PoolCalculator) GetMarketPrice() float64 {
---- 	return (quoteF / quoteDecimalAdj) / (baseF / baseDecimalAdj)
---- }
---- 
----+// Добавить в pool.go:
----+type RaydiumV5Pool struct {
----+	RaydiumPool
----+	PnlOwner    solana.PublicKey
----+	ModelDataId solana.PublicKey
----+	RecentRoot  *big.Int
----+	MaxOrders   uint64
----+	OrderStates []*big.Int
----+	TickSpacing uint16
----+}
----+
---- // Методы для работы с v5 пулами
---- func (pm *PoolManager) InitializeV5Pool(ctx context.Context, params *RaydiumPoolV5) error {
---- 	// TODO: implement
----diff --git a/internal/dex/raydium/state.go b/internal/dex/raydium/state.go
----index 49dd70a..cff0664 100644
------- a/internal/dex/raydium/state.go
----+++ b/internal/dex/raydium/state.go
----@@ -6,7 +6,6 @@ import (
---- 	"fmt"
---- 	"math"
---- 
-----	"github.com/gagliardetto/binary"
---- 	"github.com/gagliardetto/solana-go"
---- 	"go.uber.org/zap"
---- )
----@@ -294,16 +293,101 @@ func (d *StateDecoder) CalculateVirtualPrice(layout *Layout) (float64, error) {
---- 	return 2 * sqrtK / lpAdjusted, nil
---- }
---- 
-----// Декодер для v5 состояния
----+// LayoutV5 расширяет базовую структуру Layout дополнительными полями для v5
----+type LayoutV5 struct {
----+	Layout                       // Встраиваем базовый Layout
----+	PnlOwner    solana.PublicKey // Владелец PnL
----+	ModelDataId solana.PublicKey // ID модели данных
----+	PnlPool     solana.PublicKey // Пул PnL
----+}
----+
----+// DecodeV5State декодирует бинарные данные в структуру состояния версии 5
---- func (d *StateDecoder) DecodeV5State(data []byte) (*LayoutV5, error) {
-----	// ... реализация декодирования v5 состояния
-----	// Этот метод будет реализован в следующей части
-----	return nil, nil
----+	logger := d.logger.With(zap.Int("data_length", len(data)))
----+	logger.Debug("Starting v5 state decoding")
----+
----+	// Сначала декодируем базовую структуру
----+	baseLayout, err := d.DecodeState(data)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to decode base layout: %w", err)
----+	}
----+
----+	// Проверяем версию
----+	if baseLayout.Version != uint8(StateV5) {
----+		return nil, fmt.Errorf("invalid version for V5 decode: %d", baseLayout.Version)
----+	}
----+
----+	// Создаем V5 структуру
----+	layout := &LayoutV5{
----+		Layout: *baseLayout,
----+	}
----+
----+	// Вычисляем смещение для дополнительных полей V5
----+	offset := d.GetStateSize(StateV4)
----+
----+	// Проверяем достаточно ли данных для V5 полей
----+	if len(data) < int(d.GetStateSize(StateV5)) {
----+		return nil, fmt.Errorf("insufficient data for V5 layout: got %d, need %d",
----+			len(data), d.GetStateSize(StateV5))
----+	}
----+
----+	// Читаем дополнительные поля V5
----+	copy(layout.PnlOwner[:], data[offset:offset+32])
----+	offset += 32
----+
----+	copy(layout.ModelDataId[:], data[offset:offset+32])
----+	offset += 32
----+
----+	copy(layout.PnlPool[:], data[offset:offset+32])
----+
----+	logger.Debug("V5 state decoded successfully",
----+		zap.Stringer("pnl_owner", layout.PnlOwner),
----+		zap.Stringer("model_data_id", layout.ModelDataId),
----+		zap.Stringer("pnl_pool", layout.PnlPool))
----+
----+	return layout, nil
---- }
---- 
-----// Методы миграции
----+// MigrateState выполняет миграцию состояния между версиями
---- func (d *StateDecoder) MigrateState(oldState *Layout, newVersion StateVersion) (*Layout, error) {
-----	// ... реализация миграции состояния
-----	// Этот метод будет реализован в следующей части
-----	return nil, nil
----+	if oldState == nil {
----+		return nil, fmt.Errorf("old state is nil")
----+	}
----+
----+	// Проверяем корректность текущей версии
----+	currentVersion := StateVersion(oldState.Version)
----+	if currentVersion != StateV4 && currentVersion != StateV5 {
----+		return nil, fmt.Errorf("unsupported current version: %d", currentVersion)
----+	}
----+
----+	// Проверяем поддерживается ли миграция на новую версию
----+	if newVersion != StateV4 && newVersion != StateV5 {
----+		return nil, fmt.Errorf("unsupported target version: %d", newVersion)
----+	}
----+
----+	// Если версии совпадают, возвращаем копию старого состояния
----+	if currentVersion == newVersion {
----+		newState := *oldState
----+		return &newState, nil
----+	}
----+
----+	// Миграция с V4 на V5
----+	if currentVersion == StateV4 && newVersion == StateV5 {
----+		// При миграции с V4 на V5 мы просто копируем базовые поля
----+		// и инициализируем новые поля нулевыми значениями
----+		newState := *oldState
----+		newState.Version = uint8(StateV5)
----+		return &newState, nil
----+	}
----+
----+	// Миграция с V5 на V4
----+	if currentVersion == StateV5 && newVersion == StateV4 {
----+		// При миграции с V5 на V4 мы просто копируем базовые поля
----+		newState := *oldState
----+		newState.Version = uint8(StateV4)
----+		return &newState, nil
----+	}
----+
----+	return nil, fmt.Errorf("unsupported migration path: %d -> %d",
----+		currentVersion, newVersion)
---- }
----diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
----index ef19a7a..a2965fa 100644
------- a/internal/dex/raydium/types.go
----+++ b/internal/dex/raydium/types.go
----@@ -5,8 +5,10 @@ package raydium
---- import (
---- 	"context"
---- 	"fmt"
----+	"math/big"
---- 
---- 	"github.com/gagliardetto/solana-go"
----+	"go.uber.org/zap"
---- )
---- 
---- // Layout константы для правильного чтения данных из аккаунта пула
----@@ -28,6 +30,20 @@ const (
---- 	MinimumAmountOut      = 1
---- )
---- 
----+const (
----+	PoolDataSize = 217 // Минимальный размер данных пула
----+
----+	LayoutAmmProgramID = 2
----+	LayoutAuthority    = 34
----+	LayoutBaseVault    = 66
----+	LayoutQuoteVault   = 98
----+	LayoutBaseMint     = 130
----+	LayoutQuoteMint    = 162
----+	LayoutBaseReserve  = 194
----+	LayoutQuoteReserve = 202
----+	LayoutFeeRate      = 210
----+)
----+
---- // RaydiumPool представляет собой конфигурацию пула ликвидности Raydium
---- type RaydiumPool struct {
---- 	// Программы
----@@ -69,6 +85,34 @@ type RaydiumPool struct {
---- 	SwapInstructionIndex uint8
---- 	DefaultMinimumOutBps uint16 // базовых пунктов (1 bps = 0.01%)
---- 	DefaultFeeBps        uint16 // комиссия пула в базовых пунктах
----+
----+	// Статус пула
----+	Status uint8
----+	Nonce  uint8
----+
----+	BaseReserve  uint64
----+	QuoteReserve uint64
----+	FeeRate      uint64
----+}
----+
----+// Добавить в types.go:
----+type LiquidityState struct {
----+	Status      uint8
----+	Nonce       uint8
----+	MaxOrder    *big.Int         // Используется для ограничения размера ордера
----+	DepthBPS    uint64           // Глубина пула в базисных пунктах
----+	PnLOwner    solana.PublicKey // Владелец PnL
----+	ModelDataId solana.PublicKey // ID модели данных
----+	RecentRoot  *big.Int         // Последний корень для верификации
----+	OrderBook   OrderBookState
----+}
----+
----+type OrderBookState struct {
----+	Bids       solana.PublicKey
----+	Asks       solana.PublicKey
----+	EventQueue solana.PublicKey
----+	BaseVault  solana.PublicKey
----+	QuoteVault solana.PublicKey
---- }
---- 
---- // PoolState содержит динамическое состояние пула
----@@ -99,6 +143,11 @@ type SwapParams struct {
---- 	WritableIndexes     []uint8           // Индексы для writable аккаунтов в lookup table
---- 	ReadonlyIndexes     []uint8           // Индексы для readonly аккаунтов в lookup table
---- 	Pool                *RaydiumPool      // Информация о пуле
----+	Logger              *zap.Logger       // Добавляем поле logger
----+
----+	// Аккаунты для свапа
----+	SourceTokenAccount      solana.PublicKey
----+	DestinationTokenAccount solana.PublicKey
---- }
---- 
---- // Client представляет интерфейс для взаимодействия с Raydium DEX
----diff --git a/internal/dex/raydium/utils.go b/internal/dex/raydium/utils.go
----index b8f7378..9739bad 100644
------- a/internal/dex/raydium/utils.go
----+++ b/internal/dex/raydium/utils.go
----@@ -2,6 +2,7 @@
---- package raydium
---- 
---- import (
----+	"bytes"
---- 	"context"
---- 	"encoding/binary"
---- 	"fmt"
----@@ -152,7 +153,6 @@ func FindAssociatedTokenAddress(
---- 			owner, // payer
---- 			ata,   // ata
---- 			owner, // owner
-----			mint,  // mint
---- 		).Build()
---- 
---- 		instructions = append(instructions, createATAInst)
----@@ -271,7 +271,7 @@ func ValidateTokenAccount(
---- 	}
---- 
---- 	var tokenAccount token.Account
-----	if err := binary.NewDecoder(info.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
----+	if err := binary.Read(bytes.NewReader(info.Value.Data.GetBinary()), binary.LittleEndian, &tokenAccount); err != nil {
---- 		return fmt.Errorf("failed to decode token account: %w", err)
---- 	}
---- 
----diff --git a/newdif.txt b/newdif.txt
----index 2431b7e..949f2f1 100644
------- a/newdif.txt
----+++ b/newdif.txt
----@@ -1,4014 +0,0 @@
-----diff --git a/TODOata.md b/TODOata.md
-----deleted file mode 100644
-----index daa131d..0000000
-------- a/TODOata.md
-----+++ /dev/null
-----@@ -1,69 +0,0 @@
------
------## Оптимизация работы с ATA (Associated Token Accounts)
------
------### 1. Этап подготовки и архитектуры
------
------- [ ] Создать отдельный сервис для управления ATA
------- [ ] Спроектировать интерфейс сервиса
------- [ ] Определить методы и основные операции
------- [ ] Разработать схему кэширования
------- [ ] Определить стратегии обработки ошибок
------
------- [ ] Разработать систему предварительной инициализации
------- [ ] Создать механизм проверки необходимых ATA
------      - [ ] Внедрить процесс предварительного создания ATA
------- [ ] Добавить валидацию состояния ATA
------
------### 2. Оптимизация RPC взаимодействия
------
------- [ ] Улучшить работу с RPC запросами
------- [ ] Внедрить batch-запросы для множественных проверок
------- [ ] Оптимизировать частоту запросов
------- [ ] Настроить умные повторные попытки
------
------- [ ] Создать систему кэширования
------- [ ] Реализовать локальный кэш ATA состояний
------  - [ ] Настроить TTL для кэша
------  - [ ] Добавить механизм инвалидации кэша
------
------### 3. Мониторинг и логирование
------
------- [ ] Внедрить расширенное логирование
------  - [ ] Добавить детальные логи для каждой операции с ATA
------  - [ ] Логировать времена выполнения операций
------  - [ ] Отслеживать ошибки и их причины
------
------- [ ] Настроить метрики
------  - [ ] Время создания ATA
------  - [ ] Количество успешных/неуспешных операций
------  - [ ] Использование кэша
------  - [ ] Задержки RPC
------
------- [ ] Создать систему алертов
------  - [ ] Настроить оповещения о критических ошибках
------  - [ ] Мониторить аномалии в работе
------  - [ ] Отслеживать деградацию производительности
------
------### 4. Обработка ошибок
------
------- [ ] Улучшить систему обработки ошибок
------  - [ ] Создать специфические коды ошибок
------  - [ ] Внедрить механизм автоматического восстановления
------  - [ ] Добавить логику повторных попыток
------
------- [ ] Разработать стратегии восстановления
------  - [ ] Определить сценарии восстановления
------  - [ ] Внедрить автоматическое исправление ошибок
------  - [ ] Добавить механизм откатов
------
------### 5. Производительность
------
------- [ ] Оптимизировать работу с ATA
------  - [ ] Внедрить параллельную обработку запросов
------  - [ ] Оптимизировать использование памяти
------  - [ ] Улучшить время отклика
------
------- [ ] Настроить пулы и очереди
------  - [ ] Создать пул предварительно инициализированных ATA
------  - [ ] Настроить очередь для операций создания
------  - [ ] Оптимизировать управление ресурсами
-----diff --git a/go.mod b/go.mod
-----index 6c586dc..6b29758 100644
-------- a/go.mod
-----+++ b/go.mod
-----@@ -10,7 +10,7 @@ require (
----- 	github.com/google/uuid v1.6.0
----- 	github.com/mr-tron/base58 v1.2.0
----- 	github.com/prometheus/client_golang v1.20.5
------	github.com/sirupsen/logrus v1.9.3
-----+	github.com/shopspring/decimal v1.3.1
----- 	github.com/spf13/viper v1.19.0
----- 	go.uber.org/zap v1.27.0
----- 	gopkg.in/natefinch/lumberjack.v2 v2.2.1
-----diff --git a/go.sum b/go.sum
-----index 6a9097a..21aa3cc 100644
-------- a/go.sum
-----+++ b/go.sum
-----@@ -141,8 +141,6 @@ github.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6g
----- github.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=
----- github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8=
----- github.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=
------github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
------github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
----- github.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=
----- github.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=
----- github.com/spf13/afero v1.11.0 h1:WJQKhtpdm3v2IzqG8VMqrr6Rf3UYpEF239Jy9wNepM8=
-----@@ -235,7 +233,6 @@ golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7w
----- golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
----- golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
----- golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
------golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
----- golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
----- golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
----- golang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=
-----diff --git a/internal/dex/raydium/config.go b/internal/dex/raydium/config.go
-----deleted file mode 100644
-----index fab480a..0000000
-------- a/internal/dex/raydium/config.go
-----+++ /dev/null
-----@@ -1,31 +0,0 @@
------// internal/dex/raydium/config.go
------package raydium
------
------// DefaultPoolConfig с обновленным типом для RaydiumSwapInstructionCode
------var DefaultPoolConfig = &Pool{
------	// Программы
------	AmmProgramID:   "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8", // ✅ Подтверждено
------	SerumProgramID: "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX",  // ✅ Подтверждено
------
------	// AMM конфигурация
------	AmmID:           "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", // ✅ Подтверждено
------	AmmAuthority:    "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1", // ✅ Обновлено (authority)
------	AmmOpenOrders:   "HmiHHzq4Fym9e1D4qzLS6LDDM3tNsCTBPDWHTLZ763jY", // ✅ Обновлено (openOrders)
------	AmmTargetOrders: "CZza3Ej4Mc58MnxWA385itCC9jCo3L1D7zc3LKy1bZMR", // ✅ Обновлено (targetOrders)
------
------	// Token Accounts
------	PoolCoinTokenAccount: "DQyrAcCrDXQ7NeoqGgDCZwBvWDcYmFCjSb9JtteuvPpz", // ✅ Обновлено (baseVault)
------	PoolPcTokenAccount:   "HLmqeL62xR1QoZ1HKKbXRrdN1p3phKpxRMb2VVopvBBz", // ✅ Обновлено (quoteVault)
------
------	// Serum Market
------	SerumMarket:           "8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6", // ✅ Подтверждено
------	SerumBids:             "5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh", // ✅ Подтверждено
------	SerumAsks:             "EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCLNBEDXDn1d5", // ✅ Обновлено
------	SerumEventQueue:       "8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa", // ✅ Подтверждено
------	SerumCoinVaultAccount: "CKxTHwM9fPMRRvZmFnFoqKNd9pQR21c5Aq9bh5h9oghX", // ✅ Обновлено (marketBaseVault)
------	SerumPcVaultAccount:   "6A5NHCj1yF6urc9wZNe6Bcjj4LVszQNj5DwAWG97yzMu", // ✅ Обновлено (marketQuoteVault)
------	SerumVaultSigner:      "CTz5UMLQm2SRWHzQnU62Pi4yJqbNGjgRBHqqp6oDHfF7", // ✅ Обновлено (marketAuthority)
------
------	// Дополнительные параметры
------	RaydiumSwapInstructionCode: 1, // ✅ Не изменилось
------}
-----diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
-----deleted file mode 100644
-----index c684b6e..0000000
-------- a/internal/dex/raydium/raydium.go
-----+++ /dev/null
-----@@ -1,927 +0,0 @@
------// internal/dex/raydium/raydium.go
------
------package raydium
------
------import (
------	"context"
------	"encoding/binary"
------	"fmt"
------	"math"
------	"time"
------
------	bin "github.com/gagliardetto/binary"
------	"github.com/gagliardetto/solana-go"
------	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
------	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
------	"github.com/gagliardetto/solana-go/programs/token"
------
------	solanarpc "github.com/gagliardetto/solana-go/rpc"
------	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
------	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
------	"github.com/rovshanmuradov/solana-bot/internal/types"
------	"github.com/rovshanmuradov/solana-bot/internal/wallet"
------	"go.uber.org/zap"
------)
------
------const (
------	defaultTimeout  = 10 * time.Second
------	maxRetries      = 3
------	retryDelay      = 500 * time.Millisecond
------	ataCheckTimeout = 5 * time.Second
------	txSendTimeout   = 15 * time.Second
------)
------
------// Добавляем новые типы для работы с ценами
------type PriceValidator interface {
------	ValidatePrice(poolPrice float64) error
------	GetMaxDeviation() float64
------}
------
------// Обновляем структуру PoolState
------
------// Добавляем базовую реализацию валидатора цен
------type BasicPriceValidator struct {
------	basePrice    float64
------	maxDeviation float64
------	logger       *zap.Logger
------}
------
------func NewBasicPriceValidator(basePrice float64, maxDeviation float64, logger *zap.Logger) *BasicPriceValidator {
------	return &BasicPriceValidator{
------		basePrice:    basePrice,
------		maxDeviation: maxDeviation,
------		logger:       logger,
------	}
------}
------
------func (v *BasicPriceValidator) ValidatePrice(poolPrice float64) error {
------	if v.basePrice <= 0 {
------		// Если базовая цена не установлена, пропускаем валидацию
------		return nil
------	}
------
------	deviation := math.Abs(poolPrice-v.basePrice) / v.basePrice
------	if deviation > v.maxDeviation {
------		return fmt.Errorf("pool price deviation too high: %.2f%% (pool: %.2f, base: %.2f)",
------			deviation*100, poolPrice, v.basePrice)
------	}
------
------	return nil
------}
------
------func (v *BasicPriceValidator) GetMaxDeviation() float64 {
------	return v.maxDeviation
------}
------
------// NewDEX создает новый экземпляр DEX
------func NewDEX(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) *DEX {
------	if err := validateDEXParams(client, logger, poolInfo); err != nil {
------		logger.Error("Failed to create DEX", zap.Error(err))
------		return nil
------	}
------
------	priceValidator := NewBasicPriceValidator(
------		181.0, // Базовая цена SOL/USDC
------		0.5,   // 50% максимальное отклонение
------		logger,
------	)
------
------	dex := &DEX{
------		client:         client,
------		logger:         logger.Named("raydium-dex"),
------		poolInfo:       poolInfo,
------		tokenCache:     solbc.NewTokenMetadataCache(logger),
------		priceValidator: priceValidator,
------	}
------
------	// Инициализируем atomic.Value
------	dex.lastPoolState.Store((*PoolState)(nil))
------
------	return dex
------}
------
------func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wallet.Wallet) error {
------	opCtx, cancel := context.WithTimeout(ctx, defaultTimeout)
------	defer cancel()
------
------	r.slippage = task.SlippageConfig.Value
------
------	logger := r.logger.With(
------		zap.String("task", task.TaskName),
------		zap.String("wallet", userWallet.PublicKey.String()),
------		zap.String("slippage_type", string(task.SlippageConfig.Type)),
------		zap.Float64("slippage_value", task.SlippageConfig.Value),
------	)
------	logger.Info("Starting swap execution")
------
------	// Parse token addresses
------	sourceMint, targetMint, err := parseTokenAddresses(task.SourceToken, task.TargetToken)
------	if err != nil {
------		return fmt.Errorf("invalid token addresses: %w", err)
------	}
------
------	ataCtx, ataCancel := context.WithTimeout(opCtx, ataCheckTimeout)
------	defer ataCancel()
------
------	// Setup token accounts
------	sourceATA, targetATA, err := r.setupTokenAccounts(ataCtx, userWallet, sourceMint, targetMint, logger)
------	if err != nil {
------		return fmt.Errorf("failed to setup token accounts: %w", err)
------	}
------
------	// Prepare amount with decimals
------	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
------
------	logger.Debug("Prepared swap amount",
------		zap.Uint64("amount_in", amountIn),
------		zap.String("slippage_type", string(task.SlippageConfig.Type)),
------		zap.Float64("slippage_value", task.SlippageConfig.Value),
------	)
------
------	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
------	defer swapCancel()
------
------	// Prepare swap instructions
------	instructions, err := r.PrepareSwapInstructions(
------		swapCtx,
------		userWallet.PublicKey,
------		sourceATA,
------		targetATA,
------		amountIn,
------		task.PriorityFee,
------		logger,
------	)
------	if err != nil {
------		return fmt.Errorf("failed to prepare swap instructions: %w", err)
------	}
------
------	// Send transaction
------	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
------	if err != nil {
------		return fmt.Errorf("failed to send swap transaction: %w", err)
------	}
------
------	logger.Info("Swap transaction sent successfully",
------		zap.String("signature", signature.String()),
------		zap.Float64("priority_fee", task.PriorityFee))
------
------	return nil
------}
------
------func (r *DEX) setupTokenAccounts(
------	ctx context.Context,
------	wallet *wallet.Wallet,
------	sourceMint, targetMint solana.PublicKey,
------	logger *zap.Logger,
------) (solana.PublicKey, solana.PublicKey, error) {
------	sourceATA, _, err := solana.FindAssociatedTokenAddress(wallet.PublicKey, sourceMint)
------	if err != nil {
------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("failed to find source ATA: %w", err)
------	}
------
------	targetATA, _, err := solana.FindAssociatedTokenAddress(wallet.PublicKey, targetMint)
------	if err != nil {
------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("failed to find target ATA: %w", err)
------	}
------
------	// Проверяем и создаем ATA если необходимо
------	if err := r.ensureATA(ctx, wallet, sourceMint, sourceATA, "source", logger); err != nil {
------		return solana.PublicKey{}, solana.PublicKey{}, err
------	}
------
------	if err := r.ensureATA(ctx, wallet, targetMint, targetATA, "target", logger); err != nil {
------		return solana.PublicKey{}, solana.PublicKey{}, err
------	}
------
------	return sourceATA, targetATA, nil
------}
------
------func (r *DEX) ensureATA(
------	ctx context.Context,
------	wallet *wallet.Wallet,
------	mint, ata solana.PublicKey,
------	ataType string,
------	logger *zap.Logger,
------) error {
------	logger = logger.With(
------		zap.String("mint", mint.String()),
------		zap.String("ata", ata.String()),
------		zap.String("wallet", wallet.PublicKey.String()),
------	)
------
------	// Проверяем существование ATA с повторными попытками
------	exists, err := r.checkATAExists(ctx, ata, logger)
------	if err != nil {
------		return fmt.Errorf("failed to check %s ATA: %w", ataType, err)
------	}
------
------	if !exists {
------		logger.Debug("Creating new ATA")
------		// Используем правильное создание инструкции из solana-go
------		instruction, err := r.createATAInstruction(wallet, mint)
------		if err != nil {
------			return fmt.Errorf("failed to create %s ATA instruction: %w", ataType, err)
------		}
------
------		// Отправляем транзакцию и ждем подтверждения
------		signature, err := r.sendTransactionWithRetryAndConfirmation(ctx, wallet, []solana.Instruction{instruction}, logger)
------		if err != nil {
------			return fmt.Errorf("failed to create %s ATA: %w", ataType, err)
------		}
------
------		logger.Info("ATA created successfully",
------			zap.String("signature", signature.String()))
------
------		// Ждем появления аккаунта
------		if err := r.waitForATACreation(ctx, ata, logger); err != nil {
------			return fmt.Errorf("failed to confirm %s ATA creation: %w", ataType, err)
------		}
------	}
------
------	return nil
------}
------
------func (r *DEX) checkATAExists(
------	ctx context.Context,
------	ata solana.PublicKey,
------	logger *zap.Logger,
------) (bool, error) {
------	for attempt := 0; attempt < maxRetries; attempt++ {
------		account, err := r.client.GetAccountInfo(ctx, ata)
------		if err == nil && account.Value != nil {
------			// Проверяем, что владелец - TokenProgram
------			return account.Value.Owner == solana.TokenProgramID, nil
------		}
------
------		if attempt < maxRetries-1 {
------			select {
------			case <-ctx.Done():
------				return false, ctx.Err()
------			case <-time.After(retryDelay):
------				logger.Debug("Retrying ATA check", zap.Int("attempt", attempt+1))
------			}
------		}
------	}
------	return false, nil
------}
------
------func (r *DEX) createATAInstruction(
------	wallet *wallet.Wallet,
------	mint solana.PublicKey,
------) (solana.Instruction, error) {
------	// Используем билдер из solana-go
------	inst := associatedtokenaccount.NewCreateInstruction(
------		wallet.PublicKey, // payer
------		wallet.PublicKey, // wallet address
------		mint,             // token mint
------	)
------
------	// Проводим валидацию
------	if err := inst.Validate(); err != nil {
------		return nil, fmt.Errorf("invalid ATA instruction: %w", err)
------	}
------
------	return inst.Build(), nil
------}
------
------func (r *DEX) waitForATACreation(
------	ctx context.Context,
------	ata solana.PublicKey,
------	logger *zap.Logger,
------) error {
------	// Увеличиваем время ожидания до 2 минут
------	deadline := time.Now().Add(2 * time.Minute)
------	// Начальный интервал проверки
------	ticker := time.NewTicker(2 * time.Second)
------	defer ticker.Stop()
------
------	retryCount := 0
------	maxRetries := 60 // Максимальное количество попыток
------
------	for {
------		if time.Now().After(deadline) {
------			return fmt.Errorf("timeout waiting for ATA creation after 2 minutes")
------		}
------
------		if retryCount >= maxRetries {
------			return fmt.Errorf("exceeded maximum retry attempts (%d) waiting for ATA creation", maxRetries)
------		}
------
------		select {
------		case <-ctx.Done():
------			return ctx.Err()
------		case <-ticker.C:
------			account, err := r.client.GetAccountInfo(ctx, ata)
------			if err != nil {
------				logger.Debug("ATA verification attempt failed",
------					zap.Error(err),
------					zap.Int("retry", retryCount),
------					zap.Time("deadline", deadline))
------				retryCount++
------				continue
------			}
------
------			if account.Value != nil && account.Value.Owner == solana.TokenProgramID {
------				logger.Info("ATA creation confirmed",
------					zap.String("ata", ata.String()),
------					zap.Int("retries", retryCount))
------				return nil
------			}
------
------			logger.Debug("ATA not ready yet",
------				zap.String("ata", ata.String()),
------				zap.Int("retry", retryCount))
------			retryCount++
------		}
------	}
------}
------
------// PrepareSwapInstructions объединяет все инструкции для свапа
------func (r *DEX) PrepareSwapInstructions(
------	ctx context.Context,
------	wallet solana.PublicKey,
------	sourceATA solana.PublicKey,
------	targetATA solana.PublicKey,
------	amountIn uint64,
------	priorityFee float64,
------	logger *zap.Logger,
------) ([]solana.Instruction, error) {
------	var instructions []solana.Instruction
------
------	// Добавляем compute budget инструкции
------	computeBudgetInst := computebudget.NewSetComputeUnitPriceInstruction(
------		uint64(priorityFee * 1e6),
------	).Build()
------	instructions = append(instructions, computeBudgetInst)
------
------	// Создаем базовую инструкцию свапа
------	swapInst, err := r.PrepareSwapInstruction(
------		ctx,
------		wallet,
------		sourceATA,
------		targetATA,
------		amountIn,
------		logger,
------	)
------	if err != nil {
------		return nil, fmt.Errorf("failed to prepare swap instruction: %w", err)
------	}
------	instructions = append(instructions, swapInst)
------
------	return instructions, nil
------}
------
------// PrepareSwapInstruction подготавливает базовую инструкцию свапа
------func (r *DEX) PrepareSwapInstruction(
------	ctx context.Context,
------	wallet solana.PublicKey,
------	sourceATA solana.PublicKey,
------	targetATA solana.PublicKey,
------	amountIn uint64,
------	logger *zap.Logger,
------) (solana.Instruction, error) {
------	logger = logger.With(
------		zap.String("wallet", wallet.String()),
------		zap.String("source_ata", sourceATA.String()),
------		zap.String("target_ata", targetATA.String()),
------	)
------	logger.Debug("Preparing swap instruction")
------
------	// Получаем ожидаемый выход
------	sourceMint, err := r.getMintFromATA(ctx, sourceATA)
------	if err != nil {
------		return nil, fmt.Errorf("failed to get source mint: %w", err)
------	}
------
------	targetMint, err := r.getMintFromATA(ctx, targetATA)
------	if err != nil {
------		return nil, fmt.Errorf("failed to get target mint: %w", err)
------	}
------
------	expectedOut, err := r.getExpectedOutput(
------		ctx,
------		amountIn,
------		sourceMint,
------		targetMint,
------		r.poolInfo,
------		logger,
------	)
------	if err != nil {
------		return nil, fmt.Errorf("failed to get expected output: %w", err)
------	}
------
------	// Используем slippage из структуры DEX
------	minAmountOut := calculateMinimumOut(expectedOut, r.slippage)
------
------	return r.createSwapInstruction(
------		wallet,
------		sourceATA,
------		targetATA,
------		amountIn,
------		minAmountOut,
------		logger,
------		r.poolInfo,
------	)
------}
------
------// createSwapInstruction внутренний метод для создания инструкции свапа
------func (r *DEX) createSwapInstruction(
------	wallet solana.PublicKey,
------	sourceATA solana.PublicKey,
------	targetATA solana.PublicKey,
------	amountIn uint64,
------	minAmountOut uint64,
------	logger *zap.Logger,
------	poolInfo *Pool,
------) (solana.Instruction, error) {
------	// Существующая логика из CreateSwapInstruction
------	return r.CreateSwapInstruction(
------		wallet,
------		sourceATA,
------		targetATA,
------		amountIn,
------		minAmountOut,
------		logger,
------		poolInfo,
------	)
------}
------
------// Вспомогательный метод для получения mint address из ATA
------func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.PublicKey, error) {
------	account, err := r.client.GetAccountInfo(ctx, ata)
------	if err != nil {
------		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
------	}
------
------	if account.Value == nil || len(account.Value.Data.GetBinary()) < 64 {
------		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
------	}
------
------	var tokenAccount token.Account
------	if err := bin.NewBinDecoder(account.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
------		return solana.PublicKey{}, fmt.Errorf("failed to decode ATA data: %w", err)
------	}
------
------	return tokenAccount.Mint, nil
------}
------
------func (r *DEX) sendTransactionWithRetryAndConfirmation(
------	ctx context.Context,
------	wallet *wallet.Wallet,
------	instructions []solana.Instruction,
------	logger *zap.Logger,
------) (solana.Signature, error) {
------	const (
------		maxRetries          = 3
------		sendTimeout         = 15 * time.Second
------		confirmationTimeout = 60 * time.Second
------	)
------
------	var lastErr error
------	for attempt := 0; attempt < maxRetries; attempt++ {
------		select {
------		case <-ctx.Done():
------			return solana.Signature{}, ctx.Err()
------		default:
------			// Создаем контекст с таймаутом для отправки
------			sendCtx, cancel := context.WithTimeout(ctx, sendTimeout)
------			signature, err := r.sendTransaction(sendCtx, wallet, instructions)
------			cancel()
------
------			if err != nil {
------				lastErr = err
------				logger.Warn("Retrying transaction send",
------					zap.Int("attempt", attempt+1),
------					zap.Error(err))
------				time.Sleep(time.Second * time.Duration(attempt+1))
------				continue
------			}
------
------			// Создаем отдельный контекст для подтверждения
------			confirmCtx, cancel := context.WithTimeout(ctx, confirmationTimeout)
------			defer cancel()
------
------			// Ждем подтверждения с периодическими проверками
------			ticker := time.NewTicker(time.Second)
------			defer ticker.Stop()
------
------			for {
------				select {
------				case <-confirmCtx.Done():
------					return signature, fmt.Errorf("confirmation timeout exceeded: %v", confirmCtx.Err())
------				case <-ticker.C:
------					status, err := r.getTransactionStatus(ctx, signature)
------					if err != nil {
------						logger.Debug("Failed to get transaction status",
------							zap.Error(err),
------							zap.String("signature", signature.String()))
------						continue
------					}
------
------					// Проверяем ошибки в транзакции
------					if status.Error != "" {
------						return signature, fmt.Errorf("transaction failed: %s", status.Error)
------					}
------
------					// Проверяем подтверждение
------					if status.Confirmations >= 1 || status.Status == "finalized" {
------						logger.Debug("Transaction confirmed",
------							zap.String("signature", signature.String()),
------							zap.String("status", status.Status),
------							zap.Uint64("confirmations", status.Confirmations))
------						return signature, nil
------					}
------
------					logger.Debug("Waiting for confirmation",
------						zap.String("signature", signature.String()),
------						zap.String("status", status.Status),
------						zap.Uint64("confirmations", status.Confirmations))
------				}
------			}
------		}
------	}
------
------	return solana.Signature{}, fmt.Errorf("failed after %d attempts: %w", maxRetries, lastErr)
------}
------
------func (r *DEX) sendTransaction(
------	ctx context.Context,
------	wallet *wallet.Wallet,
------	instructions []solana.Instruction,
------) (solana.Signature, error) {
------	recent, err := r.client.GetRecentBlockhash(ctx)
------	if err != nil {
------		return solana.Signature{}, fmt.Errorf("failed to get recent blockhash: %w", err)
------	}
------
------	tx, err := solana.NewTransaction(
------		instructions,
------		recent,
------		solana.TransactionPayer(wallet.PublicKey),
------	)
------	if err != nil {
------		return solana.Signature{}, fmt.Errorf("failed to create transaction: %w", err)
------	}
------
------	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
------		if key.Equals(wallet.PublicKey) {
------			return &wallet.PrivateKey
------		}
------		return nil
------	})
------	if err != nil {
------		return solana.Signature{}, fmt.Errorf("failed to sign transaction: %w", err)
------	}
------
------	opts := blockchain.TransactionOptions{
------		SkipPreflight:       true,
------		PreflightCommitment: solanarpc.CommitmentProcessed,
------	}
------
------	signature, err := r.client.SendTransactionWithOpts(ctx, tx, opts)
------	if err != nil {
------		return solana.Signature{}, fmt.Errorf("failed to send transaction: %w", err)
------	}
------
------	return signature, nil
------}
------
------func validateDEXParams(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) error {
------	switch {
------	case client == nil:
------		return fmt.Errorf("client cannot be nil")
------	case logger == nil:
------		return fmt.Errorf("logger cannot be nil")
------	case poolInfo == nil:
------		return fmt.Errorf("pool info cannot be nil")
------	}
------	return nil
------}
------
------func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, solana.PublicKey, error) {
------	sourceMint, err := solana.PublicKeyFromBase58(sourceToken)
------	if err != nil {
------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("invalid source token: %w", err)
------	}
------
------	targetMint, err := solana.PublicKeyFromBase58(targetToken)
------	if err != nil {
------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("invalid target token: %w", err)
------	}
------
------	return sourceMint, targetMint, nil
------}
------
------// getExpectedOutput calculates the expected output for the swap
------func (r *DEX) getExpectedOutput(
------	ctx context.Context,
------	amountIn uint64,
------	sourceToken, targetToken solana.PublicKey,
------	poolInfo *Pool,
------	logger *zap.Logger,
------) (float64, error) {
------	// Get pool state
------	poolState, err := r.getPoolState(ctx, poolInfo)
------	if err != nil {
------		return 0, fmt.Errorf("failed to get pool state: %w", err)
------	}
------
------	// Get decimals for tokens
------	sourceMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, sourceToken)
------	if err != nil {
------		return 0, fmt.Errorf("failed to get source token metadata: %w", err)
------	}
------
------	targetMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, targetToken)
------	if err != nil {
------		return 0, fmt.Errorf("failed to get target token metadata: %w", err)
------	}
------
------	// Calculate expected output
------	expectedOut := r.calculateExpectedOutput(
------		amountIn,
------		int(sourceMetadata.Decimals),
------		int(targetMetadata.Decimals),
------		poolState,
------	)
------
------	// Validate calculated price against market price
------	marketPrice := 181.0 // Use current market price of SOL in USDC
------	err = validateSwapAmount(expectedOut, marketPrice, amountIn,
------		int(sourceMetadata.Decimals),
------		int(targetMetadata.Decimals))
------	if err != nil {
------		return 0, fmt.Errorf("swap amount validation failed: %w", err)
------	}
------
------	return expectedOut, nil
------}
------
------// getPoolState gets the current state of the pool
------// Скорректированные смещения для Raydium v4 пула
------const (
------	DISCRIMINATOR_SIZE = 8
------	STATUS_SIZE        = 1
------	NONCE_SIZE         = 1
------	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 bytes
------
------	// Новые смещения (в байтах)
------	baseVaultOffset    = BASE_SIZE + 96       // После discriminator + статуса + nonce + 3 pubkeys
------	quoteVaultOffset   = baseVaultOffset + 40 // После base vault + доп. данные
------	baseReserveOffset  = 178                  // Фиксированное смещение для базового резерва
------	quoteReserveOffset = 186                  // Фиксированное смещение для quote резерва
------)
------
------// Добавляем новые типы для работы с ценами
------type PriceSource interface {
------	GetCurrentPrice(ctx context.Context, base, quote solana.PublicKey) (float64, error)
------}
------
------type PoolPriceValidator struct {
------	priceSource  PriceSource
------	maxDeviation float64
------	logger       *zap.Logger
------}
------
------func NewPoolPriceValidator(priceSource PriceSource, logger *zap.Logger) *PoolPriceValidator {
------	return &PoolPriceValidator{
------		priceSource:  priceSource,
------		maxDeviation: 0.5, // 50% максимальное отклонение
------		logger:       logger,
------	}
------}
------
------// Добавляем метод для обновления валидатора цен
------func (r *DEX) SetPriceValidator(validator PriceValidator) {
------	r.priceValidator = validator
------}
------
------// internal/dex/raydium/raydium.go
------
------func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
------	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
------	if err != nil {
------		return nil, fmt.Errorf("failed to get pool account: %w", err)
------	}
------
------	if poolAccount == nil || poolAccount.Value == nil {
------		return nil, fmt.Errorf("pool account not found")
------	}
------
------	data := poolAccount.Value.Data.GetBinary()
------
------	r.logger.Debug("Full pool data",
------		zap.Binary("data", data),
------		zap.Int("length", len(data)))
------
------	if len(data) < quoteReserveOffset+8 {
------		return nil, fmt.Errorf("invalid pool data length: got %d, need at least %d",
------			len(data), quoteReserveOffset+8)
------	}
------
------	// Читаем резервы
------	baseReserve := binary.LittleEndian.Uint64(data[baseReserveOffset : baseReserveOffset+8])
------	quoteReserve := binary.LittleEndian.Uint64(data[quoteReserveOffset : quoteReserveOffset+8])
------
------	r.logger.Debug("Raw reserves",
------		zap.Uint64("base_reserve_raw", baseReserve),
------		zap.Uint64("quote_reserve_raw", quoteReserve))
------
------	// Проверяем резервы
------	if baseReserve == 0 || quoteReserve == 0 {
------		return nil, fmt.Errorf("invalid pool reserves: base=%d, quote=%d",
------			baseReserve, quoteReserve)
------	}
------
------	// Нормализуем значения с учетом decimals
------	solAmount := float64(baseReserve) / 1e9   // 9 decimals для SOL
------	usdcAmount := float64(quoteReserve) / 1e6 // 6 decimals для USDC
------
------	poolPrice := usdcAmount / solAmount
------	r.logger.Debug("Pool price calculated",
------		zap.Float64("pool_price", poolPrice),
------		zap.Float64("sol_amount", solAmount),
------		zap.Float64("usdc_amount", usdcAmount))
------
------	// Проверяем цену через валидатор
------	if r.priceValidator != nil {
------		if err := r.priceValidator.ValidatePrice(poolPrice); err != nil {
------			return nil, fmt.Errorf("pool price validation failed: %w", err)
------		}
------	}
------
------	state := &PoolState{
------		TokenAReserve: baseReserve,
------		TokenBReserve: quoteReserve,
------		SwapFee:       0.25,
------		CurrentPrice:  poolPrice,
------	}
------
------	// Сохраняем новое состояние
------	r.UpdatePoolState(state)
------
------	return state, nil
------}
------
------// Добавляем вспомогательные методы для работы с ценами
------// GetCurrentPoolPrice возвращает текущую цену пула
------func (r *DEX) GetCurrentPoolPrice() float64 {
------	if state := r.lastPoolState.Load().(*PoolState); state != nil {
------		return state.CurrentPrice
------	}
------	return 0
------}
------
------func (r *DEX) SetMaxPriceDeviation(deviation float64) {
------	if r.priceValidator != nil {
------		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
------			basicValidator.maxDeviation = deviation
------		}
------	}
------}
------
------func (r *DEX) UpdateBasePrice(price float64) {
------	if r.priceValidator != nil {
------		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
------			basicValidator.basePrice = price
------		}
------	}
------}
------
------// calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
------// calculateExpectedOutput computes the expected output based on the pool state
------func (r *DEX) calculateExpectedOutput(
------	amountIn uint64,
------	sourceDec,
------	targetDec int,
------	state *PoolState,
------) float64 {
------	logger := r.logger.With(
------		zap.Uint64("amount_in_raw", amountIn),
------		zap.Int("source_decimals", sourceDec),
------		zap.Int("target_decimals", targetDec),
------	)
------
------	// Normalize input amount
------	amountInF := float64(amountIn) / math.Pow10(sourceDec)
------	logger.Debug("Normalized input amount",
------		zap.Float64("amount_in_normalized", amountInF))
------
------	// Get normalized reserves
------	reserveIn := float64(state.TokenAReserve) / math.Pow10(sourceDec)
------	reserveOut := float64(state.TokenBReserve) / math.Pow10(targetDec)
------	logger.Debug("Normalized reserves",
------		zap.Float64("reserve_in_normalized", reserveIn),
------		zap.Float64("reserve_out_normalized", reserveOut))
------
------	// Calculate output using constant product formula
------	amountOut := (amountInF * reserveOut * (1 - state.SwapFee/100)) / (reserveIn + amountInF*(1-state.SwapFee/100))
------	logger.Debug("Calculated amount out",
------		zap.Float64("amount_out", amountOut))
------
------	// Convert back to lamports
------	finalOutput := amountOut * math.Pow10(targetDec)
------	logger.Debug("Final output in lamports",
------		zap.Float64("final_output_lamports", finalOutput))
------
------	return finalOutput
------}
------
------func validateSwapAmount(expectedOut float64, currentPrice float64, amountIn uint64, sourceDec, targetDec int) error {
------	// Normalize values
------	realAmountIn := float64(amountIn) / math.Pow10(sourceDec)
------	realExpectedOut := expectedOut / math.Pow10(targetDec)
------
------	// Calculate the swap price
------	calculatedPrice := realExpectedOut / realAmountIn
------
------	// Calculate price difference percentage
------	priceDiff := math.Abs(calculatedPrice-currentPrice) / currentPrice
------
------	// Allow up to 20% difference
------	if priceDiff > 0.2 {
------		return fmt.Errorf("calculated price differs too much from current price: %.2f vs %.2f",
------			calculatedPrice, currentPrice)
------	}
------
------	return nil
------}
------
------// GetAmountOutQuote получает котировку для свапа
------func (r *DEX) GetAmountOutQuote(
------	ctx context.Context,
------	amountIn uint64,
------	sourceToken, targetToken solana.PublicKey,
------) (float64, error) {
------	// Создаем временный пул для получения котировки
------	poolInfo := r.poolInfo
------	if poolInfo == nil {
------		return 0, fmt.Errorf("pool info not configured")
------	}
------
------	// Получаем ожидаемый выход
------	expectedOut, err := r.getExpectedOutput(ctx, amountIn, sourceToken, targetToken, poolInfo, r.logger)
------	if err != nil {
------		return 0, fmt.Errorf("failed to get expected output: %w", err)
------	}
------
------	return expectedOut, nil
------}
------
------// TransactionStatus представляет статус транзакции
------type TransactionStatus struct {
------	Signature     string    `json:"signature"`
------	Status        string    `json:"status"`
------	Confirmations uint64    `json:"confirmations"`
------	Slot          uint64    `json:"slot"`
------	Error         string    `json:"error,omitempty"`
------	Timestamp     time.Time `json:"timestamp"` // Время проверки статуса
------}
------
------// getTransactionStatus получает полный статус транзакции
------func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signature) (*TransactionStatus, error) {
------	result, err := r.client.GetSignatureStatuses(ctx, signature)
------	if err != nil {
------		return nil, fmt.Errorf("failed to get signature status: %w", err)
------	}
------
------	now := time.Now()
------	status := &TransactionStatus{
------		Signature: signature.String(),
------		Status:    "pending",
------		Timestamp: now,
------	}
------
------	if len(result.Value) == 0 || result.Value[0] == nil {
------		return status, nil
------	}
------
------	statusInfo := result.Value[0]
------	if statusInfo.Err != nil {
------		status.Error = fmt.Sprintf("%v", statusInfo.Err)
------		status.Status = "failed"
------		return status, nil
------	}
------
------	if statusInfo.Confirmations != nil {
------		status.Confirmations = *statusInfo.Confirmations
------	}
------
------	if statusInfo.Slot > 0 {
------		status.Slot = statusInfo.Slot
------	}
------
------	switch statusInfo.ConfirmationStatus {
------	case solanarpc.ConfirmationStatusFinalized:
------		status.Status = "finalized"
------	case solanarpc.ConfirmationStatusConfirmed:
------		status.Status = "confirmed"
------	}
------
------	return status, nil
------}
------
------// GetSignatureStatus получает детальный статус подписи
------func (r *DEX) GetSignatureStatus(ctx context.Context, signature solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
------	return r.client.GetSignatureStatuses(ctx, signature)
------}
-----diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
-----deleted file mode 100644
-----index 61d78a0..0000000
-------- a/internal/dex/raydium/transaction.go
-----+++ /dev/null
-----@@ -1,264 +0,0 @@
------// internal/dex/raydium/transaction.go
------
------package raydium
------
------import (
------	"context"
------	"encoding/binary"
------	"fmt"
------	"math"
------
------	"github.com/gagliardetto/solana-go"
------	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
------	"github.com/rovshanmuradov/solana-bot/internal/types"
------	"github.com/rovshanmuradov/solana-bot/internal/wallet"
------	"go.uber.org/zap"
------)
------
------// Serialize serializes the swap instruction data
------func (s *SwapInstructionData) Serialize() ([]byte, error) {
------	if err := s.Validate(); err != nil {
------		return nil, err
------	}
------
------	data := make([]byte, 17)
------
------	// Write instruction discriminator
------	data[0] = s.Instruction
------
------	// Write amount in
------	binary.LittleEndian.PutUint64(data[1:9], s.AmountIn)
------
------	// Write minimum out
------	binary.LittleEndian.PutUint64(data[9:17], s.MinAmountOut)
------
------	return data, nil
------}
------
------// Validate validates the swap instruction data
------func (s *SwapInstructionData) Validate() error {
------	if s.Instruction != 1 {
------		return fmt.Errorf("invalid instruction type: expected 1, got %d", s.Instruction)
------	}
------
------	if s.AmountIn == 0 {
------		return fmt.Errorf("amount_in cannot be zero")
------	}
------
------	// MinimumOut can be zero, but log a warning
------	if s.MinAmountOut == 0 {
------		// You may want to log a warning here
------	}
------
------	return nil
------}
------
------// CreateSwapInstruction creates a swap instruction for Raydium
------func (r *DEX) CreateSwapInstruction(
------	userWallet solana.PublicKey,
------	userSourceTokenAccount solana.PublicKey,
------	userDestinationTokenAccount solana.PublicKey,
------	amountIn uint64,
------	minAmountOut uint64,
------	logger *zap.Logger,
------	poolInfo *Pool,
------) (solana.Instruction, error) {
------	logger.Debug("Creating swap instruction",
------		zap.String("user_wallet", userWallet.String()),
------		zap.String("source_account", userSourceTokenAccount.String()),
------		zap.String("destination_account", userDestinationTokenAccount.String()),
------		zap.Uint64("amount_in", amountIn),
------		zap.Uint64("min_amount_out", minAmountOut))
------
------	if poolInfo == nil {
------		return nil, fmt.Errorf("pool info is nil")
------	}
------
------	// Validate and parse all necessary public keys
------	ammProgramID, err := validatePublicKey(poolInfo.AmmProgramID)
------	if err != nil {
------		logger.Error("Invalid AmmProgramID", zap.Error(err))
------		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
------	}
------
------	// Map of required accounts with their names
------	requiredAccounts := map[string]string{
------		"AmmID":                poolInfo.AmmID,
------		"AmmAuthority":         poolInfo.AmmAuthority,
------		"AmmOpenOrders":        poolInfo.AmmOpenOrders,
------		"AmmTargetOrders":      poolInfo.AmmTargetOrders,
------		"PoolCoinTokenAccount": poolInfo.PoolCoinTokenAccount,
------		"PoolPcTokenAccount":   poolInfo.PoolPcTokenAccount,
------		"SerumProgramID":       poolInfo.SerumProgramID,
------		"SerumMarket":          poolInfo.SerumMarket,
------		"SerumBids":            poolInfo.SerumBids,
------		"SerumAsks":            poolInfo.SerumAsks,
------		"SerumEventQueue":      poolInfo.SerumEventQueue,
------		"SerumCoinVault":       poolInfo.SerumCoinVaultAccount,
------		"SerumPcVault":         poolInfo.SerumPcVaultAccount,
------		"SerumVaultSigner":     poolInfo.SerumVaultSigner,
------	}
------
------	accounts := make(map[string]solana.PublicKey)
------	for name, address := range requiredAccounts {
------		pubKey, err := validatePublicKey(address)
------		if err != nil {
------			logger.Error(fmt.Sprintf("Invalid %s", name),
------				zap.String("address", address),
------				zap.Error(err))
------			return nil, fmt.Errorf("invalid %s: %w", name, err)
------		}
------		accounts[name] = pubKey
------	}
------
------	// Create the account meta slice in the correct order
------	metas := solana.AccountMetaSlice{
------		// User accounts
------		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
------		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
------		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
------		// Pool accounts
------		{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
------		{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
------		// Serum accounts
------		{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
------		{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
------		{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
------		// System accounts
------		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
------		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
------		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
------	}
------
------	// Create swap instruction data
------	instructionData := &SwapInstructionData{
------		Instruction:  poolInfo.RaydiumSwapInstructionCode,
------		AmountIn:     amountIn,
------		MinAmountOut: minAmountOut,
------	}
------
------	// Serialize instruction data
------	data, err := instructionData.Serialize()
------	if err != nil {
------		logger.Error("Failed to serialize instruction data",
------			zap.Error(err),
------			zap.Uint8("instruction", instructionData.Instruction),
------			zap.Uint64("amount_in", instructionData.AmountIn),
------			zap.Uint64("min_amount_out", instructionData.MinAmountOut))
------		return nil, fmt.Errorf("failed to serialize instruction data: %w", err)
------	}
------
------	// Create the instruction
------	instruction := solana.NewInstruction(ammProgramID, metas, data)
------
------	logger.Debug("Created swap instruction",
------		zap.Int("num_accounts", len(metas)),
------		zap.Int("data_len", len(data)))
------
------	return instruction, nil
------}
------
------// PrepareAndSendTransaction prepares and sends the swap transaction
------func (r *DEX) PrepareAndSendTransaction(
------	ctx context.Context,
------	task *types.Task,
------	userWallet *wallet.Wallet,
------	logger *zap.Logger,
------	swapInstruction solana.Instruction,
------) error {
------	recentBlockhash, err := r.client.GetRecentBlockhash(ctx)
------	if err != nil {
------		logger.Error("Failed to get recent blockhash", zap.Error(err))
------		return fmt.Errorf("failed to get recent blockhash: %w", err)
------	}
------
------	// Create compute budget instruction if needed
------	computeBudgetInst := computebudget.NewSetComputeUnitPriceInstruction(
------		uint64(task.PriorityFee * 1e6), // Convert SOL to micro-lamports
------	).Build()
------
------	// Combine all instructions
------	instructions := []solana.Instruction{
------		computeBudgetInst,
------		swapInstruction,
------	}
------
------	// Create the transaction
------	tx, err := solana.NewTransaction(
------		instructions,
------		recentBlockhash,
------		solana.TransactionPayer(userWallet.PublicKey),
------	)
------	if err != nil {
------		logger.Error("Failed to create transaction", zap.Error(err))
------		return fmt.Errorf("failed to create transaction: %w", err)
------	}
------
------	// Sign the transaction
------	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
------		if key.Equals(userWallet.PublicKey) {
------			return &userWallet.PrivateKey
------		}
------		return nil
------	})
------	if err != nil {
------		logger.Error("Failed to sign transaction", zap.Error(err))
------		return fmt.Errorf("failed to sign transaction: %w", err)
------	}
------
------	// Send the transaction
------	signature, err := r.client.SendTransaction(ctx, tx)
------	if err != nil {
------		logger.Error("Failed to send transaction", zap.Error(err))
------		return fmt.Errorf("failed to send transaction: %w", err)
------	}
------
------	logger.Info("Transaction sent successfully",
------		zap.String("signature", signature.String()),
------		zap.Float64("priority_fee_sol", task.PriorityFee))
------
------	return nil
------}
------
------// validatePublicKey checks if a public key string is valid
------func validatePublicKey(key string) (solana.PublicKey, error) {
------	if key == "" {
------		return solana.PublicKey{}, fmt.Errorf("empty public key")
------	}
------
------	pubKey, err := solana.PublicKeyFromBase58(key)
------	if err != nil {
------		return solana.PublicKey{}, fmt.Errorf("invalid public key %s: %w", key, err)
------	}
------
------	return pubKey, nil
------}
------
------// Helper function to calculate minimum output considering slippage
------func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
------	if expectedOut <= 0 {
------		return 1 // Minimum safe value
------	}
------
------	// Consider slippage
------	minOut := expectedOut * (1 - slippagePercent/100)
------
------	// Convert to uint64 and check for minimum value
------	result := uint64(math.Floor(minOut))
------	if result == 0 {
------		return 1
------	}
------
------	return result
------}
------
------// You may want to include other helper functions or adjust existing ones as needed
-----diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
-----index 7db11c6..ef19a7a 100644
-------- a/internal/dex/raydium/types.go
-----+++ b/internal/dex/raydium/types.go
-----@@ -1,103 +1,152 @@
----- // internal/dex/raydium/types.go
------
-----+// Package raydium реализует интеграцию с Raydium DEX на Solana
----- package raydium
----- 
----- import (
------	"sync"
------	"sync/atomic"
-----+	"context"
-----+	"fmt"
-----+
-----+	"github.com/gagliardetto/solana-go"
-----+)
----- 
------	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
------	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
------	"go.uber.org/zap"
-----+// Layout константы для правильного чтения данных из аккаунта пула
-----+const (
-----+	// Базовые смещения
-----+	LayoutDiscriminator = 8
-----+	LayoutStatus        = 1
-----+	LayoutNonce         = 1
-----+	LayoutBaseSize      = LayoutDiscriminator + LayoutStatus + LayoutNonce // 10 байт
-----+
-----+	// Смещения для резервов и других данных пула
-----+	LayoutBaseVaultOffset    = LayoutBaseSize + 32 + 32 + 32 // После discriminator, status, nonce и трех pubkeys
-----+	LayoutQuoteVaultOffset   = LayoutBaseVaultOffset + 32
-----+	LayoutBaseReserveOffset  = LayoutQuoteVaultOffset + 32 + 8
-----+	LayoutQuoteReserveOffset = LayoutBaseReserveOffset + 8
-----+
-----+	// Константы протокола
-----+	DefaultSwapFeePercent = 0.25
-----+	MinimumAmountOut      = 1
----- )
----- 
------// RaydiumPoolInfo содержит информацию о пуле Raydium
------type Pool struct {
------	AmmProgramID               string
------	AmmID                      string
------	AmmAuthority               string
------	AmmOpenOrders              string
------	AmmTargetOrders            string
------	PoolCoinTokenAccount       string
------	PoolPcTokenAccount         string
------	SerumProgramID             string
------	SerumMarket                string
------	SerumBids                  string
------	SerumAsks                  string
------	SerumEventQueue            string
------	SerumCoinVaultAccount      string
------	SerumPcVaultAccount        string
------	SerumVaultSigner           string
------	RaydiumSwapInstructionCode uint8
-----+// RaydiumPool представляет собой конфигурацию пула ликвидности Raydium
-----+type RaydiumPool struct {
-----+	// Программы
-----+	AmmProgramID   solana.PublicKey
-----+	SerumProgramID solana.PublicKey
-----+
-----+	// AMM конфигурация
-----+	ID            solana.PublicKey // ID пула
-----+	Authority     solana.PublicKey
-----+	OpenOrders    solana.PublicKey
-----+	TargetOrders  solana.PublicKey
-----+	BaseVault     solana.PublicKey
-----+	QuoteVault    solana.PublicKey
-----+	WithdrawQueue solana.PublicKey
-----+	LPVault       solana.PublicKey
-----+
-----+	// Токены и минты
-----+	BaseMint      solana.PublicKey
-----+	QuoteMint     solana.PublicKey
-----+	LPMint        solana.PublicKey
-----+	BaseDecimals  uint8
-----+	QuoteDecimals uint8
-----+	LPDecimals    uint8
-----+
-----+	// Serum Market
-----+	MarketID         solana.PublicKey
-----+	MarketProgramID  solana.PublicKey
-----+	MarketAuthority  solana.PublicKey
-----+	MarketBaseVault  solana.PublicKey
-----+	MarketQuoteVault solana.PublicKey
-----+	MarketBids       solana.PublicKey
-----+	MarketAsks       solana.PublicKey
-----+	MarketEventQueue solana.PublicKey
-----+	MarketVersion    uint8
-----+	LookupTableID    solana.PublicKey
-----+
-----+	// Версионирование и инструкции
-----+	Version              uint8
-----+	SwapInstructionIndex uint8
-----+	DefaultMinimumOutBps uint16 // базовых пунктов (1 bps = 0.01%)
-----+	DefaultFeeBps        uint16 // комиссия пула в базовых пунктах
----- }
-----+
-----+// PoolState содержит динамическое состояние пула
----- type PoolState struct {
------	TokenAReserve uint64
------	TokenBReserve uint64
------	SwapFee       float64 // в процентах
------	CurrentPrice  float64 // текущая цена пула
-----+	BaseReserve        uint64
-----+	QuoteReserve       uint64
-----+	SwapFeeNumerator   uint64
-----+	SwapFeeDenominator uint64
-----+	Status             uint8
----- }
----- 
------// SwapInstructionData представляет данные инструкции свапа
------type SwapInstructionData struct {
------	Instruction  uint8  // Тип инструкции
------	AmountIn     uint64 // Входящая сумма
------	MinAmountOut uint64 // Минимальная исходящая сумма
------}
------type DEX struct {
------	client         blockchain.Client
------	logger         *zap.Logger
------	poolInfo       *Pool
------	slippage       float64
------	tokenCache     *solbc.TokenMetadataCache
------	priceValidator PriceValidator
------	lastPoolState  atomic.Value // Используем atomic.Value для потокобезопасного доступа
------	stateMutex     sync.RWMutex // Мьютекс для дополнительной синхронизации при необходимости
------}
-----+// SwapSide определяет направление свапа
-----+type SwapSide uint8
----- 
------// setLastPoolState безопасно обновляет состояние пула
------func (r *DEX) setLastPoolState(state *PoolState) {
------	r.lastPoolState.Store(state)
------}
-----+const (
-----+	SwapSideIn SwapSide = iota
-----+	SwapSideOut
-----+)
----- 
------// getLastPoolState безопасно получает состояние пула
------func (r *DEX) getLastPoolState() *PoolState {
------	return r.lastPoolState.Load().(*PoolState)
-----+// SwapParams содержит параметры для создания инструкций свапа
-----+type SwapParams struct {
-----+	UserWallet          solana.PublicKey
-----+	AmountIn            uint64
-----+	MinAmountOut        uint64
-----+	ComputeUnits        uint32
-----+	PriorityFeeLamports uint64
-----+	LookupTableAccount  *solana.PublicKey // Опционально: адрес lookup таблицы
-----+	WritableIndexes     []uint8           // Индексы для writable аккаунтов в lookup table
-----+	ReadonlyIndexes     []uint8           // Индексы для readonly аккаунтов в lookup table
-----+	Pool                *RaydiumPool      // Информация о пуле
----- }
----- 
------// UpdatePoolState обновляет состояние пула с дополнительной синхронизацией
------func (r *DEX) UpdatePoolState(state *PoolState) {
------	r.stateMutex.Lock()
------	defer r.stateMutex.Unlock()
-----+// Client представляет интерфейс для взаимодействия с Raydium DEX
-----+type Client interface {
-----+	// Основные методы пула
-----+	GetPool(ctx context.Context, poolID solana.PublicKey) (*RaydiumPool, error)
-----+	GetPoolState(ctx context.Context, pool *RaydiumPool) (*PoolState, error)
----- 
------	r.setLastPoolState(state)
-----+	// Методы для свапов
-----+	CreateSwapInstructions(ctx context.Context, params SwapParams) ([]solana.Instruction, error)
-----+	SimulateSwap(ctx context.Context, instructions []solana.Instruction) error
-----+	GetAmountOut(pool *RaydiumPool, state *PoolState, amountIn uint64) (uint64, error)
-----+}
----- 
------	// Логируем обновление состояния
------	r.logger.Debug("Pool state updated",
------		zap.Float64("current_price", state.CurrentPrice),
------		zap.Uint64("token_a_reserve", state.TokenAReserve),
------		zap.Uint64("token_b_reserve", state.TokenBReserve))
-----+// ValidationError представляет ошибку валидации
-----+type ValidationError struct {
-----+	Field   string
-----+	Message string
----- }
----- 
------// GetPoolStateSnapshot получает снапшот текущего состояния пула
------func (r *DEX) GetPoolStateSnapshot() *PoolState {
------	r.stateMutex.RLock()
------	defer r.stateMutex.RUnlock()
-----+func (e *ValidationError) Error() string {
-----+	return fmt.Sprintf("validation error for %s: %s", e.Field, e.Message)
-----+}
----- 
------	state := r.getLastPoolState()
------	if state == nil {
------		return nil
------	}
-----+// SwapError представляет ошибку при выполнении свапа
-----+type SwapError struct {
-----+	Stage   string
-----+	Message string
-----+	Err     error
-----+}
----- 
------	// Возвращаем копию состояния
------	return &PoolState{
------		TokenAReserve: state.TokenAReserve,
------		TokenBReserve: state.TokenBReserve,
------		SwapFee:       state.SwapFee,
------		CurrentPrice:  state.CurrentPrice,
-----+func (e *SwapError) Error() string {
-----+	if e.Err != nil {
-----+		return fmt.Sprintf("swap error at %s: %s: %v", e.Stage, e.Message, e.Err)
----- 	}
-----+	return fmt.Sprintf("swap error at %s: %s", e.Stage, e.Message)
-----+}
-----+
-----+func (e *SwapError) Unwrap() error {
-----+	return e.Err
-----+}
-----+
-----+// Типы для v5 пулов
-----+type RaydiumPoolV5 struct {
-----+	// Новые поля v5
----- }
----- 
------// Name возвращает имя DEX
------func (r *DEX) Name() string {
------	return "Raydium"
-----+// Типы для маркет-мейкинга
-----+type MarketMakingParams struct {
-----+	// Параметры для MM
----- }
-----diff --git a/internal/dex/raydium/validation.go b/internal/dex/raydium/validation.go
-----deleted file mode 100644
-----index 9267897..0000000
-------- a/internal/dex/raydium/validation.go
-----+++ /dev/null
-----@@ -1,105 +0,0 @@
------// internal/dex/raydium/validation.go
------package raydium
------
------import (
------	"fmt"
------
------	"github.com/gagliardetto/solana-go"
------	"github.com/rovshanmuradov/solana-bot/internal/types"
------)
------
------// ValidateTask проверяет корректность параметров задачи
------func ValidateTask(task *types.Task) error {
------	if task == nil {
------		return fmt.Errorf("task cannot be nil")
------	}
------
------	if task.TaskName == "" {
------		return fmt.Errorf("task name cannot be empty")
------	}
------
------	if task.SourceToken == "" {
------		return fmt.Errorf("source token cannot be empty")
------	}
------
------	if task.TargetToken == "" {
------		return fmt.Errorf("target token cannot be empty")
------	}
------
------	// Проверяем корректность адресов токенов
------	if _, err := solana.PublicKeyFromBase58(task.SourceToken); err != nil {
------		return fmt.Errorf("invalid source token address: %w", err)
------	}
------
------	if _, err := solana.PublicKeyFromBase58(task.TargetToken); err != nil {
------		return fmt.Errorf("invalid target token address: %w", err)
------	}
------
------	if task.AmountIn <= 0 {
------		return fmt.Errorf("amount in must be greater than 0")
------	}
------
------	// Удаляем проверку MinAmountOut, так как теперь оно может быть нулевым или пустым
------	// if task.MinAmountOut <= 0 {
------	//     return fmt.Errorf("min amount out must be greater than 0")
------	// }
------
------	// Проверяем конфигурацию проскальзывания, если она используется
------	if task.SlippageConfig.Type != types.SlippageNone {
------		if task.SlippageConfig.Type == types.SlippagePercent &&
------			(task.SlippageConfig.Value <= 0 || task.SlippageConfig.Value > 100) {
------			return fmt.Errorf("slippage percentage must be between 0 and 100")
------		}
------		if task.SlippageConfig.Type == types.SlippageFixed && task.SlippageConfig.Value < 0 {
------			return fmt.Errorf("fixed slippage value cannot be negative")
------		}
------	}
------
------	if task.SourceTokenDecimals <= 0 {
------		return fmt.Errorf("source token decimals must be greater than 0")
------	}
------
------	if task.TargetTokenDecimals <= 0 {
------		return fmt.Errorf("target token decimals must be greater than 0")
------	}
------
------	return nil
------}
------
------// ValidatePool проверяет корректность конфигурации пула
------func ValidatePool(pool *Pool) error {
------	if pool == nil {
------		return fmt.Errorf("pool config cannot be nil")
------	}
------
------	// Проверяем все обязательные адреса
------	addresses := map[string]string{
------		"AmmProgramID":          pool.AmmProgramID,
------		"AmmID":                 pool.AmmID,
------		"AmmAuthority":          pool.AmmAuthority,
------		"AmmOpenOrders":         pool.AmmOpenOrders,
------		"AmmTargetOrders":       pool.AmmTargetOrders,
------		"PoolCoinTokenAccount":  pool.PoolCoinTokenAccount,
------		"PoolPcTokenAccount":    pool.PoolPcTokenAccount,
------		"SerumProgramID":        pool.SerumProgramID,
------		"SerumMarket":           pool.SerumMarket,
------		"SerumBids":             pool.SerumBids,
------		"SerumAsks":             pool.SerumAsks,
------		"SerumEventQueue":       pool.SerumEventQueue,
------		"SerumCoinVaultAccount": pool.SerumCoinVaultAccount,
------		"SerumPcVaultAccount":   pool.SerumPcVaultAccount,
------		"SerumVaultSigner":      pool.SerumVaultSigner,
------	}
------
------	for name, addr := range addresses {
------		if addr == "" {
------			return fmt.Errorf("%s cannot be empty", name)
------		}
------
------		if _, err := solana.PublicKeyFromBase58(addr); err != nil {
------			return fmt.Errorf("invalid %s address: %w", name, err)
------		}
------	}
------
------	return nil
------}
-----diff --git a/newdif.txt b/newdif.txt
-----index 406c273..a8395ed 100644
-------- a/newdif.txt
-----+++ b/newdif.txt
-----@@ -1,2314 +0,0 @@
------diff --git a/internal/dex/raydium/config.go b/internal/dex/raydium/config.go
------index cb0c21b..fab480a 100644
--------- a/internal/dex/raydium/config.go
------+++ b/internal/dex/raydium/config.go
------@@ -3,27 +3,29 @@ package raydium
------ 
------ // DefaultPoolConfig с обновленным типом для RaydiumSwapInstructionCode
------ var DefaultPoolConfig = &Pool{
-------	// Актуальный программный ID Raydium
-------	AmmProgramID: "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",
------+	// Программы
------+	AmmProgramID:   "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8", // ✅ Подтверждено
------+	SerumProgramID: "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX",  // ✅ Подтверждено
------ 
-------	// Актуальная конфигурация для SOL-USDC пула
-------	AmmID:                "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
-------	AmmAuthority:         "3uaZBfHPfmpAHW7dsimC1SnyR61X4bJqQZKWmRSCXJxv",
-------	AmmOpenOrders:        "4NfmERReGt1QCKey8cH5q4LsBYJoUcsuGg11J8GQFwH8",
-------	AmmTargetOrders:      "38RJcGjtgd4SKRfY2dcM8Z9LzXQR6cyZeGxvjrRsVGZD",
-------	PoolCoinTokenAccount: "8spXrXn2EWtNiAHvWZY3EE2f8E1TRDHzFTYyXtNuVFKs",
-------	PoolPcTokenAccount:   "DuYuU5Y6TEZoMhzwPsYYRFzB5xqF999kXGHUDmBZwJge",
------+	// AMM конфигурация
------+	AmmID:           "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", // ✅ Подтверждено
------+	AmmAuthority:    "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1", // ✅ Обновлено (authority)
------+	AmmOpenOrders:   "HmiHHzq4Fym9e1D4qzLS6LDDM3tNsCTBPDWHTLZ763jY", // ✅ Обновлено (openOrders)
------+	AmmTargetOrders: "CZza3Ej4Mc58MnxWA385itCC9jCo3L1D7zc3LKy1bZMR", // ✅ Обновлено (targetOrders)
------ 
-------	// OpenBook (бывший Serum) маркет
-------	SerumProgramID:        "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX",
-------	SerumMarket:           "8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6",
-------	SerumBids:             "5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh",
-------	SerumAsks:             "EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCHV5T73Sw8TL",
-------	SerumEventQueue:       "8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa",
-------	SerumCoinVaultAccount: "CKxTHwM9fPksGqGd5AHjyGWGbzGkDYjP6ABNYRLvJ1Vz",
-------	SerumPcVaultAccount:   "PCxN9aXvxtwMYrXk8BgESw3NNkGLwpPM8c6DwByrjgN",
-------	SerumVaultSigner:      "GXWEpRURaQZ9E62Q23EreTUfBy4hfemXgWFUWcg7YFgv",
------+	// Token Accounts
------+	PoolCoinTokenAccount: "DQyrAcCrDXQ7NeoqGgDCZwBvWDcYmFCjSb9JtteuvPpz", // ✅ Обновлено (baseVault)
------+	PoolPcTokenAccount:   "HLmqeL62xR1QoZ1HKKbXRrdN1p3phKpxRMb2VVopvBBz", // ✅ Обновлено (quoteVault)
------ 
-------	// Правильный код инструкции для свапа (теперь uint8)
-------	RaydiumSwapInstructionCode: 1,
------+	// Serum Market
------+	SerumMarket:           "8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6", // ✅ Подтверждено
------+	SerumBids:             "5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh", // ✅ Подтверждено
------+	SerumAsks:             "EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCLNBEDXDn1d5", // ✅ Обновлено
------+	SerumEventQueue:       "8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa", // ✅ Подтверждено
------+	SerumCoinVaultAccount: "CKxTHwM9fPMRRvZmFnFoqKNd9pQR21c5Aq9bh5h9oghX", // ✅ Обновлено (marketBaseVault)
------+	SerumPcVaultAccount:   "6A5NHCj1yF6urc9wZNe6Bcjj4LVszQNj5DwAWG97yzMu", // ✅ Обновлено (marketQuoteVault)
------+	SerumVaultSigner:      "CTz5UMLQm2SRWHzQnU62Pi4yJqbNGjgRBHqqp6oDHfF7", // ✅ Обновлено (marketAuthority)
------+
------+	// Дополнительные параметры
------+	RaydiumSwapInstructionCode: 1, // ✅ Не изменилось
------ }
------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
------index 48baf94..c684b6e 100644
--------- a/internal/dex/raydium/raydium.go
------+++ b/internal/dex/raydium/raydium.go
------@@ -17,6 +17,7 @@ import (
------ 
------ 	solanarpc "github.com/gagliardetto/solana-go/rpc"
------ 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
------+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
------ 	"github.com/rovshanmuradov/solana-bot/internal/types"
------ 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
------ 	"go.uber.org/zap"
------@@ -30,17 +31,73 @@ const (
------ 	txSendTimeout   = 15 * time.Second
------ )
------ 
------+// Добавляем новые типы для работы с ценами
------+type PriceValidator interface {
------+	ValidatePrice(poolPrice float64) error
------+	GetMaxDeviation() float64
------+}
------+
------+// Обновляем структуру PoolState
------+
------+// Добавляем базовую реализацию валидатора цен
------+type BasicPriceValidator struct {
------+	basePrice    float64
------+	maxDeviation float64
------+	logger       *zap.Logger
------+}
------+
------+func NewBasicPriceValidator(basePrice float64, maxDeviation float64, logger *zap.Logger) *BasicPriceValidator {
------+	return &BasicPriceValidator{
------+		basePrice:    basePrice,
------+		maxDeviation: maxDeviation,
------+		logger:       logger,
------+	}
------+}
------+
------+func (v *BasicPriceValidator) ValidatePrice(poolPrice float64) error {
------+	if v.basePrice <= 0 {
------+		// Если базовая цена не установлена, пропускаем валидацию
------+		return nil
------+	}
------+
------+	deviation := math.Abs(poolPrice-v.basePrice) / v.basePrice
------+	if deviation > v.maxDeviation {
------+		return fmt.Errorf("pool price deviation too high: %.2f%% (pool: %.2f, base: %.2f)",
------+			deviation*100, poolPrice, v.basePrice)
------+	}
------+
------+	return nil
------+}
------+
------+func (v *BasicPriceValidator) GetMaxDeviation() float64 {
------+	return v.maxDeviation
------+}
------+
------+// NewDEX создает новый экземпляр DEX
------ func NewDEX(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) *DEX {
------ 	if err := validateDEXParams(client, logger, poolInfo); err != nil {
------ 		logger.Error("Failed to create DEX", zap.Error(err))
------ 		return nil
------ 	}
------ 
-------	return &DEX{
-------		client:   client,
-------		logger:   logger.Named("raydium-dex"),
-------		poolInfo: poolInfo,
------+	priceValidator := NewBasicPriceValidator(
------+		181.0, // Базовая цена SOL/USDC
------+		0.5,   // 50% максимальное отклонение
------+		logger,
------+	)
------+
------+	dex := &DEX{
------+		client:         client,
------+		logger:         logger.Named("raydium-dex"),
------+		poolInfo:       poolInfo,
------+		tokenCache:     solbc.NewTokenMetadataCache(logger),
------+		priceValidator: priceValidator,
------ 	}
------+
------+	// Инициализируем atomic.Value
------+	dex.lastPoolState.Store((*PoolState)(nil))
------+
------+	return dex
------ }
------ 
------ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wallet.Wallet) error {
------@@ -57,7 +114,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
------ 	)
------ 	logger.Info("Starting swap execution")
------ 
-------	// Проверяем и получаем токен-аккаунты с таймаутом
------+	// Parse token addresses
------ 	sourceMint, targetMint, err := parseTokenAddresses(task.SourceToken, task.TargetToken)
------ 	if err != nil {
------ 		return fmt.Errorf("invalid token addresses: %w", err)
------@@ -66,12 +123,13 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
------ 	ataCtx, ataCancel := context.WithTimeout(opCtx, ataCheckTimeout)
------ 	defer ataCancel()
------ 
------+	// Setup token accounts
------ 	sourceATA, targetATA, err := r.setupTokenAccounts(ataCtx, userWallet, sourceMint, targetMint, logger)
------ 	if err != nil {
------ 		return fmt.Errorf("failed to setup token accounts: %w", err)
------ 	}
------ 
-------	// Подготавливаем amount с учетом decimals
------+	// Prepare amount with decimals
------ 	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
------ 
------ 	logger.Debug("Prepared swap amount",
------@@ -80,11 +138,10 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
------ 		zap.Float64("slippage_value", task.SlippageConfig.Value),
------ 	)
------ 
-------	// Создаем инструкции с таймаутом
------ 	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
------ 	defer swapCancel()
------ 
-------	// Подготавливаем все необходимые инструкции
------+	// Prepare swap instructions
------ 	instructions, err := r.PrepareSwapInstructions(
------ 		swapCtx,
------ 		userWallet.PublicKey,
------@@ -98,7 +155,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
------ 		return fmt.Errorf("failed to prepare swap instructions: %w", err)
------ 	}
------ 
-------	// Отправляем транзакцию
------+	// Send transaction
------ 	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
------ 	if err != nil {
------ 		return fmt.Errorf("failed to send swap transaction: %w", err)
------@@ -555,7 +612,7 @@ func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, sol
------ 	return sourceMint, targetMint, nil
------ }
------ 
-------// getExpectedOutput вычисляет ожидаемый выход для свапа
------+// getExpectedOutput calculates the expected output for the swap
------ func (r *DEX) getExpectedOutput(
------ 	ctx context.Context,
------ 	amountIn uint64,
------@@ -563,52 +620,84 @@ func (r *DEX) getExpectedOutput(
------ 	poolInfo *Pool,
------ 	logger *zap.Logger,
------ ) (float64, error) {
-------	// Создаем контекст с тайм-аутом
-------	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
-------	defer cancel()
-------
-------	logger = logger.With(
-------		zap.String("source_token", sourceToken.String()),
-------		zap.String("target_token", targetToken.String()),
-------		zap.Uint64("amount_in", amountIn),
-------	)
-------
-------	// Получаем состояние пула
------+	// Get pool state
------ 	poolState, err := r.getPoolState(ctx, poolInfo)
------ 	if err != nil {
------ 		return 0, fmt.Errorf("failed to get pool state: %w", err)
------ 	}
------ 
-------	logger.Debug("Pool state retrieved",
-------		zap.Uint64("token_a_reserve", poolState.TokenAReserve),
-------		zap.Uint64("token_b_reserve", poolState.TokenBReserve),
-------		zap.Float64("swap_fee", poolState.SwapFee))
------+	// Get decimals for tokens
------+	sourceMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, sourceToken)
------+	if err != nil {
------+		return 0, fmt.Errorf("failed to get source token metadata: %w", err)
------+	}
------ 
-------	// Вычисляем ожидаемый выход с учетом всех факторов
-------	expectedOut := r.calculateExpectedOutput(amountIn, poolState)
------+	targetMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, targetToken)
------+	if err != nil {
------+		return 0, fmt.Errorf("failed to get target token metadata: %w", err)
------+	}
------ 
-------	logger.Debug("Expected output calculated",
-------		zap.Float64("expected_out", expectedOut))
------+	// Calculate expected output
------+	expectedOut := r.calculateExpectedOutput(
------+		amountIn,
------+		int(sourceMetadata.Decimals),
------+		int(targetMetadata.Decimals),
------+		poolState,
------+	)
------+
------+	// Validate calculated price against market price
------+	marketPrice := 181.0 // Use current market price of SOL in USDC
------+	err = validateSwapAmount(expectedOut, marketPrice, amountIn,
------+		int(sourceMetadata.Decimals),
------+		int(targetMetadata.Decimals))
------+	if err != nil {
------+		return 0, fmt.Errorf("swap amount validation failed: %w", err)
------+	}
------ 
------ 	return expectedOut, nil
------ }
------ 
-------// Определяем смещения для чтения данных пула Raydium
------+// getPoolState gets the current state of the pool
------+// Скорректированные смещения для Raydium v4 пула
------ const (
-------	// Смещения в байтах для различных полей в структуре пула
------ 	DISCRIMINATOR_SIZE = 8
------ 	STATUS_SIZE        = 1
------ 	NONCE_SIZE         = 1
-------	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 байт
------+	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 bytes
------ 
-------	// Смещения для резервов
-------	baseVaultOffset    = BASE_SIZE + 32 + 32 + 32 // После discriminator, status, nonce и трех pubkeys
-------	quoteVaultOffset   = baseVaultOffset + 32
-------	baseReserveOffset  = quoteVaultOffset + 32 + 8 // +8 для uint64
-------	quoteReserveOffset = baseReserveOffset + 8
------+	// Новые смещения (в байтах)
------+	baseVaultOffset    = BASE_SIZE + 96       // После discriminator + статуса + nonce + 3 pubkeys
------+	quoteVaultOffset   = baseVaultOffset + 40 // После base vault + доп. данные
------+	baseReserveOffset  = 178                  // Фиксированное смещение для базового резерва
------+	quoteReserveOffset = 186                  // Фиксированное смещение для quote резерва
------ )
------ 
-------// getPoolState получает текущее состояние пула
------+// Добавляем новые типы для работы с ценами
------+type PriceSource interface {
------+	GetCurrentPrice(ctx context.Context, base, quote solana.PublicKey) (float64, error)
------+}
------+
------+type PoolPriceValidator struct {
------+	priceSource  PriceSource
------+	maxDeviation float64
------+	logger       *zap.Logger
------+}
------+
------+func NewPoolPriceValidator(priceSource PriceSource, logger *zap.Logger) *PoolPriceValidator {
------+	return &PoolPriceValidator{
------+		priceSource:  priceSource,
------+		maxDeviation: 0.5, // 50% максимальное отклонение
------+		logger:       logger,
------+	}
------+}
------+
------+// Добавляем метод для обновления валидатора цен
------+func (r *DEX) SetPriceValidator(validator PriceValidator) {
------+	r.priceValidator = validator
------+}
------+
------+// internal/dex/raydium/raydium.go
------+
------ func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
------ 	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
------ 	if err != nil {
------@@ -621,7 +710,6 @@ func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, err
------ 
------ 	data := poolAccount.Value.Data.GetBinary()
------ 
-------	// Debug полных данных
------ 	r.logger.Debug("Full pool data",
------ 		zap.Binary("data", data),
------ 		zap.Int("length", len(data)))
------@@ -635,41 +723,128 @@ func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, err
------ 	baseReserve := binary.LittleEndian.Uint64(data[baseReserveOffset : baseReserveOffset+8])
------ 	quoteReserve := binary.LittleEndian.Uint64(data[quoteReserveOffset : quoteReserveOffset+8])
------ 
-------	r.logger.Debug("Pool reserves offsets",
-------		zap.Int("base_offset", baseReserveOffset),
-------		zap.Int("quote_offset", quoteReserveOffset))
------+	r.logger.Debug("Raw reserves",
------+		zap.Uint64("base_reserve_raw", baseReserve),
------+		zap.Uint64("quote_reserve_raw", quoteReserve))
------ 
-------	r.logger.Debug("Pool reserves raw bytes",
-------		zap.Binary("base_bytes", data[baseReserveOffset:baseReserveOffset+8]),
-------		zap.Binary("quote_bytes", data[quoteReserveOffset:quoteReserveOffset+8]))
------+	// Проверяем резервы
------+	if baseReserve == 0 || quoteReserve == 0 {
------+		return nil, fmt.Errorf("invalid pool reserves: base=%d, quote=%d",
------+			baseReserve, quoteReserve)
------+	}
------+
------+	// Нормализуем значения с учетом decimals
------+	solAmount := float64(baseReserve) / 1e9   // 9 decimals для SOL
------+	usdcAmount := float64(quoteReserve) / 1e6 // 6 decimals для USDC
------+
------+	poolPrice := usdcAmount / solAmount
------+	r.logger.Debug("Pool price calculated",
------+		zap.Float64("pool_price", poolPrice),
------+		zap.Float64("sol_amount", solAmount),
------+		zap.Float64("usdc_amount", usdcAmount))
------+
------+	// Проверяем цену через валидатор
------+	if r.priceValidator != nil {
------+		if err := r.priceValidator.ValidatePrice(poolPrice); err != nil {
------+			return nil, fmt.Errorf("pool price validation failed: %w", err)
------+		}
------+	}
------ 
-------	return &PoolState{
------+	state := &PoolState{
------ 		TokenAReserve: baseReserve,
------ 		TokenBReserve: quoteReserve,
------ 		SwapFee:       0.25,
-------	}, nil
------+		CurrentPrice:  poolPrice,
------+	}
------+
------+	// Сохраняем новое состояние
------+	r.UpdatePoolState(state)
------+
------+	return state, nil
------+}
------+
------+// Добавляем вспомогательные методы для работы с ценами
------+// GetCurrentPoolPrice возвращает текущую цену пула
------+func (r *DEX) GetCurrentPoolPrice() float64 {
------+	if state := r.lastPoolState.Load().(*PoolState); state != nil {
------+		return state.CurrentPrice
------+	}
------+	return 0
------+}
------+
------+func (r *DEX) SetMaxPriceDeviation(deviation float64) {
------+	if r.priceValidator != nil {
------+		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
------+			basicValidator.maxDeviation = deviation
------+		}
------+	}
------+}
------+
------+func (r *DEX) UpdateBasePrice(price float64) {
------+	if r.priceValidator != nil {
------+		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
------+			basicValidator.basePrice = price
------+		}
------+	}
------ }
------ 
------ // calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
-------func (r *DEX) calculateExpectedOutput(amountIn uint64, state *PoolState) float64 {
-------	// Конвертируем все в float64 для точных вычислений
-------	amountInF := float64(amountIn)
-------	reserveInF := float64(state.TokenAReserve)
-------	reserveOutF := float64(state.TokenBReserve)
------+// calculateExpectedOutput computes the expected output based on the pool state
------+func (r *DEX) calculateExpectedOutput(
------+	amountIn uint64,
------+	sourceDec,
------+	targetDec int,
------+	state *PoolState,
------+) float64 {
------+	logger := r.logger.With(
------+		zap.Uint64("amount_in_raw", amountIn),
------+		zap.Int("source_decimals", sourceDec),
------+		zap.Int("target_decimals", targetDec),
------+	)
------+
------+	// Normalize input amount
------+	amountInF := float64(amountIn) / math.Pow10(sourceDec)
------+	logger.Debug("Normalized input amount",
------+		zap.Float64("amount_in_normalized", amountInF))
------+
------+	// Get normalized reserves
------+	reserveIn := float64(state.TokenAReserve) / math.Pow10(sourceDec)
------+	reserveOut := float64(state.TokenBReserve) / math.Pow10(targetDec)
------+	logger.Debug("Normalized reserves",
------+		zap.Float64("reserve_in_normalized", reserveIn),
------+		zap.Float64("reserve_out_normalized", reserveOut))
------+
------+	// Calculate output using constant product formula
------+	amountOut := (amountInF * reserveOut * (1 - state.SwapFee/100)) / (reserveIn + amountInF*(1-state.SwapFee/100))
------+	logger.Debug("Calculated amount out",
------+		zap.Float64("amount_out", amountOut))
------+
------+	// Convert back to lamports
------+	finalOutput := amountOut * math.Pow10(targetDec)
------+	logger.Debug("Final output in lamports",
------+		zap.Float64("final_output_lamports", finalOutput))
------+
------+	return finalOutput
------+}
------ 
-------	// Учитываем комиссию (0.25%)
-------	amountInWithFee := amountInF * (1 - state.SwapFee/100)
------+func validateSwapAmount(expectedOut float64, currentPrice float64, amountIn uint64, sourceDec, targetDec int) error {
------+	// Normalize values
------+	realAmountIn := float64(amountIn) / math.Pow10(sourceDec)
------+	realExpectedOut := expectedOut / math.Pow10(targetDec)
------ 
-------	// Используем формулу Raydium: dy = y * dx / (x + dx)
-------	// где dx - входная сумма с учетом комиссии
-------	// x, y - резервы токенов
-------	numerator := reserveOutF * amountInWithFee
-------	denominator := reserveInF + amountInWithFee
------+	// Calculate the swap price
------+	calculatedPrice := realExpectedOut / realAmountIn
------ 
-------	expectedOut := numerator / denominator
------+	// Calculate price difference percentage
------+	priceDiff := math.Abs(calculatedPrice-currentPrice) / currentPrice
------ 
-------	// Применяем дополнительный запас надежности 0.5%
-------	return expectedOut * 0.995
------+	// Allow up to 20% difference
------+	if priceDiff > 0.2 {
------+		return fmt.Errorf("calculated price differs too much from current price: %.2f vs %.2f",
------+			calculatedPrice, currentPrice)
------+	}
------+
------+	return nil
------ }
------ 
------ // GetAmountOutQuote получает котировку для свапа
------@@ -750,5 +925,3 @@ func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signatu
------ func (r *DEX) GetSignatureStatus(ctx context.Context, signature solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
------ 	return r.client.GetSignatureStatuses(ctx, signature)
------ }
-------
-------// Удалены неиспользуемые функции getConfirmations и waitForTransactionConfirmation
------diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
------index 2063598..61d78a0 100644
--------- a/internal/dex/raydium/transaction.go
------+++ b/internal/dex/raydium/transaction.go
------@@ -1,3 +1,5 @@
------+// internal/dex/raydium/transaction.go
------+
------ package raydium
------ 
------ import (
------@@ -5,16 +7,15 @@ import (
------ 	"encoding/binary"
------ 	"fmt"
------ 	"math"
-------	"testing"
------ 
------ 	"github.com/gagliardetto/solana-go"
------+	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
------ 	"github.com/rovshanmuradov/solana-bot/internal/types"
------ 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
-------	"github.com/sirupsen/logrus"
------ 	"go.uber.org/zap"
------ )
------ 
-------// Serialize сериализует данные инструкции свапа
------+// Serialize serializes the swap instruction data
------ func (s *SwapInstructionData) Serialize() ([]byte, error) {
------ 	if err := s.Validate(); err != nil {
------ 		return nil, err
------@@ -34,6 +35,7 @@ func (s *SwapInstructionData) Serialize() ([]byte, error) {
------ 	return data, nil
------ }
------ 
------+// Validate validates the swap instruction data
------ func (s *SwapInstructionData) Validate() error {
------ 	if s.Instruction != 1 {
------ 		return fmt.Errorf("invalid instruction type: expected 1, got %d", s.Instruction)
------@@ -43,99 +45,15 @@ func (s *SwapInstructionData) Validate() error {
------ 		return fmt.Errorf("amount_in cannot be zero")
------ 	}
------ 
-------	// MinimumOut может быть 0, но логируем это как предупреждение
------+	// MinimumOut can be zero, but log a warning
------ 	if s.MinAmountOut == 0 {
-------		logrus.Warn("minimum_out is set to zero, this may result in high slippage")
------+		// You may want to log a warning here
------ 	}
------ 
------ 	return nil
------ }
------ 
-------// Обновляем вычисление минимального выхода
-------func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
-------	if expectedOut <= 0 {
-------		return 1 // Минимальное безопасное значение
-------	}
-------
-------	// Учитываем слиппаж
-------	minOut := expectedOut * (1 - slippagePercent/100)
-------
-------	// Конвертируем в uint64 и проверяем на минимальное значение
-------	result := uint64(math.Floor(minOut))
-------	if result == 0 {
-------		return 1
-------	}
-------
-------	return result
-------}
-------
-------// TestSwapInstructionDataSerialization тест для проверки сериализации
-------func TestSwapInstructionDataSerialization(t *testing.T) {
-------	inst := &SwapInstructionData{
-------		Instruction:  1,
-------		AmountIn:     20000000,
-------		MinAmountOut: 6,
-------	}
-------
-------	data, err := inst.Serialize()
-------	if err != nil {
-------		t.Fatalf("Failed to serialize: %v", err)
-------	}
-------
-------	// Проверяем instruction code
-------	if data[0] != 1 {
-------		t.Errorf("Expected instruction 1, got %d", data[0])
-------	}
-------
-------	// Проверяем amountIn
-------	gotAmountIn := binary.LittleEndian.Uint64(data[1:9])
-------	if gotAmountIn != 20000000 {
-------		t.Errorf("Expected amountIn 20000000, got %d", gotAmountIn)
-------	}
-------
-------	// Проверяем minAmountOut
-------	gotMinAmountOut := binary.LittleEndian.Uint64(data[9:17])
-------	if gotMinAmountOut != 6 {
-------		t.Errorf("Expected minAmountOut 6, got %d", gotMinAmountOut)
-------	}
-------}
-------
-------// Debug выводит шестнадцатеричное представление данных
-------func (s *SwapInstructionData) Debug(logger *zap.Logger) {
-------	data, err := s.Serialize()
-------	if err != nil {
-------		logger.Error("Failed to serialize for debug", zap.Error(err))
-------		return
-------	}
-------
-------	// Проверяем данные
-------	amountIn := binary.LittleEndian.Uint64(data[1:9])
-------	minAmountOut := binary.LittleEndian.Uint64(data[9:17])
-------
-------	logger.Debug("Instruction data debug",
-------		zap.Uint8("instruction", data[0]),
-------		zap.Uint64("amount_in_original", s.AmountIn),
-------		zap.Uint64("amount_in_serialized", amountIn),
-------		zap.Uint64("min_amount_out_original", s.MinAmountOut),
-------		zap.Uint64("min_amount_out_serialized", minAmountOut),
-------		zap.Binary("raw_data", data))
-------}
-------
-------// validatePublicKey проверяет корректность публичного ключа
-------func validatePublicKey(key string) (solana.PublicKey, error) {
-------	if key == "" {
-------		return solana.PublicKey{}, fmt.Errorf("empty public key")
-------	}
-------
-------	pubKey, err := solana.PublicKeyFromBase58(key)
-------	if err != nil {
-------		return solana.PublicKey{}, fmt.Errorf("invalid public key %s: %w", key, err)
-------	}
-------
-------	return pubKey, nil
-------}
-------
-------// CreateSwapInstruction создает инструкцию свапа для Raydium
------+// CreateSwapInstruction creates a swap instruction for Raydium
------ func (r *DEX) CreateSwapInstruction(
------ 	userWallet solana.PublicKey,
------ 	userSourceTokenAccount solana.PublicKey,
------@@ -156,14 +74,14 @@ func (r *DEX) CreateSwapInstruction(
------ 		return nil, fmt.Errorf("pool info is nil")
------ 	}
------ 
-------	// Проверяем и конвертируем все необходимые публичные ключи
------+	// Validate and parse all necessary public keys
------ 	ammProgramID, err := validatePublicKey(poolInfo.AmmProgramID)
------ 	if err != nil {
------ 		logger.Error("Invalid AmmProgramID", zap.Error(err))
------ 		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
------ 	}
------ 
-------	// Проверяем и создаем все необходимые аккаунты
------+	// Map of required accounts with their names
------ 	requiredAccounts := map[string]string{
------ 		"AmmID":                poolInfo.AmmID,
------ 		"AmmAuthority":         poolInfo.AmmAuthority,
------@@ -193,56 +111,42 @@ func (r *DEX) CreateSwapInstruction(
------ 		accounts[name] = pubKey
------ 	}
------ 
-------	// Создаем слайс аккаунтов в правильном порядке для Raydium
-------	metas := make(solana.AccountMetaSlice, 0, 20)
-------
-------	// Токен аккаунты пользователя
-------	metas = append(metas,
-------		&solana.AccountMeta{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
-------	)
-------
-------	// Аккаунты AMM
-------	metas = append(metas,
-------		&solana.AccountMeta{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
-------		&solana.AccountMeta{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
-------	)
-------
-------	// Аккаунты Serum
-------	metas = append(metas,
-------		&solana.AccountMeta{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
-------		&solana.AccountMeta{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
-------		&solana.AccountMeta{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
-------	)
-------
-------	// Системные аккаунты
-------	metas = append(metas,
-------		&solana.AccountMeta{PublicKey: userWallet, IsSigner: true, IsWritable: false},
-------		&solana.AccountMeta{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
-------		&solana.AccountMeta{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
-------		&solana.AccountMeta{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
-------	)
------+	// Create the account meta slice in the correct order
------+	metas := solana.AccountMetaSlice{
------+		// User accounts
------+		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
------+		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
------+		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
------+		// Pool accounts
------+		{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
------+		{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
------+		// Serum accounts
------+		{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
------+		{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
------+		{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
------+		// System accounts
------+		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
------+		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
------+		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
------+	}
------ 
-------	// Создание данных инструкции
------+	// Create swap instruction data
------ 	instructionData := &SwapInstructionData{
------ 		Instruction:  poolInfo.RaydiumSwapInstructionCode,
------ 		AmountIn:     amountIn,
------ 		MinAmountOut: minAmountOut,
------ 	}
------ 
-------	// Добавляем отладочный вывод
-------	instructionData.Debug(logger)
-------
-------	// Сериализация
------+	// Serialize instruction data
------ 	data, err := instructionData.Serialize()
------ 	if err != nil {
------ 		logger.Error("Failed to serialize instruction data",
------@@ -253,39 +157,17 @@ func (r *DEX) CreateSwapInstruction(
------ 		return nil, fmt.Errorf("failed to serialize instruction data: %w", err)
------ 	}
------ 
-------	// Проверка сериализованных данных
-------	if len(data) != 17 {
-------		logger.Error("Invalid serialized data length",
-------			zap.Int("got_length", len(data)),
-------			zap.Int("expected_length", 17))
-------		return nil, fmt.Errorf("invalid serialized data length")
-------	}
-------
-------	// Проверяем значения после сериализации
-------	amountInCheck := binary.LittleEndian.Uint64(data[1:9])
-------	minAmountOutCheck := binary.LittleEndian.Uint64(data[9:17])
-------
-------	logger.Debug("Serialized data check",
-------		zap.Uint64("amount_in_check", amountInCheck),
-------		zap.Uint64("min_amount_out_check", minAmountOutCheck))
-------
-------	if amountInCheck != amountIn {
-------		logger.Error("AmountIn mismatch after serialization",
-------			zap.Uint64("original", amountIn),
-------			zap.Uint64("serialized", amountInCheck))
-------		return nil, fmt.Errorf("amountIn mismatch after serialization")
-------	}
-------
------+	// Create the instruction
------ 	instruction := solana.NewInstruction(ammProgramID, metas, data)
------ 
-------	logger.Debug("Created instruction",
------+	logger.Debug("Created swap instruction",
------ 		zap.Int("num_accounts", len(metas)),
------ 		zap.Int("data_len", len(data)))
------ 
------ 	return instruction, nil
------ }
------ 
-------// PrepareAndSendTransaction готовит и отправляет транзакцию свапа
------+// PrepareAndSendTransaction prepares and sends the swap transaction
------ func (r *DEX) PrepareAndSendTransaction(
------ 	ctx context.Context,
------ 	task *types.Task,
------@@ -299,23 +181,18 @@ func (r *DEX) PrepareAndSendTransaction(
------ 		return fmt.Errorf("failed to get recent blockhash: %w", err)
------ 	}
------ 
-------	// Создаем compute budget инструкции с использованием нового PriorityManager
-------	priorityManager := types.NewPriorityManager(logger)
-------	budgetInstructions, err := priorityManager.CreateCustomPriorityInstructions(
-------		uint64(task.PriorityFee*1e6), // Конвертируем SOL в микро-ламports
-------		1_000_000,                    // Используем sniping units
-------	)
-------	if err != nil {
-------		logger.Error("Failed to create compute budget instructions", zap.Error(err))
-------		return fmt.Errorf("failed to create compute budget instructions: %w", err)
-------	}
------+	// Create compute budget instruction if needed
------+	computeBudgetInst := computebudget.NewSetComputeUnitPriceInstruction(
------+		uint64(task.PriorityFee * 1e6), // Convert SOL to micro-lamports
------+	).Build()
------ 
-------	// Combine all instructions properly
-------	instructions := make([]solana.Instruction, 0, len(budgetInstructions)+1)
-------	instructions = append(instructions, budgetInstructions...)
-------	instructions = append(instructions, swapInstruction)
------+	// Combine all instructions
------+	instructions := []solana.Instruction{
------+		computeBudgetInst,
------+		swapInstruction,
------+	}
------ 
-------	// Создаем транзакцию
------+	// Create the transaction
------ 	tx, err := solana.NewTransaction(
------ 		instructions,
------ 		recentBlockhash,
------@@ -326,7 +203,7 @@ func (r *DEX) PrepareAndSendTransaction(
------ 		return fmt.Errorf("failed to create transaction: %w", err)
------ 	}
------ 
-------	// Подписываем транзакцию
------+	// Sign the transaction
------ 	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
------ 		if key.Equals(userWallet.PublicKey) {
------ 			return &userWallet.PrivateKey
------@@ -338,7 +215,7 @@ func (r *DEX) PrepareAndSendTransaction(
------ 		return fmt.Errorf("failed to sign transaction: %w", err)
------ 	}
------ 
-------	// Отправляем транзакцию
------+	// Send the transaction
------ 	signature, err := r.client.SendTransaction(ctx, tx)
------ 	if err != nil {
------ 		logger.Error("Failed to send transaction", zap.Error(err))
------@@ -347,8 +224,41 @@ func (r *DEX) PrepareAndSendTransaction(
------ 
------ 	logger.Info("Transaction sent successfully",
------ 		zap.String("signature", signature.String()),
-------		zap.Float64("priority_fee_sol", task.PriorityFee),
-------		zap.Uint64("compute_units", 1_000_000))
------+		zap.Float64("priority_fee_sol", task.PriorityFee))
------ 
------ 	return nil
------ }
------+
------+// validatePublicKey checks if a public key string is valid
------+func validatePublicKey(key string) (solana.PublicKey, error) {
------+	if key == "" {
------+		return solana.PublicKey{}, fmt.Errorf("empty public key")
------+	}
------+
------+	pubKey, err := solana.PublicKeyFromBase58(key)
------+	if err != nil {
------+		return solana.PublicKey{}, fmt.Errorf("invalid public key %s: %w", key, err)
------+	}
------+
------+	return pubKey, nil
------+}
------+
------+// Helper function to calculate minimum output considering slippage
------+func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
------+	if expectedOut <= 0 {
------+		return 1 // Minimum safe value
------+	}
------+
------+	// Consider slippage
------+	minOut := expectedOut * (1 - slippagePercent/100)
------+
------+	// Convert to uint64 and check for minimum value
------+	result := uint64(math.Floor(minOut))
------+	if result == 0 {
------+		return 1
------+	}
------+
------+	return result
------+}
------+
------+// You may want to include other helper functions or adjust existing ones as needed
------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
------index 001489f..7db11c6 100644
--------- a/internal/dex/raydium/types.go
------+++ b/internal/dex/raydium/types.go
------@@ -1,8 +1,13 @@
------ // internal/dex/raydium/types.go
------+
------ package raydium
------ 
------ import (
------+	"sync"
------+	"sync/atomic"
------+
------ 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
------+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
------ 	"go.uber.org/zap"
------ )
------ 
------@@ -25,6 +30,12 @@ type Pool struct {
------ 	SerumVaultSigner           string
------ 	RaydiumSwapInstructionCode uint8
------ }
------+type PoolState struct {
------+	TokenAReserve uint64
------+	TokenBReserve uint64
------+	SwapFee       float64 // в процентах
------+	CurrentPrice  float64 // текущая цена пула
------+}
------ 
------ // SwapInstructionData представляет данные инструкции свапа
------ type SwapInstructionData struct {
------@@ -33,32 +44,60 @@ type SwapInstructionData struct {
------ 	MinAmountOut uint64 // Минимальная исходящая сумма
------ }
------ type DEX struct {
-------	client   blockchain.Client // изменяем тип на интерфейс.
-------	logger   *zap.Logger
-------	poolInfo *Pool
-------	slippage float64 // Добавляем поле для slippage
------+	client         blockchain.Client
------+	logger         *zap.Logger
------+	poolInfo       *Pool
------+	slippage       float64
------+	tokenCache     *solbc.TokenMetadataCache
------+	priceValidator PriceValidator
------+	lastPoolState  atomic.Value // Используем atomic.Value для потокобезопасного доступа
------+	stateMutex     sync.RWMutex // Мьютекс для дополнительной синхронизации при необходимости
------ }
------ 
-------func (r *Pool) GetProgramID() string {
-------	return r.AmmProgramID
------+// setLastPoolState безопасно обновляет состояние пула
------+func (r *DEX) setLastPoolState(state *PoolState) {
------+	r.lastPoolState.Store(state)
------ }
------ 
-------func (r *Pool) GetPoolID() string {
-------	return r.AmmID
------+// getLastPoolState безопасно получает состояние пула
------+func (r *DEX) getLastPoolState() *PoolState {
------+	return r.lastPoolState.Load().(*PoolState)
------ }
------ 
-------func (r *Pool) GetTokenAccounts() (string, string) {
-------	return r.PoolCoinTokenAccount, r.PoolPcTokenAccount
------+// UpdatePoolState обновляет состояние пула с дополнительной синхронизацией
------+func (r *DEX) UpdatePoolState(state *PoolState) {
------+	r.stateMutex.Lock()
------+	defer r.stateMutex.Unlock()
------+
------+	r.setLastPoolState(state)
------+
------+	// Логируем обновление состояния
------+	r.logger.Debug("Pool state updated",
------+		zap.Float64("current_price", state.CurrentPrice),
------+		zap.Uint64("token_a_reserve", state.TokenAReserve),
------+		zap.Uint64("token_b_reserve", state.TokenBReserve))
------+}
------+
------+// GetPoolStateSnapshot получает снапшот текущего состояния пула
------+func (r *DEX) GetPoolStateSnapshot() *PoolState {
------+	r.stateMutex.RLock()
------+	defer r.stateMutex.RUnlock()
------+
------+	state := r.getLastPoolState()
------+	if state == nil {
------+		return nil
------+	}
------+
------+	// Возвращаем копию состояния
------+	return &PoolState{
------+		TokenAReserve: state.TokenAReserve,
------+		TokenBReserve: state.TokenBReserve,
------+		SwapFee:       state.SwapFee,
------+		CurrentPrice:  state.CurrentPrice,
------+	}
------ }
------ 
------ // Name возвращает имя DEX
------ func (r *DEX) Name() string {
------ 	return "Raydium"
------ }
-------
-------// PoolState содержит состояние пула ликвидности
-------type PoolState struct {
-------	TokenAReserve uint64
-------	TokenBReserve uint64
-------	SwapFee       float64 // в процентах
-------}
------diff --git a/newdif.txt b/newdif.txt
------index cc2c079..c7ae03d 100644
--------- a/newdif.txt
------+++ b/newdif.txt
------@@ -1,1340 +0,0 @@
-------diff --git a/TODO.md b/TODO.md
-------index 5b1d499..34aab1e 100644
---------- a/TODO.md
-------+++ b/TODO.md
-------@@ -264,3 +264,8 @@
-------     - [ ] Например, прогнозирование цен, анализ рынка и т.д.
------- - [ ] Рассмотреть возможность масштабирования
-------     - [ ] Настроить приложение для работы в распределенной среде.
-------+
-------+
-------+TODO: Оптимизация работы с ATA (Associated Token Accounts)
-------+1. Этап подготовки и архитектуры
-------+
-------diff --git a/configs/tasks.csv b/configs/tasks.csv
-------index 33e5da0..bbc2c6d 100644
---------- a/configs/tasks.csv
-------+++ b/configs/tasks.csv
-------@@ -1,2 +1,2 @@
------- TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,MinAmountOut,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
--------buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
-------\ No newline at end of file
-------+buyTokens,Raydium,1,wallet1,100,0.0001,58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
-------\ No newline at end of file
-------diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
-------index 75b6e0d..bcfeacc 100644
---------- a/internal/blockchain/solbc/client.go
-------+++ b/internal/blockchain/solbc/client.go
-------@@ -64,3 +64,6 @@ func (c *Client) Close() error {
------- 	c.rpc.Close()
------- 	return nil
------- }
-------+func (c *Client) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
-------+	return c.rpc.GetSignatureStatuses(ctx, signatures...)
-------+}
-------diff --git a/internal/blockchain/solbc/rpc/rpc.go b/internal/blockchain/solbc/rpc/rpc.go
-------index ee4c137..ac6f2c4 100644
---------- a/internal/blockchain/solbc/rpc/rpc.go
-------+++ b/internal/blockchain/solbc/rpc/rpc.go
-------@@ -144,5 +144,16 @@ func (c *RPCClient) SendTransaction(ctx context.Context, tx *solana.Transaction)
------- 	return signature, err
------- }
------- 
-------+// Добавляем новый метод в RPCClient
-------+func (c *RPCClient) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
-------+	var result *solanarpc.GetSignatureStatusesResult
-------+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
-------+		var err error
-------+		result, err = client.GetSignatureStatuses(ctx, false, signatures...)
-------+		return err
-------+	})
-------+	return result, err
-------+}
-------+
------- // Close закрывает клиент
------- func (c *RPCClient) Close() {}
-------diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
-------index cc61a29..42debad 100644
---------- a/internal/blockchain/solbc/types.go
-------+++ b/internal/blockchain/solbc/types.go
-------@@ -19,7 +19,7 @@ type TokenMetadataCache struct {
------- 
------- // Client представляет основной клиент Solana
------- type Client struct {
--------	rpc     *rpc.RPCClient // Меняем тип с enhancedRPC на RPCClient
-------+	rpc     *rpc.RPCClient
------- 	logger  *zap.Logger
------- 	metrics *ClientMetrics
------- }
-------diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
-------index 2690c82..202b59a 100644
---------- a/internal/blockchain/types.go
-------+++ b/internal/blockchain/types.go
-------@@ -13,4 +13,5 @@ type Client interface {
------- 	GetRecentBlockhash(ctx context.Context) (solana.Hash, error)
------- 	SendTransaction(ctx context.Context, tx *solana.Transaction) (solana.Signature, error)
------- 	GetAccountInfo(ctx context.Context, pubkey solana.PublicKey) (*rpc.GetAccountInfoResult, error)
-------+	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
------- }
-------diff --git a/internal/dex/dex.go b/internal/dex/dex.go
-------index 5aebaa7..9b9fb16 100644
---------- a/internal/dex/dex.go
-------+++ b/internal/dex/dex.go
-------@@ -1,62 +1,79 @@
--------// internal/dex/dex.go
------- package dex
------- 
------- import (
--------	"errors"
------- 	"fmt"
------- 	"strings"
------- 
------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
-------+	"github.com/rovshanmuradov/solana-bot/internal/dex/pumpfun"
------- 	"github.com/rovshanmuradov/solana-bot/internal/dex/raydium"
------- 	"github.com/rovshanmuradov/solana-bot/internal/types"
------- 	"go.uber.org/zap"
------- )
------- 
-------+// GetDEXByName возвращает имплементацию DEX по имени
------- func GetDEXByName(name string, client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
--------	logger = logger.With(zap.String("dex_name", name))
--------	logger.Info("Getting DEX by name")
--------	fmt.Printf("\n=== Getting DEX by name: %s ===\n", name)
-------+	if client == nil {
-------+		return nil, fmt.Errorf("client cannot be nil")
-------+	}
------- 
------- 	if logger == nil {
--------		fmt.Println("Logger is nil")
--------		return nil, errors.New("logger is nil")
-------+		return nil, fmt.Errorf("logger cannot be nil")
------- 	}
------- 
--------	name = strings.TrimSpace(name)
-------+	name = strings.TrimSpace(strings.ToLower(name))
------- 	if name == "" {
--------		fmt.Println("DEX name is empty")
--------		return nil, errors.New("DEX name cannot be empty")
-------+		return nil, fmt.Errorf("DEX name cannot be empty")
------- 	}
------- 
--------	fmt.Printf("Client nil? %v\n", client == nil)
-------+	logger = logger.With(zap.String("dex_name", name))
-------+	logger.Info("Initializing DEX instance")
------- 
--------	if client == nil {
--------		fmt.Println("Solana client is nil")
--------		return nil, errors.New("solana client cannot be nil")
-------+	switch name {
-------+	case "raydium":
-------+		return initializeRaydiumDEX(client, logger)
-------+	case "pump.fun":
-------+		return initializePumpFunDEX(client, logger)
-------+	default:
-------+		logger.Error("Unsupported DEX requested", zap.String("name", name))
-------+		return nil, fmt.Errorf("unsupported DEX: %s", name)
------- 	}
-------+}
------- 
--------	switch strings.ToLower(name) {
--------	case strings.ToLower("Raydium"):
--------		fmt.Println("Creating Raydium DEX instance")
-------+// initializeRaydiumDEX инициализирует Raydium DEX
-------+func initializeRaydiumDEX(client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
-------+	logger.Debug("Initializing Raydium DEX")
------- 
--------		if raydium.DefaultPoolConfig == nil {
--------			fmt.Println("Default pool config is nil")
--------			return nil, errors.New("default pool config is nil")
--------		}
-------+	if raydium.DefaultPoolConfig == nil {
-------+		logger.Error("Default pool configuration is missing")
-------+		return nil, fmt.Errorf("raydium default pool config is nil")
-------+	}
------- 
--------		fmt.Printf("Pool config: %+v\n", raydium.DefaultPoolConfig)
-------+	logger.Debug("Creating Raydium DEX instance",
-------+		zap.String("pool_id", raydium.DefaultPoolConfig.AmmID),
-------+		zap.String("program_id", raydium.DefaultPoolConfig.AmmProgramID))
------- 
--------		dex := raydium.NewDEX(client, logger, raydium.DefaultPoolConfig)
--------		if dex == nil {
--------			fmt.Println("Failed to create Raydium DEX instance")
--------			return nil, errors.New("failed to create Raydium DEX instance")
--------		}
-------+	dex := raydium.NewDEX(client, logger, raydium.DefaultPoolConfig)
-------+	if dex == nil {
-------+		logger.Error("Failed to create Raydium DEX instance")
-------+		return nil, fmt.Errorf("failed to create Raydium DEX instance")
-------+	}
------- 
--------		fmt.Printf("DEX created: %+v\n", dex)
--------		return dex, nil
-------+	logger.Info("Raydium DEX initialized successfully")
-------+	return dex, nil
-------+}
------- 
--------	default:
--------		fmt.Printf("Unsupported DEX: %s\n", name)
--------		return nil, fmt.Errorf("unsupported DEX: %s", name)
-------+// initializePumpFunDEX инициализирует Pump.fun DEX
-------+func initializePumpFunDEX(_ blockchain.Client, logger *zap.Logger) (types.DEX, error) {
-------+	logger.Debug("Initializing Pump.fun DEX")
-------+
-------+	// Создаем новый экземпляр Pump.fun DEX
-------+	dex := pumpfun.NewDEX()
-------+	if dex == nil {
-------+		logger.Error("Failed to create Pump.fun DEX instance")
-------+		return nil, fmt.Errorf("failed to create Pump.fun DEX instance")
------- 	}
-------+
-------+	logger.Info("Pump.fun DEX initialized successfully")
-------+	return dex, nil
------- }
-------diff --git a/internal/dex/pumpfun/pumpfun.go b/internal/dex/pumpfun/pumpfun.go
-------index 83e62de..a1450ec 100644
---------- a/internal/dex/pumpfun/pumpfun.go
-------+++ b/internal/dex/pumpfun/pumpfun.go
-------@@ -1,4 +1,3 @@
--------// internal/dex/pumpfun/pumpfun.go
------- package pumpfun
------- 
------- import (
-------@@ -30,7 +29,6 @@ func (p *DEX) PrepareSwapInstruction(
------- 	_ solana.PublicKey,
------- 	_ solana.PublicKey,
------- 	_ uint64,
--------	_ uint64,
------- 	_ *zap.Logger,
------- ) (solana.Instruction, error) {
------- 	return nil, fmt.Errorf("pump.fun DEX implementation not ready")
-------diff --git a/internal/dex/raydium/config.go b/internal/dex/raydium/config.go
-------index acf9464..cb0c21b 100644
---------- a/internal/dex/raydium/config.go
-------+++ b/internal/dex/raydium/config.go
-------@@ -7,7 +7,7 @@ var DefaultPoolConfig = &Pool{
------- 	AmmProgramID: "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",
------- 
------- 	// Актуальная конфигурация для SOL-USDC пула
--------	AmmID:                "EVzLJhqMtfPHFp5piYSeXqx5cY6hLbrE8oRR5Zrm1YaT",
-------+	AmmID:                "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
------- 	AmmAuthority:         "3uaZBfHPfmpAHW7dsimC1SnyR61X4bJqQZKWmRSCXJxv",
------- 	AmmOpenOrders:        "4NfmERReGt1QCKey8cH5q4LsBYJoUcsuGg11J8GQFwH8",
------- 	AmmTargetOrders:      "38RJcGjtgd4SKRfY2dcM8Z9LzXQR6cyZeGxvjrRsVGZD",
-------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
-------index bcd26a9..8e2c6c3 100644
---------- a/internal/dex/raydium/raydium.go
-------+++ b/internal/dex/raydium/raydium.go
-------@@ -9,9 +9,12 @@ import (
------- 	"math"
------- 	"time"
------- 
-------+	bin "github.com/gagliardetto/binary"
------- 	"github.com/gagliardetto/solana-go"
------- 	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
------- 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
-------+	"github.com/gagliardetto/solana-go/programs/token"
-------+	solanarpc "github.com/gagliardetto/solana-go/rpc"
------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
------- 	"github.com/rovshanmuradov/solana-bot/internal/types"
------- 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
-------@@ -93,7 +96,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
------- 	}
------- 
------- 	// Отправляем транзакцию
--------	signature, err := r.sendTransactionWithRetry(swapCtx, userWallet, instructions, logger)
-------+	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
------- 	if err != nil {
------- 		return fmt.Errorf("failed to send swap transaction: %w", err)
------- 	}
-------@@ -140,91 +143,139 @@ func (r *DEX) ensureATA(
------- 	ataType string,
------- 	logger *zap.Logger,
------- ) error {
--------	account, err := r.client.GetAccountInfo(ctx, ata)
-------+	logger = logger.With(
-------+		zap.String("mint", mint.String()),
-------+		zap.String("ata", ata.String()),
-------+		zap.String("wallet", wallet.PublicKey.String()),
-------+	)
-------+
-------+	// Проверяем существование ATA с повторными попытками
-------+	exists, err := r.checkATAExists(ctx, ata, logger)
------- 	if err != nil {
------- 		return fmt.Errorf("failed to check %s ATA: %w", ataType, err)
------- 	}
------- 
--------	if account.Value == nil {
--------		logger.Debug("Creating ATA", zap.String("type", ataType), zap.String("address", ata.String()))
--------
--------		instruction := associatedtokenaccount.NewCreateInstruction(
--------			wallet.PublicKey,
--------			wallet.PublicKey,
--------			mint,
--------		).Build()
-------+	if !exists {
-------+		logger.Debug("Creating new ATA")
-------+		// Используем правильное создание инструкции из solana-go
-------+		instruction, err := r.createATAInstruction(wallet, mint)
-------+		if err != nil {
-------+			return fmt.Errorf("failed to create %s ATA instruction: %w", ataType, err)
-------+		}
------- 
--------		if err := r.sendATATransaction(ctx, wallet, instruction); err != nil {
-------+		// Отправляем транзакцию и ждем подтверждения
-------+		signature, err := r.sendTransactionWithRetryAndConfirmation(ctx, wallet, []solana.Instruction{instruction}, logger)
-------+		if err != nil {
------- 			return fmt.Errorf("failed to create %s ATA: %w", ataType, err)
------- 		}
------- 
--------		logger.Debug("ATA created successfully", zap.String("type", ataType))
-------+		logger.Info("ATA created successfully",
-------+			zap.String("signature", signature.String()))
-------+
-------+		// Ждем появления аккаунта
-------+		if err := r.waitForATACreation(ctx, ata, logger); err != nil {
-------+			return fmt.Errorf("failed to confirm %s ATA creation: %w", ataType, err)
-------+		}
------- 	}
------- 
------- 	return nil
------- }
------- 
--------// Добавляем метод sendATATransaction
--------func (r *DEX) sendATATransaction(ctx context.Context, wallet *wallet.Wallet, instruction solana.Instruction) error {
--------	logger := r.logger.With(
--------		zap.String("wallet", wallet.PublicKey.String()),
--------		zap.String("operation", "create_ata"),
-------+func (r *DEX) checkATAExists(
-------+	ctx context.Context,
-------+	ata solana.PublicKey,
-------+	logger *zap.Logger,
-------+) (bool, error) {
-------+	for attempt := 0; attempt < maxRetries; attempt++ {
-------+		account, err := r.client.GetAccountInfo(ctx, ata)
-------+		if err == nil && account.Value != nil {
-------+			// Проверяем, что владелец - TokenProgram
-------+			return account.Value.Owner == solana.TokenProgramID, nil
-------+		}
-------+
-------+		if attempt < maxRetries-1 {
-------+			select {
-------+			case <-ctx.Done():
-------+				return false, ctx.Err()
-------+			case <-time.After(retryDelay):
-------+				logger.Debug("Retrying ATA check", zap.Int("attempt", attempt+1))
-------+			}
-------+		}
-------+	}
-------+	return false, nil
-------+}
-------+
-------+func (r *DEX) createATAInstruction(
-------+	wallet *wallet.Wallet,
-------+	mint solana.PublicKey,
-------+) (solana.Instruction, error) {
-------+	// Используем билдер из solana-go
-------+	inst := associatedtokenaccount.NewCreateInstruction(
-------+		wallet.PublicKey, // payer
-------+		wallet.PublicKey, // wallet address
-------+		mint,             // token mint
------- 	)
------- 
--------	var lastErr error
--------	for attempt := 0; attempt < maxRetries; attempt++ {
-------+	// Проводим валидацию
-------+	if err := inst.Validate(); err != nil {
-------+		return nil, fmt.Errorf("invalid ATA instruction: %w", err)
-------+	}
-------+
-------+	return inst.Build(), nil
-------+}
-------+
-------+func (r *DEX) waitForATACreation(
-------+	ctx context.Context,
-------+	ata solana.PublicKey,
-------+	logger *zap.Logger,
-------+) error {
-------+	// Увеличиваем время ожидания до 2 минут
-------+	deadline := time.Now().Add(2 * time.Minute)
-------+	// Начальный интервал проверки
-------+	ticker := time.NewTicker(2 * time.Second)
-------+	defer ticker.Stop()
-------+
-------+	retryCount := 0
-------+	maxRetries := 60 // Максимальное количество попыток
-------+
-------+	for {
-------+		if time.Now().After(deadline) {
-------+			return fmt.Errorf("timeout waiting for ATA creation after 2 minutes")
-------+		}
-------+
-------+		if retryCount >= maxRetries {
-------+			return fmt.Errorf("exceeded maximum retry attempts (%d) waiting for ATA creation", maxRetries)
-------+		}
-------+
------- 		select {
------- 		case <-ctx.Done():
------- 			return ctx.Err()
--------		default:
--------			recent, err := r.client.GetRecentBlockhash(ctx)
-------+		case <-ticker.C:
-------+			account, err := r.client.GetAccountInfo(ctx, ata)
------- 			if err != nil {
--------				lastErr = fmt.Errorf("failed to get recent blockhash: %w", err)
-------+				logger.Debug("ATA verification attempt failed",
-------+					zap.Error(err),
-------+					zap.Int("retry", retryCount),
-------+					zap.Time("deadline", deadline))
-------+				retryCount++
------- 				continue
------- 			}
------- 
--------			tx, err := solana.NewTransaction(
--------				[]solana.Instruction{instruction},
--------				recent,
--------				solana.TransactionPayer(wallet.PublicKey),
--------			)
--------			if err != nil {
--------				lastErr = fmt.Errorf("failed to create ATA transaction: %w", err)
--------				continue
--------			}
--------
--------			_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
--------				if key.Equals(wallet.PublicKey) {
--------					return &wallet.PrivateKey
--------				}
-------+			if account.Value != nil && account.Value.Owner == solana.TokenProgramID {
-------+				logger.Info("ATA creation confirmed",
-------+					zap.String("ata", ata.String()),
-------+					zap.Int("retries", retryCount))
------- 				return nil
--------			})
--------			if err != nil {
--------				lastErr = fmt.Errorf("failed to sign ATA transaction: %w", err)
--------				continue
------- 			}
------- 
--------			sig, err := r.client.SendTransaction(ctx, tx)
--------			if err != nil {
--------				lastErr = err
--------				logger.Warn("Failed to send ATA transaction, retrying",
--------					zap.Int("attempt", attempt+1),
--------					zap.Error(err))
--------				time.Sleep(retryDelay)
--------				continue
--------			}
--------
--------			logger.Debug("ATA transaction sent successfully",
--------				zap.String("signature", sig.String()))
--------			return nil
-------+			logger.Debug("ATA not ready yet",
-------+				zap.String("ata", ata.String()),
-------+				zap.Int("retry", retryCount))
-------+			retryCount++
------- 		}
------- 	}
--------
--------	return fmt.Errorf("failed to send ATA transaction after %d attempts: %w", maxRetries, lastErr)
------- }
------- 
--------// internal/dex/raydium/raydium.go
--------
------- // PrepareSwapInstructions объединяет все инструкции для свапа
------- func (r *DEX) PrepareSwapInstructions(
------- 	ctx context.Context,
-------@@ -343,24 +394,19 @@ func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.
------- 		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
------- 	}
------- 
--------	if account.Value == nil || len(account.Value.Data.GetBinary()) < 32 {
-------+	if account.Value == nil || len(account.Value.Data.GetBinary()) < 64 {
------- 		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
------- 	}
------- 
--------	data := account.Value.Data.GetBinary()[:32]
--------	if len(data) != 32 {
--------		return solana.PublicKey{}, fmt.Errorf("invalid public key length: expected 32 bytes, got %d", len(data))
-------+	var tokenAccount token.Account
-------+	if err := bin.NewBinDecoder(account.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
-------+		return solana.PublicKey{}, fmt.Errorf("failed to decode ATA data: %w", err)
------- 	}
------- 
--------	pubkey := solana.PublicKeyFromBytes(data)
--------	if pubkey.IsZero() {
--------		return solana.PublicKey{}, fmt.Errorf("invalid zero public key")
--------	}
--------
--------	return pubkey, nil
-------+	return tokenAccount.Mint, nil
------- }
------- 
--------func (r *DEX) sendTransactionWithRetry(
-------+func (r *DEX) sendTransactionWithRetryAndConfirmation(
------- 	ctx context.Context,
------- 	wallet *wallet.Wallet,
------- 	instructions []solana.Instruction,
-------@@ -373,14 +419,44 @@ func (r *DEX) sendTransactionWithRetry(
------- 			return solana.Signature{}, ctx.Err()
------- 		default:
------- 			signature, err := r.sendTransaction(ctx, wallet, instructions)
--------			if err == nil {
--------				return signature, nil
-------+			if err != nil {
-------+				lastErr = err
-------+				logger.Warn("Retrying transaction send",
-------+					zap.Int("attempt", attempt+1),
-------+					zap.Error(err))
-------+				time.Sleep(retryDelay)
-------+				continue
-------+			}
-------+
-------+			// Ждем подтверждения транзакции
-------+			logger.Debug("Waiting for transaction confirmation",
-------+				zap.String("signature", signature.String()))
-------+
-------+			// Ждем подтверждения с таймаутом
-------+			confirmCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
-------+			defer cancel()
-------+
-------+			for {
-------+				select {
-------+				case <-confirmCtx.Done():
-------+					return signature, fmt.Errorf("timeout waiting for transaction confirmation")
-------+				case <-time.After(time.Second):
-------+					// Проверяем статус транзакции
-------+					status, err := r.getTransactionStatus(ctx, signature)
-------+					if err != nil {
-------+						logger.Debug("Failed to get transaction status", zap.Error(err))
-------+						continue
-------+					}
-------+
-------+					// Проверяем подтверждение
-------+					if status.Confirmations >= 1 || status.Status == "finalized" {
-------+						logger.Debug("Transaction confirmed",
-------+							zap.String("status", status.Status),
-------+							zap.Uint64("confirmations", status.Confirmations))
-------+						return signature, nil
-------+					}
-------+				}
------- 			}
--------			lastErr = err
--------			logger.Warn("Retrying transaction send",
--------				zap.Int("attempt", attempt+1),
--------				zap.Error(err))
--------			time.Sleep(retryDelay)
------- 		}
------- 	}
------- 	return solana.Signature{}, fmt.Errorf("failed after %d attempts: %w", maxRetries, lastErr)
-------@@ -452,7 +528,7 @@ func (r *DEX) getExpectedOutput(
------- 	poolInfo *Pool,
------- 	logger *zap.Logger,
------- ) (float64, error) {
--------	// Создаем контекст с таймаутом
-------+	// Создаем контекст с тайм-аутом
------- 	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
------- 	defer cancel()
------- 
-------@@ -557,3 +633,50 @@ func (r *DEX) GetAmountOutQuote(
------- 
------- 	return expectedOut, nil
------- }
-------+
-------+// TransactionStatus представляет статус транзакции
-------+type TransactionStatus struct {
-------+	Status        string
-------+	Confirmations uint64
-------+	Error         interface{}
-------+	Slot          uint64
-------+}
-------+
-------+// getConfirmations получает количество подтверждений из результата статуса
-------+func getConfirmations(status *solanarpc.SignatureStatusesResult) uint64 {
-------+	if status == nil {
-------+		return 0
-------+	}
-------+
-------+	if status.Confirmations == nil {
-------+		if status.ConfirmationStatus == solanarpc.ConfirmationStatusFinalized {
-------+			return math.MaxUint64 // Максимальное значение для финализированных транзакций
-------+		}
-------+		return 0
-------+	}
-------+	return *status.Confirmations
-------+}
-------+
-------+// getTransactionStatus получает полный статус транзакции
-------+func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signature) (*TransactionStatus, error) {
-------+	result, err := r.client.GetSignatureStatuses(ctx, signature)
-------+	if err != nil {
-------+		return nil, fmt.Errorf("failed to get signature status: %w", err)
-------+	}
-------+
-------+	if result == nil || len(result.Value) == 0 || result.Value[0] == nil {
-------+		return &TransactionStatus{
-------+			Status: "pending",
-------+		}, nil
-------+	}
-------+
-------+	status := result.Value[0]
-------+	confirmations := getConfirmations(status)
-------+
-------+	return &TransactionStatus{
-------+		Status:        string(status.ConfirmationStatus),
-------+		Confirmations: confirmations,
-------+		Error:         status.Err,
-------+		Slot:          status.Slot,
-------+	}, nil
-------+}
-------diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
-------index 85d91eb..cf37967 100644
---------- a/internal/dex/raydium/transaction.go
-------+++ b/internal/dex/raydium/transaction.go
-------@@ -1,10 +1,10 @@
------- package raydium
------- 
------- import (
--------	"bytes"
------- 	"context"
------- 	"encoding/binary"
------- 	"fmt"
-------+	"testing"
------- 
------- 	"github.com/gagliardetto/solana-go"
------- 	"github.com/rovshanmuradov/solana-bot/internal/types"
-------@@ -13,23 +13,71 @@ import (
------- )
------- 
------- // Serialize сериализует данные инструкции свапа
--------// Метод Serialize нужно обновить для корректной работы с uint8
------- func (s *SwapInstructionData) Serialize() ([]byte, error) {
--------	buf := new(bytes.Buffer)
-------+	data := make([]byte, 17)
------- 
--------	// Записываем Instruction как uint8
--------	if err := buf.WriteByte(s.Instruction); err != nil {
--------		return nil, fmt.Errorf("failed to serialize instruction: %w", err)
-------+	// Instruction (1 byte)
-------+	data[0] = s.Instruction
-------+
-------+	// AmountIn (8 bytes)
-------+	binary.LittleEndian.PutUint64(data[1:9], s.AmountIn)
-------+
-------+	// MinAmountOut (8 bytes)
-------+	binary.LittleEndian.PutUint64(data[9:17], s.MinAmountOut)
-------+
-------+	return data, nil
-------+}
-------+
-------+// TestSwapInstructionDataSerialization тест для проверки сериализации
-------+func TestSwapInstructionDataSerialization(t *testing.T) {
-------+	inst := &SwapInstructionData{
-------+		Instruction:  1,
-------+		AmountIn:     20000000,
-------+		MinAmountOut: 6,
------- 	}
------- 
--------	// Записываем AmountIn и MinAmountOut как uint64
--------	for _, v := range []uint64{s.AmountIn, s.MinAmountOut} {
--------		if err := binary.Write(buf, binary.LittleEndian, v); err != nil {
--------			return nil, fmt.Errorf("failed to serialize value: %w", err)
--------		}
-------+	data, err := inst.Serialize()
-------+	if err != nil {
-------+		t.Fatalf("Failed to serialize: %v", err)
------- 	}
------- 
--------	return buf.Bytes(), nil
-------+	// Проверяем instruction code
-------+	if data[0] != 1 {
-------+		t.Errorf("Expected instruction 1, got %d", data[0])
-------+	}
-------+
-------+	// Проверяем amountIn
-------+	gotAmountIn := binary.LittleEndian.Uint64(data[1:9])
-------+	if gotAmountIn != 20000000 {
-------+		t.Errorf("Expected amountIn 20000000, got %d", gotAmountIn)
-------+	}
-------+
-------+	// Проверяем minAmountOut
-------+	gotMinAmountOut := binary.LittleEndian.Uint64(data[9:17])
-------+	if gotMinAmountOut != 6 {
-------+		t.Errorf("Expected minAmountOut 6, got %d", gotMinAmountOut)
-------+	}
-------+}
-------+
-------+// Debug выводит шестнадцатеричное представление данных
-------+func (s *SwapInstructionData) Debug(logger *zap.Logger) {
-------+	data, err := s.Serialize()
-------+	if err != nil {
-------+		logger.Error("Failed to serialize for debug", zap.Error(err))
-------+		return
-------+	}
-------+
-------+	// Проверяем данные
-------+	amountIn := binary.LittleEndian.Uint64(data[1:9])
-------+	minAmountOut := binary.LittleEndian.Uint64(data[9:17])
-------+
-------+	logger.Debug("Instruction data debug",
-------+		zap.Uint8("instruction", data[0]),
-------+		zap.Uint64("amount_in_original", s.AmountIn),
-------+		zap.Uint64("amount_in_serialized", amountIn),
-------+		zap.Uint64("min_amount_out_original", s.MinAmountOut),
-------+		zap.Uint64("min_amount_out_serialized", minAmountOut),
-------+		zap.Binary("raw_data", data))
------- }
------- 
------- // validatePublicKey проверяет корректность публичного ключа
-------@@ -74,91 +122,125 @@ func (r *DEX) CreateSwapInstruction(
------- 		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
------- 	}
------- 
--------	ammID, err := validatePublicKey(poolInfo.AmmID)
--------	if err != nil {
--------		logger.Error("Invalid AmmID", zap.Error(err))
--------		return nil, fmt.Errorf("invalid AmmID: %w", err)
--------	}
--------
--------	// Создаем массив для всех аккаунтов, которые нужно проверить
--------	accountChecks := []struct {
--------		name    string
--------		address string
--------	}{
--------		{"AmmAuthority", poolInfo.AmmAuthority},
--------		{"AmmOpenOrders", poolInfo.AmmOpenOrders},
--------		{"AmmTargetOrders", poolInfo.AmmTargetOrders},
--------		{"PoolCoinTokenAccount", poolInfo.PoolCoinTokenAccount},
--------		{"PoolPcTokenAccount", poolInfo.PoolPcTokenAccount},
--------		{"SerumProgramID", poolInfo.SerumProgramID},
--------		{"SerumMarket", poolInfo.SerumMarket},
--------		{"SerumBids", poolInfo.SerumBids},
--------		{"SerumAsks", poolInfo.SerumAsks},
--------		{"SerumEventQueue", poolInfo.SerumEventQueue},
--------		{"SerumCoinVaultAccount", poolInfo.SerumCoinVaultAccount},
--------		{"SerumPcVaultAccount", poolInfo.SerumPcVaultAccount},
--------		{"SerumVaultSigner", poolInfo.SerumVaultSigner},
--------	}
--------
--------	// Создаем слайс для аккаунтов с предварительно выделенной памятью
--------	accounts := make([]*solana.AccountMeta, 0, len(accountChecks)+7) // +7 для базовых аккаунтов
--------
--------	// Добавляем базовые аккаунты
--------	accounts = append(accounts, []*solana.AccountMeta{
--------		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
--------		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
--------		{PublicKey: ammID, IsSigner: false, IsWritable: true},
--------	}...)
--------
--------	// Проверяем и добавляем остальные аккаунты
--------	for _, check := range accountChecks {
--------		pubKey, err := validatePublicKey(check.address)
-------+	// Проверяем и создаем все необходимые аккаунты
-------+	requiredAccounts := map[string]string{
-------+		"AmmID":                poolInfo.AmmID,
-------+		"AmmAuthority":         poolInfo.AmmAuthority,
-------+		"AmmOpenOrders":        poolInfo.AmmOpenOrders,
-------+		"AmmTargetOrders":      poolInfo.AmmTargetOrders,
-------+		"PoolCoinTokenAccount": poolInfo.PoolCoinTokenAccount,
-------+		"PoolPcTokenAccount":   poolInfo.PoolPcTokenAccount,
-------+		"SerumProgramID":       poolInfo.SerumProgramID,
-------+		"SerumMarket":          poolInfo.SerumMarket,
-------+		"SerumBids":            poolInfo.SerumBids,
-------+		"SerumAsks":            poolInfo.SerumAsks,
-------+		"SerumEventQueue":      poolInfo.SerumEventQueue,
-------+		"SerumCoinVault":       poolInfo.SerumCoinVaultAccount,
-------+		"SerumPcVault":         poolInfo.SerumPcVaultAccount,
-------+		"SerumVaultSigner":     poolInfo.SerumVaultSigner,
-------+	}
-------+
-------+	accounts := make(map[string]solana.PublicKey)
-------+	for name, address := range requiredAccounts {
-------+		pubKey, err := validatePublicKey(address)
------- 		if err != nil {
--------			logger.Error(fmt.Sprintf("Invalid %s", check.name),
--------				zap.String("address", check.address),
-------+			logger.Error(fmt.Sprintf("Invalid %s", name),
-------+				zap.String("address", address),
------- 				zap.Error(err))
--------			return nil, fmt.Errorf("invalid %s: %w", check.name, err)
-------+			return nil, fmt.Errorf("invalid %s: %w", name, err)
------- 		}
-------+		accounts[name] = pubKey
-------+	}
------- 
--------		isWritable := false
--------		switch check.name {
--------		case "AmmOpenOrders", "AmmTargetOrders", "PoolCoinTokenAccount",
--------			"PoolPcTokenAccount", "SerumMarket", "SerumBids", "SerumAsks",
--------			"SerumEventQueue", "SerumCoinVaultAccount", "SerumPcVaultAccount":
--------			isWritable = true
--------		}
-------+	// Создаем слайс аккаунтов в правильном порядке для Raydium
-------+	metas := make(solana.AccountMetaSlice, 0, 20)
------- 
--------		accounts = append(accounts, &solana.AccountMeta{
--------			PublicKey:  pubKey,
--------			IsSigner:   false,
--------			IsWritable: isWritable,
--------		})
--------	}
-------+	// Токен аккаунты пользователя
-------+	metas = append(metas,
-------+		&solana.AccountMeta{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
-------+	)
-------+
-------+	// Аккаунты AMM
-------+	metas = append(metas,
-------+		&solana.AccountMeta{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
-------+		&solana.AccountMeta{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
-------+	)
-------+
-------+	// Аккаунты Serum
-------+	metas = append(metas,
-------+		&solana.AccountMeta{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
-------+		&solana.AccountMeta{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
-------+		&solana.AccountMeta{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
-------+	)
------- 
--------	// Добавляем системные аккаунты
--------	accounts = append(accounts, []*solana.AccountMeta{
--------		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
--------		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
--------		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
--------		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
--------	}...)
-------+	// Системные аккаунты
-------+	metas = append(metas,
-------+		&solana.AccountMeta{PublicKey: userWallet, IsSigner: true, IsWritable: false},
-------+		&solana.AccountMeta{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
-------+		&solana.AccountMeta{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
-------+		&solana.AccountMeta{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
-------+	)
------- 
------- 	// Создание данных инструкции
--------	instructionData := SwapInstructionData{
-------+	instructionData := &SwapInstructionData{
------- 		Instruction:  poolInfo.RaydiumSwapInstructionCode,
------- 		AmountIn:     amountIn,
------- 		MinAmountOut: minAmountOut,
------- 	}
------- 
-------+	// Добавляем отладочный вывод
-------+	instructionData.Debug(logger)
-------+
-------+	// Сериализация
------- 	data, err := instructionData.Serialize()
------- 	if err != nil {
--------		logger.Error("Failed to serialize instruction data", zap.Error(err))
-------+		logger.Error("Failed to serialize instruction data",
-------+			zap.Error(err),
-------+			zap.Uint8("instruction", instructionData.Instruction),
-------+			zap.Uint64("amount_in", instructionData.AmountIn),
-------+			zap.Uint64("min_amount_out", instructionData.MinAmountOut))
------- 		return nil, fmt.Errorf("failed to serialize instruction data: %w", err)
------- 	}
------- 
--------	instruction := solana.NewInstruction(ammProgramID, accounts, data)
-------+	// Проверка сериализованных данных
-------+	if len(data) != 17 {
-------+		logger.Error("Invalid serialized data length",
-------+			zap.Int("got_length", len(data)),
-------+			zap.Int("expected_length", 17))
-------+		return nil, fmt.Errorf("invalid serialized data length")
-------+	}
-------+
-------+	// Проверяем значения после сериализации
-------+	amountInCheck := binary.LittleEndian.Uint64(data[1:9])
-------+	minAmountOutCheck := binary.LittleEndian.Uint64(data[9:17])
-------+
-------+	logger.Debug("Serialized data check",
-------+		zap.Uint64("amount_in_check", amountInCheck),
-------+		zap.Uint64("min_amount_out_check", minAmountOutCheck))
-------+
-------+	if amountInCheck != amountIn {
-------+		logger.Error("AmountIn mismatch after serialization",
-------+			zap.Uint64("original", amountIn),
-------+			zap.Uint64("serialized", amountInCheck))
-------+		return nil, fmt.Errorf("amountIn mismatch after serialization")
-------+	}
-------+
-------+	instruction := solana.NewInstruction(ammProgramID, metas, data)
-------+
-------+	logger.Debug("Created instruction",
-------+		zap.Int("num_accounts", len(metas)),
-------+		zap.Int("data_len", len(data)))
------- 
--------	logger.Debug("Swap instruction created successfully")
------- 	return instruction, nil
------- }
------- 
-------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
-------index cd3089e..4cc1b1e 100644
---------- a/internal/dex/raydium/types.go
-------+++ b/internal/dex/raydium/types.go
-------@@ -27,11 +27,10 @@ type Pool struct {
------- }
------- 
------- // SwapInstructionData представляет данные инструкции свапа
--------// Обновляем также структуру инструкции
------- type SwapInstructionData struct {
--------	Instruction  uint8 // Изменено на uint8
--------	AmountIn     uint64
--------	MinAmountOut uint64
-------+	Instruction  uint8  // Тип инструкции
-------+	AmountIn     uint64 // Входящая сумма
-------+	MinAmountOut uint64 // Минимальная исходящая сумма
------- }
------- type DEX struct {
------- 	client   blockchain.Client // изменяем тип на интерфейс.
-------diff --git a/newdif.txt b/newdif.txt
-------index 073754f..a086373 100644
---------- a/newdif.txt
-------+++ b/newdif.txt
-------@@ -1,436 +0,0 @@
--------diff --git a/configs/tasks.csv b/configs/tasks.csv
--------index e44faa8..33e5da0 100644
----------- a/configs/tasks.csv
--------+++ b/configs/tasks.csv
--------@@ -1,2 +1,2 @@
-------- TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,MinAmountOut,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
---------buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,,,,,100,
--------\ No newline at end of file
--------+buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
--------\ No newline at end of file
--------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
--------index 1703360..bcd26a9 100644
----------- a/internal/dex/raydium/raydium.go
--------+++ b/internal/dex/raydium/raydium.go
--------@@ -4,6 +4,7 @@ package raydium
-------- 
-------- import (
-------- 	"context"
--------+	"encoding/binary"
-------- 	"fmt"
-------- 	"math"
-------- 	"time"
--------@@ -45,6 +46,8 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
-------- 	logger := r.logger.With(
-------- 		zap.String("task", task.TaskName),
-------- 		zap.String("wallet", userWallet.PublicKey.String()),
--------+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
--------+		zap.Float64("slippage_value", task.SlippageConfig.Value),
-------- 	)
-------- 	logger.Info("Starting swap execution")
-------- 
--------@@ -64,11 +67,12 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
-------- 
-------- 	// Подготавливаем amount с учетом decimals
-------- 	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
---------	minAmountOut := uint64(task.MinAmountOut * math.Pow10(task.TargetTokenDecimals))
-------- 
---------	logger.Debug("Prepared swap amounts",
--------+	logger.Debug("Prepared swap amount",
-------- 		zap.Uint64("amount_in", amountIn),
---------		zap.Uint64("min_amount_out", minAmountOut))
--------+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
--------+		zap.Float64("slippage_value", task.SlippageConfig.Value),
--------+	)
-------- 
-------- 	// Создаем инструкции с таймаутом
-------- 	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
--------@@ -81,7 +85,6 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
-------- 		sourceATA,
-------- 		targetATA,
-------- 		amountIn,
---------		minAmountOut,
-------- 		task.PriorityFee,
-------- 		logger,
-------- 	)
--------@@ -220,7 +223,8 @@ func (r *DEX) sendATATransaction(ctx context.Context, wallet *wallet.Wallet, ins
-------- 	return fmt.Errorf("failed to send ATA transaction after %d attempts: %w", maxRetries, lastErr)
-------- }
-------- 
---------// Добавляем метод PrepareSwapInstruction для соответствия интерфейсу types.DEX
--------+// internal/dex/raydium/raydium.go
--------+
-------- // PrepareSwapInstructions объединяет все инструкции для свапа
-------- func (r *DEX) PrepareSwapInstructions(
-------- 	ctx context.Context,
--------@@ -228,7 +232,6 @@ func (r *DEX) PrepareSwapInstructions(
-------- 	sourceATA solana.PublicKey,
-------- 	targetATA solana.PublicKey,
-------- 	amountIn uint64,
---------	minAmountOut uint64,
-------- 	priorityFee float64,
-------- 	logger *zap.Logger,
-------- ) ([]solana.Instruction, error) {
--------@@ -247,7 +250,6 @@ func (r *DEX) PrepareSwapInstructions(
-------- 		sourceATA,
-------- 		targetATA,
-------- 		amountIn,
---------		minAmountOut,
-------- 		logger,
-------- 	)
-------- 	if err != nil {
--------@@ -265,7 +267,6 @@ func (r *DEX) PrepareSwapInstruction(
-------- 	sourceATA solana.PublicKey,
-------- 	targetATA solana.PublicKey,
-------- 	amountIn uint64,
---------	minAmountOut uint64,
-------- 	logger *zap.Logger,
-------- ) (solana.Instruction, error) {
-------- 	logger = logger.With(
--------@@ -275,8 +276,34 @@ func (r *DEX) PrepareSwapInstruction(
-------- 	)
-------- 	logger.Debug("Preparing swap instruction")
-------- 
---------	// Создаем инструкцию свапа
---------	instruction, err := r.CreateSwapInstruction(
--------+	// Получаем ожидаемый выход
--------+	sourceMint, err := r.getMintFromATA(ctx, sourceATA)
--------+	if err != nil {
--------+		return nil, fmt.Errorf("failed to get source mint: %w", err)
--------+	}
--------+
--------+	targetMint, err := r.getMintFromATA(ctx, targetATA)
--------+	if err != nil {
--------+		return nil, fmt.Errorf("failed to get target mint: %w", err)
--------+	}
--------+
--------+	expectedOut, err := r.getExpectedOutput(
--------+		ctx,
--------+		amountIn,
--------+		sourceMint,
--------+		targetMint,
--------+		r.poolInfo,
--------+		logger,
--------+	)
--------+	if err != nil {
--------+		return nil, fmt.Errorf("failed to get expected output: %w", err)
--------+	}
--------+
--------+	// Используем безопасное значение minAmountOut по умолчанию (99% от ожидаемого выхода)
--------+	minAmountOut := uint64(float64(expectedOut) * 0.99)
--------+
--------+	// Создаем инструкцию свапа с помощью внутреннего метода createSwapInstruction
--------+	return r.createSwapInstruction(
-------- 		wallet,
-------- 		sourceATA,
-------- 		targetATA,
--------@@ -285,12 +312,52 @@ func (r *DEX) PrepareSwapInstruction(
-------- 		logger,
-------- 		r.poolInfo,
-------- 	)
--------+}
--------+
--------+// createSwapInstruction внутренний метод для создания инструкции свапа
--------+func (r *DEX) createSwapInstruction(
--------+	wallet solana.PublicKey,
--------+	sourceATA solana.PublicKey,
--------+	targetATA solana.PublicKey,
--------+	amountIn uint64,
--------+	minAmountOut uint64,
--------+	logger *zap.Logger,
--------+	poolInfo *Pool,
--------+) (solana.Instruction, error) {
--------+	// Существующая логика из CreateSwapInstruction
--------+	return r.CreateSwapInstruction(
--------+		wallet,
--------+		sourceATA,
--------+		targetATA,
--------+		amountIn,
--------+		minAmountOut,
--------+		logger,
--------+		poolInfo,
--------+	)
--------+}
--------+
--------+// Вспомогательный метод для получения mint address из ATA
--------+func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.PublicKey, error) {
--------+	account, err := r.client.GetAccountInfo(ctx, ata)
-------- 	if err != nil {
---------		return nil, fmt.Errorf("failed to create swap instruction: %w", err)
--------+		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
-------- 	}
-------- 
---------	logger.Debug("Swap instruction prepared successfully")
---------	return instruction, nil
--------+	if account.Value == nil || len(account.Value.Data.GetBinary()) < 32 {
--------+		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
--------+	}
--------+
--------+	data := account.Value.Data.GetBinary()[:32]
--------+	if len(data) != 32 {
--------+		return solana.PublicKey{}, fmt.Errorf("invalid public key length: expected 32 bytes, got %d", len(data))
--------+	}
--------+
--------+	pubkey := solana.PublicKeyFromBytes(data)
--------+	if pubkey.IsZero() {
--------+		return solana.PublicKey{}, fmt.Errorf("invalid zero public key")
--------+	}
--------+
--------+	return pubkey, nil
-------- }
-------- 
-------- func (r *DEX) sendTransactionWithRetry(
--------@@ -376,3 +443,117 @@ func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, sol
-------- 
-------- 	return sourceMint, targetMint, nil
-------- }
--------+
--------+// getExpectedOutput вычисляет ожидаемый выход для свапа
--------+func (r *DEX) getExpectedOutput(
--------+	ctx context.Context,
--------+	amountIn uint64,
--------+	sourceToken, targetToken solana.PublicKey,
--------+	poolInfo *Pool,
--------+	logger *zap.Logger,
--------+) (float64, error) {
--------+	// Создаем контекст с таймаутом
--------+	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
--------+	defer cancel()
--------+
--------+	logger = logger.With(
--------+		zap.String("source_token", sourceToken.String()),
--------+		zap.String("target_token", targetToken.String()),
--------+		zap.Uint64("amount_in", amountIn),
--------+	)
--------+
--------+	// Получаем состояние пула
--------+	poolState, err := r.getPoolState(ctx, poolInfo)
--------+	if err != nil {
--------+		return 0, fmt.Errorf("failed to get pool state: %w", err)
--------+	}
--------+
--------+	logger.Debug("Pool state retrieved",
--------+		zap.Uint64("token_a_reserve", poolState.TokenAReserve),
--------+		zap.Uint64("token_b_reserve", poolState.TokenBReserve),
--------+		zap.Float64("swap_fee", poolState.SwapFee))
--------+
--------+	// Вычисляем ожидаемый выход с учетом всех факторов
--------+	expectedOut := r.calculateExpectedOutput(amountIn, poolState)
--------+
--------+	logger.Debug("Expected output calculated",
--------+		zap.Float64("expected_out", expectedOut))
--------+
--------+	return expectedOut, nil
--------+}
--------+
--------+// getPoolState получает текущее состояние пула
--------+func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
--------+	// Получаем аккаунт пула
--------+	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
--------+	if err != nil {
--------+		return nil, fmt.Errorf("failed to get pool account: %w", err)
--------+	}
--------+
--------+	if poolAccount == nil || poolAccount.Value == nil {
--------+		return nil, fmt.Errorf("pool account not found")
--------+	}
--------+
--------+	// Парсим данные аккаунта
--------+	data := poolAccount.Value.Data.GetBinary()
--------+	if len(data) < 8+32*2 { // Минимальный размер для резервов
--------+		return nil, fmt.Errorf("invalid pool account data size")
--------+	}
--------+
--------+	// Извлекаем резервы из данных аккаунта
--------+	// Обратите внимание: это упрощенная версия, реальная структура данных может отличаться
--------+	tokenAReserve := binary.LittleEndian.Uint64(data[8:16])
--------+	tokenBReserve := binary.LittleEndian.Uint64(data[16:24])
--------+
--------+	// Получаем информацию о комиссии пула
--------+	swapFee := 0.25 // 0.25% это стандартная комиссия Raydium
--------+
--------+	return &PoolState{
--------+		TokenAReserve: tokenAReserve,
--------+		TokenBReserve: tokenBReserve,
--------+		SwapFee:       swapFee,
--------+	}, nil
--------+}
--------+
--------+// calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
--------+func (r *DEX) calculateExpectedOutput(amountIn uint64, state *PoolState) float64 {
--------+	// Константа k = x * y, где x и y - резервы токенов
--------+	k := float64(state.TokenAReserve) * float64(state.TokenBReserve)
--------+
--------+	// Вычисляем amount_in после комиссии
--------+	amountInAfterFee := float64(amountIn) * (1 - state.SwapFee/100)
--------+
--------+	// Новый резерв входного токена
--------+	newSourceReserve := float64(state.TokenAReserve) + amountInAfterFee
--------+
--------+	// Вычисляем новый резерв выходного токена используя формулу k = x * y
--------+	newTargetReserve := k / newSourceReserve
--------+
--------+	// Ожидаемый выход это разница между старым и новым резервом
--------+	expectedOut := float64(state.TokenBReserve) - newTargetReserve
--------+
--------+	// Применяем дополнительный запас надежности
--------+	safetyFactor := 0.995 // 0.5% запас для учета изменения цены
--------+	return expectedOut * safetyFactor
--------+}
--------+
--------+// GetAmountOutQuote получает котировку для свапа
--------+func (r *DEX) GetAmountOutQuote(
--------+	ctx context.Context,
--------+	amountIn uint64,
--------+	sourceToken, targetToken solana.PublicKey,
--------+) (float64, error) {
--------+	// Создаем временный пул для получения котировки
--------+	poolInfo := r.poolInfo
--------+	if poolInfo == nil {
--------+		return 0, fmt.Errorf("pool info not configured")
--------+	}
--------+
--------+	// Получаем ожидаемый выход
--------+	expectedOut, err := r.getExpectedOutput(ctx, amountIn, sourceToken, targetToken, poolInfo, r.logger)
--------+	if err != nil {
--------+		return 0, fmt.Errorf("failed to get expected output: %w", err)
--------+	}
--------+
--------+	return expectedOut, nil
--------+}
--------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
--------index dd0f18f..cd3089e 100644
----------- a/internal/dex/raydium/types.go
--------+++ b/internal/dex/raydium/types.go
--------@@ -55,3 +55,10 @@ func (r *Pool) GetTokenAccounts() (string, string) {
-------- func (r *DEX) Name() string {
-------- 	return "Raydium"
-------- }
--------+
--------+// PoolState содержит состояние пула ликвидности
--------+type PoolState struct {
--------+	TokenAReserve uint64
--------+	TokenBReserve uint64
--------+	SwapFee       float64 // в процентах
--------+}
--------diff --git a/internal/dex/raydium/validation.go b/internal/dex/raydium/validation.go
--------index a948715..9267897 100644
----------- a/internal/dex/raydium/validation.go
--------+++ b/internal/dex/raydium/validation.go
--------@@ -1,5 +1,4 @@
-------- // internal/dex/raydium/validation.go
---------
-------- package raydium
-------- 
-------- import (
--------@@ -11,7 +10,6 @@ import (
-------- 
-------- // ValidateTask проверяет корректность параметров задачи
-------- func ValidateTask(task *types.Task) error {
---------
-------- 	if task == nil {
-------- 		return fmt.Errorf("task cannot be nil")
-------- 	}
--------@@ -41,8 +39,20 @@ func ValidateTask(task *types.Task) error {
-------- 		return fmt.Errorf("amount in must be greater than 0")
-------- 	}
-------- 
---------	if task.MinAmountOut <= 0 {
---------		return fmt.Errorf("min amount out must be greater than 0")
--------+	// Удаляем проверку MinAmountOut, так как теперь оно может быть нулевым или пустым
--------+	// if task.MinAmountOut <= 0 {
--------+	//     return fmt.Errorf("min amount out must be greater than 0")
--------+	// }
--------+
--------+	// Проверяем конфигурацию проскальзывания, если она используется
--------+	if task.SlippageConfig.Type != types.SlippageNone {
--------+		if task.SlippageConfig.Type == types.SlippagePercent &&
--------+			(task.SlippageConfig.Value <= 0 || task.SlippageConfig.Value > 100) {
--------+			return fmt.Errorf("slippage percentage must be between 0 and 100")
--------+		}
--------+		if task.SlippageConfig.Type == types.SlippageFixed && task.SlippageConfig.Value < 0 {
--------+			return fmt.Errorf("fixed slippage value cannot be negative")
--------+		}
-------- 	}
-------- 
-------- 	if task.SourceTokenDecimals <= 0 {
--------diff --git a/internal/sniping/strategy.go b/internal/sniping/strategy.go
--------index 91602f1..aa5b32c 100644
----------- a/internal/sniping/strategy.go
--------+++ b/internal/sniping/strategy.go
--------@@ -60,9 +60,12 @@ func parseTask(record []string) (*types.Task, error) {
-------- 		return nil, fmt.Errorf("invalid AmountIn value: %v", err)
-------- 	}
-------- 
---------	minAmountOut, err := strconv.ParseFloat(record[10], 64)
---------	if err != nil {
---------		return nil, fmt.Errorf("invalid MinAmountOut value: %v", err)
--------+	slippageValue := 1.0 // Значение по умолчанию
--------+	if record[10] != "" {
--------+		slippageValue, err = strconv.ParseFloat(record[10], 64)
--------+		if err != nil {
--------+			return nil, fmt.Errorf("invalid Slippage value: %v", err)
--------+		}
-------- 	}
-------- 
-------- 	autosellPercent, err := strconv.ParseFloat(record[11], 64)
--------@@ -107,12 +110,15 @@ func parseTask(record []string) (*types.Task, error) {
-------- 		SourceToken:         record[7],
-------- 		TargetToken:         record[8],
-------- 		AmountIn:            amountIn,
---------		MinAmountOut:        minAmountOut,
-------- 		AutosellPercent:     autosellPercent,
-------- 		AutosellDelay:       autosellDelay,
-------- 		AutosellAmount:      autosellAmount,
-------- 		TransactionDelay:    transactionDelay,
-------- 		AutosellPriorityFee: autosellPriorityFee,
---------		DEXName:             dexName, // Устанавливаем имя DEX
--------+		DEXName:             dexName,
--------+		SlippageConfig: types.SlippageConfig{
--------+			Type:  types.SlippagePercent, // Используем процентное проскальзывание по умолчанию
--------+			Value: slippageValue,
--------+		},
-------- 	}, nil
-------- }
--------diff --git a/internal/types/types.go b/internal/types/types.go
--------index babccdd..6b8c246 100644
----------- a/internal/types/types.go
--------+++ b/internal/types/types.go
--------@@ -20,7 +20,6 @@ type Task struct {
-------- 	SourceToken                 string
-------- 	TargetToken                 string
-------- 	AmountIn                    float64
---------	MinAmountOut                float64
-------- 	AutosellPercent             float64
-------- 	AutosellDelay               int
-------- 	AutosellAmount              float64
--------@@ -31,6 +30,7 @@ type Task struct {
-------- 	SourceTokenDecimals         int
-------- 	TargetTokenDecimals         int
-------- 	DEXName                     string `default:"Raydium"` // Добавляем значение по умолчанию
--------+	SlippageConfig              SlippageConfig
-------- }
-------- 
-------- type DEX interface {
--------@@ -41,7 +41,6 @@ type DEX interface {
-------- 		sourceToken solana.PublicKey,
-------- 		destinationToken solana.PublicKey,
-------- 		amountIn uint64,
---------		minAmountOut uint64,
-------- 		logger *zap.Logger,
-------- 	) (solana.Instruction, error)
-------- 
--------diff --git a/internal/utils/logger/logger.go b/internal/utils/logger/logger.go
--------index e5e813c..5b76758 100644
----------- a/internal/utils/logger/logger.go
--------+++ b/internal/utils/logger/logger.go
--------@@ -138,7 +138,8 @@ func (l *Logger) WithTask(task *types.Task) *zap.Logger {
-------- 		zap.String("source_token", task.SourceToken),
-------- 		zap.String("target_token", task.TargetToken),
-------- 		zap.Float64("amount_in", task.AmountIn),
---------		zap.Float64("min_amount_out", task.MinAmountOut),
--------+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
--------+		zap.Float64("slippage_value", task.SlippageConfig.Value),
-------- 		zap.Float64("priority_fee", task.PriorityFee),
-------- 	)
-------- }
