diff --git a/TODO.md b/TODO.md
index 5b1d499..34aab1e 100644
--- a/TODO.md
+++ b/TODO.md
@@ -264,3 +264,8 @@
     - [ ] Например, прогнозирование цен, анализ рынка и т.д.
 - [ ] Рассмотреть возможность масштабирования
     - [ ] Настроить приложение для работы в распределенной среде.
+
+
+TODO: Оптимизация работы с ATA (Associated Token Accounts)
+1. Этап подготовки и архитектуры
+
diff --git a/configs/tasks.csv b/configs/tasks.csv
index 33e5da0..bbc2c6d 100644
--- a/configs/tasks.csv
+++ b/configs/tasks.csv
@@ -1,2 +1,2 @@
 TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,MinAmountOut,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
-buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
\ No newline at end of file
+buyTokens,Raydium,1,wallet1,100,0.0001,58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
\ No newline at end of file
diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
index 75b6e0d..bcfeacc 100644
--- a/internal/blockchain/solbc/client.go
+++ b/internal/blockchain/solbc/client.go
@@ -64,3 +64,6 @@ func (c *Client) Close() error {
 	c.rpc.Close()
 	return nil
 }
+func (c *Client) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
+	return c.rpc.GetSignatureStatuses(ctx, signatures...)
+}
diff --git a/internal/blockchain/solbc/rpc/rpc.go b/internal/blockchain/solbc/rpc/rpc.go
index ee4c137..ac6f2c4 100644
--- a/internal/blockchain/solbc/rpc/rpc.go
+++ b/internal/blockchain/solbc/rpc/rpc.go
@@ -144,5 +144,16 @@ func (c *RPCClient) SendTransaction(ctx context.Context, tx *solana.Transaction)
 	return signature, err
 }
 
+// Добавляем новый метод в RPCClient
+func (c *RPCClient) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
+	var result *solanarpc.GetSignatureStatusesResult
+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
+		var err error
+		result, err = client.GetSignatureStatuses(ctx, false, signatures...)
+		return err
+	})
+	return result, err
+}
+
 // Close закрывает клиент
 func (c *RPCClient) Close() {}
diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
index cc61a29..42debad 100644
--- a/internal/blockchain/solbc/types.go
+++ b/internal/blockchain/solbc/types.go
@@ -19,7 +19,7 @@ type TokenMetadataCache struct {
 
 // Client представляет основной клиент Solana
 type Client struct {
-	rpc     *rpc.RPCClient // Меняем тип с enhancedRPC на RPCClient
+	rpc     *rpc.RPCClient
 	logger  *zap.Logger
 	metrics *ClientMetrics
 }
diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
index 2690c82..202b59a 100644
--- a/internal/blockchain/types.go
+++ b/internal/blockchain/types.go
@@ -13,4 +13,5 @@ type Client interface {
 	GetRecentBlockhash(ctx context.Context) (solana.Hash, error)
 	SendTransaction(ctx context.Context, tx *solana.Transaction) (solana.Signature, error)
 	GetAccountInfo(ctx context.Context, pubkey solana.PublicKey) (*rpc.GetAccountInfoResult, error)
+	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
 }
diff --git a/internal/dex/dex.go b/internal/dex/dex.go
index 5aebaa7..9b9fb16 100644
--- a/internal/dex/dex.go
+++ b/internal/dex/dex.go
@@ -1,62 +1,79 @@
-// internal/dex/dex.go
 package dex
 
 import (
-	"errors"
 	"fmt"
 	"strings"
 
 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+	"github.com/rovshanmuradov/solana-bot/internal/dex/pumpfun"
 	"github.com/rovshanmuradov/solana-bot/internal/dex/raydium"
 	"github.com/rovshanmuradov/solana-bot/internal/types"
 	"go.uber.org/zap"
 )
 
+// GetDEXByName возвращает имплементацию DEX по имени
 func GetDEXByName(name string, client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
-	logger = logger.With(zap.String("dex_name", name))
-	logger.Info("Getting DEX by name")
-	fmt.Printf("\n=== Getting DEX by name: %s ===\n", name)
+	if client == nil {
+		return nil, fmt.Errorf("client cannot be nil")
+	}
 
 	if logger == nil {
-		fmt.Println("Logger is nil")
-		return nil, errors.New("logger is nil")
+		return nil, fmt.Errorf("logger cannot be nil")
 	}
 
-	name = strings.TrimSpace(name)
+	name = strings.TrimSpace(strings.ToLower(name))
 	if name == "" {
-		fmt.Println("DEX name is empty")
-		return nil, errors.New("DEX name cannot be empty")
+		return nil, fmt.Errorf("DEX name cannot be empty")
 	}
 
-	fmt.Printf("Client nil? %v\n", client == nil)
+	logger = logger.With(zap.String("dex_name", name))
+	logger.Info("Initializing DEX instance")
 
-	if client == nil {
-		fmt.Println("Solana client is nil")
-		return nil, errors.New("solana client cannot be nil")
+	switch name {
+	case "raydium":
+		return initializeRaydiumDEX(client, logger)
+	case "pump.fun":
+		return initializePumpFunDEX(client, logger)
+	default:
+		logger.Error("Unsupported DEX requested", zap.String("name", name))
+		return nil, fmt.Errorf("unsupported DEX: %s", name)
 	}
+}
 
-	switch strings.ToLower(name) {
-	case strings.ToLower("Raydium"):
-		fmt.Println("Creating Raydium DEX instance")
+// initializeRaydiumDEX инициализирует Raydium DEX
+func initializeRaydiumDEX(client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
+	logger.Debug("Initializing Raydium DEX")
 
-		if raydium.DefaultPoolConfig == nil {
-			fmt.Println("Default pool config is nil")
-			return nil, errors.New("default pool config is nil")
-		}
+	if raydium.DefaultPoolConfig == nil {
+		logger.Error("Default pool configuration is missing")
+		return nil, fmt.Errorf("raydium default pool config is nil")
+	}
 
-		fmt.Printf("Pool config: %+v\n", raydium.DefaultPoolConfig)
+	logger.Debug("Creating Raydium DEX instance",
+		zap.String("pool_id", raydium.DefaultPoolConfig.AmmID),
+		zap.String("program_id", raydium.DefaultPoolConfig.AmmProgramID))
 
-		dex := raydium.NewDEX(client, logger, raydium.DefaultPoolConfig)
-		if dex == nil {
-			fmt.Println("Failed to create Raydium DEX instance")
-			return nil, errors.New("failed to create Raydium DEX instance")
-		}
+	dex := raydium.NewDEX(client, logger, raydium.DefaultPoolConfig)
+	if dex == nil {
+		logger.Error("Failed to create Raydium DEX instance")
+		return nil, fmt.Errorf("failed to create Raydium DEX instance")
+	}
 
-		fmt.Printf("DEX created: %+v\n", dex)
-		return dex, nil
+	logger.Info("Raydium DEX initialized successfully")
+	return dex, nil
+}
 
-	default:
-		fmt.Printf("Unsupported DEX: %s\n", name)
-		return nil, fmt.Errorf("unsupported DEX: %s", name)
+// initializePumpFunDEX инициализирует Pump.fun DEX
+func initializePumpFunDEX(_ blockchain.Client, logger *zap.Logger) (types.DEX, error) {
+	logger.Debug("Initializing Pump.fun DEX")
+
+	// Создаем новый экземпляр Pump.fun DEX
+	dex := pumpfun.NewDEX()
+	if dex == nil {
+		logger.Error("Failed to create Pump.fun DEX instance")
+		return nil, fmt.Errorf("failed to create Pump.fun DEX instance")
 	}
+
+	logger.Info("Pump.fun DEX initialized successfully")
+	return dex, nil
 }
diff --git a/internal/dex/pumpfun/pumpfun.go b/internal/dex/pumpfun/pumpfun.go
index 83e62de..a1450ec 100644
--- a/internal/dex/pumpfun/pumpfun.go
+++ b/internal/dex/pumpfun/pumpfun.go
@@ -1,4 +1,3 @@
-// internal/dex/pumpfun/pumpfun.go
 package pumpfun
 
 import (
@@ -30,7 +29,6 @@ func (p *DEX) PrepareSwapInstruction(
 	_ solana.PublicKey,
 	_ solana.PublicKey,
 	_ uint64,
-	_ uint64,
 	_ *zap.Logger,
 ) (solana.Instruction, error) {
 	return nil, fmt.Errorf("pump.fun DEX implementation not ready")
diff --git a/internal/dex/raydium/config.go b/internal/dex/raydium/config.go
index acf9464..cb0c21b 100644
--- a/internal/dex/raydium/config.go
+++ b/internal/dex/raydium/config.go
@@ -7,7 +7,7 @@ var DefaultPoolConfig = &Pool{
 	AmmProgramID: "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",
 
 	// Актуальная конфигурация для SOL-USDC пула
-	AmmID:                "EVzLJhqMtfPHFp5piYSeXqx5cY6hLbrE8oRR5Zrm1YaT",
+	AmmID:                "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
 	AmmAuthority:         "3uaZBfHPfmpAHW7dsimC1SnyR61X4bJqQZKWmRSCXJxv",
 	AmmOpenOrders:        "4NfmERReGt1QCKey8cH5q4LsBYJoUcsuGg11J8GQFwH8",
 	AmmTargetOrders:      "38RJcGjtgd4SKRfY2dcM8Z9LzXQR6cyZeGxvjrRsVGZD",
diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
index bcd26a9..8e2c6c3 100644
--- a/internal/dex/raydium/raydium.go
+++ b/internal/dex/raydium/raydium.go
@@ -9,9 +9,12 @@ import (
 	"math"
 	"time"
 
+	bin "github.com/gagliardetto/binary"
 	"github.com/gagliardetto/solana-go"
 	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
+	"github.com/gagliardetto/solana-go/programs/token"
+	solanarpc "github.com/gagliardetto/solana-go/rpc"
 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
 	"github.com/rovshanmuradov/solana-bot/internal/types"
 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
@@ -93,7 +96,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
 	}
 
 	// Отправляем транзакцию
-	signature, err := r.sendTransactionWithRetry(swapCtx, userWallet, instructions, logger)
+	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
 	if err != nil {
 		return fmt.Errorf("failed to send swap transaction: %w", err)
 	}
@@ -140,91 +143,139 @@ func (r *DEX) ensureATA(
 	ataType string,
 	logger *zap.Logger,
 ) error {
-	account, err := r.client.GetAccountInfo(ctx, ata)
+	logger = logger.With(
+		zap.String("mint", mint.String()),
+		zap.String("ata", ata.String()),
+		zap.String("wallet", wallet.PublicKey.String()),
+	)
+
+	// Проверяем существование ATA с повторными попытками
+	exists, err := r.checkATAExists(ctx, ata, logger)
 	if err != nil {
 		return fmt.Errorf("failed to check %s ATA: %w", ataType, err)
 	}
 
-	if account.Value == nil {
-		logger.Debug("Creating ATA", zap.String("type", ataType), zap.String("address", ata.String()))
-
-		instruction := associatedtokenaccount.NewCreateInstruction(
-			wallet.PublicKey,
-			wallet.PublicKey,
-			mint,
-		).Build()
+	if !exists {
+		logger.Debug("Creating new ATA")
+		// Используем правильное создание инструкции из solana-go
+		instruction, err := r.createATAInstruction(wallet, mint)
+		if err != nil {
+			return fmt.Errorf("failed to create %s ATA instruction: %w", ataType, err)
+		}
 
-		if err := r.sendATATransaction(ctx, wallet, instruction); err != nil {
+		// Отправляем транзакцию и ждем подтверждения
+		signature, err := r.sendTransactionWithRetryAndConfirmation(ctx, wallet, []solana.Instruction{instruction}, logger)
+		if err != nil {
 			return fmt.Errorf("failed to create %s ATA: %w", ataType, err)
 		}
 
-		logger.Debug("ATA created successfully", zap.String("type", ataType))
+		logger.Info("ATA created successfully",
+			zap.String("signature", signature.String()))
+
+		// Ждем появления аккаунта
+		if err := r.waitForATACreation(ctx, ata, logger); err != nil {
+			return fmt.Errorf("failed to confirm %s ATA creation: %w", ataType, err)
+		}
 	}
 
 	return nil
 }
 
-// Добавляем метод sendATATransaction
-func (r *DEX) sendATATransaction(ctx context.Context, wallet *wallet.Wallet, instruction solana.Instruction) error {
-	logger := r.logger.With(
-		zap.String("wallet", wallet.PublicKey.String()),
-		zap.String("operation", "create_ata"),
+func (r *DEX) checkATAExists(
+	ctx context.Context,
+	ata solana.PublicKey,
+	logger *zap.Logger,
+) (bool, error) {
+	for attempt := 0; attempt < maxRetries; attempt++ {
+		account, err := r.client.GetAccountInfo(ctx, ata)
+		if err == nil && account.Value != nil {
+			// Проверяем, что владелец - TokenProgram
+			return account.Value.Owner == solana.TokenProgramID, nil
+		}
+
+		if attempt < maxRetries-1 {
+			select {
+			case <-ctx.Done():
+				return false, ctx.Err()
+			case <-time.After(retryDelay):
+				logger.Debug("Retrying ATA check", zap.Int("attempt", attempt+1))
+			}
+		}
+	}
+	return false, nil
+}
+
+func (r *DEX) createATAInstruction(
+	wallet *wallet.Wallet,
+	mint solana.PublicKey,
+) (solana.Instruction, error) {
+	// Используем билдер из solana-go
+	inst := associatedtokenaccount.NewCreateInstruction(
+		wallet.PublicKey, // payer
+		wallet.PublicKey, // wallet address
+		mint,             // token mint
 	)
 
-	var lastErr error
-	for attempt := 0; attempt < maxRetries; attempt++ {
+	// Проводим валидацию
+	if err := inst.Validate(); err != nil {
+		return nil, fmt.Errorf("invalid ATA instruction: %w", err)
+	}
+
+	return inst.Build(), nil
+}
+
+func (r *DEX) waitForATACreation(
+	ctx context.Context,
+	ata solana.PublicKey,
+	logger *zap.Logger,
+) error {
+	// Увеличиваем время ожидания до 2 минут
+	deadline := time.Now().Add(2 * time.Minute)
+	// Начальный интервал проверки
+	ticker := time.NewTicker(2 * time.Second)
+	defer ticker.Stop()
+
+	retryCount := 0
+	maxRetries := 60 // Максимальное количество попыток
+
+	for {
+		if time.Now().After(deadline) {
+			return fmt.Errorf("timeout waiting for ATA creation after 2 minutes")
+		}
+
+		if retryCount >= maxRetries {
+			return fmt.Errorf("exceeded maximum retry attempts (%d) waiting for ATA creation", maxRetries)
+		}
+
 		select {
 		case <-ctx.Done():
 			return ctx.Err()
-		default:
-			recent, err := r.client.GetRecentBlockhash(ctx)
+		case <-ticker.C:
+			account, err := r.client.GetAccountInfo(ctx, ata)
 			if err != nil {
-				lastErr = fmt.Errorf("failed to get recent blockhash: %w", err)
+				logger.Debug("ATA verification attempt failed",
+					zap.Error(err),
+					zap.Int("retry", retryCount),
+					zap.Time("deadline", deadline))
+				retryCount++
 				continue
 			}
 
-			tx, err := solana.NewTransaction(
-				[]solana.Instruction{instruction},
-				recent,
-				solana.TransactionPayer(wallet.PublicKey),
-			)
-			if err != nil {
-				lastErr = fmt.Errorf("failed to create ATA transaction: %w", err)
-				continue
-			}
-
-			_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
-				if key.Equals(wallet.PublicKey) {
-					return &wallet.PrivateKey
-				}
+			if account.Value != nil && account.Value.Owner == solana.TokenProgramID {
+				logger.Info("ATA creation confirmed",
+					zap.String("ata", ata.String()),
+					zap.Int("retries", retryCount))
 				return nil
-			})
-			if err != nil {
-				lastErr = fmt.Errorf("failed to sign ATA transaction: %w", err)
-				continue
 			}
 
-			sig, err := r.client.SendTransaction(ctx, tx)
-			if err != nil {
-				lastErr = err
-				logger.Warn("Failed to send ATA transaction, retrying",
-					zap.Int("attempt", attempt+1),
-					zap.Error(err))
-				time.Sleep(retryDelay)
-				continue
-			}
-
-			logger.Debug("ATA transaction sent successfully",
-				zap.String("signature", sig.String()))
-			return nil
+			logger.Debug("ATA not ready yet",
+				zap.String("ata", ata.String()),
+				zap.Int("retry", retryCount))
+			retryCount++
 		}
 	}
-
-	return fmt.Errorf("failed to send ATA transaction after %d attempts: %w", maxRetries, lastErr)
 }
 
-// internal/dex/raydium/raydium.go
-
 // PrepareSwapInstructions объединяет все инструкции для свапа
 func (r *DEX) PrepareSwapInstructions(
 	ctx context.Context,
@@ -343,24 +394,19 @@ func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.
 		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
 	}
 
-	if account.Value == nil || len(account.Value.Data.GetBinary()) < 32 {
+	if account.Value == nil || len(account.Value.Data.GetBinary()) < 64 {
 		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
 	}
 
-	data := account.Value.Data.GetBinary()[:32]
-	if len(data) != 32 {
-		return solana.PublicKey{}, fmt.Errorf("invalid public key length: expected 32 bytes, got %d", len(data))
+	var tokenAccount token.Account
+	if err := bin.NewBinDecoder(account.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
+		return solana.PublicKey{}, fmt.Errorf("failed to decode ATA data: %w", err)
 	}
 
-	pubkey := solana.PublicKeyFromBytes(data)
-	if pubkey.IsZero() {
-		return solana.PublicKey{}, fmt.Errorf("invalid zero public key")
-	}
-
-	return pubkey, nil
+	return tokenAccount.Mint, nil
 }
 
-func (r *DEX) sendTransactionWithRetry(
+func (r *DEX) sendTransactionWithRetryAndConfirmation(
 	ctx context.Context,
 	wallet *wallet.Wallet,
 	instructions []solana.Instruction,
@@ -373,14 +419,44 @@ func (r *DEX) sendTransactionWithRetry(
 			return solana.Signature{}, ctx.Err()
 		default:
 			signature, err := r.sendTransaction(ctx, wallet, instructions)
-			if err == nil {
-				return signature, nil
+			if err != nil {
+				lastErr = err
+				logger.Warn("Retrying transaction send",
+					zap.Int("attempt", attempt+1),
+					zap.Error(err))
+				time.Sleep(retryDelay)
+				continue
+			}
+
+			// Ждем подтверждения транзакции
+			logger.Debug("Waiting for transaction confirmation",
+				zap.String("signature", signature.String()))
+
+			// Ждем подтверждения с таймаутом
+			confirmCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
+			defer cancel()
+
+			for {
+				select {
+				case <-confirmCtx.Done():
+					return signature, fmt.Errorf("timeout waiting for transaction confirmation")
+				case <-time.After(time.Second):
+					// Проверяем статус транзакции
+					status, err := r.getTransactionStatus(ctx, signature)
+					if err != nil {
+						logger.Debug("Failed to get transaction status", zap.Error(err))
+						continue
+					}
+
+					// Проверяем подтверждение
+					if status.Confirmations >= 1 || status.Status == "finalized" {
+						logger.Debug("Transaction confirmed",
+							zap.String("status", status.Status),
+							zap.Uint64("confirmations", status.Confirmations))
+						return signature, nil
+					}
+				}
 			}
-			lastErr = err
-			logger.Warn("Retrying transaction send",
-				zap.Int("attempt", attempt+1),
-				zap.Error(err))
-			time.Sleep(retryDelay)
 		}
 	}
 	return solana.Signature{}, fmt.Errorf("failed after %d attempts: %w", maxRetries, lastErr)
@@ -452,7 +528,7 @@ func (r *DEX) getExpectedOutput(
 	poolInfo *Pool,
 	logger *zap.Logger,
 ) (float64, error) {
-	// Создаем контекст с таймаутом
+	// Создаем контекст с тайм-аутом
 	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
 	defer cancel()
 
@@ -557,3 +633,50 @@ func (r *DEX) GetAmountOutQuote(
 
 	return expectedOut, nil
 }
+
+// TransactionStatus представляет статус транзакции
+type TransactionStatus struct {
+	Status        string
+	Confirmations uint64
+	Error         interface{}
+	Slot          uint64
+}
+
+// getConfirmations получает количество подтверждений из результата статуса
+func getConfirmations(status *solanarpc.SignatureStatusesResult) uint64 {
+	if status == nil {
+		return 0
+	}
+
+	if status.Confirmations == nil {
+		if status.ConfirmationStatus == solanarpc.ConfirmationStatusFinalized {
+			return math.MaxUint64 // Максимальное значение для финализированных транзакций
+		}
+		return 0
+	}
+	return *status.Confirmations
+}
+
+// getTransactionStatus получает полный статус транзакции
+func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signature) (*TransactionStatus, error) {
+	result, err := r.client.GetSignatureStatuses(ctx, signature)
+	if err != nil {
+		return nil, fmt.Errorf("failed to get signature status: %w", err)
+	}
+
+	if result == nil || len(result.Value) == 0 || result.Value[0] == nil {
+		return &TransactionStatus{
+			Status: "pending",
+		}, nil
+	}
+
+	status := result.Value[0]
+	confirmations := getConfirmations(status)
+
+	return &TransactionStatus{
+		Status:        string(status.ConfirmationStatus),
+		Confirmations: confirmations,
+		Error:         status.Err,
+		Slot:          status.Slot,
+	}, nil
+}
diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
index 85d91eb..cf37967 100644
--- a/internal/dex/raydium/transaction.go
+++ b/internal/dex/raydium/transaction.go
@@ -1,10 +1,10 @@
 package raydium
 
 import (
-	"bytes"
 	"context"
 	"encoding/binary"
 	"fmt"
+	"testing"
 
 	"github.com/gagliardetto/solana-go"
 	"github.com/rovshanmuradov/solana-bot/internal/types"
@@ -13,23 +13,71 @@ import (
 )
 
 // Serialize сериализует данные инструкции свапа
-// Метод Serialize нужно обновить для корректной работы с uint8
 func (s *SwapInstructionData) Serialize() ([]byte, error) {
-	buf := new(bytes.Buffer)
+	data := make([]byte, 17)
 
-	// Записываем Instruction как uint8
-	if err := buf.WriteByte(s.Instruction); err != nil {
-		return nil, fmt.Errorf("failed to serialize instruction: %w", err)
+	// Instruction (1 byte)
+	data[0] = s.Instruction
+
+	// AmountIn (8 bytes)
+	binary.LittleEndian.PutUint64(data[1:9], s.AmountIn)
+
+	// MinAmountOut (8 bytes)
+	binary.LittleEndian.PutUint64(data[9:17], s.MinAmountOut)
+
+	return data, nil
+}
+
+// TestSwapInstructionDataSerialization тест для проверки сериализации
+func TestSwapInstructionDataSerialization(t *testing.T) {
+	inst := &SwapInstructionData{
+		Instruction:  1,
+		AmountIn:     20000000,
+		MinAmountOut: 6,
 	}
 
-	// Записываем AmountIn и MinAmountOut как uint64
-	for _, v := range []uint64{s.AmountIn, s.MinAmountOut} {
-		if err := binary.Write(buf, binary.LittleEndian, v); err != nil {
-			return nil, fmt.Errorf("failed to serialize value: %w", err)
-		}
+	data, err := inst.Serialize()
+	if err != nil {
+		t.Fatalf("Failed to serialize: %v", err)
 	}
 
-	return buf.Bytes(), nil
+	// Проверяем instruction code
+	if data[0] != 1 {
+		t.Errorf("Expected instruction 1, got %d", data[0])
+	}
+
+	// Проверяем amountIn
+	gotAmountIn := binary.LittleEndian.Uint64(data[1:9])
+	if gotAmountIn != 20000000 {
+		t.Errorf("Expected amountIn 20000000, got %d", gotAmountIn)
+	}
+
+	// Проверяем minAmountOut
+	gotMinAmountOut := binary.LittleEndian.Uint64(data[9:17])
+	if gotMinAmountOut != 6 {
+		t.Errorf("Expected minAmountOut 6, got %d", gotMinAmountOut)
+	}
+}
+
+// Debug выводит шестнадцатеричное представление данных
+func (s *SwapInstructionData) Debug(logger *zap.Logger) {
+	data, err := s.Serialize()
+	if err != nil {
+		logger.Error("Failed to serialize for debug", zap.Error(err))
+		return
+	}
+
+	// Проверяем данные
+	amountIn := binary.LittleEndian.Uint64(data[1:9])
+	minAmountOut := binary.LittleEndian.Uint64(data[9:17])
+
+	logger.Debug("Instruction data debug",
+		zap.Uint8("instruction", data[0]),
+		zap.Uint64("amount_in_original", s.AmountIn),
+		zap.Uint64("amount_in_serialized", amountIn),
+		zap.Uint64("min_amount_out_original", s.MinAmountOut),
+		zap.Uint64("min_amount_out_serialized", minAmountOut),
+		zap.Binary("raw_data", data))
 }
 
 // validatePublicKey проверяет корректность публичного ключа
@@ -74,91 +122,125 @@ func (r *DEX) CreateSwapInstruction(
 		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
 	}
 
-	ammID, err := validatePublicKey(poolInfo.AmmID)
-	if err != nil {
-		logger.Error("Invalid AmmID", zap.Error(err))
-		return nil, fmt.Errorf("invalid AmmID: %w", err)
-	}
-
-	// Создаем массив для всех аккаунтов, которые нужно проверить
-	accountChecks := []struct {
-		name    string
-		address string
-	}{
-		{"AmmAuthority", poolInfo.AmmAuthority},
-		{"AmmOpenOrders", poolInfo.AmmOpenOrders},
-		{"AmmTargetOrders", poolInfo.AmmTargetOrders},
-		{"PoolCoinTokenAccount", poolInfo.PoolCoinTokenAccount},
-		{"PoolPcTokenAccount", poolInfo.PoolPcTokenAccount},
-		{"SerumProgramID", poolInfo.SerumProgramID},
-		{"SerumMarket", poolInfo.SerumMarket},
-		{"SerumBids", poolInfo.SerumBids},
-		{"SerumAsks", poolInfo.SerumAsks},
-		{"SerumEventQueue", poolInfo.SerumEventQueue},
-		{"SerumCoinVaultAccount", poolInfo.SerumCoinVaultAccount},
-		{"SerumPcVaultAccount", poolInfo.SerumPcVaultAccount},
-		{"SerumVaultSigner", poolInfo.SerumVaultSigner},
-	}
-
-	// Создаем слайс для аккаунтов с предварительно выделенной памятью
-	accounts := make([]*solana.AccountMeta, 0, len(accountChecks)+7) // +7 для базовых аккаунтов
-
-	// Добавляем базовые аккаунты
-	accounts = append(accounts, []*solana.AccountMeta{
-		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
-		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
-		{PublicKey: ammID, IsSigner: false, IsWritable: true},
-	}...)
-
-	// Проверяем и добавляем остальные аккаунты
-	for _, check := range accountChecks {
-		pubKey, err := validatePublicKey(check.address)
+	// Проверяем и создаем все необходимые аккаунты
+	requiredAccounts := map[string]string{
+		"AmmID":                poolInfo.AmmID,
+		"AmmAuthority":         poolInfo.AmmAuthority,
+		"AmmOpenOrders":        poolInfo.AmmOpenOrders,
+		"AmmTargetOrders":      poolInfo.AmmTargetOrders,
+		"PoolCoinTokenAccount": poolInfo.PoolCoinTokenAccount,
+		"PoolPcTokenAccount":   poolInfo.PoolPcTokenAccount,
+		"SerumProgramID":       poolInfo.SerumProgramID,
+		"SerumMarket":          poolInfo.SerumMarket,
+		"SerumBids":            poolInfo.SerumBids,
+		"SerumAsks":            poolInfo.SerumAsks,
+		"SerumEventQueue":      poolInfo.SerumEventQueue,
+		"SerumCoinVault":       poolInfo.SerumCoinVaultAccount,
+		"SerumPcVault":         poolInfo.SerumPcVaultAccount,
+		"SerumVaultSigner":     poolInfo.SerumVaultSigner,
+	}
+
+	accounts := make(map[string]solana.PublicKey)
+	for name, address := range requiredAccounts {
+		pubKey, err := validatePublicKey(address)
 		if err != nil {
-			logger.Error(fmt.Sprintf("Invalid %s", check.name),
-				zap.String("address", check.address),
+			logger.Error(fmt.Sprintf("Invalid %s", name),
+				zap.String("address", address),
 				zap.Error(err))
-			return nil, fmt.Errorf("invalid %s: %w", check.name, err)
+			return nil, fmt.Errorf("invalid %s: %w", name, err)
 		}
+		accounts[name] = pubKey
+	}
 
-		isWritable := false
-		switch check.name {
-		case "AmmOpenOrders", "AmmTargetOrders", "PoolCoinTokenAccount",
-			"PoolPcTokenAccount", "SerumMarket", "SerumBids", "SerumAsks",
-			"SerumEventQueue", "SerumCoinVaultAccount", "SerumPcVaultAccount":
-			isWritable = true
-		}
+	// Создаем слайс аккаунтов в правильном порядке для Raydium
+	metas := make(solana.AccountMetaSlice, 0, 20)
 
-		accounts = append(accounts, &solana.AccountMeta{
-			PublicKey:  pubKey,
-			IsSigner:   false,
-			IsWritable: isWritable,
-		})
-	}
+	// Токен аккаунты пользователя
+	metas = append(metas,
+		&solana.AccountMeta{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
+	)
+
+	// Аккаунты AMM
+	metas = append(metas,
+		&solana.AccountMeta{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
+		&solana.AccountMeta{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
+	)
+
+	// Аккаунты Serum
+	metas = append(metas,
+		&solana.AccountMeta{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
+		&solana.AccountMeta{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
+		&solana.AccountMeta{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
+	)
 
-	// Добавляем системные аккаунты
-	accounts = append(accounts, []*solana.AccountMeta{
-		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
-		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
-		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
-		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
-	}...)
+	// Системные аккаунты
+	metas = append(metas,
+		&solana.AccountMeta{PublicKey: userWallet, IsSigner: true, IsWritable: false},
+		&solana.AccountMeta{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
+		&solana.AccountMeta{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
+		&solana.AccountMeta{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
+	)
 
 	// Создание данных инструкции
-	instructionData := SwapInstructionData{
+	instructionData := &SwapInstructionData{
 		Instruction:  poolInfo.RaydiumSwapInstructionCode,
 		AmountIn:     amountIn,
 		MinAmountOut: minAmountOut,
 	}
 
+	// Добавляем отладочный вывод
+	instructionData.Debug(logger)
+
+	// Сериализация
 	data, err := instructionData.Serialize()
 	if err != nil {
-		logger.Error("Failed to serialize instruction data", zap.Error(err))
+		logger.Error("Failed to serialize instruction data",
+			zap.Error(err),
+			zap.Uint8("instruction", instructionData.Instruction),
+			zap.Uint64("amount_in", instructionData.AmountIn),
+			zap.Uint64("min_amount_out", instructionData.MinAmountOut))
 		return nil, fmt.Errorf("failed to serialize instruction data: %w", err)
 	}
 
-	instruction := solana.NewInstruction(ammProgramID, accounts, data)
+	// Проверка сериализованных данных
+	if len(data) != 17 {
+		logger.Error("Invalid serialized data length",
+			zap.Int("got_length", len(data)),
+			zap.Int("expected_length", 17))
+		return nil, fmt.Errorf("invalid serialized data length")
+	}
+
+	// Проверяем значения после сериализации
+	amountInCheck := binary.LittleEndian.Uint64(data[1:9])
+	minAmountOutCheck := binary.LittleEndian.Uint64(data[9:17])
+
+	logger.Debug("Serialized data check",
+		zap.Uint64("amount_in_check", amountInCheck),
+		zap.Uint64("min_amount_out_check", minAmountOutCheck))
+
+	if amountInCheck != amountIn {
+		logger.Error("AmountIn mismatch after serialization",
+			zap.Uint64("original", amountIn),
+			zap.Uint64("serialized", amountInCheck))
+		return nil, fmt.Errorf("amountIn mismatch after serialization")
+	}
+
+	instruction := solana.NewInstruction(ammProgramID, metas, data)
+
+	logger.Debug("Created instruction",
+		zap.Int("num_accounts", len(metas)),
+		zap.Int("data_len", len(data)))
 
-	logger.Debug("Swap instruction created successfully")
 	return instruction, nil
 }
 
diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
index cd3089e..4cc1b1e 100644
--- a/internal/dex/raydium/types.go
+++ b/internal/dex/raydium/types.go
@@ -27,11 +27,10 @@ type Pool struct {
 }
 
 // SwapInstructionData представляет данные инструкции свапа
-// Обновляем также структуру инструкции
 type SwapInstructionData struct {
-	Instruction  uint8 // Изменено на uint8
-	AmountIn     uint64
-	MinAmountOut uint64
+	Instruction  uint8  // Тип инструкции
+	AmountIn     uint64 // Входящая сумма
+	MinAmountOut uint64 // Минимальная исходящая сумма
 }
 type DEX struct {
 	client   blockchain.Client // изменяем тип на интерфейс.
diff --git a/newdif.txt b/newdif.txt
index 073754f..a086373 100644
--- a/newdif.txt
+++ b/newdif.txt
@@ -1,436 +0,0 @@
-diff --git a/configs/tasks.csv b/configs/tasks.csv
-index e44faa8..33e5da0 100644
---- a/configs/tasks.csv
-+++ b/configs/tasks.csv
-@@ -1,2 +1,2 @@
- TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,MinAmountOut,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
--buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,,,,,100,
-\ No newline at end of file
-+buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
-\ No newline at end of file
-diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
-index 1703360..bcd26a9 100644
---- a/internal/dex/raydium/raydium.go
-+++ b/internal/dex/raydium/raydium.go
-@@ -4,6 +4,7 @@ package raydium
- 
- import (
- 	"context"
-+	"encoding/binary"
- 	"fmt"
- 	"math"
- 	"time"
-@@ -45,6 +46,8 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
- 	logger := r.logger.With(
- 		zap.String("task", task.TaskName),
- 		zap.String("wallet", userWallet.PublicKey.String()),
-+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
-+		zap.Float64("slippage_value", task.SlippageConfig.Value),
- 	)
- 	logger.Info("Starting swap execution")
- 
-@@ -64,11 +67,12 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
- 
- 	// Подготавливаем amount с учетом decimals
- 	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
--	minAmountOut := uint64(task.MinAmountOut * math.Pow10(task.TargetTokenDecimals))
- 
--	logger.Debug("Prepared swap amounts",
-+	logger.Debug("Prepared swap amount",
- 		zap.Uint64("amount_in", amountIn),
--		zap.Uint64("min_amount_out", minAmountOut))
-+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
-+		zap.Float64("slippage_value", task.SlippageConfig.Value),
-+	)
- 
- 	// Создаем инструкции с таймаутом
- 	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
-@@ -81,7 +85,6 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
- 		sourceATA,
- 		targetATA,
- 		amountIn,
--		minAmountOut,
- 		task.PriorityFee,
- 		logger,
- 	)
-@@ -220,7 +223,8 @@ func (r *DEX) sendATATransaction(ctx context.Context, wallet *wallet.Wallet, ins
- 	return fmt.Errorf("failed to send ATA transaction after %d attempts: %w", maxRetries, lastErr)
- }
- 
--// Добавляем метод PrepareSwapInstruction для соответствия интерфейсу types.DEX
-+// internal/dex/raydium/raydium.go
-+
- // PrepareSwapInstructions объединяет все инструкции для свапа
- func (r *DEX) PrepareSwapInstructions(
- 	ctx context.Context,
-@@ -228,7 +232,6 @@ func (r *DEX) PrepareSwapInstructions(
- 	sourceATA solana.PublicKey,
- 	targetATA solana.PublicKey,
- 	amountIn uint64,
--	minAmountOut uint64,
- 	priorityFee float64,
- 	logger *zap.Logger,
- ) ([]solana.Instruction, error) {
-@@ -247,7 +250,6 @@ func (r *DEX) PrepareSwapInstructions(
- 		sourceATA,
- 		targetATA,
- 		amountIn,
--		minAmountOut,
- 		logger,
- 	)
- 	if err != nil {
-@@ -265,7 +267,6 @@ func (r *DEX) PrepareSwapInstruction(
- 	sourceATA solana.PublicKey,
- 	targetATA solana.PublicKey,
- 	amountIn uint64,
--	minAmountOut uint64,
- 	logger *zap.Logger,
- ) (solana.Instruction, error) {
- 	logger = logger.With(
-@@ -275,8 +276,34 @@ func (r *DEX) PrepareSwapInstruction(
- 	)
- 	logger.Debug("Preparing swap instruction")
- 
--	// Создаем инструкцию свапа
--	instruction, err := r.CreateSwapInstruction(
-+	// Получаем ожидаемый выход
-+	sourceMint, err := r.getMintFromATA(ctx, sourceATA)
-+	if err != nil {
-+		return nil, fmt.Errorf("failed to get source mint: %w", err)
-+	}
-+
-+	targetMint, err := r.getMintFromATA(ctx, targetATA)
-+	if err != nil {
-+		return nil, fmt.Errorf("failed to get target mint: %w", err)
-+	}
-+
-+	expectedOut, err := r.getExpectedOutput(
-+		ctx,
-+		amountIn,
-+		sourceMint,
-+		targetMint,
-+		r.poolInfo,
-+		logger,
-+	)
-+	if err != nil {
-+		return nil, fmt.Errorf("failed to get expected output: %w", err)
-+	}
-+
-+	// Используем безопасное значение minAmountOut по умолчанию (99% от ожидаемого выхода)
-+	minAmountOut := uint64(float64(expectedOut) * 0.99)
-+
-+	// Создаем инструкцию свапа с помощью внутреннего метода createSwapInstruction
-+	return r.createSwapInstruction(
- 		wallet,
- 		sourceATA,
- 		targetATA,
-@@ -285,12 +312,52 @@ func (r *DEX) PrepareSwapInstruction(
- 		logger,
- 		r.poolInfo,
- 	)
-+}
-+
-+// createSwapInstruction внутренний метод для создания инструкции свапа
-+func (r *DEX) createSwapInstruction(
-+	wallet solana.PublicKey,
-+	sourceATA solana.PublicKey,
-+	targetATA solana.PublicKey,
-+	amountIn uint64,
-+	minAmountOut uint64,
-+	logger *zap.Logger,
-+	poolInfo *Pool,
-+) (solana.Instruction, error) {
-+	// Существующая логика из CreateSwapInstruction
-+	return r.CreateSwapInstruction(
-+		wallet,
-+		sourceATA,
-+		targetATA,
-+		amountIn,
-+		minAmountOut,
-+		logger,
-+		poolInfo,
-+	)
-+}
-+
-+// Вспомогательный метод для получения mint address из ATA
-+func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.PublicKey, error) {
-+	account, err := r.client.GetAccountInfo(ctx, ata)
- 	if err != nil {
--		return nil, fmt.Errorf("failed to create swap instruction: %w", err)
-+		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
- 	}
- 
--	logger.Debug("Swap instruction prepared successfully")
--	return instruction, nil
-+	if account.Value == nil || len(account.Value.Data.GetBinary()) < 32 {
-+		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
-+	}
-+
-+	data := account.Value.Data.GetBinary()[:32]
-+	if len(data) != 32 {
-+		return solana.PublicKey{}, fmt.Errorf("invalid public key length: expected 32 bytes, got %d", len(data))
-+	}
-+
-+	pubkey := solana.PublicKeyFromBytes(data)
-+	if pubkey.IsZero() {
-+		return solana.PublicKey{}, fmt.Errorf("invalid zero public key")
-+	}
-+
-+	return pubkey, nil
- }
- 
- func (r *DEX) sendTransactionWithRetry(
-@@ -376,3 +443,117 @@ func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, sol
- 
- 	return sourceMint, targetMint, nil
- }
-+
-+// getExpectedOutput вычисляет ожидаемый выход для свапа
-+func (r *DEX) getExpectedOutput(
-+	ctx context.Context,
-+	amountIn uint64,
-+	sourceToken, targetToken solana.PublicKey,
-+	poolInfo *Pool,
-+	logger *zap.Logger,
-+) (float64, error) {
-+	// Создаем контекст с таймаутом
-+	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
-+	defer cancel()
-+
-+	logger = logger.With(
-+		zap.String("source_token", sourceToken.String()),
-+		zap.String("target_token", targetToken.String()),
-+		zap.Uint64("amount_in", amountIn),
-+	)
-+
-+	// Получаем состояние пула
-+	poolState, err := r.getPoolState(ctx, poolInfo)
-+	if err != nil {
-+		return 0, fmt.Errorf("failed to get pool state: %w", err)
-+	}
-+
-+	logger.Debug("Pool state retrieved",
-+		zap.Uint64("token_a_reserve", poolState.TokenAReserve),
-+		zap.Uint64("token_b_reserve", poolState.TokenBReserve),
-+		zap.Float64("swap_fee", poolState.SwapFee))
-+
-+	// Вычисляем ожидаемый выход с учетом всех факторов
-+	expectedOut := r.calculateExpectedOutput(amountIn, poolState)
-+
-+	logger.Debug("Expected output calculated",
-+		zap.Float64("expected_out", expectedOut))
-+
-+	return expectedOut, nil
-+}
-+
-+// getPoolState получает текущее состояние пула
-+func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
-+	// Получаем аккаунт пула
-+	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
-+	if err != nil {
-+		return nil, fmt.Errorf("failed to get pool account: %w", err)
-+	}
-+
-+	if poolAccount == nil || poolAccount.Value == nil {
-+		return nil, fmt.Errorf("pool account not found")
-+	}
-+
-+	// Парсим данные аккаунта
-+	data := poolAccount.Value.Data.GetBinary()
-+	if len(data) < 8+32*2 { // Минимальный размер для резервов
-+		return nil, fmt.Errorf("invalid pool account data size")
-+	}
-+
-+	// Извлекаем резервы из данных аккаунта
-+	// Обратите внимание: это упрощенная версия, реальная структура данных может отличаться
-+	tokenAReserve := binary.LittleEndian.Uint64(data[8:16])
-+	tokenBReserve := binary.LittleEndian.Uint64(data[16:24])
-+
-+	// Получаем информацию о комиссии пула
-+	swapFee := 0.25 // 0.25% это стандартная комиссия Raydium
-+
-+	return &PoolState{
-+		TokenAReserve: tokenAReserve,
-+		TokenBReserve: tokenBReserve,
-+		SwapFee:       swapFee,
-+	}, nil
-+}
-+
-+// calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
-+func (r *DEX) calculateExpectedOutput(amountIn uint64, state *PoolState) float64 {
-+	// Константа k = x * y, где x и y - резервы токенов
-+	k := float64(state.TokenAReserve) * float64(state.TokenBReserve)
-+
-+	// Вычисляем amount_in после комиссии
-+	amountInAfterFee := float64(amountIn) * (1 - state.SwapFee/100)
-+
-+	// Новый резерв входного токена
-+	newSourceReserve := float64(state.TokenAReserve) + amountInAfterFee
-+
-+	// Вычисляем новый резерв выходного токена используя формулу k = x * y
-+	newTargetReserve := k / newSourceReserve
-+
-+	// Ожидаемый выход это разница между старым и новым резервом
-+	expectedOut := float64(state.TokenBReserve) - newTargetReserve
-+
-+	// Применяем дополнительный запас надежности
-+	safetyFactor := 0.995 // 0.5% запас для учета изменения цены
-+	return expectedOut * safetyFactor
-+}
-+
-+// GetAmountOutQuote получает котировку для свапа
-+func (r *DEX) GetAmountOutQuote(
-+	ctx context.Context,
-+	amountIn uint64,
-+	sourceToken, targetToken solana.PublicKey,
-+) (float64, error) {
-+	// Создаем временный пул для получения котировки
-+	poolInfo := r.poolInfo
-+	if poolInfo == nil {
-+		return 0, fmt.Errorf("pool info not configured")
-+	}
-+
-+	// Получаем ожидаемый выход
-+	expectedOut, err := r.getExpectedOutput(ctx, amountIn, sourceToken, targetToken, poolInfo, r.logger)
-+	if err != nil {
-+		return 0, fmt.Errorf("failed to get expected output: %w", err)
-+	}
-+
-+	return expectedOut, nil
-+}
-diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
-index dd0f18f..cd3089e 100644
---- a/internal/dex/raydium/types.go
-+++ b/internal/dex/raydium/types.go
-@@ -55,3 +55,10 @@ func (r *Pool) GetTokenAccounts() (string, string) {
- func (r *DEX) Name() string {
- 	return "Raydium"
- }
-+
-+// PoolState содержит состояние пула ликвидности
-+type PoolState struct {
-+	TokenAReserve uint64
-+	TokenBReserve uint64
-+	SwapFee       float64 // в процентах
-+}
-diff --git a/internal/dex/raydium/validation.go b/internal/dex/raydium/validation.go
-index a948715..9267897 100644
---- a/internal/dex/raydium/validation.go
-+++ b/internal/dex/raydium/validation.go
-@@ -1,5 +1,4 @@
- // internal/dex/raydium/validation.go
--
- package raydium
- 
- import (
-@@ -11,7 +10,6 @@ import (
- 
- // ValidateTask проверяет корректность параметров задачи
- func ValidateTask(task *types.Task) error {
--
- 	if task == nil {
- 		return fmt.Errorf("task cannot be nil")
- 	}
-@@ -41,8 +39,20 @@ func ValidateTask(task *types.Task) error {
- 		return fmt.Errorf("amount in must be greater than 0")
- 	}
- 
--	if task.MinAmountOut <= 0 {
--		return fmt.Errorf("min amount out must be greater than 0")
-+	// Удаляем проверку MinAmountOut, так как теперь оно может быть нулевым или пустым
-+	// if task.MinAmountOut <= 0 {
-+	//     return fmt.Errorf("min amount out must be greater than 0")
-+	// }
-+
-+	// Проверяем конфигурацию проскальзывания, если она используется
-+	if task.SlippageConfig.Type != types.SlippageNone {
-+		if task.SlippageConfig.Type == types.SlippagePercent &&
-+			(task.SlippageConfig.Value <= 0 || task.SlippageConfig.Value > 100) {
-+			return fmt.Errorf("slippage percentage must be between 0 and 100")
-+		}
-+		if task.SlippageConfig.Type == types.SlippageFixed && task.SlippageConfig.Value < 0 {
-+			return fmt.Errorf("fixed slippage value cannot be negative")
-+		}
- 	}
- 
- 	if task.SourceTokenDecimals <= 0 {
-diff --git a/internal/sniping/strategy.go b/internal/sniping/strategy.go
-index 91602f1..aa5b32c 100644
---- a/internal/sniping/strategy.go
-+++ b/internal/sniping/strategy.go
-@@ -60,9 +60,12 @@ func parseTask(record []string) (*types.Task, error) {
- 		return nil, fmt.Errorf("invalid AmountIn value: %v", err)
- 	}
- 
--	minAmountOut, err := strconv.ParseFloat(record[10], 64)
--	if err != nil {
--		return nil, fmt.Errorf("invalid MinAmountOut value: %v", err)
-+	slippageValue := 1.0 // Значение по умолчанию
-+	if record[10] != "" {
-+		slippageValue, err = strconv.ParseFloat(record[10], 64)
-+		if err != nil {
-+			return nil, fmt.Errorf("invalid Slippage value: %v", err)
-+		}
- 	}
- 
- 	autosellPercent, err := strconv.ParseFloat(record[11], 64)
-@@ -107,12 +110,15 @@ func parseTask(record []string) (*types.Task, error) {
- 		SourceToken:         record[7],
- 		TargetToken:         record[8],
- 		AmountIn:            amountIn,
--		MinAmountOut:        minAmountOut,
- 		AutosellPercent:     autosellPercent,
- 		AutosellDelay:       autosellDelay,
- 		AutosellAmount:      autosellAmount,
- 		TransactionDelay:    transactionDelay,
- 		AutosellPriorityFee: autosellPriorityFee,
--		DEXName:             dexName, // Устанавливаем имя DEX
-+		DEXName:             dexName,
-+		SlippageConfig: types.SlippageConfig{
-+			Type:  types.SlippagePercent, // Используем процентное проскальзывание по умолчанию
-+			Value: slippageValue,
-+		},
- 	}, nil
- }
-diff --git a/internal/types/types.go b/internal/types/types.go
-index babccdd..6b8c246 100644
---- a/internal/types/types.go
-+++ b/internal/types/types.go
-@@ -20,7 +20,6 @@ type Task struct {
- 	SourceToken                 string
- 	TargetToken                 string
- 	AmountIn                    float64
--	MinAmountOut                float64
- 	AutosellPercent             float64
- 	AutosellDelay               int
- 	AutosellAmount              float64
-@@ -31,6 +30,7 @@ type Task struct {
- 	SourceTokenDecimals         int
- 	TargetTokenDecimals         int
- 	DEXName                     string `default:"Raydium"` // Добавляем значение по умолчанию
-+	SlippageConfig              SlippageConfig
- }
- 
- type DEX interface {
-@@ -41,7 +41,6 @@ type DEX interface {
- 		sourceToken solana.PublicKey,
- 		destinationToken solana.PublicKey,
- 		amountIn uint64,
--		minAmountOut uint64,
- 		logger *zap.Logger,
- 	) (solana.Instruction, error)
- 
-diff --git a/internal/utils/logger/logger.go b/internal/utils/logger/logger.go
-index e5e813c..5b76758 100644
---- a/internal/utils/logger/logger.go
-+++ b/internal/utils/logger/logger.go
-@@ -138,7 +138,8 @@ func (l *Logger) WithTask(task *types.Task) *zap.Logger {
- 		zap.String("source_token", task.SourceToken),
- 		zap.String("target_token", task.TargetToken),
- 		zap.Float64("amount_in", task.AmountIn),
--		zap.Float64("min_amount_out", task.MinAmountOut),
-+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
-+		zap.Float64("slippage_value", task.SlippageConfig.Value),
- 		zap.Float64("priority_fee", task.PriorityFee),
- 	)
- }
