diff --git a/cmd/bot/main.go b/cmd/bot/main.go
index deaef2a..6c1eb4f 100644
--- a/cmd/bot/main.go
+++ b/cmd/bot/main.go
@@ -59,14 +59,22 @@ func main() {
 	fmt.Println("=== Loading wallets ===")
 	wallets, err := wallet.LoadWallets("configs/wallets.csv")
 	if err != nil {
-		fmt.Printf("Failed to load wallets: %v\n", err)
 		logger.Fatal("Failed to load wallets", zap.Error(err))
 	}
 	fmt.Printf("Loaded %d wallets\n", len(wallets))
 
-	// Инициализация Solana клиента
+	// Получаем первый кошелек для инициализации клиента
+	var primaryWallet *wallet.Wallet
+	for _, w := range wallets {
+		primaryWallet = w
+		break
+	}
+	if primaryWallet == nil {
+		logger.Fatal("No wallets available")
+	}
+	// Инициализация Solana клиента с приватным ключом
 	fmt.Println("=== Initializing Solana client ===")
-	client, err := solbc.NewClient(cfg.RPCList, logger)
+	client, err := solbc.NewClient(cfg.RPCList, primaryWallet.PrivateKey, logger)
 	if err != nil {
 		logger.Fatal("Failed to initialize Solana client", zap.Error(err))
 	}
diff --git a/configs/config.json b/configs/config.json
index 8c6b748..beb5a22 100644
--- a/configs/config.json
+++ b/configs/config.json
@@ -1,13 +1,16 @@
 {
     "license": "TEST-LICENSE-123456789",
-    "rpc_list": ["http://rpc-lax-a.thornode.io/e711fbc80050bff888e8584d9e2521ca"],
+    "rpc_list": [
+        "http://rpc-lax-a.thornode.io/e711fbc80050bff888e8584d9e2521ca"
+
+],
     "websocket_url": "ws://rpc-lax-a.thornode.io/e711fbc80050bff888e8584d9e2521ca",
     "monitor_delay": 1000,
     "rpc_delay": 100,
     "price_delay": 500,
     "debug_logging": true,
     "tps_logging": true,
-    "retries": 3,
+    "retries": 8,
     "webhook_url": "",
     "workers": 1,
     "postgres_url": "postgresql://rovshan:muradov25@postgres:5432/solana_bot?sslmode=disable"
diff --git a/configs/tasks.csv b/configs/tasks.csv
index 2823e89..d6dea62 100644
--- a/configs/tasks.csv
+++ b/configs/tasks.csv
@@ -1,2 +1,2 @@
 TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,SlippageConfig,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
-buyTokens,Raydium,1,wallet1,100,0.001,58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0.5,0,0,0,100,0.0003
\ No newline at end of file
+buyTokens,Raydium,1,wallet1,100,0.001,5QNAD6iofs8K4p7i9pbKty36bfaCixEVJPxBz2d8Y5cy,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0.5,0,0,0,100,0.0003
\ No newline at end of file
diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
index a9ee794..ce4d157 100644
--- a/internal/blockchain/solbc/client.go
+++ b/internal/blockchain/solbc/client.go
@@ -14,19 +14,19 @@ import (
 )
 
 // NewClient создает новый экземпляр клиента с улучшенным мониторингом
-func NewClient(rpcURLs []string, logger *zap.Logger) (*Client, error) {
+func NewClient(rpcURLs []string, privateKey solana.PrivateKey, logger *zap.Logger) (*Client, error) {
 	logger = logger.Named("solana-client")
 
-	// Создаем новый RPC клиент
 	rpcClient, err := rpc.NewClient(rpcURLs, logger)
 	if err != nil {
 		return nil, fmt.Errorf("failed to create RPC client: %w", err)
 	}
 
 	return &Client{
-		rpc:     rpcClient,
-		logger:  logger,
-		metrics: &ClientMetrics{},
+		rpc:        rpcClient,
+		logger:     logger,
+		metrics:    &ClientMetrics{},
+		privateKey: privateKey,
 	}, nil
 }
 
@@ -193,7 +193,8 @@ func (c *Client) GetRPCEndpoint() string {
 
 // GetWalletKey возвращает приватный ключ кошелька
 func (c *Client) GetWalletKey() (solana.PrivateKey, error) {
-	// Реализация получения ключа из конфигурации клиента
-	// Это зависит от того, как у вас хранится ключ
-	return nil, fmt.Errorf("not implemented")
+	if c.privateKey == nil {
+		return nil, fmt.Errorf("private key not set")
+	}
+	return c.privateKey, nil
 }
diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
index 9f5db0a..0589b05 100644
--- a/internal/blockchain/solbc/types.go
+++ b/internal/blockchain/solbc/types.go
@@ -8,6 +8,7 @@ import (
 
 	"go.uber.org/zap"
 
+	"github.com/gagliardetto/solana-go"
 	solanarpc "github.com/gagliardetto/solana-go/rpc"
 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
 	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
@@ -21,10 +22,11 @@ type TokenMetadataCache struct {
 
 // Client представляет основной клиент Solana
 type Client struct {
-	rpc     *rpc.Client
-	adapter *solanarpc.Client
-	logger  *zap.Logger
-	metrics *ClientMetrics
+	rpc        *rpc.Client
+	adapter    *solanarpc.Client
+	logger     *zap.Logger
+	metrics    *ClientMetrics
+	privateKey solana.PrivateKey // Добавляем поле для приватного ключа
 }
 
 type ClientMetrics struct {
diff --git a/internal/dex/dex.go b/internal/dex/dex.go
index acc9648..89a1139 100644
--- a/internal/dex/dex.go
+++ b/internal/dex/dex.go
@@ -43,9 +43,7 @@ func GetDEXByName(name string, client blockchain.Client, logger *zap.Logger) (ty
 }
 
 // initializeRaydiumDEX инициализирует Raydium DEX
-// internal/dex/dex.go
 func initializeRaydiumDEX(client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
-	// Проверяем и приводим клиент к нужному типу
 	solClient, ok := client.(*solbc.Client)
 	if !ok {
 		return nil, fmt.Errorf("invalid client type")
@@ -64,16 +62,12 @@ func initializeRaydiumDEX(client blockchain.Client, logger *zap.Logger) (types.D
 	}
 
 	// Создаем Raydium клиент
-	raydiumClient, err := raydium.NewRaydiumClient(
-		endpoint,
-		walletKey,
-		logger.Named("raydium"),
-	)
+	raydiumClient, err := raydium.NewRaydiumClient(endpoint, walletKey, logger.Named("raydium"))
 	if err != nil {
 		return nil, fmt.Errorf("failed to create Raydium client: %w", err)
 	}
 
-	// Создаем конфигурацию снайпера
+	// Создаем конфигурацию
 	config := &raydium.SniperConfig{
 		MaxSlippageBps:   500,        // 5%
 		MinAmountSOL:     100000,     // 0.0001 SOL
diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
index 4924747..aa8a188 100644
--- a/internal/dex/raydium/client.go
+++ b/internal/dex/raydium/client.go
@@ -21,7 +21,11 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
 	logger = logger.Named("raydium-client")
 
 	// Создаем базового клиента через фабрику
-	solClient, err := solbc.NewClient([]string{rpcEndpoint}, logger)
+	solClient, err := solbc.NewClient(
+		[]string{rpcEndpoint},
+		wallet, // Передаем приватный ключ в NewClient
+		logger,
+	)
 	if err != nil {
 		return nil, fmt.Errorf("failed to create solana client: %w", err)
 	}
@@ -38,6 +42,47 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
 	}, nil
 }
 
+// Добавим также вспомогательный метод для получения публичного ключа
+func (c *Client) GetPublicKey() solana.PublicKey {
+	return c.privateKey.PublicKey()
+}
+
+// Добавим метод для подписания транзакций
+func (c *Client) SignTransaction(tx *solana.Transaction) error {
+	_, err := tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+		if key.Equals(c.GetPublicKey()) {
+			return &c.privateKey
+		}
+		return nil
+	})
+	return err
+}
+
+// Добавим метод для проверки баланса кошелька
+func (c *Client) CheckWalletBalance(ctx context.Context) (uint64, error) {
+	balance, err := c.client.GetBalance(
+		ctx,
+		c.GetPublicKey(),
+		solanarpc.CommitmentConfirmed,
+	)
+	if err != nil {
+		return 0, fmt.Errorf("failed to get wallet balance: %w", err)
+	}
+	return balance, nil
+}
+
+// Добавим метод для получения ATA (Associated Token Account)
+func (c *Client) GetAssociatedTokenAccount(mint solana.PublicKey) (solana.PublicKey, error) {
+	ata, _, err := solana.FindAssociatedTokenAddress(
+		c.GetPublicKey(),
+		mint,
+	)
+	if err != nil {
+		return solana.PublicKey{}, fmt.Errorf("failed to find associated token address: %w", err)
+	}
+	return ata, nil
+}
+
 // GetPool получает информацию о пуле по базовому и котируемому токенам
 func (c *Client) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*Pool, error) {
 	c.logger.Debug("getting raydium pool info",
diff --git a/internal/dex/types.go b/internal/dex/types.go
new file mode 100644
index 0000000..f0fe9c5
--- /dev/null
+++ b/internal/dex/types.go
@@ -0,0 +1,74 @@
+// internal/dex/types.go
+package dex
+
+import (
+	"context"
+	"fmt"
+
+	"github.com/gagliardetto/solana-go"
+	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+	"github.com/rovshanmuradov/solana-bot/internal/dex/raydium"
+	"github.com/rovshanmuradov/solana-bot/internal/types"
+	"github.com/rovshanmuradov/solana-bot/internal/wallet"
+	"go.uber.org/zap"
+)
+
+// raydiumDEX реализует интерфейс types.DEX
+type raydiumDEX struct {
+	client *raydium.Client
+	logger *zap.Logger
+	config *raydium.SniperConfig
+}
+
+func (d *raydiumDEX) GetName() string {
+	return "Raydium"
+}
+
+func (d *raydiumDEX) GetClient() blockchain.Client {
+	return d.client.GetBaseClient()
+}
+
+func (d *raydiumDEX) GetConfig() interface{} {
+	return d.config
+}
+
+func (d *raydiumDEX) ExecuteSwap(ctx context.Context, task *types.Task, w *wallet.Wallet) error {
+	// Создание параметров свапа
+	d.logger.Debug("Starting swap execution",
+		zap.String("source_token", task.SourceToken),
+		zap.String("target_token", task.TargetToken),
+		zap.Float64("amount_in", task.AmountIn))
+
+	// Получаем информацию о пуле
+	pool, err := d.client.GetPool(ctx,
+		solana.MustPublicKeyFromBase58(task.SourceToken),
+		solana.MustPublicKeyFromBase58(task.TargetToken))
+	if err != nil {
+		return fmt.Errorf("failed to get pool info: %w", err)
+	}
+
+	// Конвертируем AmountIn в uint64
+	amountInLamports := uint64(task.AmountIn * float64(solana.LAMPORTS_PER_SOL))
+
+	// Создаем параметры свапа
+	params := &raydium.SwapParams{
+		UserWallet:          w.PublicKey,
+		PrivateKey:          &w.PrivateKey,
+		AmountIn:            amountInLamports,
+		Pool:                pool,
+		PriorityFeeLamports: uint64(task.PriorityFee * float64(solana.LAMPORTS_PER_SOL)),
+	}
+
+	// Выполняем свап
+	signature, err := d.client.ExecuteSwap(params)
+	if err != nil {
+		return fmt.Errorf("swap failed: %w", err)
+	}
+
+	d.logger.Info("Swap executed successfully",
+		zap.String("signature", signature),
+		zap.String("pool", pool.ID.String()),
+		zap.String("wallet", w.PublicKey.String()))
+
+	return nil
+}
diff --git a/internal/wallet/wallet.go b/internal/wallet/wallet.go
index 61f8297..0ef2422 100644
--- a/internal/wallet/wallet.go
+++ b/internal/wallet/wallet.go
@@ -1,3 +1,4 @@
+// inernal/wallet/wallet.go
 package wallet
 
 import (
diff --git a/newdif.txt b/newdif.txt
index 1862cc8..5ac359c 100644
--- a/newdif.txt
+++ b/newdif.txt
@@ -1,1558 +1,1488 @@
-diff --git a/go.mod b/go.mod
-index 6b29758..f342265 100644
---- a/go.mod
-+++ b/go.mod
-@@ -4,13 +4,11 @@ go 1.23.2
- 
- require (
- 	github.com/cenkalti/backoff/v4 v4.3.0
--	github.com/gagliardetto/binary v0.8.0
- 	github.com/gagliardetto/solana-go v1.11.0
- 	github.com/gobwas/ws v1.4.0
- 	github.com/google/uuid v1.6.0
- 	github.com/mr-tron/base58 v1.2.0
- 	github.com/prometheus/client_golang v1.20.5
--	github.com/shopspring/decimal v1.3.1
- 	github.com/spf13/viper v1.19.0
- 	go.uber.org/zap v1.27.0
- 	gopkg.in/natefinch/lumberjack.v2 v2.2.1
-@@ -27,6 +25,7 @@ require (
- 	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
- 	github.com/fatih/color v1.17.0 // indirect
- 	github.com/fsnotify/fsnotify v1.7.0 // indirect
-+	github.com/gagliardetto/binary v0.8.0 // indirect
- 	github.com/gagliardetto/treeout v0.1.4 // indirect
- 	github.com/gobwas/httphead v0.1.0 // indirect
- 	github.com/gobwas/pool v0.2.1 // indirect
-diff --git a/go.sum b/go.sum
-index 21aa3cc..4ff8611 100644
---- a/go.sum
-+++ b/go.sum
-@@ -27,8 +27,6 @@ github.com/fsnotify/fsnotify v1.7.0 h1:8JEhPFa5W2WU7YfeZzPNqzMP6Lwt7L2715Ggo0nos
- github.com/fsnotify/fsnotify v1.7.0/go.mod h1:40Bi/Hjc2AVfZrqy+aj+yEI+/bRxZnMJyTJwOpGvigM=
- github.com/gagliardetto/binary v0.8.0 h1:U9ahc45v9HW0d15LoN++vIXSJyqR/pWw8DDlhd7zvxg=
- github.com/gagliardetto/binary v0.8.0/go.mod h1:2tfj51g5o9dnvsc+fL3Jxr22MuWzYXwx9wEoN0XQ7/c=
--github.com/gagliardetto/gofuzz v1.2.2 h1:XL/8qDMzcgvR4+CyRQW9UGdwPRPMHVJfqQ/uMvSUuQw=
--github.com/gagliardetto/gofuzz v1.2.2/go.mod h1:bkH/3hYLZrMLbfYWA0pWzXmi5TTRZnu4pMGZBkqMKvY=
- github.com/gagliardetto/solana-go v1.11.0 h1:g6mR7uRNVT0Y0LVR0bvJNfKV6TyO6oUzBYu03ZmkEmY=
- github.com/gagliardetto/solana-go v1.11.0/go.mod h1:afBEcIRrDLJst3lvAahTr63m6W2Ns6dajZxe2irF7Jg=
- github.com/gagliardetto/treeout v0.1.4 h1:ozeYerrLCmCubo1TcIjFiOWTTGteOOHND1twdFpgwaw=
-diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
-index 4e0e778..4924747 100644
---- a/internal/dex/raydium/client.go
-+++ b/internal/dex/raydium/client.go
-@@ -17,7 +17,7 @@ import (
- )
- 
- // NewRaydiumClient создает новый экземпляр клиента Raydium с дефолтными настройками
--func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*RaydiumClient, error) {
-+func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*Client, error) {
- 	logger = logger.Named("raydium-client")
- 
- 	// Создаем базового клиента через фабрику
-@@ -27,7 +27,7 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
- 	}
- 
- 	// Создаем клиент с дефолтными настройками
--	return &RaydiumClient{
-+	return &Client{
- 		client:      solClient,
- 		logger:      logger,
- 		privateKey:  wallet,
-@@ -39,7 +39,7 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
- }
- 
- // GetPool получает информацию о пуле по базовому и котируемому токенам
--func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
-+func (c *Client) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*Pool, error) {
- 	c.logger.Debug("getting raydium pool info",
- 		zap.String("baseMint", baseMint.String()),
- 		zap.String("quoteMint", quoteMint.String()),
-@@ -48,7 +48,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
- 	// Получаем программные аккаунты через интерфейс
- 	accounts, err := c.client.GetProgramAccounts(
- 		ctx,
--		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
-+		RaydiumV4ProgramID,
- 		solanarpc.GetProgramAccountsOpts{
- 			Filters: []solanarpc.RPCFilter{
- 				{
-@@ -84,7 +84,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
- 	// Получаем authority пула через PDA
- 	authority, _, err := solana.FindProgramAddress(
- 		[][]byte{[]byte("amm_authority")},
--		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
-+		RaydiumV4ProgramID,
- 	)
+diff --git a/cmd/bot/main.go b/cmd/bot/main.go
+index deaef2a..6c1eb4f 100644
+--- a/cmd/bot/main.go
++++ b/cmd/bot/main.go
+@@ -59,14 +59,22 @@ func main() {
+ 	fmt.Println("=== Loading wallets ===")
+ 	wallets, err := wallet.LoadWallets("configs/wallets.csv")
  	if err != nil {
- 		return nil, fmt.Errorf("failed to derive authority: %w", err)
-@@ -98,7 +98,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
- 
- 	// Извлекаем данные из бинарного представления
- 	// Офсеты взяты из документации Raydium и SDK
--	pool := &RaydiumPool{
-+	pool := &Pool{
- 		ID:        poolAccount.Pubkey, // Исправлено с PublicKey на Pubkey
- 		Authority: authority,
- 		BaseMint:  baseMint,
-@@ -107,8 +107,8 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
- 		BaseVault:  solana.PublicKeyFromBytes(data[72:104]),
- 		QuoteVault: solana.PublicKeyFromBytes(data[104:136]),
- 		// Извлекаем decimals
--		BaseDecimals:  uint8(data[136]),
--		QuoteDecimals: uint8(data[137]),
-+		BaseDecimals:  (data[136]),
-+		QuoteDecimals: (data[137]),
- 		// Извлекаем fee в базисных пунктах (2 байта)
- 		DefaultFeeBps: binary.LittleEndian.Uint16(data[138:140]),
+-		fmt.Printf("Failed to load wallets: %v\n", err)
+ 		logger.Fatal("Failed to load wallets", zap.Error(err))
  	}
-@@ -126,7 +126,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
- }
+ 	fmt.Printf("Loaded %d wallets\n", len(wallets))
  
- // GetPoolState получает текущее состояние пула
--func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
-+func (c *Client) GetPoolState(pool *Pool) (*PoolState, error) {
- 	c.logger.Debug("getting pool state",
- 		zap.String("poolId", pool.ID.String()),
- 	)
-@@ -202,13 +202,13 @@ func (inst *SwapInstruction) SetDirection(direction SwapDirection) *SwapInstruct
- // Validate проверяет все необходимые параметры
- func (inst *SwapInstruction) Validate() error {
- 	if inst.Amount == nil {
--		return errors.New("Amount is not set")
-+		return errors.New("amount is not set")
- 	}
- 	if inst.MinimumOut == nil {
--		return errors.New("MinimumOut is not set")
-+		return errors.New("minimumOut is not set")
- 	}
- 	if inst.Direction == nil {
--		return errors.New("Direction is not set")
-+		return errors.New("direction is not set")
+-	// Инициализация Solana клиента
++	// Получаем первый кошелек для инициализации клиента
++	var primaryWallet *wallet.Wallet
++	for _, w := range wallets {
++		primaryWallet = w
++		break
++	}
++	if primaryWallet == nil {
++		logger.Fatal("No wallets available")
++	}
++	// Инициализация Solana клиента с приватным ключом
+ 	fmt.Println("=== Initializing Solana client ===")
+-	client, err := solbc.NewClient(cfg.RPCList, logger)
++	client, err := solbc.NewClient(cfg.RPCList, primaryWallet.PrivateKey, logger)
+ 	if err != nil {
+ 		logger.Fatal("Failed to initialize Solana client", zap.Error(err))
  	}
+diff --git a/configs/config.json b/configs/config.json
+index 8c6b748..beb5a22 100644
+--- a/configs/config.json
++++ b/configs/config.json
+@@ -1,13 +1,16 @@
+ {
+     "license": "TEST-LICENSE-123456789",
+-    "rpc_list": ["http://rpc-lax-a.thornode.io/e711fbc80050bff888e8584d9e2521ca"],
++    "rpc_list": [
++        "http://rpc-lax-a.thornode.io/e711fbc80050bff888e8584d9e2521ca"
++
++],
+     "websocket_url": "ws://rpc-lax-a.thornode.io/e711fbc80050bff888e8584d9e2521ca",
+     "monitor_delay": 1000,
+     "rpc_delay": 100,
+     "price_delay": 500,
+     "debug_logging": true,
+     "tps_logging": true,
+-    "retries": 3,
++    "retries": 8,
+     "webhook_url": "",
+     "workers": 1,
+     "postgres_url": "postgresql://rovshan:muradov25@postgres:5432/solana_bot?sslmode=disable"
+diff --git a/configs/tasks.csv b/configs/tasks.csv
+index 2823e89..d6dea62 100644
+--- a/configs/tasks.csv
++++ b/configs/tasks.csv
+@@ -1,2 +1,2 @@
+ TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,SlippageConfig,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
+-buyTokens,Raydium,1,wallet1,100,0.001,58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0.5,0,0,0,100,0.0003
+\ No newline at end of file
++buyTokens,Raydium,1,wallet1,100,0.001,5QNAD6iofs8K4p7i9pbKty36bfaCixEVJPxBz2d8Y5cy,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0.5,0,0,0,100,0.0003
+\ No newline at end of file
+diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
+index a9ee794..ce4d157 100644
+--- a/internal/blockchain/solbc/client.go
++++ b/internal/blockchain/solbc/client.go
+@@ -14,19 +14,19 @@ import (
+ )
  
- 	// Проверка всех аккаунтов
-@@ -221,17 +221,17 @@ func (inst *SwapInstruction) Validate() error {
- }
- 
- // ProgramID возвращает ID программы Raydium
--func (i *RaydiumSwapInstruction) ProgramID() solana.PublicKey {
-+func (i *ExecutableSwapInstruction) ProgramID() solana.PublicKey {
- 	return i.programID
- }
- 
- // Accounts возвращает список аккаунтов
--func (i *RaydiumSwapInstruction) Accounts() []*solana.AccountMeta {
-+func (i *ExecutableSwapInstruction) Accounts() []*solana.AccountMeta {
- 	return i.accounts
- }
- 
- // Data возвращает сериализованные данные инструкции
--func (i *RaydiumSwapInstruction) Data() ([]byte, error) {
-+func (i *ExecutableSwapInstruction) Data() ([]byte, error) {
- 	return i.data, nil
- }
- 
-@@ -251,8 +251,8 @@ func (inst *SwapInstruction) Build() (solana.Instruction, error) {
- 		data[16] = 1
- 	}
+ // NewClient создает новый экземпляр клиента с улучшенным мониторингом
+-func NewClient(rpcURLs []string, logger *zap.Logger) (*Client, error) {
++func NewClient(rpcURLs []string, privateKey solana.PrivateKey, logger *zap.Logger) (*Client, error) {
+ 	logger = logger.Named("solana-client")
  
--	instruction := &RaydiumSwapInstruction{
--		programID: solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
-+	instruction := &ExecutableSwapInstruction{
-+		programID: RaydiumV4ProgramID,
- 		accounts:  inst.AccountMetaSlice,
- 		data:      data,
+-	// Создаем новый RPC клиент
+ 	rpcClient, err := rpc.NewClient(rpcURLs, logger)
+ 	if err != nil {
+ 		return nil, fmt.Errorf("failed to create RPC client: %w", err)
  	}
-@@ -261,7 +261,7 @@ func (inst *SwapInstruction) Build() (solana.Instruction, error) {
- }
  
- // CreateSwapInstructions создает инструкции для свапа
--func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
-+func (c *Client) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
- 	if err := validateSwapParams(params); err != nil {
- 		return nil, err
- 	}
-@@ -271,7 +271,7 @@ func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Ins
- 	// Добавляем инструкцию compute budget если указан приоритетный fee
- 	if params.PriorityFeeLamports > 0 {
- 		computeLimitIx, err := computebudget.NewSetComputeUnitLimitInstructionBuilder().
--			SetUnits(MAX_COMPUTE_UNIT_LIMIT).
-+			SetUnits(MaxComputeUnitLimit).
- 			ValidateAndBuild()
- 		if err != nil {
- 			return nil, fmt.Errorf("failed to build compute limit instruction: %w", err)
-@@ -337,7 +337,7 @@ func validateSwapParams(params *SwapParams) error {
+ 	return &Client{
+-		rpc:     rpcClient,
+-		logger:  logger,
+-		metrics: &ClientMetrics{},
++		rpc:        rpcClient,
++		logger:     logger,
++		metrics:    &ClientMetrics{},
++		privateKey: privateKey,
+ 	}, nil
  }
  
- // SimulateSwap выполняет симуляцию транзакции свапа
--func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) error {
-+func (c *Client) SimulateSwap(ctx context.Context, params *SwapParams) error {
- 	c.logger.Debug("simulating swap transaction",
- 		zap.String("userWallet", params.UserWallet.String()),
- 		zap.Uint64("amountIn", params.AmountIn),
-@@ -369,12 +369,21 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) er
- 
- 	// Подписываем транзакцию если есть приватный ключ
- 	if params.PrivateKey != nil {
--		tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
-+		signatures, err := tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
- 			if key.Equals(params.UserWallet) {
- 				return params.PrivateKey
- 			}
- 			return nil
- 		})
-+		if err != nil {
-+			return fmt.Errorf("failed to sign transaction: %w", err)
-+		}
-+
-+		// Опционально: можно добавить логирование подписей
-+		c.logger.Debug("transaction signed",
-+			zap.Int("signatures_count", len(signatures)),
-+			zap.String("first_signature", signatures[0].String()),
-+		)
- 	}
- 
- 	// Симулируем транзакцию
-@@ -412,7 +421,7 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) er
- // Метрики выполнения свапов
+@@ -193,7 +193,8 @@ func (c *Client) GetRPCEndpoint() string {
  
- // ExecuteSwap выполняет свап и возвращает signature транзакции
--func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
-+func (c *Client) ExecuteSwap(params *SwapParams) (string, error) {
- 	c.logger.Debug("starting swap execution",
- 		zap.String("userWallet", params.UserWallet.String()),
- 		zap.Uint64("amountIn", params.AmountIn),
-@@ -492,39 +501,40 @@ func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
- 	return sig.String(), nil
+ // GetWalletKey возвращает приватный ключ кошелька
+ func (c *Client) GetWalletKey() (solana.PrivateKey, error) {
+-	// Реализация получения ключа из конфигурации клиента
+-	// Это зависит от того, как у вас хранится ключ
+-	return nil, fmt.Errorf("not implemented")
++	if c.privateKey == nil {
++		return nil, fmt.Errorf("private key not set")
++	}
++	return c.privateKey, nil
  }
+diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
+index 9f5db0a..0589b05 100644
+--- a/internal/blockchain/solbc/types.go
++++ b/internal/blockchain/solbc/types.go
+@@ -8,6 +8,7 @@ import (
  
-+// TODO: этот метод нигде пока не используется, надо добавить его в код
- // logUpdatedBalances вспомогательный метод для логирования балансов после свапа
--func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
--	ctx := context.Background()
--
--	// Получаем баланс SOL
--	solBalance, err := c.client.GetBalance(
--		ctx,
--		params.UserWallet,
--		solanarpc.CommitmentConfirmed,
--	)
--	if err != nil {
--		return fmt.Errorf("failed to get SOL balance: %w", err)
--	}
--
--	// Получаем баланс токена
--	tokenBalance, err := c.client.GetTokenAccountBalance(
--		ctx,
--		params.DestinationTokenAccount,
--		solanarpc.CommitmentConfirmed,
--	)
--	if err != nil {
--		return fmt.Errorf("failed to get token balance: %w", err)
--	}
--
--	c.logger.Info("updated balances",
--		zap.Float64("solBalance", float64(solBalance)/float64(solana.LAMPORTS_PER_SOL)),
--		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
--	)
--
--	return nil
--}
-+// func (c *Client) logUpdatedBalances(params *SwapParams) error {
-+// 	ctx := context.Background()
-+
-+// 	// Получаем баланс SOL
-+// 	solBalance, err := c.client.GetBalance(
-+// 		ctx,
-+// 		params.UserWallet,
-+// 		solanarpc.CommitmentConfirmed,
-+// 	)
-+// 	if err != nil {
-+// 		return fmt.Errorf("failed to get SOL balance: %w", err)
-+// 	}
-+
-+// 	// Получаем баланс токена
-+// 	tokenBalance, err := c.client.GetTokenAccountBalance(
-+// 		ctx,
-+// 		params.DestinationTokenAccount,
-+// 		solanarpc.CommitmentConfirmed,
-+// 	)
-+// 	if err != nil {
-+// 		return fmt.Errorf("failed to get token balance: %w", err)
-+// 	}
-+
-+// 	c.logger.Info("updated balances",
-+// 		zap.Float64("solBalance", float64(solBalance)/float64(solana.LAMPORTS_PER_SOL)),
-+// 		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
-+// 	)
-+
-+// 	return nil
-+// }
- 
- // GetBaseClient возвращает базовый blockchain.Client
--func (c *RaydiumClient) GetBaseClient() blockchain.Client {
-+func (c *Client) GetBaseClient() blockchain.Client {
- 	return c.client
- }
-diff --git a/internal/dex/raydium/constants.go b/internal/dex/raydium/constants.go
-index 049e4ff..43282e4 100644
---- a/internal/dex/raydium/constants.go
-+++ b/internal/dex/raydium/constants.go
-@@ -1,96 +1,101 @@
- // internal/dex/raydium/constants.go
- package raydium
+ 	"go.uber.org/zap"
  
--import "fmt"
-+import (
-+	"fmt"
-+
 +	"github.com/gagliardetto/solana-go"
-+)
- 
- // Program IDs
--const (
--	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
--	TOKEN_PROGRAM_ID      = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
--	SYSTEM_PROGRAM_ID     = "11111111111111111111111111111111"
--	SYSVAR_RENT_PUBKEY    = "SysvarRent111111111111111111111111111111111"
--	WRAPPED_SOL_MINT      = "So11111111111111111111111111111111111111112" // Добавлено
-+var (
-+	// Используем MPK для краткости, так как это константы
-+	TokenProgramID     = solana.MPK("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
-+	RaydiumV4ProgramID = solana.MPK("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8")
-+	SystemProgramID    = solana.MPK("11111111111111111111111111111111")
-+	SysvarRentPubkey   = solana.MPK("SysvarRent111111111111111111111111111111111")
-+	WrappedSolMint     = solana.MPK("So11111111111111111111111111111111111111112")
- )
- 
- // Compute budget constants
- const (
--	MAX_COMPUTE_UNIT_LIMIT = 300000
--	DEFAULT_COMPUTE_PRICE  = 1000
--	MIN_COMPUTE_PRICE      = 0      // Добавлено
--	MAX_COMPUTE_PRICE      = 100000 // Добавлено
-+	MaxComputeUnitLimit = 300000
-+	DefaultComputePrice = 1000
-+	MinComputePrice     = 0
-+	MaxComputePrice     = 100000
- )
- 
- // Pool account layout constants
- const (
--	POOL_ACCOUNT_SIZE     = 388
--	POOL_VERSION_OFFSET   = 0 // Добавлено
--	STATUS_OFFSET         = 1 // Добавлено
--	BASE_MINT_OFFSET      = 8
--	QUOTE_MINT_OFFSET     = 40
--	LP_MINT_OFFSET        = 72 // Добавлено
--	BASE_VAULT_OFFSET     = 104
--	QUOTE_VAULT_OFFSET    = 136
--	DECIMALS_OFFSET       = 168
--	FEE_BPS_OFFSET        = 170
--	POOL_STATUS_OFFSET    = 188
--	AMM_OPEN_ORDERS       = 196
--	MARKET_ID_OFFSET      = 228
--	TARGET_ORDERS_OFFSET  = 260 // Добавлено
--	WITHDRAW_QUEUE_OFFSET = 292 // Добавлено
-+	PoolAccountSize     = 388
-+	PoolVersionOffset   = 0
-+	StatusOffset        = 1
-+	BaseMintOffset      = 8
-+	QuoteMintOffset     = 40
-+	LpMintOffset        = 72
-+	BaseVaultOffset     = 104
-+	QuoteVaultOffset    = 136
-+	DecimalsOffset      = 168
-+	FeeBpsOffset        = 170
-+	PoolStatusOffset    = 188
-+	AmmOpenOrders       = 196
-+	MarketIDOffset      = 228
-+	TargetOrdersOffset  = 260
-+	WithdrawQueueOffset = 292
- )
- 
- // Pool status
- const (
--	POOL_STATUS_UNINITIALIZED uint8 = 0
--	POOL_STATUS_INITIALIZED   uint8 = 1
--	POOL_STATUS_DISABLED      uint8 = 2
--	POOL_STATUS_ACTIVE        uint8 = 3
-+	PoolStatusUninitialized uint8 = 0
-+	PoolStatusInitialized   uint8 = 1
-+	PoolStatusDisabled      uint8 = 2
-+	PoolStatusActive        uint8 = 3
- )
- 
- // PDA seeds
- const (
--	AMM_AUTHORITY_LAYOUT = "amm_authority"
--	POOL_TEMP_LP_LAYOUT  = "pool_temp_lp"
--	POOL_WITHDRAW_QUEUE  = "withdraw_queue"
--	TARGET_ORDERS_SEED   = "target_orders" // Добавлено
--	OPEN_ORDERS_SEED     = "open_orders"   // Добавлено
-+	AmmAuthorityLayout = "amm_authority"
-+	PoolTempLpLayout   = "pool_temp_lp"
-+	PoolWithdrawQueue  = "withdraw_queue"
-+	TargetOrdersSeed   = "target_orders"
-+	OpenOrdersSeed     = "open_orders"
- )
- 
- // Swap constants
- const (
--	DEFAULT_SLIPPAGE_PERCENT = 0.5
--	MAX_SLIPPAGE_PERCENT     = 5.0
--	MIN_SWAP_AMOUNT          = 1000   // Добавлено: минимальная сумма для свапа в лампортах
--	MAX_TOKENS_IN_POOL       = 100000 // Добавлено: максимальное количество токенов в пуле
--	TRADE_DIRECTION_IN       = "in"   // Добавлено
--	TRADE_DIRECTION_OUT      = "out"  // Добавлено
-+	DefaultSlippagePercent = 0.5
-+	MaxSlippagePercent     = 5.0
-+	MinSwapAmount          = 1000
-+	MaxTokensInPool        = 100000
-+	TradeDirectionIn       = "in"
-+	TradeDirectionOut      = "out"
- )
- 
- // Error codes
- const (
--	ERR_POOL_NOT_FOUND      = "POOL_NOT_FOUND" // Изменено на uppercase
--	ERR_INVALID_POOL_STATUS = "INVALID_POOL_STATUS"
--	ERR_INSUFFICIENT_FUNDS  = "INSUFFICIENT_FUNDS"
--	ERR_SLIPPAGE_EXCEEDED   = "SLIPPAGE_EXCEEDED"
--	ERR_INVALID_MINT        = "INVALID_MINT"
--	ERR_INVALID_AMOUNT      = "INVALID_AMOUNT"    // Добавлено
--	ERR_POOL_DISABLED       = "POOL_DISABLED"     // Добавлено
--	ERR_INVALID_DIRECTION   = "INVALID_DIRECTION" // Добавлено
-+	ErrPoolNotFound      = "POOL_NOT_FOUND"
-+	ErrInvalidPoolStatus = "INVALID_POOL_STATUS"
-+	ErrInsufficientFunds = "INSUFFICIENT_FUNDS"
-+	ErrSlippageExceeded  = "SLIPPAGE_EXCEEDED"
-+	ErrInvalidMint       = "INVALID_MINT"
-+	ErrInvalidAmount     = "INVALID_AMOUNT"
-+	ErrPoolDisabled      = "POOL_DISABLED"
-+	ErrInvalidDirection  = "INVALID_DIRECTION"
- )
- 
- // Account size constants
- const (
--	TOKEN_ACCOUNT_SIZE = 165 // Добавлено
--	MINT_ACCOUNT_SIZE  = 82  // Добавлено
-+	TokenAccountSize = 165
-+	MintAccountSize  = 82
- )
+ 	solanarpc "github.com/gagliardetto/solana-go/rpc"
+ 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+ 	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
+@@ -21,10 +22,11 @@ type TokenMetadataCache struct {
  
--func (e *RaydiumError) Error() string {
-+func (e *Error) Error() string {
- 	return fmt.Sprintf("%s: %s", e.Code, e.Message)
+ // Client представляет основной клиент Solana
+ type Client struct {
+-	rpc     *rpc.Client
+-	adapter *solanarpc.Client
+-	logger  *zap.Logger
+-	metrics *ClientMetrics
++	rpc        *rpc.Client
++	adapter    *solanarpc.Client
++	logger     *zap.Logger
++	metrics    *ClientMetrics
++	privateKey solana.PrivateKey // Добавляем поле для приватного ключа
  }
  
- // Добавляем конструктор для RaydiumError
--func NewRaydiumError(code string, message string, details map[string]interface{}) *RaydiumError {
--	return &RaydiumError{
-+func NewRaydiumError(code string, message string, details map[string]interface{}) *Error {
-+	return &Error{
- 		Code:    code,
- 		Message: message,
- 		Details: details,
-diff --git a/internal/dex/raydium/newSwap.txt b/internal/dex/raydium/newSwap.txt
-index 3d803c5..0eda437 100644
---- a/internal/dex/raydium/newSwap.txt
-+++ b/internal/dex/raydium/newSwap.txt
-@@ -48,7 +48,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
- 	// Получаем программные аккаунты через интерфейс
- 	accounts, err := c.client.GetProgramAccounts(
- 		ctx,
--		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
-+		solana.MustPublicKeyFromBase58(RaydiumV4ProgramID),
- 		solanarpc.GetProgramAccountsOpts{
- 			Filters: []solanarpc.RPCFilter{
- 				{
-@@ -84,7 +84,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
- 	// Получаем authority пула через PDA
- 	authority, _, err := solana.FindProgramAddress(
- 		[][]byte{[]byte("amm_authority")},
--		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
-+		solana.MustPublicKeyFromBase58(RaydiumV4ProgramID),
- 	)
- 	if err != nil {
- 		return nil, fmt.Errorf("failed to derive authority: %w", err)
-@@ -107,8 +107,8 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
- 		BaseVault:  solana.PublicKeyFromBytes(data[72:104]),
- 		QuoteVault: solana.PublicKeyFromBytes(data[104:136]),
- 		// Извлекаем decimals
--		BaseDecimals:  uint8(data[136]),
--		QuoteDecimals: uint8(data[137]),
-+		BaseDecimals:  (data[136]),
-+		QuoteDecimals: (data[137]),
- 		// Извлекаем fee в базисных пунктах (2 байта)
- 		DefaultFeeBps: binary.LittleEndian.Uint16(data[138:140]),
- 	}
-@@ -202,13 +202,13 @@ func (inst *SwapInstruction) SetDirection(direction SwapDirection) *SwapInstruct
- // Validate проверяет все необходимые параметры
- func (inst *SwapInstruction) Validate() error {
- 	if inst.Amount == nil {
--		return errors.New("Amount is not set")
-+		return errors.New("amount is not set")
- 	}
- 	if inst.MinimumOut == nil {
--		return errors.New("MinimumOut is not set")
-+		return errors.New("minimumOut is not set")
- 	}
- 	if inst.Direction == nil {
--		return errors.New("Direction is not set")
-+		return errors.New("direction is not set")
- 	}
- 
- 	// Проверка всех аккаунтов
-@@ -252,7 +252,7 @@ func (inst *SwapInstruction) Build() (solana.Instruction, error) {
- 	}
- 
- 	instruction := &RaydiumSwapInstruction{
--		programID: solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
-+		programID: solana.MustPublicKeyFromBase58(RaydiumV4ProgramID),
- 		accounts:  inst.AccountMetaSlice,
- 		data:      data,
- 	}
-@@ -271,7 +271,7 @@ func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Ins
- 	// Добавляем инструкцию compute budget если указан приоритетный fee
- 	if params.PriorityFeeLamports > 0 {
- 		computeLimitIx, err := computebudget.NewSetComputeUnitLimitInstructionBuilder().
--			SetUnits(MAX_COMPUTE_UNIT_LIMIT).
-+			SetUnits(MaxComputeUnitLimit).
- 			ValidateAndBuild()
- 		if err != nil {
- 			return nil, fmt.Errorf("failed to build compute limit instruction: %w", err)
-@@ -369,12 +369,21 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) er
- 
- 	// Подписываем транзакцию если есть приватный ключ
- 	if params.PrivateKey != nil {
--		tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
-+		signatures, err := tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
- 			if key.Equals(params.UserWallet) {
- 				return params.PrivateKey
- 			}
- 			return nil
- 		})
-+		if err != nil {
-+			return fmt.Errorf("failed to sign transaction: %w", err)
-+		}
-+
-+		// Опционально: можно добавить логирование подписей
-+		c.logger.Debug("transaction signed",
-+			zap.Int("signatures_count", len(signatures)),
-+			zap.String("first_signature", signatures[0].String()),
-+		)
- 	}
- 
- 	// Симулируем транзакцию
-@@ -524,6 +533,10 @@ func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
- 	return nil
+ type ClientMetrics struct {
+diff --git a/internal/dex/dex.go b/internal/dex/dex.go
+index acc9648..89a1139 100644
+--- a/internal/dex/dex.go
++++ b/internal/dex/dex.go
+@@ -43,9 +43,7 @@ func GetDEXByName(name string, client blockchain.Client, logger *zap.Logger) (ty
  }
  
-+// GetBaseClient возвращает базовый blockchain.Client
-+func (c *RaydiumClient) GetBaseClient() blockchain.Client {
-+	return c.client
-+}
- // internal/dex/raydium/constants.go
- package raydium
- 
-@@ -531,83 +544,83 @@ import "fmt"
- 
- // Program IDs
- const (
--	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
--	TOKEN_PROGRAM_ID      = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
--	SYSTEM_PROGRAM_ID     = "11111111111111111111111111111111"
--	SYSVAR_RENT_PUBKEY    = "SysvarRent111111111111111111111111111111111"
--	WRAPPED_SOL_MINT      = "So11111111111111111111111111111111111111112" // Добавлено
-+	RaydiumV4ProgramID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
-+	TokenProgramID     = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
-+	SystemProgramID    = "11111111111111111111111111111111"
-+	SysvarRentPubkey   = "SysvarRent111111111111111111111111111111111"
-+	WrappedSolMint     = "So11111111111111111111111111111111111111112"
- )
- 
- // Compute budget constants
- const (
--	MAX_COMPUTE_UNIT_LIMIT = 300000
--	DEFAULT_COMPUTE_PRICE  = 1000
--	MIN_COMPUTE_PRICE      = 0      // Добавлено
--	MAX_COMPUTE_PRICE      = 100000 // Добавлено
-+	MaxComputeUnitLimit = 300000
-+	DefaultComputePrice = 1000
-+	MinComputePrice     = 0
-+	MaxComputePrice     = 100000
- )
- 
- // Pool account layout constants
- const (
--	POOL_ACCOUNT_SIZE     = 388
--	POOL_VERSION_OFFSET   = 0 // Добавлено
--	STATUS_OFFSET         = 1 // Добавлено
--	BASE_MINT_OFFSET      = 8
--	QUOTE_MINT_OFFSET     = 40
--	LP_MINT_OFFSET        = 72 // Добавлено
--	BASE_VAULT_OFFSET     = 104
--	QUOTE_VAULT_OFFSET    = 136
--	DECIMALS_OFFSET       = 168
--	FEE_BPS_OFFSET        = 170
--	POOL_STATUS_OFFSET    = 188
--	AMM_OPEN_ORDERS       = 196
--	MARKET_ID_OFFSET      = 228
--	TARGET_ORDERS_OFFSET  = 260 // Добавлено
--	WITHDRAW_QUEUE_OFFSET = 292 // Добавлено
-+	PoolAccountSize     = 388
-+	PoolVersionOffset   = 0
-+	StatusOffset        = 1
-+	BaseMintOffset      = 8
-+	QuoteMintOffset     = 40
-+	LpMintOffset        = 72
-+	BaseVaultOffset     = 104
-+	QuoteVaultOffset    = 136
-+	DecimalsOffset      = 168
-+	FeeBpsOffset        = 170
-+	PoolStatusOffset    = 188
-+	AmmOpenOrders       = 196
-+	MarketIDOffset      = 228
-+	TargetOrdersOffset  = 260
-+	WithdrawQueueOffset = 292
- )
- 
- // Pool status
- const (
--	POOL_STATUS_UNINITIALIZED uint8 = 0
--	POOL_STATUS_INITIALIZED   uint8 = 1
--	POOL_STATUS_DISABLED      uint8 = 2
--	POOL_STATUS_ACTIVE        uint8 = 3
-+	PoolStatusUninitialized uint8 = 0
-+	PoolStatusInitialized   uint8 = 1
-+	PoolStatusDisabled      uint8 = 2
-+	PoolStatusActive        uint8 = 3
- )
- 
- // PDA seeds
- const (
--	AMM_AUTHORITY_LAYOUT = "amm_authority"
--	POOL_TEMP_LP_LAYOUT  = "pool_temp_lp"
--	POOL_WITHDRAW_QUEUE  = "withdraw_queue"
--	TARGET_ORDERS_SEED   = "target_orders" // Добавлено
--	OPEN_ORDERS_SEED     = "open_orders"   // Добавлено
-+	AmmAuthorityLayout = "amm_authority"
-+	PoolTempLpLayout   = "pool_temp_lp"
-+	PoolWithdrawQueue  = "withdraw_queue"
-+	TargetOrdersSeed   = "target_orders"
-+	OpenOrdersSeed     = "open_orders"
- )
- 
- // Swap constants
- const (
--	DEFAULT_SLIPPAGE_PERCENT = 0.5
--	MAX_SLIPPAGE_PERCENT     = 5.0
--	MIN_SWAP_AMOUNT          = 1000   // Добавлено: минимальная сумма для свапа в лампортах
--	MAX_TOKENS_IN_POOL       = 100000 // Добавлено: максимальное количество токенов в пуле
--	TRADE_DIRECTION_IN       = "in"   // Добавлено
--	TRADE_DIRECTION_OUT      = "out"  // Добавлено
-+	DefaultSlippagePercent = 0.5
-+	MaxSlippagePercent     = 5.0
-+	MinSwapAmount          = 1000
-+	MaxTokensInPool        = 100000
-+	TradeDirectionIn       = "in"
-+	TradeDirectionOut      = "out"
- )
- 
- // Error codes
- const (
--	ERR_POOL_NOT_FOUND      = "POOL_NOT_FOUND" // Изменено на uppercase
--	ERR_INVALID_POOL_STATUS = "INVALID_POOL_STATUS"
--	ERR_INSUFFICIENT_FUNDS  = "INSUFFICIENT_FUNDS"
--	ERR_SLIPPAGE_EXCEEDED   = "SLIPPAGE_EXCEEDED"
--	ERR_INVALID_MINT        = "INVALID_MINT"
--	ERR_INVALID_AMOUNT      = "INVALID_AMOUNT"    // Добавлено
--	ERR_POOL_DISABLED       = "POOL_DISABLED"     // Добавлено
--	ERR_INVALID_DIRECTION   = "INVALID_DIRECTION" // Добавлено
-+	ErrPoolNotFound      = "POOL_NOT_FOUND"
-+	ErrInvalidPoolStatus = "INVALID_POOL_STATUS"
-+	ErrInsufficientFunds = "INSUFFICIENT_FUNDS"
-+	ErrSlippageExceeded  = "SLIPPAGE_EXCEEDED"
-+	ErrInvalidMint       = "INVALID_MINT"
-+	ErrInvalidAmount     = "INVALID_AMOUNT"
-+	ErrPoolDisabled      = "POOL_DISABLED"
-+	ErrInvalidDirection  = "INVALID_DIRECTION"
- )
- 
- // Account size constants
- const (
--	TOKEN_ACCOUNT_SIZE = 165 // Добавлено
--	MINT_ACCOUNT_SIZE  = 82  // Добавлено
-+	TokenAccountSize = 165
-+	MintAccountSize  = 82
- )
- 
- func (e *RaydiumError) Error() string {
-@@ -886,62 +899,66 @@ func (s *Sniper) ValidateAndPrepare() error {
- // 4. Добавить отслеживание транзакций в мемпуле
- // 5. Добавить механизм websocket подключения
- // 6. Добавить механизм агрегации данных по нескольким RPC
--func (s *Sniper) MonitorPoolChanges() error {
-+func (s *Sniper) MonitorPoolChanges(ctx context.Context) error {
- 	s.logger.Debug("starting pool monitoring")
- 
- 	ticker := time.NewTicker(s.config.MonitorInterval)
- 	defer ticker.Stop()
- 
- 	// Получаем начальное состояние пула
--	pool, err := s.client.GetPool(context.Background(), s.config.BaseMint, s.config.QuoteMint)
-+	pool, err := s.client.GetPool(ctx, s.config.BaseMint, s.config.QuoteMint)
- 	if err != nil {
- 		return fmt.Errorf("failed to get initial pool state: %w", err)
+ // initializeRaydiumDEX инициализирует Raydium DEX
+-// internal/dex/dex.go
+ func initializeRaydiumDEX(client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
+-	// Проверяем и приводим клиент к нужному типу
+ 	solClient, ok := client.(*solbc.Client)
+ 	if !ok {
+ 		return nil, fmt.Errorf("invalid client type")
+@@ -64,16 +62,12 @@ func initializeRaydiumDEX(client blockchain.Client, logger *zap.Logger) (types.D
  	}
  
- 	poolManager := NewPoolManager(s.client.client, s.logger, pool)
--	initialState, err := poolManager.GetPoolState(context.Background())
-+	initialState, err := poolManager.GetPoolState(ctx)
+ 	// Создаем Raydium клиент
+-	raydiumClient, err := raydium.NewRaydiumClient(
+-		endpoint,
+-		walletKey,
+-		logger.Named("raydium"),
+-	)
++	raydiumClient, err := raydium.NewRaydiumClient(endpoint, walletKey, logger.Named("raydium"))
  	if err != nil {
- 		return fmt.Errorf("failed to get initial pool state: %w", err)
- 	}
- 
- 	var retryCount int
--	for {
--		select {
--		case <-ticker.C:
--			// Получаем текущее состояние пула
--			currentState, err := poolManager.GetPoolState(context.Background())
--			if err != nil {
--				retryCount++
--				s.logger.Error("failed to get current pool state",
--					zap.Error(err),
--					zap.Int("retry", retryCount),
--				)
--				if retryCount >= s.config.MaxRetries {
--					return fmt.Errorf("max retries exceeded while monitoring pool")
--				}
--				continue
-+	for range ticker.C {
-+		// Проверяем контекст перед каждой итерацией
-+		if err := ctx.Err(); err != nil {
-+			return fmt.Errorf("monitoring stopped: %w", err)
-+		}
-+
-+		// Получаем текущее состояние пула
-+		currentState, err := poolManager.GetPoolState(ctx)
-+		if err != nil {
-+			retryCount++
-+			s.logger.Error("failed to get current pool state",
-+				zap.Error(err),
-+				zap.Int("retry", retryCount),
-+			)
-+			if retryCount >= s.config.MaxRetries {
-+				return fmt.Errorf("max retries exceeded while monitoring pool")
- 			}
--			retryCount = 0
--
--			// Проверяем изменения в пуле
--			if s.hasSignificantChanges(initialState, currentState) {
--				s.logger.Info("detected significant pool changes",
--					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
--					zap.Uint64("newBaseReserve", currentState.BaseReserve),
--					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
--					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
--				)
--
--				// Если пул неактивен, прекращаем мониторинг
--				if currentState.Status != 1 {
--					return fmt.Errorf("pool became inactive")
--				}
--
--				// Обновляем начальное состояние
--				initialState = currentState
-+			continue
-+		}
-+		retryCount = 0
-+
-+		// Проверяем изменения в пуле
-+		if s.hasSignificantChanges(initialState, currentState) {
-+			s.logger.Info("detected significant pool changes",
-+				zap.Uint64("oldBaseReserve", initialState.BaseReserve),
-+				zap.Uint64("newBaseReserve", currentState.BaseReserve),
-+				zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
-+				zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
-+			)
-+
-+			// Если пул неактивен, прекращаем мониторинг
-+			if currentState.Status != 1 {
-+				return fmt.Errorf("pool became inactive")
- 			}
-+
-+			// Обновляем начальное состояние
-+			initialState = currentState
- 		}
+ 		return nil, fmt.Errorf("failed to create Raydium client: %w", err)
  	}
-+
-+	return nil
- }
- 
- // Вспомогательный метод для определения значительных изменений в пуле
-diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
-index f144a25..5e47fb8 100644
---- a/internal/dex/raydium/pool.go
-+++ b/internal/dex/raydium/pool.go
-@@ -12,7 +12,7 @@ import (
- )
- 
- // NewPoolManager создает новый менеджер пула
--func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *RaydiumPool) *PoolManager {
-+func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *Pool) *PoolManager {
- 	return &PoolManager{
- 		client: client,
- 		logger: logger,
-diff --git a/internal/dex/raydium/sniper.go b/internal/dex/raydium/sniper.go
-index 7c0daf1..b361693 100644
---- a/internal/dex/raydium/sniper.go
-+++ b/internal/dex/raydium/sniper.go
-@@ -133,62 +133,66 @@ func (s *Sniper) ValidateAndPrepare() error {
- // 4. Добавить отслеживание транзакций в мемпуле
- // 5. Добавить механизм websocket подключения
- // 6. Добавить механизм агрегации данных по нескольким RPC
--func (s *Sniper) MonitorPoolChanges() error {
-+func (s *Sniper) MonitorPoolChanges(ctx context.Context) error {
- 	s.logger.Debug("starting pool monitoring")
  
- 	ticker := time.NewTicker(s.config.MonitorInterval)
- 	defer ticker.Stop()
- 
- 	// Получаем начальное состояние пула
--	pool, err := s.client.GetPool(context.Background(), s.config.BaseMint, s.config.QuoteMint)
-+	pool, err := s.client.GetPool(ctx, s.config.BaseMint, s.config.QuoteMint)
- 	if err != nil {
- 		return fmt.Errorf("failed to get initial pool state: %w", err)
- 	}
+-	// Создаем конфигурацию снайпера
++	// Создаем конфигурацию
+ 	config := &raydium.SniperConfig{
+ 		MaxSlippageBps:   500,        // 5%
+ 		MinAmountSOL:     100000,     // 0.0001 SOL
+diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
+index 4924747..aa8a188 100644
+--- a/internal/dex/raydium/client.go
++++ b/internal/dex/raydium/client.go
+@@ -21,7 +21,11 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
+ 	logger = logger.Named("raydium-client")
  
- 	poolManager := NewPoolManager(s.client.client, s.logger, pool)
--	initialState, err := poolManager.GetPoolState(context.Background())
-+	initialState, err := poolManager.GetPoolState(ctx)
+ 	// Создаем базового клиента через фабрику
+-	solClient, err := solbc.NewClient([]string{rpcEndpoint}, logger)
++	solClient, err := solbc.NewClient(
++		[]string{rpcEndpoint},
++		wallet, // Передаем приватный ключ в NewClient
++		logger,
++	)
  	if err != nil {
- 		return fmt.Errorf("failed to get initial pool state: %w", err)
+ 		return nil, fmt.Errorf("failed to create solana client: %w", err)
  	}
+@@ -38,6 +42,47 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
+ 	}, nil
+ }
  
- 	var retryCount int
--	for {
--		select {
--		case <-ticker.C:
--			// Получаем текущее состояние пула
--			currentState, err := poolManager.GetPoolState(context.Background())
--			if err != nil {
--				retryCount++
--				s.logger.Error("failed to get current pool state",
--					zap.Error(err),
--					zap.Int("retry", retryCount),
--				)
--				if retryCount >= s.config.MaxRetries {
--					return fmt.Errorf("max retries exceeded while monitoring pool")
--				}
--				continue
-+	for range ticker.C {
-+		// Проверяем контекст перед каждой итерацией
-+		if err := ctx.Err(); err != nil {
-+			return fmt.Errorf("monitoring stopped: %w", err)
-+		}
++// Добавим также вспомогательный метод для получения публичного ключа
++func (c *Client) GetPublicKey() solana.PublicKey {
++	return c.privateKey.PublicKey()
++}
 +
-+		// Получаем текущее состояние пула
-+		currentState, err := poolManager.GetPoolState(ctx)
-+		if err != nil {
-+			retryCount++
-+			s.logger.Error("failed to get current pool state",
-+				zap.Error(err),
-+				zap.Int("retry", retryCount),
-+			)
-+			if retryCount >= s.config.MaxRetries {
-+				return fmt.Errorf("max retries exceeded while monitoring pool")
- 			}
--			retryCount = 0
--
--			// Проверяем изменения в пуле
--			if s.hasSignificantChanges(initialState, currentState) {
--				s.logger.Info("detected significant pool changes",
--					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
--					zap.Uint64("newBaseReserve", currentState.BaseReserve),
--					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
--					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
--				)
--
--				// Если пул неактивен, прекращаем мониторинг
--				if currentState.Status != 1 {
--					return fmt.Errorf("pool became inactive")
--				}
--
--				// Обновляем начальное состояние
--				initialState = currentState
-+			continue
++// Добавим метод для подписания транзакций
++func (c *Client) SignTransaction(tx *solana.Transaction) error {
++	_, err := tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
++		if key.Equals(c.GetPublicKey()) {
++			return &c.privateKey
 +		}
-+		retryCount = 0
-+
-+		// Проверяем изменения в пуле
-+		if s.hasSignificantChanges(initialState, currentState) {
-+			s.logger.Info("detected significant pool changes",
-+				zap.Uint64("oldBaseReserve", initialState.BaseReserve),
-+				zap.Uint64("newBaseReserve", currentState.BaseReserve),
-+				zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
-+				zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
-+			)
++		return nil
++	})
++	return err
++}
 +
-+			// Если пул неактивен, прекращаем мониторинг
-+			if currentState.Status != 1 {
-+				return fmt.Errorf("pool became inactive")
- 			}
++// Добавим метод для проверки баланса кошелька
++func (c *Client) CheckWalletBalance(ctx context.Context) (uint64, error) {
++	balance, err := c.client.GetBalance(
++		ctx,
++		c.GetPublicKey(),
++		solanarpc.CommitmentConfirmed,
++	)
++	if err != nil {
++		return 0, fmt.Errorf("failed to get wallet balance: %w", err)
++	}
++	return balance, nil
++}
 +
-+			// Обновляем начальное состояние
-+			initialState = currentState
- 		}
- 	}
++// Добавим метод для получения ATA (Associated Token Account)
++func (c *Client) GetAssociatedTokenAccount(mint solana.PublicKey) (solana.PublicKey, error) {
++	ata, _, err := solana.FindAssociatedTokenAddress(
++		c.GetPublicKey(),
++		mint,
++	)
++	if err != nil {
++		return solana.PublicKey{}, fmt.Errorf("failed to find associated token address: %w", err)
++	}
++	return ata, nil
++}
 +
-+	return nil
- }
- 
- // Вспомогательный метод для определения значительных изменений в пуле
-diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
-index 9f523f5..02db401 100644
---- a/internal/dex/raydium/types.go
-+++ b/internal/dex/raydium/types.go
-@@ -32,7 +32,7 @@ const (
- 	PoolVersionV3 PoolVersion = 3
- )
- 
--type RaydiumPool struct {
-+type Pool struct {
- 	ID            solana.PublicKey // Идентификатор пула
- 	Authority     solana.PublicKey // Публичный ключ, который имеет полномочия управлять пулом
- 	BaseMint      solana.PublicKey // Публичный ключ базового токена
-@@ -59,7 +59,7 @@ type SwapParams struct {
- 	PrivateKey              *solana.PrivateKey // Приватный ключ для подписания транзакции
- 	AmountIn                uint64             // Количество входного токена для обмена
- 	MinAmountOut            uint64             // Минимальное количество выходного токена
--	Pool                    *RaydiumPool       // Указатель на пул для обмена
-+	Pool                    *Pool              // Указатель на пул для обмена
- 	SourceTokenAccount      solana.PublicKey   // Аккаунт исходного токена
- 	DestinationTokenAccount solana.PublicKey   // Аккаунт целевого токена
- 	PriorityFeeLamports     uint64             // Приоритетная комиссия в лампортах
-@@ -69,7 +69,7 @@ type SwapParams struct {
- 	Deadline    time.Time // таймаут для транзакции
- }
- 
--type RaydiumClient struct {
-+type Client struct {
- 	client      blockchain.Client
- 	logger      *zap.Logger
- 	privateKey  solana.PrivateKey
-@@ -96,14 +96,14 @@ type SwapInstruction struct {
- }
- 
- // RaydiumSwapInstruction реализует интерфейс solana.Instruction
--type RaydiumSwapInstruction struct {
-+type ExecutableSwapInstruction struct {
- 	programID solana.PublicKey
- 	accounts  []*solana.AccountMeta
- 	data      []byte
- }
- 
- // RaydiumError represents a custom error type
--type RaydiumError struct {
-+type Error struct {
- 	Code    string
- 	Message string
- 	Stage   string
-@@ -120,11 +120,11 @@ type SwapAmounts struct {
- type PoolManager struct {
- 	client blockchain.Client
- 	logger *zap.Logger
--	pool   *RaydiumPool
-+	pool   *Pool
- }
- 
- type Sniper struct {
--	client *RaydiumClient
-+	client *Client
- 	logger *zap.Logger
- 	config *SniperConfig // Конфигурация снайпинга
- }
-diff --git a/internal/sniping/strategy.go b/internal/sniping/strategy.go
-index 6803b8d..f6ec71d 100644
---- a/internal/sniping/strategy.go
-+++ b/internal/sniping/strategy.go
+ // GetPool получает информацию о пуле по базовому и котируемому токенам
+ func (c *Client) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*Pool, error) {
+ 	c.logger.Debug("getting raydium pool info",
+diff --git a/internal/wallet/wallet.go b/internal/wallet/wallet.go
+index 61f8297..0ef2422 100644
+--- a/internal/wallet/wallet.go
++++ b/internal/wallet/wallet.go
 @@ -1,3 +1,4 @@
-+// internal/sniping/strategy.go
- package sniping
++// inernal/wallet/wallet.go
+ package wallet
  
  import (
 diff --git a/newdif.txt b/newdif.txt
-index 8e5c180..4ae4320 100644
+index 1862cc8..c314e23 100644
 --- a/newdif.txt
 +++ b/newdif.txt
-@@ -1,9671 +0,0 @@
--diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
--index e059ba7..d562eb6 100644
----- a/internal/blockchain/solbc/client.go
--+++ b/internal/blockchain/solbc/client.go
--@@ -155,3 +155,27 @@ func (c *Client) SimulateTransaction(
-- 
-- 	return simulationResult, nil
-- }
--+
--+// TODO: Этот метод реализован в sdk solana-go, надо переписать
--+// GetBalance реализует интерфейс blockchain.Client
--+func (c *Client) GetBalance(
--+	ctx context.Context,
--+	pubkey solana.PublicKey,
--+	commitment solanarpc.CommitmentType,
--+) (uint64, error) {
--+	c.logger.Debug("getting balance",
--+		zap.String("pubkey", pubkey.String()),
--+		zap.String("commitment", string(commitment)),
--+	)
--+
--+	result, err := c.rpc.GetBalance(ctx, pubkey, commitment)
--+	if err != nil {
--+		c.metrics.FailedRequests++
--+		c.metrics.LastError = err
--+		c.metrics.LastErrorTime = time.Now()
--+		return 0, fmt.Errorf("failed to get balance: %w", err)
--+	}
--+
--+	c.metrics.BalanceRequests++
--+	return result.Value, nil
--+}
--diff --git a/internal/blockchain/solbc/rpc/rpc.go b/internal/blockchain/solbc/rpc/rpc.go
--index 1b027e2..754a9a9 100644
----- a/internal/blockchain/solbc/rpc/rpc.go
--+++ b/internal/blockchain/solbc/rpc/rpc.go
--@@ -267,3 +267,26 @@ func (c *RPCClient) SimulateTransaction(
-- 
-- 	return result, nil
-- }
--+
--+func (c *RPCClient) GetBalance(
--+	ctx context.Context,
--+	pubkey solana.PublicKey,
--+	commitment solanarpc.CommitmentType,
--+) (*solanarpc.GetBalanceResult, error) {
--+	var result *solanarpc.GetBalanceResult
--+
--+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
--+		var err error
--+		result, err = client.GetBalance(ctx, pubkey, commitment)
--+		if err != nil {
--+			return fmt.Errorf("RPC GetBalance failed: %w", err)
--+		}
--+		return nil
--+	})
--+
--+	if err != nil {
--+		return nil, fmt.Errorf("failed to get balance after retries: %w", err)
--+	}
--+
--+	return result, nil
--+}
--diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
--index 4d9d608..ba00000 100644
----- a/internal/blockchain/solbc/types.go
--+++ b/internal/blockchain/solbc/types.go
--@@ -34,6 +34,7 @@ type ClientMetrics struct {
-- 	ProgramAccountRequests uint64 // Добавляем новое поле
-- 	LastError              error
-- 	LastErrorTime          time.Time
--+	BalanceRequests        uint64
-- }
-- 
-- // IncrementProgramAccountRequests атомарно увеличивает счетчик запросов
--@@ -45,6 +46,9 @@ func (m *ClientMetrics) IncrementProgramAccountRequests() {
-- func (m *ClientMetrics) IncrementFailedRequests() {
-- 	atomic.AddUint64(&m.FailedRequests, 1)
-- }
--+func (m *ClientMetrics) IncrementBalanceRequests() {
--+	atomic.AddUint64(&m.BalanceRequests, 1)
--+}
-- 
-- // Проверяем, что Client реализует blockchain.Client интерфейс
-- var _ blockchain.Client = (*Client)(nil)
--diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
--index b702a54..673e820 100644
----- a/internal/blockchain/types.go
--+++ b/internal/blockchain/types.go
--@@ -34,4 +34,7 @@ type Client interface {
+@@ -1,10662 +0,0 @@
+-diff --git a/go.mod b/go.mod
+-index 6b29758..f342265 100644
+---- a/go.mod
+-+++ b/go.mod
+-@@ -4,13 +4,11 @@ go 1.23.2
 - 
-- 	// Добавляем новый метод для получения программных аккаунтов
-- 	GetProgramAccounts(ctx context.Context, program solana.PublicKey, opts rpc.GetProgramAccountsOpts) ([]rpc.KeyedAccount, error)
--+
--+	// Добавляем новый метод для получения баланса
--+	GetBalance(ctx context.Context, pubkey solana.PublicKey, commitment rpc.CommitmentType) (uint64, error)
-- }
+- require (
+- 	github.com/cenkalti/backoff/v4 v4.3.0
+--	github.com/gagliardetto/binary v0.8.0
+- 	github.com/gagliardetto/solana-go v1.11.0
+- 	github.com/gobwas/ws v1.4.0
+- 	github.com/google/uuid v1.6.0
+- 	github.com/mr-tron/base58 v1.2.0
+- 	github.com/prometheus/client_golang v1.20.5
+--	github.com/shopspring/decimal v1.3.1
+- 	github.com/spf13/viper v1.19.0
+- 	go.uber.org/zap v1.27.0
+- 	gopkg.in/natefinch/lumberjack.v2 v2.2.1
+-@@ -27,6 +25,7 @@ require (
+- 	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
+- 	github.com/fatih/color v1.17.0 // indirect
+- 	github.com/fsnotify/fsnotify v1.7.0 // indirect
+-+	github.com/gagliardetto/binary v0.8.0 // indirect
+- 	github.com/gagliardetto/treeout v0.1.4 // indirect
+- 	github.com/gobwas/httphead v0.1.0 // indirect
+- 	github.com/gobwas/pool v0.2.1 // indirect
+-diff --git a/go.sum b/go.sum
+-index 21aa3cc..4ff8611 100644
+---- a/go.sum
+-+++ b/go.sum
+-@@ -27,8 +27,6 @@ github.com/fsnotify/fsnotify v1.7.0 h1:8JEhPFa5W2WU7YfeZzPNqzMP6Lwt7L2715Ggo0nos
+- github.com/fsnotify/fsnotify v1.7.0/go.mod h1:40Bi/Hjc2AVfZrqy+aj+yEI+/bRxZnMJyTJwOpGvigM=
+- github.com/gagliardetto/binary v0.8.0 h1:U9ahc45v9HW0d15LoN++vIXSJyqR/pWw8DDlhd7zvxg=
+- github.com/gagliardetto/binary v0.8.0/go.mod h1:2tfj51g5o9dnvsc+fL3Jxr22MuWzYXwx9wEoN0XQ7/c=
+--github.com/gagliardetto/gofuzz v1.2.2 h1:XL/8qDMzcgvR4+CyRQW9UGdwPRPMHVJfqQ/uMvSUuQw=
+--github.com/gagliardetto/gofuzz v1.2.2/go.mod h1:bkH/3hYLZrMLbfYWA0pWzXmi5TTRZnu4pMGZBkqMKvY=
+- github.com/gagliardetto/solana-go v1.11.0 h1:g6mR7uRNVT0Y0LVR0bvJNfKV6TyO6oUzBYu03ZmkEmY=
+- github.com/gagliardetto/solana-go v1.11.0/go.mod h1:afBEcIRrDLJst3lvAahTr63m6W2Ns6dajZxe2irF7Jg=
+- github.com/gagliardetto/treeout v0.1.4 h1:ozeYerrLCmCubo1TcIjFiOWTTGteOOHND1twdFpgwaw=
 -diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
--index 4e94724..c52dce3 100644
+-index 4e0e778..4924747 100644
 ---- a/internal/dex/raydium/client.go
 -+++ b/internal/dex/raydium/client.go
--@@ -10,38 +10,12 @@ import (
-- 
-- 	"github.com/gagliardetto/solana-go"
-- 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
---	"github.com/gagliardetto/solana-go/rpc"
--+	solanarpc "github.com/gagliardetto/solana-go/rpc"
-- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
-- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
-- 	"go.uber.org/zap"
+-@@ -17,7 +17,7 @@ import (
 - )
 - 
---type RaydiumClient struct {
---	client  blockchain.Client
---	logger  *zap.Logger
---	options *clientOptions // Базовые настройки таймаутов и retry
---}
---type clientOptions struct {
---	timeout     time.Duration      // Таймаут для операций
---	retries     int                // Количество повторных попыток
---	priorityFee uint64             // Приоритетная комиссия в лампортах
---	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
---}
---
---// Вспомогательные структуры для инструкций
---type ComputeBudgetInstruction struct {
---	Units         uint32
---	MicroLamports uint64
---}
---
---type SwapInstruction struct {
---	Amount     *uint64
---	MinimumOut *uint64
---
---	// Slice для хранения аккаунтов, следуя паттерну из SDK
---	solana.AccountMetaSlice `bin:"-" borsh_skip:"true"`
---}
---
-- // NewRaydiumClient создает новый экземпляр клиента Raydium
-- func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*RaydiumClient, error) {
+- // NewRaydiumClient создает новый экземпляр клиента Raydium с дефолтными настройками
+--func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*RaydiumClient, error) {
+-+func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*Client, error) {
 - 	logger = logger.Named("raydium-client")
--@@ -56,7 +30,7 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
-- 		timeout:     30 * time.Second,
-- 		retries:     3,
-- 		priorityFee: 1000,
---		commitment:  rpc.CommitmentConfirmed,
--+		commitment:  solanarpc.CommitmentConfirmed,
+- 
+- 	// Создаем базового клиента через фабрику
+-@@ -27,7 +27,7 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
 - 	}
 - 
-- 	return &RaydiumClient{
--@@ -66,9 +40,6 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
-- 	}, nil
+- 	// Создаем клиент с дефолтными настройками
+--	return &RaydiumClient{
+-+	return &Client{
+- 		client:      solClient,
+- 		logger:      logger,
+- 		privateKey:  wallet,
+-@@ -39,7 +39,7 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
 - }
 - 
---// GetPool получает информацию о пуле по базовому и котируемому токенам
---// internal/dex/raydium/client.go
---
 - // GetPool получает информацию о пуле по базовому и котируемому токенам
-- func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
+--func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
+-+func (c *Client) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*Pool, error) {
 - 	c.logger.Debug("getting raydium pool info",
--@@ -80,19 +51,19 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
+- 		zap.String("baseMint", baseMint.String()),
+- 		zap.String("quoteMint", quoteMint.String()),
+-@@ -48,7 +48,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
+- 	// Получаем программные аккаунты через интерфейс
 - 	accounts, err := c.client.GetProgramAccounts(
 - 		ctx,
-- 		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
---		rpc.GetProgramAccountsOpts{
---			Filters: []rpc.RPCFilter{
--+		solanarpc.GetProgramAccountsOpts{
--+			Filters: []solanarpc.RPCFilter{
-- 				{
-- 					DataSize: 388, // Размер данных аккаунта пула
-- 				},
-- 				{
---					Memcmp: &rpc.RPCFilterMemcmp{
--+					Memcmp: &solanarpc.RPCFilterMemcmp{
-- 						Offset: 8,
-- 						Bytes:  baseMint.Bytes(),
-- 					},
-- 				},
+--		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+-+		RaydiumV4ProgramID,
+- 		solanarpc.GetProgramAccountsOpts{
+- 			Filters: []solanarpc.RPCFilter{
 - 				{
---					Memcmp: &rpc.RPCFilterMemcmp{
--+					Memcmp: &solanarpc.RPCFilterMemcmp{
-- 						Offset: 40,
-- 						Bytes:  quoteMint.Bytes(),
-- 					},
--@@ -242,13 +213,7 @@ func (inst *SwapInstruction) Validate() error {
-- 	return nil
+-@@ -84,7 +84,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
+- 	// Получаем authority пула через PDA
+- 	authority, _, err := solana.FindProgramAddress(
+- 		[][]byte{[]byte("amm_authority")},
+--		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+-+		RaydiumV4ProgramID,
+- 	)
+- 	if err != nil {
+- 		return nil, fmt.Errorf("failed to derive authority: %w", err)
+-@@ -98,7 +98,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
+- 
+- 	// Извлекаем данные из бинарного представления
+- 	// Офсеты взяты из документации Raydium и SDK
+--	pool := &RaydiumPool{
+-+	pool := &Pool{
+- 		ID:        poolAccount.Pubkey, // Исправлено с PublicKey на Pubkey
+- 		Authority: authority,
+- 		BaseMint:  baseMint,
+-@@ -107,8 +107,8 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
+- 		BaseVault:  solana.PublicKeyFromBytes(data[72:104]),
+- 		QuoteVault: solana.PublicKeyFromBytes(data[104:136]),
+- 		// Извлекаем decimals
+--		BaseDecimals:  uint8(data[136]),
+--		QuoteDecimals: uint8(data[137]),
+-+		BaseDecimals:  (data[136]),
+-+		QuoteDecimals: (data[137]),
+- 		// Извлекаем fee в базисных пунктах (2 байта)
+- 		DefaultFeeBps: binary.LittleEndian.Uint16(data[138:140]),
+- 	}
+-@@ -126,7 +126,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
 - }
 - 
---// Build создает инструкцию
---// RaydiumSwapInstruction реализует интерфейс solana.Instruction
---type RaydiumSwapInstruction struct {
---	programID solana.PublicKey
---	accounts  []*solana.AccountMeta
---	data      []byte
---}
--+// Build создает инструкци
+- // GetPoolState получает текущее состояние пула
+--func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
+-+func (c *Client) GetPoolState(pool *Pool) (*PoolState, error) {
+- 	c.logger.Debug("getting pool state",
+- 		zap.String("poolId", pool.ID.String()),
+- 	)
+-@@ -202,13 +202,13 @@ func (inst *SwapInstruction) SetDirection(direction SwapDirection) *SwapInstruct
+- // Validate проверяет все необходимые параметры
+- func (inst *SwapInstruction) Validate() error {
+- 	if inst.Amount == nil {
+--		return errors.New("Amount is not set")
+-+		return errors.New("amount is not set")
+- 	}
+- 	if inst.MinimumOut == nil {
+--		return errors.New("MinimumOut is not set")
+-+		return errors.New("minimumOut is not set")
+- 	}
+- 	if inst.Direction == nil {
+--		return errors.New("Direction is not set")
+-+		return errors.New("direction is not set")
+- 	}
+- 
+- 	// Проверка всех аккаунтов
+-@@ -221,17 +221,17 @@ func (inst *SwapInstruction) Validate() error {
+- }
 - 
 - // ProgramID возвращает ID программы Raydium
-- func (i *RaydiumSwapInstruction) ProgramID() solana.PublicKey {
--@@ -439,40 +404,61 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) er
+--func (i *RaydiumSwapInstruction) ProgramID() solana.PublicKey {
+-+func (i *ExecutableSwapInstruction) ProgramID() solana.PublicKey {
+- 	return i.programID
+- }
 - 
-- // ExecuteSwap выполняет свап и возвращает signature транзакции
-- func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
---	c.logger.Debug("executing swap",
--+	c.logger.Debug("starting swap execution",
-- 		zap.String("userWallet", params.UserWallet.String()),
-- 		zap.Uint64("amountIn", params.AmountIn),
-- 		zap.Uint64("minAmountOut", params.MinAmountOut),
--+		zap.String("pool", params.Pool.ID.String()),
--+		zap.Uint64("priorityFee", params.PriorityFeeLamports),
-- 	)
+- // Accounts возвращает список аккаунтов
+--func (i *RaydiumSwapInstruction) Accounts() []*solana.AccountMeta {
+-+func (i *ExecutableSwapInstruction) Accounts() []*solana.AccountMeta {
+- 	return i.accounts
+- }
+- 
+- // Data возвращает сериализованные данные инструкции
+--func (i *RaydiumSwapInstruction) Data() ([]byte, error) {
+-+func (i *ExecutableSwapInstruction) Data() ([]byte, error) {
+- 	return i.data, nil
+- }
 - 
---	// Сначала симулируем транзакцию
---	if err := c.SimulateSwap(params); err != nil {
---		return "", fmt.Errorf("swap simulation failed: %w", err)
--+	// Базовая валидация параметров
--+	if err := validateSwapParams(params); err != nil {
--+		return "", fmt.Errorf("invalid swap parameters: %w", err)
+-@@ -251,8 +251,8 @@ func (inst *SwapInstruction) Build() (solana.Instruction, error) {
+- 		data[16] = 1
 - 	}
 - 
---	// Получаем инструкции для свапа
--+	// Проверяем баланс кошелька
--+	ctx := context.Background()
--+	balance, err := c.client.GetBalance(ctx, params.UserWallet, solanarpc.CommitmentConfirmed)
--+	if err != nil {
--+		return "", fmt.Errorf("failed to get wallet balance: %w", err)
--+	}
--+
--+	// Учитываем приоритетную комиссию и обычную комиссию транзакции
--+	requiredBalance := params.AmountIn + params.PriorityFeeLamports + 5000
--+	if balance < requiredBalance {
--+		return "", fmt.Errorf("insufficient balance: required %d, got %d", requiredBalance, balance)
--+	}
--+
--+	// Создаем все необходимые инструкции для свапа
-- 	instructions, err := c.CreateSwapInstructions(params)
-- 	if err != nil {
-- 		return "", fmt.Errorf("failed to create swap instructions: %w", err)
+--	instruction := &RaydiumSwapInstruction{
+--		programID: solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+-+	instruction := &ExecutableSwapInstruction{
+-+		programID: RaydiumV4ProgramID,
+- 		accounts:  inst.AccountMetaSlice,
+- 		data:      data,
 - 	}
+-@@ -261,7 +261,7 @@ func (inst *SwapInstruction) Build() (solana.Instruction, error) {
+- }
 - 
---	// Получаем последний блокхэш
---	recent, err := c.client.GetRecentBlockhash()
--+	// Получаем последний блокхеш
--+	recent, err := c.client.GetRecentBlockhash(ctx)
-- 	if err != nil {
-- 		return "", fmt.Errorf("failed to get recent blockhash: %w", err)
+- // CreateSwapInstructions создает инструкции для свапа
+--func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
+-+func (c *Client) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
+- 	if err := validateSwapParams(params); err != nil {
+- 		return nil, err
 - 	}
+-@@ -271,7 +271,7 @@ func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Ins
+- 	// Добавляем инструкцию compute budget если указан приоритетный fee
+- 	if params.PriorityFeeLamports > 0 {
+- 		computeLimitIx, err := computebudget.NewSetComputeUnitLimitInstructionBuilder().
+--			SetUnits(MAX_COMPUTE_UNIT_LIMIT).
+-+			SetUnits(MaxComputeUnitLimit).
+- 			ValidateAndBuild()
+- 		if err != nil {
+- 			return nil, fmt.Errorf("failed to build compute limit instruction: %w", err)
+-@@ -337,7 +337,7 @@ func validateSwapParams(params *SwapParams) error {
+- }
 - 
-- 	// Создаем транзакцию
---	tx := solana.NewTransaction(
--+	tx, err := solana.NewTransaction(
-- 		instructions,
---		recent.Value.Blockhash,
--+		recent,
-- 		solana.TransactionPayer(params.UserWallet),
-- 	)
--+	if err != nil {
--+		return "", fmt.Errorf("failed to create transaction: %w", err)
--+	}
+- // SimulateSwap выполняет симуляцию транзакции свапа
+--func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) error {
+-+func (c *Client) SimulateSwap(ctx context.Context, params *SwapParams) error {
+- 	c.logger.Debug("simulating swap transaction",
+- 		zap.String("userWallet", params.UserWallet.String()),
+- 		zap.Uint64("amountIn", params.AmountIn),
+-@@ -369,12 +369,21 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) er
 - 
-- 	// Подписываем транзакцию
-- 	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
-- 		if key.Equals(params.UserWallet) {
---			return &c.client.PrivateKey
--+			if params.PrivateKey != nil {
--+				return params.PrivateKey
--+			}
--+			return &c.privateKey
-- 		}
-- 		return nil
-- 	})
--@@ -481,7 +467,7 @@ func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
+- 	// Подписываем транзакцию если есть приватный ключ
+- 	if params.PrivateKey != nil {
+--		tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+-+		signatures, err := tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+- 			if key.Equals(params.UserWallet) {
+- 				return params.PrivateKey
+- 			}
+- 			return nil
+- 		})
+-+		if err != nil {
+-+			return fmt.Errorf("failed to sign transaction: %w", err)
+-+		}
+-+
+-+		// Опционально: можно добавить логирование подписей
+-+		c.logger.Debug("transaction signed",
+-+			zap.Int("signatures_count", len(signatures)),
+-+			zap.String("first_signature", signatures[0].String()),
+-+		)
 - 	}
 - 
-- 	// Отправляем транзакцию
---	sig, err := c.client.SendTransaction(tx, &rpc.SendTransactionOpts{
--+	sig, err := c.client.SendTransactionWithOpts(ctx, tx, blockchain.TransactionOptions{
-- 		SkipPreflight:       true,
-- 		PreflightCommitment: c.options.commitment,
-- 	})
--@@ -489,49 +475,23 @@ func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
-- 		return "", fmt.Errorf("failed to send transaction: %w", err)
-- 	}
+- 	// Симулируем транзакцию
+-@@ -412,7 +421,7 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) er
+- // Метрики выполнения свапов
 - 
---	// Ждем подтверждения транзакции
---	confirmationStrategy := rpc.TransactionConfirmationStrategy{
---		Signature:            sig,
---		Commitment:           c.options.commitment,
---		LastValidBlockHeight: recent.Value.LastValidBlockHeight,
---	}
+- // ExecuteSwap выполняет свап и возвращает signature транзакции
+--func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
+-+func (c *Client) ExecuteSwap(params *SwapParams) (string, error) {
+- 	c.logger.Debug("starting swap execution",
+- 		zap.String("userWallet", params.UserWallet.String()),
+- 		zap.Uint64("amountIn", params.AmountIn),
+-@@ -492,39 +501,40 @@ func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
+- 	return sig.String(), nil
+- }
+- 
+-+// TODO: этот метод нигде пока не используется, надо добавить его в код
+- // logUpdatedBalances вспомогательный метод для логирования балансов после свапа
+--func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
+--	ctx := context.Background()
 --
---	startTime := time.Now()
---	confirmation, err := c.client.ConfirmTransaction(
---		confirmationStrategy,
---		&rpc.ConfirmTransactionOpts{
---			MaxRetries: c.options.retries,
---			Timeout:    c.options.timeout,
---		},
+--	// Получаем баланс SOL
+--	solBalance, err := c.client.GetBalance(
+--		ctx,
+--		params.UserWallet,
+--		solanarpc.CommitmentConfirmed,
 --	)
 --	if err != nil {
---		return sig, fmt.Errorf("failed to confirm transaction: %w", err)
+--		return fmt.Errorf("failed to get SOL balance: %w", err)
 --	}
 --
---	// Проверяем статус подтверждения
---	if confirmation.Value.Err != nil {
---		return sig, fmt.Errorf("transaction confirmed with error: %v", confirmation.Value.Err)
+--	// Получаем баланс токена
+--	tokenBalance, err := c.client.GetTokenAccountBalance(
+--		ctx,
+--		params.DestinationTokenAccount,
+--		solanarpc.CommitmentConfirmed,
+--	)
+--	if err != nil {
+--		return fmt.Errorf("failed to get token balance: %w", err)
 --	}
 --
-- 	c.logger.Info("swap executed successfully",
---		zap.String("signature", sig),
---		zap.Duration("duration", time.Since(startTime)),
--+		zap.String("signature", sig.String()),
--+		zap.String("explorer", fmt.Sprintf("https://explorer.solana.com/tx/%s", sig.String())),
-- 	)
-- 
---	// Опционально: получаем и логируем новые балансы
---	if err := c.logUpdatedBalances(params); err != nil {
---		c.logger.Warn("failed to get updated balances", zap.Error(err))
---	}
+--	c.logger.Info("updated balances",
+--		zap.Float64("solBalance", float64(solBalance)/float64(solana.LAMPORTS_PER_SOL)),
+--		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
+--	)
 --
---	return sig, nil
--+	return sig.String(), nil
-- }
-- 
-- // logUpdatedBalances вспомогательный метод для логирования балансов после свапа
-- func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
--+	ctx := context.Background()
+--	return nil
+--}
+-+// func (c *Client) logUpdatedBalances(params *SwapParams) error {
+-+// 	ctx := context.Background()
 -+
-- 	// Получаем баланс SOL
-- 	solBalance, err := c.client.GetBalance(
--+		ctx,
-- 		params.UserWallet,
---		rpc.CommitmentConfirmed,
--+		solanarpc.CommitmentConfirmed,
-- 	)
-- 	if err != nil {
-- 		return fmt.Errorf("failed to get SOL balance: %w", err)
--@@ -539,15 +499,16 @@ func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
-- 
-- 	// Получаем баланс токена
-- 	tokenBalance, err := c.client.GetTokenAccountBalance(
--+		ctx,
-- 		params.DestinationTokenAccount,
---		rpc.CommitmentConfirmed,
--+		solanarpc.CommitmentConfirmed,
-- 	)
-- 	if err != nil {
-- 		return fmt.Errorf("failed to get token balance: %w", err)
-- 	}
-- 
-- 	c.logger.Info("updated balances",
---		zap.Float64("solBalance", float64(solBalance.Value)/float64(solana.LAMPORTS_PER_SOL)),
--+		zap.Float64("solBalance", float64(solBalance)/float64(solana.LAMPORTS_PER_SOL)),
-- 		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
-- 	)
+-+// 	// Получаем баланс SOL
+-+// 	solBalance, err := c.client.GetBalance(
+-+// 		ctx,
+-+// 		params.UserWallet,
+-+// 		solanarpc.CommitmentConfirmed,
+-+// 	)
+-+// 	if err != nil {
+-+// 		return fmt.Errorf("failed to get SOL balance: %w", err)
+-+// 	}
+-+
+-+// 	// Получаем баланс токена
+-+// 	tokenBalance, err := c.client.GetTokenAccountBalance(
+-+// 		ctx,
+-+// 		params.DestinationTokenAccount,
+-+// 		solanarpc.CommitmentConfirmed,
+-+// 	)
+-+// 	if err != nil {
+-+// 		return fmt.Errorf("failed to get token balance: %w", err)
+-+// 	}
+-+
+-+// 	c.logger.Info("updated balances",
+-+// 		zap.Float64("solBalance", float64(solBalance)/float64(solana.LAMPORTS_PER_SOL)),
+-+// 		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
+-+// 	)
+-+
+-+// 	return nil
+-+// }
 - 
+- // GetBaseClient возвращает базовый blockchain.Client
+--func (c *RaydiumClient) GetBaseClient() blockchain.Client {
+-+func (c *Client) GetBaseClient() blockchain.Client {
+- 	return c.client
+- }
 -diff --git a/internal/dex/raydium/constants.go b/internal/dex/raydium/constants.go
--index fe6eb6e..049e4ff 100644
+-index 049e4ff..43282e4 100644
 ---- a/internal/dex/raydium/constants.go
 -+++ b/internal/dex/raydium/constants.go
--@@ -84,13 +84,6 @@ const (
-- 	MINT_ACCOUNT_SIZE  = 82  // Добавлено
+-@@ -1,96 +1,101 @@
+- // internal/dex/raydium/constants.go
+- package raydium
+- 
+--import "fmt"
+-+import (
+-+	"fmt"
+-+
+-+	"github.com/gagliardetto/solana-go"
+-+)
+- 
+- // Program IDs
+--const (
+--	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
+--	TOKEN_PROGRAM_ID      = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
+--	SYSTEM_PROGRAM_ID     = "11111111111111111111111111111111"
+--	SYSVAR_RENT_PUBKEY    = "SysvarRent111111111111111111111111111111111"
+--	WRAPPED_SOL_MINT      = "So11111111111111111111111111111111111111112" // Добавлено
+-+var (
+-+	// Используем MPK для краткости, так как это константы
+-+	TokenProgramID     = solana.MPK("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
+-+	RaydiumV4ProgramID = solana.MPK("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8")
+-+	SystemProgramID    = solana.MPK("11111111111111111111111111111111")
+-+	SysvarRentPubkey   = solana.MPK("SysvarRent111111111111111111111111111111111")
+-+	WrappedSolMint     = solana.MPK("So11111111111111111111111111111111111111112")
 - )
 - 
---// RaydiumError represents a custom error type
---type RaydiumError struct {
---	Code    string
---	Message string
---	Details map[string]interface{}
---}
---
-- func (e *RaydiumError) Error() string {
+- // Compute budget constants
+- const (
+--	MAX_COMPUTE_UNIT_LIMIT = 300000
+--	DEFAULT_COMPUTE_PRICE  = 1000
+--	MIN_COMPUTE_PRICE      = 0      // Добавлено
+--	MAX_COMPUTE_PRICE      = 100000 // Добавлено
+-+	MaxComputeUnitLimit = 300000
+-+	DefaultComputePrice = 1000
+-+	MinComputePrice     = 0
+-+	MaxComputePrice     = 100000
+- )
+- 
+- // Pool account layout constants
+- const (
+--	POOL_ACCOUNT_SIZE     = 388
+--	POOL_VERSION_OFFSET   = 0 // Добавлено
+--	STATUS_OFFSET         = 1 // Добавлено
+--	BASE_MINT_OFFSET      = 8
+--	QUOTE_MINT_OFFSET     = 40
+--	LP_MINT_OFFSET        = 72 // Добавлено
+--	BASE_VAULT_OFFSET     = 104
+--	QUOTE_VAULT_OFFSET    = 136
+--	DECIMALS_OFFSET       = 168
+--	FEE_BPS_OFFSET        = 170
+--	POOL_STATUS_OFFSET    = 188
+--	AMM_OPEN_ORDERS       = 196
+--	MARKET_ID_OFFSET      = 228
+--	TARGET_ORDERS_OFFSET  = 260 // Добавлено
+--	WITHDRAW_QUEUE_OFFSET = 292 // Добавлено
+-+	PoolAccountSize     = 388
+-+	PoolVersionOffset   = 0
+-+	StatusOffset        = 1
+-+	BaseMintOffset      = 8
+-+	QuoteMintOffset     = 40
+-+	LpMintOffset        = 72
+-+	BaseVaultOffset     = 104
+-+	QuoteVaultOffset    = 136
+-+	DecimalsOffset      = 168
+-+	FeeBpsOffset        = 170
+-+	PoolStatusOffset    = 188
+-+	AmmOpenOrders       = 196
+-+	MarketIDOffset      = 228
+-+	TargetOrdersOffset  = 260
+-+	WithdrawQueueOffset = 292
+- )
+- 
+- // Pool status
+- const (
+--	POOL_STATUS_UNINITIALIZED uint8 = 0
+--	POOL_STATUS_INITIALIZED   uint8 = 1
+--	POOL_STATUS_DISABLED      uint8 = 2
+--	POOL_STATUS_ACTIVE        uint8 = 3
+-+	PoolStatusUninitialized uint8 = 0
+-+	PoolStatusInitialized   uint8 = 1
+-+	PoolStatusDisabled      uint8 = 2
+-+	PoolStatusActive        uint8 = 3
+- )
+- 
+- // PDA seeds
+- const (
+--	AMM_AUTHORITY_LAYOUT = "amm_authority"
+--	POOL_TEMP_LP_LAYOUT  = "pool_temp_lp"
+--	POOL_WITHDRAW_QUEUE  = "withdraw_queue"
+--	TARGET_ORDERS_SEED   = "target_orders" // Добавлено
+--	OPEN_ORDERS_SEED     = "open_orders"   // Добавлено
+-+	AmmAuthorityLayout = "amm_authority"
+-+	PoolTempLpLayout   = "pool_temp_lp"
+-+	PoolWithdrawQueue  = "withdraw_queue"
+-+	TargetOrdersSeed   = "target_orders"
+-+	OpenOrdersSeed     = "open_orders"
+- )
+- 
+- // Swap constants
+- const (
+--	DEFAULT_SLIPPAGE_PERCENT = 0.5
+--	MAX_SLIPPAGE_PERCENT     = 5.0
+--	MIN_SWAP_AMOUNT          = 1000   // Добавлено: минимальная сумма для свапа в лампортах
+--	MAX_TOKENS_IN_POOL       = 100000 // Добавлено: максимальное количество токенов в пуле
+--	TRADE_DIRECTION_IN       = "in"   // Добавлено
+--	TRADE_DIRECTION_OUT      = "out"  // Добавлено
+-+	DefaultSlippagePercent = 0.5
+-+	MaxSlippagePercent     = 5.0
+-+	MinSwapAmount          = 1000
+-+	MaxTokensInPool        = 100000
+-+	TradeDirectionIn       = "in"
+-+	TradeDirectionOut      = "out"
+- )
+- 
+- // Error codes
+- const (
+--	ERR_POOL_NOT_FOUND      = "POOL_NOT_FOUND" // Изменено на uppercase
+--	ERR_INVALID_POOL_STATUS = "INVALID_POOL_STATUS"
+--	ERR_INSUFFICIENT_FUNDS  = "INSUFFICIENT_FUNDS"
+--	ERR_SLIPPAGE_EXCEEDED   = "SLIPPAGE_EXCEEDED"
+--	ERR_INVALID_MINT        = "INVALID_MINT"
+--	ERR_INVALID_AMOUNT      = "INVALID_AMOUNT"    // Добавлено
+--	ERR_POOL_DISABLED       = "POOL_DISABLED"     // Добавлено
+--	ERR_INVALID_DIRECTION   = "INVALID_DIRECTION" // Добавлено
+-+	ErrPoolNotFound      = "POOL_NOT_FOUND"
+-+	ErrInvalidPoolStatus = "INVALID_POOL_STATUS"
+-+	ErrInsufficientFunds = "INSUFFICIENT_FUNDS"
+-+	ErrSlippageExceeded  = "SLIPPAGE_EXCEEDED"
+-+	ErrInvalidMint       = "INVALID_MINT"
+-+	ErrInvalidAmount     = "INVALID_AMOUNT"
+-+	ErrPoolDisabled      = "POOL_DISABLED"
+-+	ErrInvalidDirection  = "INVALID_DIRECTION"
+- )
+- 
+- // Account size constants
+- const (
+--	TOKEN_ACCOUNT_SIZE = 165 // Добавлено
+--	MINT_ACCOUNT_SIZE  = 82  // Добавлено
+-+	TokenAccountSize = 165
+-+	MintAccountSize  = 82
+- )
+- 
+--func (e *RaydiumError) Error() string {
+-+func (e *Error) Error() string {
 - 	return fmt.Sprintf("%s: %s", e.Code, e.Message)
 - }
+- 
+- // Добавляем конструктор для RaydiumError
+--func NewRaydiumError(code string, message string, details map[string]interface{}) *RaydiumError {
+--	return &RaydiumError{
+-+func NewRaydiumError(code string, message string, details map[string]interface{}) *Error {
+-+	return &Error{
+- 		Code:    code,
+- 		Message: message,
+- 		Details: details,
+-diff --git a/internal/dex/raydium/newSwap.txt b/internal/dex/raydium/newSwap.txt
+-index 3d803c5..0eda437 100644
+---- a/internal/dex/raydium/newSwap.txt
+-+++ b/internal/dex/raydium/newSwap.txt
+-@@ -48,7 +48,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
+- 	// Получаем программные аккаунты через интерфейс
+- 	accounts, err := c.client.GetProgramAccounts(
+- 		ctx,
+--		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+-+		solana.MustPublicKeyFromBase58(RaydiumV4ProgramID),
+- 		solanarpc.GetProgramAccountsOpts{
+- 			Filters: []solanarpc.RPCFilter{
+- 				{
+-@@ -84,7 +84,7 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
+- 	// Получаем authority пула через PDA
+- 	authority, _, err := solana.FindProgramAddress(
+- 		[][]byte{[]byte("amm_authority")},
+--		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+-+		solana.MustPublicKeyFromBase58(RaydiumV4ProgramID),
+- 	)
+- 	if err != nil {
+- 		return nil, fmt.Errorf("failed to derive authority: %w", err)
+-@@ -107,8 +107,8 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
+- 		BaseVault:  solana.PublicKeyFromBytes(data[72:104]),
+- 		QuoteVault: solana.PublicKeyFromBytes(data[104:136]),
+- 		// Извлекаем decimals
+--		BaseDecimals:  uint8(data[136]),
+--		QuoteDecimals: uint8(data[137]),
+-+		BaseDecimals:  (data[136]),
+-+		QuoteDecimals: (data[137]),
+- 		// Извлекаем fee в базисных пунктах (2 байта)
+- 		DefaultFeeBps: binary.LittleEndian.Uint16(data[138:140]),
+- 	}
+-@@ -202,13 +202,13 @@ func (inst *SwapInstruction) SetDirection(direction SwapDirection) *SwapInstruct
+- // Validate проверяет все необходимые параметры
+- func (inst *SwapInstruction) Validate() error {
+- 	if inst.Amount == nil {
+--		return errors.New("Amount is not set")
+-+		return errors.New("amount is not set")
+- 	}
+- 	if inst.MinimumOut == nil {
+--		return errors.New("MinimumOut is not set")
+-+		return errors.New("minimumOut is not set")
+- 	}
+- 	if inst.Direction == nil {
+--		return errors.New("Direction is not set")
+-+		return errors.New("direction is not set")
+- 	}
+- 
+- 	// Проверка всех аккаунтов
+-@@ -252,7 +252,7 @@ func (inst *SwapInstruction) Build() (solana.Instruction, error) {
+- 	}
+- 
+- 	instruction := &RaydiumSwapInstruction{
+--		programID: solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+-+		programID: solana.MustPublicKeyFromBase58(RaydiumV4ProgramID),
+- 		accounts:  inst.AccountMetaSlice,
+- 		data:      data,
+- 	}
+-@@ -271,7 +271,7 @@ func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Ins
+- 	// Добавляем инструкцию compute budget если указан приоритетный fee
+- 	if params.PriorityFeeLamports > 0 {
+- 		computeLimitIx, err := computebudget.NewSetComputeUnitLimitInstructionBuilder().
+--			SetUnits(MAX_COMPUTE_UNIT_LIMIT).
+-+			SetUnits(MaxComputeUnitLimit).
+- 			ValidateAndBuild()
+- 		if err != nil {
+- 			return nil, fmt.Errorf("failed to build compute limit instruction: %w", err)
+-@@ -369,12 +369,21 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) er
+- 
+- 	// Подписываем транзакцию если есть приватный ключ
+- 	if params.PrivateKey != nil {
+--		tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+-+		signatures, err := tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+- 			if key.Equals(params.UserWallet) {
+- 				return params.PrivateKey
+- 			}
+- 			return nil
+- 		})
+-+		if err != nil {
+-+			return fmt.Errorf("failed to sign transaction: %w", err)
+-+		}
+-+
+-+		// Опционально: можно добавить логирование подписей
+-+		c.logger.Debug("transaction signed",
+-+			zap.Int("signatures_count", len(signatures)),
+-+			zap.String("first_signature", signatures[0].String()),
+-+		)
+- 	}
+- 
+- 	// Симулируем транзакцию
+-@@ -524,6 +533,10 @@ func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
+- 	return nil
+- }
+- 
+-+// GetBaseClient возвращает базовый blockchain.Client
+-+func (c *RaydiumClient) GetBaseClient() blockchain.Client {
+-+	return c.client
+-+}
+- // internal/dex/raydium/constants.go
+- package raydium
+- 
+-@@ -531,83 +544,83 @@ import "fmt"
+- 
+- // Program IDs
+- const (
+--	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
+--	TOKEN_PROGRAM_ID      = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
+--	SYSTEM_PROGRAM_ID     = "11111111111111111111111111111111"
+--	SYSVAR_RENT_PUBKEY    = "SysvarRent111111111111111111111111111111111"
+--	WRAPPED_SOL_MINT      = "So11111111111111111111111111111111111111112" // Добавлено
+-+	RaydiumV4ProgramID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
+-+	TokenProgramID     = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
+-+	SystemProgramID    = "11111111111111111111111111111111"
+-+	SysvarRentPubkey   = "SysvarRent111111111111111111111111111111111"
+-+	WrappedSolMint     = "So11111111111111111111111111111111111111112"
+- )
+- 
+- // Compute budget constants
+- const (
+--	MAX_COMPUTE_UNIT_LIMIT = 300000
+--	DEFAULT_COMPUTE_PRICE  = 1000
+--	MIN_COMPUTE_PRICE      = 0      // Добавлено
+--	MAX_COMPUTE_PRICE      = 100000 // Добавлено
+-+	MaxComputeUnitLimit = 300000
+-+	DefaultComputePrice = 1000
+-+	MinComputePrice     = 0
+-+	MaxComputePrice     = 100000
+- )
+- 
+- // Pool account layout constants
+- const (
+--	POOL_ACCOUNT_SIZE     = 388
+--	POOL_VERSION_OFFSET   = 0 // Добавлено
+--	STATUS_OFFSET         = 1 // Добавлено
+--	BASE_MINT_OFFSET      = 8
+--	QUOTE_MINT_OFFSET     = 40
+--	LP_MINT_OFFSET        = 72 // Добавлено
+--	BASE_VAULT_OFFSET     = 104
+--	QUOTE_VAULT_OFFSET    = 136
+--	DECIMALS_OFFSET       = 168
+--	FEE_BPS_OFFSET        = 170
+--	POOL_STATUS_OFFSET    = 188
+--	AMM_OPEN_ORDERS       = 196
+--	MARKET_ID_OFFSET      = 228
+--	TARGET_ORDERS_OFFSET  = 260 // Добавлено
+--	WITHDRAW_QUEUE_OFFSET = 292 // Добавлено
+-+	PoolAccountSize     = 388
+-+	PoolVersionOffset   = 0
+-+	StatusOffset        = 1
+-+	BaseMintOffset      = 8
+-+	QuoteMintOffset     = 40
+-+	LpMintOffset        = 72
+-+	BaseVaultOffset     = 104
+-+	QuoteVaultOffset    = 136
+-+	DecimalsOffset      = 168
+-+	FeeBpsOffset        = 170
+-+	PoolStatusOffset    = 188
+-+	AmmOpenOrders       = 196
+-+	MarketIDOffset      = 228
+-+	TargetOrdersOffset  = 260
+-+	WithdrawQueueOffset = 292
+- )
+- 
+- // Pool status
+- const (
+--	POOL_STATUS_UNINITIALIZED uint8 = 0
+--	POOL_STATUS_INITIALIZED   uint8 = 1
+--	POOL_STATUS_DISABLED      uint8 = 2
+--	POOL_STATUS_ACTIVE        uint8 = 3
+-+	PoolStatusUninitialized uint8 = 0
+-+	PoolStatusInitialized   uint8 = 1
+-+	PoolStatusDisabled      uint8 = 2
+-+	PoolStatusActive        uint8 = 3
+- )
+- 
+- // PDA seeds
+- const (
+--	AMM_AUTHORITY_LAYOUT = "amm_authority"
+--	POOL_TEMP_LP_LAYOUT  = "pool_temp_lp"
+--	POOL_WITHDRAW_QUEUE  = "withdraw_queue"
+--	TARGET_ORDERS_SEED   = "target_orders" // Добавлено
+--	OPEN_ORDERS_SEED     = "open_orders"   // Добавлено
+-+	AmmAuthorityLayout = "amm_authority"
+-+	PoolTempLpLayout   = "pool_temp_lp"
+-+	PoolWithdrawQueue  = "withdraw_queue"
+-+	TargetOrdersSeed   = "target_orders"
+-+	OpenOrdersSeed     = "open_orders"
+- )
+- 
+- // Swap constants
+- const (
+--	DEFAULT_SLIPPAGE_PERCENT = 0.5
+--	MAX_SLIPPAGE_PERCENT     = 5.0
+--	MIN_SWAP_AMOUNT          = 1000   // Добавлено: минимальная сумма для свапа в лампортах
+--	MAX_TOKENS_IN_POOL       = 100000 // Добавлено: максимальное количество токенов в пуле
+--	TRADE_DIRECTION_IN       = "in"   // Добавлено
+--	TRADE_DIRECTION_OUT      = "out"  // Добавлено
+-+	DefaultSlippagePercent = 0.5
+-+	MaxSlippagePercent     = 5.0
+-+	MinSwapAmount          = 1000
+-+	MaxTokensInPool        = 100000
+-+	TradeDirectionIn       = "in"
+-+	TradeDirectionOut      = "out"
+- )
+- 
+- // Error codes
+- const (
+--	ERR_POOL_NOT_FOUND      = "POOL_NOT_FOUND" // Изменено на uppercase
+--	ERR_INVALID_POOL_STATUS = "INVALID_POOL_STATUS"
+--	ERR_INSUFFICIENT_FUNDS  = "INSUFFICIENT_FUNDS"
+--	ERR_SLIPPAGE_EXCEEDED   = "SLIPPAGE_EXCEEDED"
+--	ERR_INVALID_MINT        = "INVALID_MINT"
+--	ERR_INVALID_AMOUNT      = "INVALID_AMOUNT"    // Добавлено
+--	ERR_POOL_DISABLED       = "POOL_DISABLED"     // Добавлено
+--	ERR_INVALID_DIRECTION   = "INVALID_DIRECTION" // Добавлено
+-+	ErrPoolNotFound      = "POOL_NOT_FOUND"
+-+	ErrInvalidPoolStatus = "INVALID_POOL_STATUS"
+-+	ErrInsufficientFunds = "INSUFFICIENT_FUNDS"
+-+	ErrSlippageExceeded  = "SLIPPAGE_EXCEEDED"
+-+	ErrInvalidMint       = "INVALID_MINT"
+-+	ErrInvalidAmount     = "INVALID_AMOUNT"
+-+	ErrPoolDisabled      = "POOL_DISABLED"
+-+	ErrInvalidDirection  = "INVALID_DIRECTION"
+- )
+- 
+- // Account size constants
+- const (
+--	TOKEN_ACCOUNT_SIZE = 165 // Добавлено
+--	MINT_ACCOUNT_SIZE  = 82  // Добавлено
+-+	TokenAccountSize = 165
+-+	MintAccountSize  = 82
+- )
+- 
+- func (e *RaydiumError) Error() string {
+-@@ -886,62 +899,66 @@ func (s *Sniper) ValidateAndPrepare() error {
+- // 4. Добавить отслеживание транзакций в мемпуле
+- // 5. Добавить механизм websocket подключения
+- // 6. Добавить механизм агрегации данных по нескольким RPC
+--func (s *Sniper) MonitorPoolChanges() error {
+-+func (s *Sniper) MonitorPoolChanges(ctx context.Context) error {
+- 	s.logger.Debug("starting pool monitoring")
+- 
+- 	ticker := time.NewTicker(s.config.MonitorInterval)
+- 	defer ticker.Stop()
+- 
+- 	// Получаем начальное состояние пула
+--	pool, err := s.client.GetPool(context.Background(), s.config.BaseMint, s.config.QuoteMint)
+-+	pool, err := s.client.GetPool(ctx, s.config.BaseMint, s.config.QuoteMint)
+- 	if err != nil {
+- 		return fmt.Errorf("failed to get initial pool state: %w", err)
+- 	}
+- 
+- 	poolManager := NewPoolManager(s.client.client, s.logger, pool)
+--	initialState, err := poolManager.GetPoolState(context.Background())
+-+	initialState, err := poolManager.GetPoolState(ctx)
+- 	if err != nil {
+- 		return fmt.Errorf("failed to get initial pool state: %w", err)
+- 	}
+- 
+- 	var retryCount int
+--	for {
+--		select {
+--		case <-ticker.C:
+--			// Получаем текущее состояние пула
+--			currentState, err := poolManager.GetPoolState(context.Background())
+--			if err != nil {
+--				retryCount++
+--				s.logger.Error("failed to get current pool state",
+--					zap.Error(err),
+--					zap.Int("retry", retryCount),
+--				)
+--				if retryCount >= s.config.MaxRetries {
+--					return fmt.Errorf("max retries exceeded while monitoring pool")
+--				}
+--				continue
+-+	for range ticker.C {
+-+		// Проверяем контекст перед каждой итерацией
+-+		if err := ctx.Err(); err != nil {
+-+			return fmt.Errorf("monitoring stopped: %w", err)
+-+		}
+-+
+-+		// Получаем текущее состояние пула
+-+		currentState, err := poolManager.GetPoolState(ctx)
+-+		if err != nil {
+-+			retryCount++
+-+			s.logger.Error("failed to get current pool state",
+-+				zap.Error(err),
+-+				zap.Int("retry", retryCount),
+-+			)
+-+			if retryCount >= s.config.MaxRetries {
+-+				return fmt.Errorf("max retries exceeded while monitoring pool")
+- 			}
+--			retryCount = 0
+--
+--			// Проверяем изменения в пуле
+--			if s.hasSignificantChanges(initialState, currentState) {
+--				s.logger.Info("detected significant pool changes",
+--					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
+--					zap.Uint64("newBaseReserve", currentState.BaseReserve),
+--					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
+--					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
+--				)
+--
+--				// Если пул неактивен, прекращаем мониторинг
+--				if currentState.Status != 1 {
+--					return fmt.Errorf("pool became inactive")
+--				}
+--
+--				// Обновляем начальное состояние
+--				initialState = currentState
+-+			continue
+-+		}
+-+		retryCount = 0
+-+
+-+		// Проверяем изменения в пуле
+-+		if s.hasSignificantChanges(initialState, currentState) {
+-+			s.logger.Info("detected significant pool changes",
+-+				zap.Uint64("oldBaseReserve", initialState.BaseReserve),
+-+				zap.Uint64("newBaseReserve", currentState.BaseReserve),
+-+				zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
+-+				zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
+-+			)
+-+
+-+			// Если пул неактивен, прекращаем мониторинг
+-+			if currentState.Status != 1 {
+-+				return fmt.Errorf("pool became inactive")
+- 			}
+-+
+-+			// Обновляем начальное состояние
+-+			initialState = currentState
+- 		}
+- 	}
+-+
+-+	return nil
+- }
+- 
+- // Вспомогательный метод для определения значительных изменений в пуле
 -diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
--index 50959de..b9ac3f5 100644
+-index f144a25..5e47fb8 100644
 ---- a/internal/dex/raydium/pool.go
 -+++ b/internal/dex/raydium/pool.go
--@@ -10,18 +10,6 @@ import (
-- 	"go.uber.org/zap"
+-@@ -12,7 +12,7 @@ import (
 - )
 - 
---type SwapAmounts struct {
---	AmountIn     uint64 // Количество входных токенов
---	AmountOut    uint64 // Ожидаемое количество выходных токенов
---	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
---}
---
---type PoolManager struct {
---	client blockchain.Client
---	logger *zap.Logger
---	pool   *RaydiumPool
---}
---
 - // NewPoolManager создает новый менеджер пула
-- func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *RaydiumPool) *PoolManager {
+--func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *RaydiumPool) *PoolManager {
+-+func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *Pool) *PoolManager {
 - 	return &PoolManager{
+- 		client: client,
+- 		logger: logger,
 -diff --git a/internal/dex/raydium/sniper.go b/internal/dex/raydium/sniper.go
--index c9a6c55..7313203 100644
+-index 7c0daf1..b361693 100644
 ---- a/internal/dex/raydium/sniper.go
 -+++ b/internal/dex/raydium/sniper.go
--@@ -11,26 +11,6 @@ import (
-- 	"go.uber.org/zap"
-- )
+-@@ -133,62 +133,66 @@ func (s *Sniper) ValidateAndPrepare() error {
+- // 4. Добавить отслеживание транзакций в мемпуле
+- // 5. Добавить механизм websocket подключения
+- // 6. Добавить механизм агрегации данных по нескольким RPC
+--func (s *Sniper) MonitorPoolChanges() error {
+-+func (s *Sniper) MonitorPoolChanges(ctx context.Context) error {
+- 	s.logger.Debug("starting pool monitoring")
 - 
---type Sniper struct {
---	client *RaydiumClient
---	logger *zap.Logger
---	config *SniperConfig // Конфигурация снайпинга
---}
---type SniperConfig struct {
---	// Существующие поля
---	maxSlippageBps   uint16
---	minAmountSOL     float64
---	maxAmountSOL     float64
---	priorityFee      uint64
---	waitConfirmation bool
---	monitorInterval  time.Duration
---	maxRetries       int
+- 	ticker := time.NewTicker(s.config.MonitorInterval)
+- 	defer ticker.Stop()
+- 
+- 	// Получаем начальное состояние пула
+--	pool, err := s.client.GetPool(context.Background(), s.config.BaseMint, s.config.QuoteMint)
+-+	pool, err := s.client.GetPool(ctx, s.config.BaseMint, s.config.QuoteMint)
+- 	if err != nil {
+- 		return fmt.Errorf("failed to get initial pool state: %w", err)
+- 	}
+- 
+- 	poolManager := NewPoolManager(s.client.client, s.logger, pool)
+--	initialState, err := poolManager.GetPoolState(context.Background())
+-+	initialState, err := poolManager.GetPoolState(ctx)
+- 	if err != nil {
+- 		return fmt.Errorf("failed to get initial pool state: %w", err)
+- 	}
+- 
+- 	var retryCount int
+--	for {
+--		select {
+--		case <-ticker.C:
+--			// Получаем текущее состояние пула
+--			currentState, err := poolManager.GetPoolState(context.Background())
+--			if err != nil {
+--				retryCount++
+--				s.logger.Error("failed to get current pool state",
+--					zap.Error(err),
+--					zap.Int("retry", retryCount),
+--				)
+--				if retryCount >= s.config.MaxRetries {
+--					return fmt.Errorf("max retries exceeded while monitoring pool")
+--				}
+--				continue
+-+	for range ticker.C {
+-+		// Проверяем контекст перед каждой итерацией
+-+		if err := ctx.Err(); err != nil {
+-+			return fmt.Errorf("monitoring stopped: %w", err)
+-+		}
+-+
+-+		// Получаем текущее состояние пула
+-+		currentState, err := poolManager.GetPoolState(ctx)
+-+		if err != nil {
+-+			retryCount++
+-+			s.logger.Error("failed to get current pool state",
+-+				zap.Error(err),
+-+				zap.Int("retry", retryCount),
+-+			)
+-+			if retryCount >= s.config.MaxRetries {
+-+				return fmt.Errorf("max retries exceeded while monitoring pool")
+- 			}
+--			retryCount = 0
 --
---	// Добавляем новые необходимые поля
---	baseMint  solana.PublicKey // Mint address базового токена
---	quoteMint solana.PublicKey // Mint address котируемого токена
---}
+--			// Проверяем изменения в пуле
+--			if s.hasSignificantChanges(initialState, currentState) {
+--				s.logger.Info("detected significant pool changes",
+--					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
+--					zap.Uint64("newBaseReserve", currentState.BaseReserve),
+--					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
+--					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
+--				)
+--
+--				// Если пул неактивен, прекращаем мониторинг
+--				if currentState.Status != 1 {
+--					return fmt.Errorf("pool became inactive")
+--				}
 --
-- // TODO: можно добавить:
+--				// Обновляем начальное состояние
+--				initialState = currentState
+-+			continue
+-+		}
+-+		retryCount = 0
+-+
+-+		// Проверяем изменения в пуле
+-+		if s.hasSignificantChanges(initialState, currentState) {
+-+			s.logger.Info("detected significant pool changes",
+-+				zap.Uint64("oldBaseReserve", initialState.BaseReserve),
+-+				zap.Uint64("newBaseReserve", currentState.BaseReserve),
+-+				zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
+-+				zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
+-+			)
+-+
+-+			// Если пул неактивен, прекращаем мониторинг
+-+			if currentState.Status != 1 {
+-+				return fmt.Errorf("pool became inactive")
+- 			}
+-+
+-+			// Обновляем начальное состояние
+-+			initialState = currentState
+- 		}
+- 	}
+-+
+-+	return nil
+- }
 - 
-- // 1. Проверку цены перед свапом
+- // Вспомогательный метод для определения значительных изменений в пуле
 -diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
--index dcca4e7..3cd90d3 100644
+-index 9f523f5..02db401 100644
 ---- a/internal/dex/raydium/types.go
 -+++ b/internal/dex/raydium/types.go
--@@ -1,7 +1,14 @@
-- // inernal/dex/raydium/types.go - это пакет, который содержит в себе реализацию работы с декстерами Raydium
-- package raydium
-- 
---import "github.com/gagliardetto/solana-go"
--+import (
--+	"time"
--+
--+	"github.com/gagliardetto/solana-go"
--+	"github.com/gagliardetto/solana-go/rpc"
--+	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
--+	"go.uber.org/zap"
--+)
+-@@ -32,7 +32,7 @@ const (
+- 	PoolVersionV3 PoolVersion = 3
+- )
 - 
-- type RaydiumPool struct {
+--type RaydiumPool struct {
+-+type Pool struct {
 - 	ID            solana.PublicKey // Идентификатор пула
--@@ -39,3 +46,76 @@ type SwapError struct {
-- 	Message string // Сообщение об ошибке
-- 	Err     error  // Вложенная ошибка
+- 	Authority     solana.PublicKey // Публичный ключ, который имеет полномочия управлять пулом
+- 	BaseMint      solana.PublicKey // Публичный ключ базового токена
+-@@ -59,7 +59,7 @@ type SwapParams struct {
+- 	PrivateKey              *solana.PrivateKey // Приватный ключ для подписания транзакции
+- 	AmountIn                uint64             // Количество входного токена для обмена
+- 	MinAmountOut            uint64             // Минимальное количество выходного токена
+--	Pool                    *RaydiumPool       // Указатель на пул для обмена
+-+	Pool                    *Pool              // Указатель на пул для обмена
+- 	SourceTokenAccount      solana.PublicKey   // Аккаунт исходного токена
+- 	DestinationTokenAccount solana.PublicKey   // Аккаунт целевого токена
+- 	PriorityFeeLamports     uint64             // Приоритетная комиссия в лампортах
+-@@ -69,7 +69,7 @@ type SwapParams struct {
+- 	Deadline    time.Time // таймаут для транзакции
 - }
--+
--+type RaydiumClient struct {
--+	client     blockchain.Client
--+	logger     *zap.Logger
--+	options    *clientOptions // Базовые настройки таймаутов и retry
--+	privateKey solana.PrivateKey
--+}
--+type clientOptions struct {
--+	timeout     time.Duration      // Таймаут для операций
--+	retries     int                // Количество повторных попыток
--+	priorityFee uint64             // Приоритетная комиссия в лампортах
--+	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
--+}
--+
--+// Вспомогательные структуры для инструкций
--+type ComputeBudgetInstruction struct {
--+	Units         uint32
--+	MicroLamports uint64
--+}
--+
--+type SwapInstruction struct {
--+	Amount     *uint64
--+	MinimumOut *uint64
--+
--+	// Slice для хранения аккаунтов, следуя паттерну из SDK
--+	solana.AccountMetaSlice `bin:"-" borsh_skip:"true"`
--+}
--+
--+// RaydiumSwapInstruction реализует интерфейс solana.Instruction
--+type RaydiumSwapInstruction struct {
--+	programID solana.PublicKey
--+	accounts  []*solana.AccountMeta
--+	data      []byte
--+}
--+
--+// RaydiumError represents a custom error type
--+type RaydiumError struct {
--+	Code    string
--+	Message string
--+	Details map[string]interface{}
--+}
--+
--+type SwapAmounts struct {
--+	AmountIn     uint64 // Количество входных токенов
--+	AmountOut    uint64 // Ожидаемое количество выходных токенов
--+	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
--+}
--+
--+type PoolManager struct {
--+	client blockchain.Client
--+	logger *zap.Logger
--+	pool   *RaydiumPool
--+}
--+
--+type Sniper struct {
--+	client *RaydiumClient
--+	logger *zap.Logger
--+	config *SniperConfig // Конфигурация снайпинга
--+}
--+type SniperConfig struct {
--+	// Существующие поля
--+	maxSlippageBps   uint16
--+	minAmountSOL     float64
--+	maxAmountSOL     float64
--+	priorityFee      uint64
--+	waitConfirmation bool
--+	monitorInterval  time.Duration
--+	maxRetries       int
--+
--+	// Добавляем новые необходимые поля
--+	baseMint  solana.PublicKey // Mint address базового токена
--+	quoteMint solana.PublicKey // Mint address котируемого токена
--+}
+- 
+--type RaydiumClient struct {
+-+type Client struct {
+- 	client      blockchain.Client
+- 	logger      *zap.Logger
+- 	privateKey  solana.PrivateKey
+-@@ -96,14 +96,14 @@ type SwapInstruction struct {
+- }
+- 
+- // RaydiumSwapInstruction реализует интерфейс solana.Instruction
+--type RaydiumSwapInstruction struct {
+-+type ExecutableSwapInstruction struct {
+- 	programID solana.PublicKey
+- 	accounts  []*solana.AccountMeta
+- 	data      []byte
+- }
+- 
+- // RaydiumError represents a custom error type
+--type RaydiumError struct {
+-+type Error struct {
+- 	Code    string
+- 	Message string
+- 	Stage   string
+-@@ -120,11 +120,11 @@ type SwapAmounts struct {
+- type PoolManager struct {
+- 	client blockchain.Client
+- 	logger *zap.Logger
+--	pool   *RaydiumPool
+-+	pool   *Pool
+- }
+- 
+- type Sniper struct {
+--	client *RaydiumClient
+-+	client *Client
+- 	logger *zap.Logger
+- 	config *SniperConfig // Конфигурация снайпинга
+- }
+-diff --git a/internal/sniping/strategy.go b/internal/sniping/strategy.go
+-index 6803b8d..f6ec71d 100644
+---- a/internal/sniping/strategy.go
+-+++ b/internal/sniping/strategy.go
+-@@ -1,3 +1,4 @@
+-+// internal/sniping/strategy.go
+- package sniping
+- 
+- import (
 -diff --git a/newdif.txt b/newdif.txt
--index 2f2ac9a..c5a89bd 100644
+-index 8e5c180..4ae4320 100644
 ---- a/newdif.txt
 -+++ b/newdif.txt
--@@ -1,9141 +0,0 @@
+-@@ -1,9671 +0,0 @@
+--diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
+--index e059ba7..d562eb6 100644
+----- a/internal/blockchain/solbc/client.go
+--+++ b/internal/blockchain/solbc/client.go
+--@@ -155,3 +155,27 @@ func (c *Client) SimulateTransaction(
+-- 
+-- 	return simulationResult, nil
+-- }
+--+
+--+// TODO: Этот метод реализован в sdk solana-go, надо переписать
+--+// GetBalance реализует интерфейс blockchain.Client
+--+func (c *Client) GetBalance(
+--+	ctx context.Context,
+--+	pubkey solana.PublicKey,
+--+	commitment solanarpc.CommitmentType,
+--+) (uint64, error) {
+--+	c.logger.Debug("getting balance",
+--+		zap.String("pubkey", pubkey.String()),
+--+		zap.String("commitment", string(commitment)),
+--+	)
+--+
+--+	result, err := c.rpc.GetBalance(ctx, pubkey, commitment)
+--+	if err != nil {
+--+		c.metrics.FailedRequests++
+--+		c.metrics.LastError = err
+--+		c.metrics.LastErrorTime = time.Now()
+--+		return 0, fmt.Errorf("failed to get balance: %w", err)
+--+	}
+--+
+--+	c.metrics.BalanceRequests++
+--+	return result.Value, nil
+--+}
+--diff --git a/internal/blockchain/solbc/rpc/rpc.go b/internal/blockchain/solbc/rpc/rpc.go
+--index 1b027e2..754a9a9 100644
+----- a/internal/blockchain/solbc/rpc/rpc.go
+--+++ b/internal/blockchain/solbc/rpc/rpc.go
+--@@ -267,3 +267,26 @@ func (c *RPCClient) SimulateTransaction(
+-- 
+-- 	return result, nil
+-- }
+--+
+--+func (c *RPCClient) GetBalance(
+--+	ctx context.Context,
+--+	pubkey solana.PublicKey,
+--+	commitment solanarpc.CommitmentType,
+--+) (*solanarpc.GetBalanceResult, error) {
+--+	var result *solanarpc.GetBalanceResult
+--+
+--+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
+--+		var err error
+--+		result, err = client.GetBalance(ctx, pubkey, commitment)
+--+		if err != nil {
+--+			return fmt.Errorf("RPC GetBalance failed: %w", err)
+--+		}
+--+		return nil
+--+	})
+--+
+--+	if err != nil {
+--+		return nil, fmt.Errorf("failed to get balance after retries: %w", err)
+--+	}
+--+
+--+	return result, nil
+--+}
+--diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
+--index 4d9d608..ba00000 100644
+----- a/internal/blockchain/solbc/types.go
+--+++ b/internal/blockchain/solbc/types.go
+--@@ -34,6 +34,7 @@ type ClientMetrics struct {
+-- 	ProgramAccountRequests uint64 // Добавляем новое поле
+-- 	LastError              error
+-- 	LastErrorTime          time.Time
+--+	BalanceRequests        uint64
+-- }
+-- 
+-- // IncrementProgramAccountRequests атомарно увеличивает счетчик запросов
+--@@ -45,6 +46,9 @@ func (m *ClientMetrics) IncrementProgramAccountRequests() {
+-- func (m *ClientMetrics) IncrementFailedRequests() {
+-- 	atomic.AddUint64(&m.FailedRequests, 1)
+-- }
+--+func (m *ClientMetrics) IncrementBalanceRequests() {
+--+	atomic.AddUint64(&m.BalanceRequests, 1)
+--+}
+-- 
+-- // Проверяем, что Client реализует blockchain.Client интерфейс
+-- var _ blockchain.Client = (*Client)(nil)
+--diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
+--index b702a54..673e820 100644
+----- a/internal/blockchain/types.go
+--+++ b/internal/blockchain/types.go
+--@@ -34,4 +34,7 @@ type Client interface {
+-- 
+-- 	// Добавляем новый метод для получения программных аккаунтов
+-- 	GetProgramAccounts(ctx context.Context, program solana.PublicKey, opts rpc.GetProgramAccountsOpts) ([]rpc.KeyedAccount, error)
+--+
+--+	// Добавляем новый метод для получения баланса
+--+	GetBalance(ctx context.Context, pubkey solana.PublicKey, commitment rpc.CommitmentType) (uint64, error)
+-- }
 --diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
---index 1d6c450..4e94724 100644
+--index 4e94724..c52dce3 100644
 ----- a/internal/dex/raydium/client.go
 --+++ b/internal/dex/raydium/client.go
---@@ -363,8 +363,13 @@ func validateSwapParams(params *SwapParams) error {
+--@@ -10,38 +10,12 @@ import (
+-- 
+-- 	"github.com/gagliardetto/solana-go"
+-- 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
+---	"github.com/gagliardetto/solana-go/rpc"
+--+	solanarpc "github.com/gagliardetto/solana-go/rpc"
+-- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+-- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
+-- 	"go.uber.org/zap"
+-- )
+-- 
+---type RaydiumClient struct {
+---	client  blockchain.Client
+---	logger  *zap.Logger
+---	options *clientOptions // Базовые настройки таймаутов и retry
+---}
+---type clientOptions struct {
+---	timeout     time.Duration      // Таймаут для операций
+---	retries     int                // Количество повторных попыток
+---	priorityFee uint64             // Приоритетная комиссия в лампортах
+---	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
+---}
+---
+---// Вспомогательные структуры для инструкций
+---type ComputeBudgetInstruction struct {
+---	Units         uint32
+---	MicroLamports uint64
+---}
+---
+---type SwapInstruction struct {
+---	Amount     *uint64
+---	MinimumOut *uint64
+---
+---	// Slice для хранения аккаунтов, следуя паттерну из SDK
+---	solana.AccountMetaSlice `bin:"-" borsh_skip:"true"`
+---}
+---
+-- // NewRaydiumClient создает новый экземпляр клиента Raydium
+-- func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*RaydiumClient, error) {
+-- 	logger = logger.Named("raydium-client")
+--@@ -56,7 +30,7 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
+-- 		timeout:     30 * time.Second,
+-- 		retries:     3,
+-- 		priorityFee: 1000,
+---		commitment:  rpc.CommitmentConfirmed,
+--+		commitment:  solanarpc.CommitmentConfirmed,
+-- 	}
+-- 
+-- 	return &RaydiumClient{
+--@@ -66,9 +40,6 @@ func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.
+-- 	}, nil
 -- }
 -- 
--- // SimulateSwap выполняет симуляцию транзакции свапа
----func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
----	c.logger.Debug("simulating swap transaction")
---+func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) error {
---+	c.logger.Debug("simulating swap transaction",
---+		zap.String("userWallet", params.UserWallet.String()),
---+		zap.Uint64("amountIn", params.AmountIn),
---+		zap.Uint64("minAmountOut", params.MinAmountOut),
+---// GetPool получает информацию о пуле по базовому и котируемому токенам
+---// internal/dex/raydium/client.go
+---
+-- // GetPool получает информацию о пуле по базовому и котируемому токенам
+-- func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
+-- 	c.logger.Debug("getting raydium pool info",
+--@@ -80,19 +51,19 @@ func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.
+-- 	accounts, err := c.client.GetProgramAccounts(
+-- 		ctx,
+-- 		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+---		rpc.GetProgramAccountsOpts{
+---			Filters: []rpc.RPCFilter{
+--+		solanarpc.GetProgramAccountsOpts{
+--+			Filters: []solanarpc.RPCFilter{
+-- 				{
+-- 					DataSize: 388, // Размер данных аккаунта пула
+-- 				},
+-- 				{
+---					Memcmp: &rpc.RPCFilterMemcmp{
+--+					Memcmp: &solanarpc.RPCFilterMemcmp{
+-- 						Offset: 8,
+-- 						Bytes:  baseMint.Bytes(),
+-- 					},
+-- 				},
+-- 				{
+---					Memcmp: &rpc.RPCFilterMemcmp{
+--+					Memcmp: &solanarpc.RPCFilterMemcmp{
+-- 						Offset: 40,
+-- 						Bytes:  quoteMint.Bytes(),
+-- 					},
+--@@ -242,13 +213,7 @@ func (inst *SwapInstruction) Validate() error {
+-- 	return nil
+-- }
+-- 
+---// Build создает инструкцию
+---// RaydiumSwapInstruction реализует интерфейс solana.Instruction
+---type RaydiumSwapInstruction struct {
+---	programID solana.PublicKey
+---	accounts  []*solana.AccountMeta
+---	data      []byte
+---}
+--+// Build создает инструкци
+-- 
+-- // ProgramID возвращает ID программы Raydium
+-- func (i *RaydiumSwapInstruction) ProgramID() solana.PublicKey {
+--@@ -439,40 +404,61 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) er
+-- 
+-- // ExecuteSwap выполняет свап и возвращает signature транзакции
+-- func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
+---	c.logger.Debug("executing swap",
+--+	c.logger.Debug("starting swap execution",
+-- 		zap.String("userWallet", params.UserWallet.String()),
+-- 		zap.Uint64("amountIn", params.AmountIn),
+-- 		zap.Uint64("minAmountOut", params.MinAmountOut),
 --+		zap.String("pool", params.Pool.ID.String()),
---+	)
+--+		zap.Uint64("priorityFee", params.PriorityFeeLamports),
+-- 	)
 -- 
--- 	// Получаем инструкции для свапа
+---	// Сначала симулируем транзакцию
+---	if err := c.SimulateSwap(params); err != nil {
+---		return "", fmt.Errorf("swap simulation failed: %w", err)
+--+	// Базовая валидация параметров
+--+	if err := validateSwapParams(params); err != nil {
+--+		return "", fmt.Errorf("invalid swap parameters: %w", err)
+-- 	}
+-- 
+---	// Получаем инструкции для свапа
+--+	// Проверяем баланс кошелька
+--+	ctx := context.Background()
+--+	balance, err := c.client.GetBalance(ctx, params.UserWallet, solanarpc.CommitmentConfirmed)
+--+	if err != nil {
+--+		return "", fmt.Errorf("failed to get wallet balance: %w", err)
+--+	}
+--+
+--+	// Учитываем приоритетную комиссию и обычную комиссию транзакции
+--+	requiredBalance := params.AmountIn + params.PriorityFeeLamports + 5000
+--+	if balance < requiredBalance {
+--+		return "", fmt.Errorf("insufficient balance: required %d, got %d", requiredBalance, balance)
+--+	}
+--+
+--+	// Создаем все необходимые инструкции для свапа
 -- 	instructions, err := c.CreateSwapInstructions(params)
---@@ -372,40 +377,53 @@ func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
--- 		return fmt.Errorf("failed to create swap instructions: %w", err)
+-- 	if err != nil {
+-- 		return "", fmt.Errorf("failed to create swap instructions: %w", err)
 -- 	}
 -- 
----	// Создаем транзакцию
+---	// Получаем последний блокхэш
 ---	recent, err := c.client.GetRecentBlockhash()
 --+	// Получаем последний блокхеш
 --+	recent, err := c.client.GetRecentBlockhash(ctx)
 -- 	if err != nil {
--- 		return fmt.Errorf("failed to get recent blockhash: %w", err)
+-- 		return "", fmt.Errorf("failed to get recent blockhash: %w", err)
 -- 	}
 -- 
+-- 	// Создаем транзакцию
 ---	tx := solana.NewTransaction(
---+	// Создаем транзакцию
 --+	tx, err := solana.NewTransaction(
 -- 		instructions,
 ---		recent.Value.Blockhash,
@@ -1560,1784 +1490,1058 @@ index 8e5c180..4ae4320 100644
 -- 		solana.TransactionPayer(params.UserWallet),
 -- 	)
 --+	if err != nil {
---+		return fmt.Errorf("failed to create transaction: %w", err)
+--+		return "", fmt.Errorf("failed to create transaction: %w", err)
 --+	}
---+
---+	// Подписываем транзакцию если есть приватный ключ
---+	if params.PrivateKey != nil {
---+		tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
---+			if key.Equals(params.UserWallet) {
+-- 
+-- 	// Подписываем транзакцию
+-- 	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+-- 		if key.Equals(params.UserWallet) {
+---			return &c.client.PrivateKey
+--+			if params.PrivateKey != nil {
 --+				return params.PrivateKey
 --+			}
---+			return nil
---+		})
---+	}
--- 
--- 	// Симулируем транзакцию
----	sim, err := c.client.SimulateTransaction(tx, &rpc.SimulateTransactionOpts{
----		SigVerify:              false,
----		Commitment:             c.options.commitment,
----		ReplaceRecentBlockhash: true,
----	})
---+	simResult, err := c.client.SimulateTransaction(ctx, tx)
--- 	if err != nil {
--- 		return fmt.Errorf("failed to simulate transaction: %w", err)
+--+			return &c.privateKey
+-- 		}
+-- 		return nil
+-- 	})
+--@@ -481,7 +467,7 @@ func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
 -- 	}
 -- 
--- 	// Проверяем результат симуляции
----	if sim.Value.Err != nil {
----		return fmt.Errorf("simulation failed: %s", sim.Value.Err)
---+	if simResult.Err != nil {
---+		return fmt.Errorf("simulation failed: %s", simResult.Err)
+-- 	// Отправляем транзакцию
+---	sig, err := c.client.SendTransaction(tx, &rpc.SendTransactionOpts{
+--+	sig, err := c.client.SendTransactionWithOpts(ctx, tx, blockchain.TransactionOptions{
+-- 		SkipPreflight:       true,
+-- 		PreflightCommitment: c.options.commitment,
+-- 	})
+--@@ -489,49 +475,23 @@ func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
+-- 		return "", fmt.Errorf("failed to send transaction: %w", err)
 -- 	}
 -- 
--- 	// Анализируем логи симуляции
----	for _, log := range sim.Value.Logs {
---+	for _, log := range simResult.Logs {
--- 		c.logger.Debug("simulation log", zap.String("log", log))
+---	// Ждем подтверждения транзакции
+---	confirmationStrategy := rpc.TransactionConfirmationStrategy{
+---		Signature:            sig,
+---		Commitment:           c.options.commitment,
+---		LastValidBlockHeight: recent.Value.LastValidBlockHeight,
+---	}
+---
+---	startTime := time.Now()
+---	confirmation, err := c.client.ConfirmTransaction(
+---		confirmationStrategy,
+---		&rpc.ConfirmTransactionOpts{
+---			MaxRetries: c.options.retries,
+---			Timeout:    c.options.timeout,
+---		},
+---	)
+---	if err != nil {
+---		return sig, fmt.Errorf("failed to confirm transaction: %w", err)
+---	}
+---
+---	// Проверяем статус подтверждения
+---	if confirmation.Value.Err != nil {
+---		return sig, fmt.Errorf("transaction confirmed with error: %v", confirmation.Value.Err)
+---	}
+---
+-- 	c.logger.Info("swap executed successfully",
+---		zap.String("signature", sig),
+---		zap.Duration("duration", time.Since(startTime)),
+--+		zap.String("signature", sig.String()),
+--+		zap.String("explorer", fmt.Sprintf("https://explorer.solana.com/tx/%s", sig.String())),
+-- 	)
+-- 
+---	// Опционально: получаем и логируем новые балансы
+---	if err := c.logUpdatedBalances(params); err != nil {
+---		c.logger.Warn("failed to get updated balances", zap.Error(err))
+---	}
+---
+---	return sig, nil
+--+	return sig.String(), nil
+-- }
+-- 
+-- // logUpdatedBalances вспомогательный метод для логирования балансов после свапа
+-- func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
+--+	ctx := context.Background()
+--+
+-- 	// Получаем баланс SOL
+-- 	solBalance, err := c.client.GetBalance(
+--+		ctx,
+-- 		params.UserWallet,
+---		rpc.CommitmentConfirmed,
+--+		solanarpc.CommitmentConfirmed,
+-- 	)
+-- 	if err != nil {
+-- 		return fmt.Errorf("failed to get SOL balance: %w", err)
+--@@ -539,15 +499,16 @@ func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
+-- 
+-- 	// Получаем баланс токена
+-- 	tokenBalance, err := c.client.GetTokenAccountBalance(
+--+		ctx,
+-- 		params.DestinationTokenAccount,
+---		rpc.CommitmentConfirmed,
+--+		solanarpc.CommitmentConfirmed,
+-- 	)
+-- 	if err != nil {
+-- 		return fmt.Errorf("failed to get token balance: %w", err)
 -- 	}
 -- 
--- 	c.logger.Info("swap simulation successful",
----		zap.Uint64("unitsConsumed", sim.Value.UnitsConsumed),
---+		zap.Uint64("unitsConsumed", simResult.UnitsConsumed),
---+		zap.String("sourceToken", params.SourceTokenAccount.String()),
---+		zap.String("destinationToken", params.DestinationTokenAccount.String()),
---+		zap.Uint64("priorityFee", params.PriorityFeeLamports),
+-- 	c.logger.Info("updated balances",
+---		zap.Float64("solBalance", float64(solBalance.Value)/float64(solana.LAMPORTS_PER_SOL)),
+--+		zap.Float64("solBalance", float64(solBalance)/float64(solana.LAMPORTS_PER_SOL)),
+-- 		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
 -- 	)
 -- 
--- 	return nil
+--diff --git a/internal/dex/raydium/constants.go b/internal/dex/raydium/constants.go
+--index fe6eb6e..049e4ff 100644
+----- a/internal/dex/raydium/constants.go
+--+++ b/internal/dex/raydium/constants.go
+--@@ -84,13 +84,6 @@ const (
+-- 	MINT_ACCOUNT_SIZE  = 82  // Добавлено
+-- )
+-- 
+---// RaydiumError represents a custom error type
+---type RaydiumError struct {
+---	Code    string
+---	Message string
+---	Details map[string]interface{}
+---}
+---
+-- func (e *RaydiumError) Error() string {
+-- 	return fmt.Sprintf("%s: %s", e.Code, e.Message)
+-- }
+--diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
+--index 50959de..b9ac3f5 100644
+----- a/internal/dex/raydium/pool.go
+--+++ b/internal/dex/raydium/pool.go
+--@@ -10,18 +10,6 @@ import (
+-- 	"go.uber.org/zap"
+-- )
+-- 
+---type SwapAmounts struct {
+---	AmountIn     uint64 // Количество входных токенов
+---	AmountOut    uint64 // Ожидаемое количество выходных токенов
+---	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
+---}
+---
+---type PoolManager struct {
+---	client blockchain.Client
+---	logger *zap.Logger
+---	pool   *RaydiumPool
+---}
+---
+-- // NewPoolManager создает новый менеджер пула
+-- func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *RaydiumPool) *PoolManager {
+-- 	return &PoolManager{
+--diff --git a/internal/dex/raydium/sniper.go b/internal/dex/raydium/sniper.go
+--index c9a6c55..7313203 100644
+----- a/internal/dex/raydium/sniper.go
+--+++ b/internal/dex/raydium/sniper.go
+--@@ -11,26 +11,6 @@ import (
+-- 	"go.uber.org/zap"
+-- )
+-- 
+---type Sniper struct {
+---	client *RaydiumClient
+---	logger *zap.Logger
+---	config *SniperConfig // Конфигурация снайпинга
+---}
+---type SniperConfig struct {
+---	// Существующие поля
+---	maxSlippageBps   uint16
+---	minAmountSOL     float64
+---	maxAmountSOL     float64
+---	priorityFee      uint64
+---	waitConfirmation bool
+---	monitorInterval  time.Duration
+---	maxRetries       int
+---
+---	// Добавляем новые необходимые поля
+---	baseMint  solana.PublicKey // Mint address базового токена
+---	quoteMint solana.PublicKey // Mint address котируемого токена
+---}
+---
+-- // TODO: можно добавить:
+-- 
+-- // 1. Проверку цены перед свапом
 --diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
---index 55c2206..dcca4e7 100644
+--index dcca4e7..3cd90d3 100644
 ----- a/internal/dex/raydium/types.go
 --+++ b/internal/dex/raydium/types.go
---@@ -23,13 +23,14 @@ type PoolState struct {
--- }
+--@@ -1,7 +1,14 @@
+-- // inernal/dex/raydium/types.go - это пакет, который содержит в себе реализацию работы с декстерами Raydium
+-- package raydium
 -- 
--- type SwapParams struct {
----	UserWallet              solana.PublicKey // Публичный ключ кошелька пользователя
----	AmountIn                uint64           // Количество входного токена для обмена
----	MinAmountOut            uint64           // Минимальное количество выходного токена, которое пользователь готов принять
----	Pool                    *RaydiumPool     // Указатель на пул, в котором происходит обмен
----	SourceTokenAccount      solana.PublicKey // Публичный ключ аккаунта исходного токена
----	DestinationTokenAccount solana.PublicKey // Публичный ключ аккаунта целевого токена
----	PriorityFeeLamports     uint64           // Приоритетная комиссия в лампортах
---+	UserWallet              solana.PublicKey   // Публичный ключ кошелька пользователя
---+	PrivateKey              *solana.PrivateKey // Приватный ключ для подписания транзакции
---+	AmountIn                uint64             // Количество входного токена для обмена
---+	MinAmountOut            uint64             // Минимальное количество выходного токена
---+	Pool                    *RaydiumPool       // Указатель на пул для обмена
---+	SourceTokenAccount      solana.PublicKey   // Аккаунт исходного токена
---+	DestinationTokenAccount solana.PublicKey   // Аккаунт целевого токена
---+	PriorityFeeLamports     uint64             // Приоритетная комиссия в лампортах
--- }
+---import "github.com/gagliardetto/solana-go"
+--+import (
+--+	"time"
+--+
+--+	"github.com/gagliardetto/solana-go"
+--+	"github.com/gagliardetto/solana-go/rpc"
+--+	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+--+	"go.uber.org/zap"
+--+)
 -- 
--- // Основные ошибки
+-- type RaydiumPool struct {
+-- 	ID            solana.PublicKey // Идентификатор пула
+--@@ -39,3 +46,76 @@ type SwapError struct {
+-- 	Message string // Сообщение об ошибке
+-- 	Err     error  // Вложенная ошибка
+-- }
+--+
+--+type RaydiumClient struct {
+--+	client     blockchain.Client
+--+	logger     *zap.Logger
+--+	options    *clientOptions // Базовые настройки таймаутов и retry
+--+	privateKey solana.PrivateKey
+--+}
+--+type clientOptions struct {
+--+	timeout     time.Duration      // Таймаут для операций
+--+	retries     int                // Количество повторных попыток
+--+	priorityFee uint64             // Приоритетная комиссия в лампортах
+--+	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
+--+}
+--+
+--+// Вспомогательные структуры для инструкций
+--+type ComputeBudgetInstruction struct {
+--+	Units         uint32
+--+	MicroLamports uint64
+--+}
+--+
+--+type SwapInstruction struct {
+--+	Amount     *uint64
+--+	MinimumOut *uint64
+--+
+--+	// Slice для хранения аккаунтов, следуя паттерну из SDK
+--+	solana.AccountMetaSlice `bin:"-" borsh_skip:"true"`
+--+}
+--+
+--+// RaydiumSwapInstruction реализует интерфейс solana.Instruction
+--+type RaydiumSwapInstruction struct {
+--+	programID solana.PublicKey
+--+	accounts  []*solana.AccountMeta
+--+	data      []byte
+--+}
+--+
+--+// RaydiumError represents a custom error type
+--+type RaydiumError struct {
+--+	Code    string
+--+	Message string
+--+	Details map[string]interface{}
+--+}
+--+
+--+type SwapAmounts struct {
+--+	AmountIn     uint64 // Количество входных токенов
+--+	AmountOut    uint64 // Ожидаемое количество выходных токенов
+--+	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
+--+}
+--+
+--+type PoolManager struct {
+--+	client blockchain.Client
+--+	logger *zap.Logger
+--+	pool   *RaydiumPool
+--+}
+--+
+--+type Sniper struct {
+--+	client *RaydiumClient
+--+	logger *zap.Logger
+--+	config *SniperConfig // Конфигурация снайпинга
+--+}
+--+type SniperConfig struct {
+--+	// Существующие поля
+--+	maxSlippageBps   uint16
+--+	minAmountSOL     float64
+--+	maxAmountSOL     float64
+--+	priorityFee      uint64
+--+	waitConfirmation bool
+--+	monitorInterval  time.Duration
+--+	maxRetries       int
+--+
+--+	// Добавляем новые необходимые поля
+--+	baseMint  solana.PublicKey // Mint address базового токена
+--+	quoteMint solana.PublicKey // Mint address котируемого токена
+--+}
 --diff --git a/newdif.txt b/newdif.txt
---index 4e87d10..babe755 100644
+--index 2f2ac9a..c5a89bd 100644
 ----- a/newdif.txt
 --+++ b/newdif.txt
---@@ -1,9023 +0,0 @@
----diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
----index b28a72a..e059ba7 100644
------- a/internal/blockchain/solbc/client.go
----+++ b/internal/blockchain/solbc/client.go
----@@ -4,6 +4,7 @@ package solbc
---- import (
---- 	"context"
---- 	"fmt"
----+	"time"
---- 
---- 	"github.com/gagliardetto/solana-go"
---- 	solanarpc "github.com/gagliardetto/solana-go/rpc"
----@@ -49,7 +50,6 @@ func (c *Client) GetRecentBlockhash(ctx context.Context) (solana.Hash, error) {
---- 	return result.Value.Blockhash, nil
+--@@ -1,9141 +0,0 @@
+---diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
+---index 1d6c450..4e94724 100644
+------ a/internal/dex/raydium/client.go
+---+++ b/internal/dex/raydium/client.go
+---@@ -363,8 +363,13 @@ func validateSwapParams(params *SwapParams) error {
 --- }
 --- 
-----// SendTransaction отправляет транзакцию
---- // SendTransaction отправляет транзакцию с улучшенной обработкой ошибок
---- func (c *Client) SendTransaction(ctx context.Context, tx *solana.Transaction) (solana.Signature, error) {
---- 	signature, err := c.rpc.SendTransaction(ctx, tx)
----@@ -80,3 +80,78 @@ func (c *Client) Close() error {
---- func (c *Client) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
---- 	return c.rpc.GetSignatureStatuses(ctx, signatures...)
---- }
----+
----+// GetProgramAccounts получает аккаунты программы по заданным фильтрам
----+func (c *Client) GetProgramAccounts(
----+	ctx context.Context,
----+	program solana.PublicKey,
----+	opts solanarpc.GetProgramAccountsOpts,
----+) ([]solanarpc.KeyedAccount, error) {
----+	c.logger.Debug("getting program accounts",
----+		zap.String("program", program.String()),
----+	)
----+
----+	accounts, err := c.rpc.GetProgramAccounts(ctx, program, opts)
----+	if err != nil {
----+		c.metrics.IncrementFailedRequests()
----+		c.metrics.LastError = err
----+		c.metrics.LastErrorTime = time.Now()
----+		return nil, fmt.Errorf("failed to get program accounts: %w", err)
----+	}
----+
----+	c.metrics.IncrementProgramAccountRequests()
----+	return accounts, nil
----+}
----+
----+// GetTokenAccountBalance получает баланс токен-аккаунта
----+func (c *Client) GetTokenAccountBalance(
----+	ctx context.Context,
----+	account solana.PublicKey,
----+	commitment solanarpc.CommitmentType,
----+) (*solanarpc.GetTokenAccountBalanceResult, error) {
----+	c.logger.Debug("getting token account balance",
----+		zap.String("account", account.String()),
----+		zap.String("commitment", string(commitment)),
+--- // SimulateSwap выполняет симуляцию транзакции свапа
+----func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
+----	c.logger.Debug("simulating swap transaction")
+---+func (c *RaydiumClient) SimulateSwap(ctx context.Context, params *SwapParams) error {
+---+	c.logger.Debug("simulating swap transaction",
+---+		zap.String("userWallet", params.UserWallet.String()),
+---+		zap.Uint64("amountIn", params.AmountIn),
+---+		zap.Uint64("minAmountOut", params.MinAmountOut),
+---+		zap.String("pool", params.Pool.ID.String()),
 ---+	)
----+
----+	result, err := c.rpc.GetTokenAccountBalance(ctx, account, commitment)
----+	if err != nil {
----+		c.metrics.FailedRequests++
----+		c.metrics.LastError = err
----+		c.metrics.LastErrorTime = time.Now()
----+		return nil, fmt.Errorf("failed to get token account balance: %w", err)
----+	}
----+
----+	return result, nil
----+}
----+
----+// SimulateTransaction симулирует выполнение транзакции
----+func (c *Client) SimulateTransaction(
----+	ctx context.Context,
----+	tx *solana.Transaction,
----+) (*blockchain.SimulationResult, error) {
----+	c.logger.Debug("simulating transaction")
----+
----+	result, err := c.rpc.SimulateTransaction(ctx, tx)
----+	if err != nil {
----+		c.metrics.FailedRequests++
----+		c.metrics.LastError = err
----+		c.metrics.LastErrorTime = time.Now()
----+		return nil, fmt.Errorf("failed to simulate transaction: %w", err)
----+	}
----+
----+	// Обработаем возможный nil в UnitsConsumed
----+	var unitsConsumed uint64
----+	if result.Value.UnitsConsumed != nil {
----+		unitsConsumed = *result.Value.UnitsConsumed
----+	}
----+
----+	// Преобразуем результат в нужный формат
----+	simulationResult := &blockchain.SimulationResult{
----+		Err:           result.Value.Err,
----+		Logs:          result.Value.Logs,
----+		UnitsConsumed: unitsConsumed,
----+	}
----+
----+	return simulationResult, nil
----+}
----diff --git a/internal/blockchain/solbc/rpc/rpc.go b/internal/blockchain/solbc/rpc/rpc.go
----index 71fbdc2..1b027e2 100644
------- a/internal/blockchain/solbc/rpc/rpc.go
----+++ b/internal/blockchain/solbc/rpc/rpc.go
----@@ -184,3 +184,86 @@ func (c *RPCClient) GetSignatureStatuses(ctx context.Context, signatures ...sola
 --- 
---- // Close закрывает клиент
---- func (c *RPCClient) Close() {}
----+
----+// GetProgramAccounts получает все аккаунты для заданной программы
----+func (c *RPCClient) GetProgramAccounts(
----+	ctx context.Context,
----+	program solana.PublicKey,
----+	opts solanarpc.GetProgramAccountsOpts,
----+) ([]solanarpc.KeyedAccount, error) {
----+	var accounts []solanarpc.KeyedAccount
----+
----+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
----+		result, err := client.GetProgramAccountsWithOpts(
----+			ctx,
----+			program,
----+			&opts,
----+		)
----+		if err != nil {
----+			return err
----+		}
----+
----+		// Преобразуем []*KeyedAccount в []KeyedAccount
----+		accounts = make([]solanarpc.KeyedAccount, len(result))
----+		for i, acc := range result {
----+			accounts[i] = *acc
----+		}
----+
----+		return nil
----+	})
----+
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to get program accounts: %w", err)
----+	}
----+
----+	return accounts, nil
----+}
----+
----+// GetTokenAccountBalance получает баланс токен-аккаунта
----+func (c *RPCClient) GetTokenAccountBalance(
----+	ctx context.Context,
----+	account solana.PublicKey,
----+	commitment solanarpc.CommitmentType,
----+) (*solanarpc.GetTokenAccountBalanceResult, error) {
----+	var result *solanarpc.GetTokenAccountBalanceResult
----+
----+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
----+		var err error
----+		result, err = client.GetTokenAccountBalance(
----+			ctx,
----+			account,
----+			commitment,
----+		)
----+		return err
----+	})
----+
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to get token account balance: %w", err)
----+	}
----+
----+	return result, nil
----+}
----+
----+// SimulateTransaction симулирует выполнение транзакции
----+func (c *RPCClient) SimulateTransaction(
----+	ctx context.Context,
----+	tx *solana.Transaction,
----+) (*solanarpc.SimulateTransactionResponse, error) {
----+	var result *solanarpc.SimulateTransactionResponse
----+
----+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
----+		var err error
----+		result, err = client.SimulateTransactionWithOpts(ctx, tx, &solanarpc.SimulateTransactionOpts{
----+			SigVerify:              false,
----+			Commitment:             solanarpc.CommitmentConfirmed,
----+			ReplaceRecentBlockhash: false,
----+		})
----+		return err
----+	})
----+
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to simulate transaction: %w", err)
----+	}
----+
----+	return result, nil
----+}
----diff --git a/internal/blockchain/solbc/solana.go b/internal/blockchain/solbc/solana.go
----index cfede3e..b24546f 100644
------- a/internal/blockchain/solbc/solana.go
----+++ b/internal/blockchain/solbc/solana.go
----@@ -54,9 +54,3 @@ func (s *Blockchain) GetRecentBlockhash(ctx context.Context) (solana.Hash, error
+--- 	// Получаем инструкции для свапа
+--- 	instructions, err := c.CreateSwapInstructions(params)
+---@@ -372,40 +377,53 @@ func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
+--- 		return fmt.Errorf("failed to create swap instructions: %w", err)
 --- 	}
---- 	return hash, nil
---- }
-----
-----// SimulateTransaction simulates a transaction on the Solana blockchain
-----func (c *Client) SimulateTransaction(tx string) (string, error) {
-----	// Implement the method logic here
-----	return "", nil
-----}
----diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
----index b3e342d..4d9d608 100644
------- a/internal/blockchain/solbc/types.go
----+++ b/internal/blockchain/solbc/types.go
----@@ -3,6 +3,7 @@ package solbc
---- 
---- import (
---- 	"sync"
----+	"sync/atomic"
---- 	"time"
---- 
---- 	"go.uber.org/zap"
----@@ -27,11 +28,22 @@ type Client struct {
---- }
---- 
---- type ClientMetrics struct {
-----	AccountInfoRequests uint64
-----	TransactionRequests uint64
-----	FailedRequests      uint64
-----	LastError           error
-----	LastErrorTime       time.Time
----+	AccountInfoRequests    uint64
----+	TransactionRequests    uint64
----+	FailedRequests         uint64
----+	ProgramAccountRequests uint64 // Добавляем новое поле
----+	LastError              error
----+	LastErrorTime          time.Time
----+}
----+
----+// IncrementProgramAccountRequests атомарно увеличивает счетчик запросов
----+func (m *ClientMetrics) IncrementProgramAccountRequests() {
----+	atomic.AddUint64(&m.ProgramAccountRequests, 1)
----+}
----+
----+// IncrementFailedRequests атомарно увеличивает счетчик ошибок
----+func (m *ClientMetrics) IncrementFailedRequests() {
----+	atomic.AddUint64(&m.FailedRequests, 1)
---- }
---- 
---- // Проверяем, что Client реализует blockchain.Client интерфейс
----diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
----index 81e8fb2..b702a54 100644
------- a/internal/blockchain/types.go
----+++ b/internal/blockchain/types.go
----@@ -3,7 +3,6 @@ package blockchain
---- 
---- import (
---- 	"context"
-----	"encoding/base64"
---- 
---- 	"github.com/gagliardetto/solana-go"
---- 	"github.com/gagliardetto/solana-go/rpc"
----@@ -21,22 +20,6 @@ type SimulationResult struct {
---- 	Err           interface{}
---- 	Logs          []string
---- 	UnitsConsumed uint64
-----	ReturnData    *Base64Data
-----}
-----
-----// Base64Data представляет данные в формате Base64
-----type Base64Data struct {
-----	Data string
-----}
-----
-----// EncodeBase64 кодирует данные в Base64
-----func (b *Base64Data) EncodeBase64(data []byte) {
-----	b.Data = base64.StdEncoding.EncodeToString(data)
-----}
-----
-----// DecodeBase64 декодирует данные из Base64
-----func (b *Base64Data) DecodeBase64() ([]byte, error) {
-----	return base64.StdEncoding.DecodeString(b.Data)
---- }
---- 
---- // Client определяет общий интерфейс для клиентов блокчейна
----@@ -48,4 +31,7 @@ type Client interface {
---- 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
---- 	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
---- 	GetTokenAccountBalance(ctx context.Context, account solana.PublicKey, commitment rpc.CommitmentType) (*rpc.GetTokenAccountBalanceResult, error)
----+
----+	// Добавляем новый метод для получения программных аккаунтов
----+	GetProgramAccounts(ctx context.Context, program solana.PublicKey, opts rpc.GetProgramAccountsOpts) ([]rpc.KeyedAccount, error)
---- }
----diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
----index 342586c..14041b4 100644
------- a/internal/dex/raydium/client.go
----+++ b/internal/dex/raydium/client.go
----@@ -2,18 +2,24 @@
---- package raydium
---- 
---- import (
----+	"context"
---- 	"encoding/binary"
----+	"errors"
---- 	"fmt"
---- 	"time"
---- 
----+	bin "github.com/gagliardetto/binary"
---- 	"github.com/gagliardetto/solana-go"
----+	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
---- 	"github.com/gagliardetto/solana-go/rpc"
---- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
----+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
---- 	"go.uber.org/zap"
---- )
---- 
---- const (
-----	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
----+	RAYDIUM_V4_PROGRAM_ID  = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
----+	MAX_COMPUTE_UNIT_LIMIT = 300000 // Из compute-budget/SetComputeUnitLimit.go
---- )
---- 
---- type RaydiumClient struct {
----@@ -35,56 +41,62 @@ type ComputeBudgetInstruction struct {
---- }
---- 
---- type SwapInstruction struct {
-----	Amount     uint64
-----	MinimumOut uint64
----+	Amount     *uint64
----+	MinimumOut *uint64
----+
----+	// Slice для хранения аккаунтов, следуя паттерну из SDK
----+	solana.AccountMetaSlice `bin:"-" borsh_skip:"true"`
---- }
---- 
---- // NewRaydiumClient создает новый экземпляр клиента Raydium
-----func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) *RaydiumClient {
-----	// Инициализация с базовыми настройками
----+func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*RaydiumClient, error) {
----+	logger = logger.Named("raydium-client")
----+
----+	// Создаем базового клиента через фабрику
----+	solClient, err := solbc.NewClient([]string{rpcEndpoint}, logger)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to create solana client: %w", err)
----+	}
 --- 
---- 	opts := &clientOptions{
---- 		timeout:     30 * time.Second,
---- 		retries:     3,
-----		priorityFee: 1000, // базовое значение в лампортах
----+		priorityFee: 1000,
---- 		commitment:  rpc.CommitmentConfirmed,
+----	// Создаем транзакцию
+----	recent, err := c.client.GetRecentBlockhash()
+---+	// Получаем последний блокхеш
+---+	recent, err := c.client.GetRecentBlockhash(ctx)
+--- 	if err != nil {
+--- 		return fmt.Errorf("failed to get recent blockhash: %w", err)
 --- 	}
 --- 
-----	client := blockchain.NewSolanaClient(rpcEndpoint, wallet)
-----
---- 	return &RaydiumClient{
-----		client:  client,
----+		client:  solClient,
---- 		logger:  logger,
---- 		options: opts,
-----	}
----+	}, nil
---- }
---- 
---- // GetPool получает информацию о пуле по базовому и котируемому токенам
-----func (c *RaydiumClient) GetPool(baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
-----	// Получение информации о пуле
-----
----+func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
---- 	c.logger.Debug("getting raydium pool info",
---- 		zap.String("baseMint", baseMint.String()),
---- 		zap.String("quoteMint", quoteMint.String()),
---- 	)
---- 
-----	// Получаем программные аккаунты по фильтрам
----+	// Получаем программные аккаунты через интерфейс
---- 	accounts, err := c.client.GetProgramAccounts(
----+		ctx,
---- 		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
---- 		rpc.GetProgramAccountsOpts{
---- 			Filters: []rpc.RPCFilter{
---- 				{
-----					DataSize: 388, // размер аккаунта пула v4
----+					DataSize: 388,
---- 				},
---- 				{
---- 					Memcmp: &rpc.RPCFilterMemcmp{
-----						Offset: 8, // смещение для baseMint
----+						Offset: 8,
---- 						Bytes:  baseMint.Bytes(),
---- 					},
---- 				},
---- 				{
---- 					Memcmp: &rpc.RPCFilterMemcmp{
-----						Offset: 40, // смещение для quoteMint
----+						Offset: 40,
---- 						Bytes:  quoteMint.Bytes(),
---- 					},
---- 				},
----@@ -120,16 +132,16 @@ func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
+----	tx := solana.NewTransaction(
+---+	// Создаем транзакцию
+---+	tx, err := solana.NewTransaction(
+--- 		instructions,
+----		recent.Value.Blockhash,
+---+		recent,
+--- 		solana.TransactionPayer(params.UserWallet),
 --- 	)
+---+	if err != nil {
+---+		return fmt.Errorf("failed to create transaction: %w", err)
+---+	}
+---+
+---+	// Подписываем транзакцию если есть приватный ключ
+---+	if params.PrivateKey != nil {
+---+		tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+---+			if key.Equals(params.UserWallet) {
+---+				return params.PrivateKey
+---+			}
+---+			return nil
+---+		})
+---+	}
 --- 
---- 	// Получаем данные аккаунта пула
-----	account, err := c.client.GetAccountInfo(pool.ID)
----+	account, err := c.client.GetAccountInfo(context.Background(), pool.ID)
+--- 	// Симулируем транзакцию
+----	sim, err := c.client.SimulateTransaction(tx, &rpc.SimulateTransactionOpts{
+----		SigVerify:              false,
+----		Commitment:             c.options.commitment,
+----		ReplaceRecentBlockhash: true,
+----	})
+---+	simResult, err := c.client.SimulateTransaction(ctx, tx)
 --- 	if err != nil {
---- 		return nil, fmt.Errorf("failed to get pool account: %w", err)
+--- 		return fmt.Errorf("failed to simulate transaction: %w", err)
 --- 	}
 --- 
---- 	// Парсим данные в структуру состояния
---- 	state := &PoolState{
-----		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // пример смещения
-----		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // пример смещения
-----		Status:       account.Data[88],                                // пример смещения
----+		BaseReserve:  binary.LittleEndian.Uint64(account.Value.Data.GetBinary()[64:72]), // пример смещения
----+		QuoteReserve: binary.LittleEndian.Uint64(account.Value.Data.GetBinary()[72:80]), // пример смещения
----+		Status:       account.Value.Data.GetBinary()[88],                                // пример смещения
+--- 	// Проверяем результат симуляции
+----	if sim.Value.Err != nil {
+----		return fmt.Errorf("simulation failed: %s", sim.Value.Err)
+---+	if simResult.Err != nil {
+---+		return fmt.Errorf("simulation failed: %s", simResult.Err)
 --- 	}
 --- 
---- 	return state, nil
----@@ -143,53 +155,158 @@ func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
---- // Обработку разных версий пулов
---- // Расчет слиппажа и проверку лимитов
---- 
-----// CreateSwapInstructions создает набор инструкций для свапа
----+// NewSwapInstructionBuilder создает новый билдер для SwapInstruction
----+func NewSwapInstructionBuilder() *SwapInstruction {
----+	return &SwapInstruction{
----+		AccountMetaSlice: make(solana.AccountMetaSlice, 7), // 7 обязательных аккаунтов
----+	}
----+}
----+
----+// Методы для установки параметров, следуя паттерну из SDK
----+func (inst *SwapInstruction) SetAmount(amount uint64) *SwapInstruction {
----+	inst.Amount = &amount
----+	return inst
----+}
----+
----+func (inst *SwapInstruction) SetMinimumOut(minimumOut uint64) *SwapInstruction {
----+	inst.MinimumOut = &minimumOut
----+	return inst
----+}
----+
----+// Методы для установки аккаунтов
----+func (inst *SwapInstruction) SetAccounts(
----+	pool solana.PublicKey,
----+	authority solana.PublicKey,
----+	userWallet solana.PublicKey,
----+	sourceToken solana.PublicKey,
----+	destToken solana.PublicKey,
----+	baseVault solana.PublicKey,
----+	quoteVault solana.PublicKey,
----+) *SwapInstruction {
----+	inst.AccountMetaSlice[0] = solana.Meta(pool).WRITE()
----+	inst.AccountMetaSlice[1] = solana.Meta(authority)
----+	inst.AccountMetaSlice[2] = solana.Meta(userWallet).WRITE().SIGNER()
----+	inst.AccountMetaSlice[3] = solana.Meta(sourceToken).WRITE()
----+	inst.AccountMetaSlice[4] = solana.Meta(destToken).WRITE()
----+	inst.AccountMetaSlice[5] = solana.Meta(baseVault).WRITE()
----+	inst.AccountMetaSlice[6] = solana.Meta(quoteVault).WRITE()
----+	return inst
----+}
----+
----+// Validate проверяет все необходимые параметры
----+func (inst *SwapInstruction) Validate() error {
----+	if inst.Amount == nil {
----+		return errors.New("Amount is not set")
----+	}
----+	if inst.MinimumOut == nil {
----+		return errors.New("MinimumOut is not set")
----+	}
----+
----+	// Проверка всех аккаунтов
----+	for i, acc := range inst.AccountMetaSlice {
----+		if acc == nil {
----+			return fmt.Errorf("account at index %d is not set", i)
----+		}
----+	}
----+	return nil
----+}
----+
----+// Build создает инструкцию
----+func (inst *SwapInstruction) Build() (*solana.Instruction, error) {
----+	if err := inst.Validate(); err != nil {
----+		return nil, err
----+	}
----+
----+	// Сериализация данных инструкции
----+	data := make([]byte, 16)
----+	binary.LittleEndian.PutUint64(data[0:8], *inst.Amount)
----+	binary.LittleEndian.PutUint64(data[8:16], *inst.MinimumOut)
----+
----+	return &solana.Instruction{BaseVariant: bin.BaseVariant{
----+		Impl: &solana.GenericInstruction{
----+			AccountValues: inst.AccountMetaSlice,
----+			ProgID:        solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
----+			DataBytes:     data,
----+		},
----+	}}, nil
----+}
----+
----+// CreateSwapInstructions создает инструкции для свапа
---- func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
-----	c.logger.Debug("creating swap instructions",
-----		zap.String("userWallet", params.UserWallet.String()),
-----		zap.Uint64("amountIn", params.AmountIn),
-----		zap.Uint64("minAmountOut", params.MinAmountOut),
-----	)
----+	if err := validateSwapParams(params); err != nil {
----+		return nil, err
----+	}
---- 
-----	// Создаем базовый массив инструкций
---- 	instructions := make([]solana.Instruction, 0)
---- 
-----	// Создаем инструкцию для установки приоритета комиссии
----+	// Добавляем инструкцию compute budget если указан приоритетный fee
---- 	if params.PriorityFeeLamports > 0 {
-----		computeBudgetIx := solana.NewInstruction(
-----			solana.ComputeBudget,
-----			&ComputeBudgetInstruction{
-----				Units:         300000, // базовые compute units как в typescript
-----				MicroLamports: params.PriorityFeeLamports,
-----			},
-----		)
-----		instructions = append(instructions, computeBudgetIx)
----+		computeLimitIx, err := computebudget.NewSetComputeUnitLimitInstructionBuilder().
----+			SetUnits(MAX_COMPUTE_UNIT_LIMIT).
----+			ValidateAndBuild()
----+		if err != nil {
----+			return nil, fmt.Errorf("failed to build compute limit instruction: %w", err)
----+		}
----+		instructions = append(instructions, computeLimitIx)
----+
----+		computePriceIx, err := computebudget.NewSetComputeUnitPriceInstructionBuilder().
----+			SetMicroLamports(params.PriorityFeeLamports).
----+			ValidateAndBuild()
----+		if err != nil {
----+			return nil, fmt.Errorf("failed to build compute price instruction: %w", err)
----+		}
----+		instructions = append(instructions, computePriceIx)
----+	}
----+
----+	// Создаем инструкцию свапа
----+	swapIx, err := NewSwapInstructionBuilder().
----+		SetAmount(params.AmountIn).
----+		SetMinimumOut(params.MinAmountOut).
----+		SetAccounts(
----+			params.Pool.ID,
----+			params.Pool.Authority,
----+			params.UserWallet,
----+			params.SourceTokenAccount,
----+			params.DestinationTokenAccount,
----+			params.Pool.BaseVault,
----+			params.Pool.QuoteVault,
----+		).
----+		Build()
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
+--- 	// Анализируем логи симуляции
+----	for _, log := range sim.Value.Logs {
+---+	for _, log := range simResult.Logs {
+--- 		c.logger.Debug("simulation log", zap.String("log", log))
 --- 	}
 --- 
-----	// Создаем основную инструкцию свапа
-----	swapIx := solana.NewInstruction(
-----		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
-----		&SwapInstruction{
-----			Amount:     params.AmountIn,
-----			MinimumOut: params.MinAmountOut,
-----		},
-----		// Добавляем необходимые аккаунты
-----		[]solana.AccountMeta{
-----			{PublicKey: params.Pool.ID, IsWritable: true, IsSigner: false},
-----			{PublicKey: params.Pool.Authority, IsWritable: false, IsSigner: false},
-----			{PublicKey: params.UserWallet, IsWritable: true, IsSigner: true},
-----			{PublicKey: params.SourceTokenAccount, IsWritable: true, IsSigner: false},
-----			{PublicKey: params.DestinationTokenAccount, IsWritable: true, IsSigner: false},
-----			{PublicKey: params.Pool.BaseVault, IsWritable: true, IsSigner: false},
-----			{PublicKey: params.Pool.QuoteVault, IsWritable: true, IsSigner: false},
-----			// Добавляем остальные необходимые аккаунты
-----		},
-----	)
---- 	instructions = append(instructions, swapIx)
+--- 	c.logger.Info("swap simulation successful",
+----		zap.Uint64("unitsConsumed", sim.Value.UnitsConsumed),
+---+		zap.Uint64("unitsConsumed", simResult.UnitsConsumed),
+---+		zap.String("sourceToken", params.SourceTokenAccount.String()),
+---+		zap.String("destinationToken", params.DestinationTokenAccount.String()),
+---+		zap.Uint64("priorityFee", params.PriorityFeeLamports),
+--- 	)
 --- 
---- 	return instructions, nil
+--- 	return nil
+---diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
+---index 55c2206..dcca4e7 100644
+------ a/internal/dex/raydium/types.go
+---+++ b/internal/dex/raydium/types.go
+---@@ -23,13 +23,14 @@ type PoolState struct {
 --- }
 --- 
----+// validateSwapParams проверяет входные параметры
----+func validateSwapParams(params *SwapParams) error {
----+	if params == nil {
----+		return errors.New("params cannot be nil")
----+	}
----+	if params.Pool == nil {
----+		return errors.New("pool cannot be nil")
----+	}
----+	if params.UserWallet.IsZero() {
----+		return errors.New("user wallet is required")
----+	}
----+	if params.SourceTokenAccount.IsZero() {
----+		return errors.New("source token account is required")
----+	}
----+	if params.DestinationTokenAccount.IsZero() {
----+		return errors.New("destination token account is required")
----+	}
----+	if params.AmountIn == 0 {
----+		return errors.New("amount in must be greater than 0")
----+	}
----+	if params.MinAmountOut == 0 {
----+		return errors.New("minimum amount out must be greater than 0")
----+	}
----+	return nil
----+}
----+
---- // SimulateSwap выполняет симуляцию транзакции свапа
---- func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
---- 	c.logger.Debug("simulating swap transaction")
----diff --git a/internal/dex/raydium/newSwap.txt b/internal/dex/raydium/newSwap.txt
----new file mode 100644
----index 0000000..5a4ec8f
------- /dev/null
----+++ b/internal/dex/raydium/newSwap.txt
----@@ -0,0 +1,760 @@
----+// internal/dex/raydium/client.go - это пакет, который содержит в себе реализацию клиента для работы с декстером Raydium
----+package raydium
----+
----+import (
----+	"encoding/binary"
----+	"fmt"
----+	"time"
----+
----+	"github.com/gagliardetto/solana-go"
----+	"github.com/gagliardetto/solana-go/rpc"
----+	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
----+	"go.uber.org/zap"
----+)
----+
----+const (
----+	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
----+)
----+
----+type RaydiumClient struct {
----+	client  blockchain.Client
----+	logger  *zap.Logger
----+	options *clientOptions // Базовые настройки таймаутов и retry
----+}
----+type clientOptions struct {
----+	timeout     time.Duration      // Таймаут для операций
----+	retries     int                // Количество повторных попыток
----+	priorityFee uint64             // Приоритетная комиссия в лампортах
----+	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
----+}
----+
----+// Вспомогательные структуры для инструкций
----+type ComputeBudgetInstruction struct {
----+	Units         uint32
----+	MicroLamports uint64
----+}
----+
----+type SwapInstruction struct {
----+	Amount     uint64
----+	MinimumOut uint64
----+}
----+
----+// NewRaydiumClient создает новый экземпляр клиента Raydium
----+func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) *RaydiumClient {
----+	// Инициализация с базовыми настройками
----+
----+	opts := &clientOptions{
----+		timeout:     30 * time.Second,
----+		retries:     3,
----+		priorityFee: 1000, // базовое значение в лампортах
----+		commitment:  rpc.CommitmentConfirmed,
----+	}
----+
----+	client := blockchain.NewSolanaClient(rpcEndpoint, wallet)
----+
----+	return &RaydiumClient{
----+		client:  client,
----+		logger:  logger,
----+		options: opts,
----+	}
----+}
----+
----+// GetPool получает информацию о пуле по базовому и котируемому токенам
----+func (c *RaydiumClient) GetPool(baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
----+	// Получение информации о пуле
----+
----+	c.logger.Debug("getting raydium pool info",
----+		zap.String("baseMint", baseMint.String()),
----+		zap.String("quoteMint", quoteMint.String()),
----+	)
----+
----+	// Получаем программные аккаунты по фильтрам
----+	accounts, err := c.client.GetProgramAccounts(
----+		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
----+		rpc.GetProgramAccountsOpts{
----+			Filters: []rpc.RPCFilter{
----+				{
----+					DataSize: 388, // размер аккаунта пула v4
----+				},
----+				{
----+					Memcmp: &rpc.RPCFilterMemcmp{
----+						Offset: 8, // смещение для baseMint
----+						Bytes:  baseMint.Bytes(),
----+					},
----+				},
----+				{
----+					Memcmp: &rpc.RPCFilterMemcmp{
----+						Offset: 40, // смещение для quoteMint
----+						Bytes:  quoteMint.Bytes(),
----+					},
----+				},
----+			},
----+		},
----+	)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to get program accounts: %w", err)
----+	}
----+
----+	if len(accounts) == 0 {
----+		return nil, fmt.Errorf("pool not found")
----+	}
----+
----+	// Берем первый найденный пул
----+	poolAccount := accounts[0]
----+
----+	// Парсим данные аккаунта в структуру пула
----+	pool := &RaydiumPool{
----+		ID:        poolAccount.PublicKey,
----+		BaseMint:  baseMint,
----+		QuoteMint: quoteMint,
----+		// ... заполнение остальных полей из данных аккаунта
----+	}
----+
----+	return pool, nil
----+}
----+
----+// GetPoolState получает текущее состояние пула
----+func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
----+	c.logger.Debug("getting pool state",
----+		zap.String("poolId", pool.ID.String()),
----+	)
----+
----+	// Получаем данные аккаунта пула
----+	account, err := c.client.GetAccountInfo(pool.ID)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to get pool account: %w", err)
----+	}
----+
----+	// Парсим данные в структуру состояния
----+	state := &PoolState{
----+		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // пример смещения
----+		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // пример смещения
----+		Status:       account.Data[88],                                // пример смещения
----+	}
----+
----+	return state, nil
----+}
----+
----+// TODO:
----+// Для полноценной работы нужно добавить:
----+// Корректную сериализацию инструкций (согласно протоколу Raydium)
----+// Детальную обработку различных типов ошибок
----+// Валидацию параметров свапа
----+// Обработку разных версий пулов
----+// Расчет слиппажа и проверку лимитов
----+
----+// CreateSwapInstructions создает набор инструкций для свапа
----+func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
----+	c.logger.Debug("creating swap instructions",
----+		zap.String("userWallet", params.UserWallet.String()),
----+		zap.Uint64("amountIn", params.AmountIn),
----+		zap.Uint64("minAmountOut", params.MinAmountOut),
----+	)
----+
----+	// Создаем базовый массив инструкций
----+	instructions := make([]solana.Instruction, 0)
----+
----+	// Создаем инструкцию для установки приоритета комиссии
----+	if params.PriorityFeeLamports > 0 {
----+		computeBudgetIx := solana.NewInstruction(
----+			solana.ComputeBudget,
----+			&ComputeBudgetInstruction{
----+				Units:         300000, // базовые compute units как в typescript
----+				MicroLamports: params.PriorityFeeLamports,
----+			},
----+		)
----+		instructions = append(instructions, computeBudgetIx)
----+	}
----+
----+	// Создаем основную инструкцию свапа
----+	swapIx := solana.NewInstruction(
----+		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
----+		&SwapInstruction{
----+			Amount:     params.AmountIn,
----+			MinimumOut: params.MinAmountOut,
----+		},
----+		// Добавляем необходимые аккаунты
----+		[]solana.AccountMeta{
----+			{PublicKey: params.Pool.ID, IsWritable: true, IsSigner: false},
----+			{PublicKey: params.Pool.Authority, IsWritable: false, IsSigner: false},
----+			{PublicKey: params.UserWallet, IsWritable: true, IsSigner: true},
----+			{PublicKey: params.SourceTokenAccount, IsWritable: true, IsSigner: false},
----+			{PublicKey: params.DestinationTokenAccount, IsWritable: true, IsSigner: false},
----+			{PublicKey: params.Pool.BaseVault, IsWritable: true, IsSigner: false},
----+			{PublicKey: params.Pool.QuoteVault, IsWritable: true, IsSigner: false},
----+			// Добавляем остальные необходимые аккаунты
----+		},
----+	)
----+	instructions = append(instructions, swapIx)
----+
----+	return instructions, nil
----+}
----+
----+// SimulateSwap выполняет симуляцию транзакции свапа
----+func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
----+	c.logger.Debug("simulating swap transaction")
----+
----+	// Получаем инструкции для свапа
----+	instructions, err := c.CreateSwapInstructions(params)
----+	if err != nil {
----+		return fmt.Errorf("failed to create swap instructions: %w", err)
----+	}
----+
----+	// Создаем транзакцию
----+	recent, err := c.client.GetRecentBlockhash()
----+	if err != nil {
----+		return fmt.Errorf("failed to get recent blockhash: %w", err)
----+	}
----+
----+	tx := solana.NewTransaction(
----+		instructions,
----+		recent.Value.Blockhash,
----+		solana.TransactionPayer(params.UserWallet),
----+	)
----+
----+	// Симулируем транзакцию
----+	sim, err := c.client.SimulateTransaction(tx, &rpc.SimulateTransactionOpts{
----+		SigVerify:              false,
----+		Commitment:             c.options.commitment,
----+		ReplaceRecentBlockhash: true,
----+	})
----+	if err != nil {
----+		return fmt.Errorf("failed to simulate transaction: %w", err)
----+	}
----+
----+	// Проверяем результат симуляции
----+	if sim.Value.Err != nil {
----+		return fmt.Errorf("simulation failed: %s", sim.Value.Err)
----+	}
----+
----+	// Анализируем логи симуляции
----+	for _, log := range sim.Value.Logs {
----+		c.logger.Debug("simulation log", zap.String("log", log))
----+	}
----+
----+	c.logger.Info("swap simulation successful",
----+		zap.Uint64("unitsConsumed", sim.Value.UnitsConsumed),
----+	)
----+
----+	return nil
----+}
----+
----+// TODO:
----+// Основные улучшения, которые можно добавить:
----+// Retry логика для случаев временных сбоев
----+// Более детальная валидация результатов транзакции
----+// Механизм отмены операции по таймауту
----+// Сохранение истории транзакций
----+// Метрики выполнения свапов
----+
----+// ExecuteSwap выполняет свап и возвращает signature транзакции
----+func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
----+	c.logger.Debug("executing swap",
----+		zap.String("userWallet", params.UserWallet.String()),
----+		zap.Uint64("amountIn", params.AmountIn),
----+		zap.Uint64("minAmountOut", params.MinAmountOut),
----+	)
----+
----+	// Сначала симулируем транзакцию
----+	if err := c.SimulateSwap(params); err != nil {
----+		return "", fmt.Errorf("swap simulation failed: %w", err)
----+	}
----+
----+	// Получаем инструкции для свапа
----+	instructions, err := c.CreateSwapInstructions(params)
----+	if err != nil {
----+		return "", fmt.Errorf("failed to create swap instructions: %w", err)
----+	}
----+
----+	// Получаем последний блокхэш
----+	recent, err := c.client.GetRecentBlockhash()
----+	if err != nil {
----+		return "", fmt.Errorf("failed to get recent blockhash: %w", err)
----+	}
----+
----+	// Создаем транзакцию
----+	tx := solana.NewTransaction(
----+		instructions,
----+		recent.Value.Blockhash,
----+		solana.TransactionPayer(params.UserWallet),
----+	)
----+
----+	// Подписываем транзакцию
----+	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
----+		if key.Equals(params.UserWallet) {
----+			return &c.client.PrivateKey
----+		}
----+		return nil
----+	})
----+	if err != nil {
----+		return "", fmt.Errorf("failed to sign transaction: %w", err)
----+	}
----+
----+	// Отправляем транзакцию
----+	sig, err := c.client.SendTransaction(tx, &rpc.SendTransactionOpts{
----+		SkipPreflight:       true,
----+		PreflightCommitment: c.options.commitment,
----+	})
----+	if err != nil {
----+		return "", fmt.Errorf("failed to send transaction: %w", err)
----+	}
----+
----+	// Ждем подтверждения транзакции
----+	confirmationStrategy := rpc.TransactionConfirmationStrategy{
----+		Signature:            sig,
----+		Commitment:           c.options.commitment,
----+		LastValidBlockHeight: recent.Value.LastValidBlockHeight,
----+	}
----+
----+	startTime := time.Now()
----+	confirmation, err := c.client.ConfirmTransaction(
----+		confirmationStrategy,
----+		&rpc.ConfirmTransactionOpts{
----+			MaxRetries: c.options.retries,
----+			Timeout:    c.options.timeout,
----+		},
----+	)
----+	if err != nil {
----+		return sig, fmt.Errorf("failed to confirm transaction: %w", err)
----+	}
----+
----+	// Проверяем статус подтверждения
----+	if confirmation.Value.Err != nil {
----+		return sig, fmt.Errorf("transaction confirmed with error: %v", confirmation.Value.Err)
----+	}
----+
----+	c.logger.Info("swap executed successfully",
----+		zap.String("signature", sig),
----+		zap.Duration("duration", time.Since(startTime)),
----+	)
----+
----+	// Опционально: получаем и логируем новые балансы
----+	if err := c.logUpdatedBalances(params); err != nil {
----+		c.logger.Warn("failed to get updated balances", zap.Error(err))
----+	}
----+
----+	return sig, nil
----+}
----+
----+// logUpdatedBalances вспомогательный метод для логирования балансов после свапа
----+func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
----+	// Получаем баланс SOL
----+	solBalance, err := c.client.GetBalance(
----+		params.UserWallet,
----+		rpc.CommitmentConfirmed,
----+	)
----+	if err != nil {
----+		return fmt.Errorf("failed to get SOL balance: %w", err)
----+	}
----+
----+	// Получаем баланс токена
----+	tokenBalance, err := c.client.GetTokenAccountBalance(
----+		params.DestinationTokenAccount,
----+		rpc.CommitmentConfirmed,
----+	)
----+	if err != nil {
----+		return fmt.Errorf("failed to get token balance: %w", err)
----+	}
----+
----+	c.logger.Info("updated balances",
----+		zap.Float64("solBalance", float64(solBalance.Value)/float64(solana.LAMPORTS_PER_SOL)),
----+		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
----+	)
----+
----+	return nil
----+}
----+
----+// internal/dex/raydium/pool.go - это пакет, который содержит в себе реализацию работы с пулами Raydium
----+package raydium
----+
----+import (
----+	"encoding/binary"
----+	"fmt"
----+
----+	"github.com/gagliardetto/solana-go"
----+	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
----+	"go.uber.org/zap"
----+)
----+
----+type SwapAmounts struct {
----+	AmountIn     uint64 // Количество входных токенов
----+	AmountOut    uint64 // Ожидаемое количество выходных токенов
----+	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
----+}
----+
----+type PoolManager struct {
----+	client blockchain.Client
----+	logger *zap.Logger
----+	pool   *RaydiumPool
----+}
----+
----+// NewPoolManager создает новый менеджер пула
----+func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *RaydiumPool) *PoolManager {
----+	return &PoolManager{
----+		client: client,
----+		logger: logger,
----+		pool:   pool,
----+	}
----+}
----+
----+// TODO: В дальнейшем этот код можно расширить:
----+// 1. Добавить более сложную формулу расчета с учетом комиссий
----+// 2. Реализовать кэширование состояния пула
----+// 3. Добавить больше проверок валидации
----+// 4. Улучшить обработку ошибок и логирование
----+
----+// GetPoolState получает актуальное состояние пула
----+func (pm *PoolManager) GetPoolState() (*PoolState, error) {
----+	pm.logger.Debug("getting pool state",
----+		zap.String("poolId", pm.pool.ID.String()),
----+	)
----+
----+	// Получаем данные аккаунта пула
----+	account, err := pm.client.GetAccountInfo(pm.pool.ID)
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to get pool account: %w", err)
----+	}
----+
----+	// Парсим данные в структуру состояния
----+	state := &PoolState{
----+		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // резервы base токена
----+		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // резервы quote токена
----+		Status:       account.Data[88],                                // статус пула
----+	}
----+
----+	return state, nil
----+}
----+
----+// CalculateAmounts рассчитывает количество выходных токенов и минимальный выход
----+func (pm *PoolManager) CalculateAmounts() (*SwapAmounts, error) {
----+	// Получаем текущее состояние пула
----+	state, err := pm.GetPoolState()
----+	if err != nil {
----+		return nil, fmt.Errorf("failed to get pool state: %w", err)
----+	}
----+
----+	// Проверяем, что пул активен
----+	if state.Status != 1 { // предполагаем, что 1 = активный статус
----+		return nil, fmt.Errorf("pool is not active")
----+	}
----+
----+	// Расчет по формуле: amountOut = (amountIn * outputReserve) / (inputReserve + amountIn)
----+	// Это упрощенная формула для начала
----+	amountIn := uint64(1000000) // пример входного количества
----+	amountOut := (amountIn * state.QuoteReserve) / (state.BaseReserve + amountIn)
----+
----+	// Учитываем проскальзывание (например, 1%)
----+	slippage := uint64(100) // 1%
----+	minAmountOut := amountOut - (amountOut * slippage / 10000)
----+
----+	return &SwapAmounts{
----+		AmountIn:     amountIn,
----+		AmountOut:    amountOut,
----+		MinAmountOut: minAmountOut,
----+	}, nil
----+}
----+
----+// ValidatePool проверяет валидность параметров пула
----+func (pm *PoolManager) ValidatePool() error {
----+	// Проверяем существование всех необходимых аккаунтов
----+	accounts := []solana.PublicKey{
----+		pm.pool.ID,
----+		pm.pool.Authority,
----+		pm.pool.BaseMint,
----+		pm.pool.QuoteMint,
----+		pm.pool.BaseVault,
----+		pm.pool.QuoteVault,
----+	}
----+
----+	for _, acc := range accounts {
----+		if acc.IsZero() {
----+			return fmt.Errorf("invalid pool account: %s is zero", acc.String())
----+		}
----+	}
----+
----+	// Проверяем состояние пула
----+	state, err := pm.GetPoolState()
----+	if err != nil {
----+		return fmt.Errorf("failed to get pool state: %w", err)
----+	}
----+
----+	// Проверяем резервы
----+	if state.BaseReserve == 0 || state.QuoteReserve == 0 {
----+		return fmt.Errorf("pool reserves are empty: base=%d, quote=%d",
----+			state.BaseReserve, state.QuoteReserve)
----+	}
----+
----+	// Проверяем статус
----+	if state.Status != 1 { // предполагаем, что 1 = активный статус
----+		return fmt.Errorf("pool is not active")
----+	}
----+
----+	return nil
----+}
----+
----+// internal/dex/raydium/sniper.go - это пакет, который содержит в себе реализацию снайпинга на декстере Raydium
----+package raydium
----+
----+import (
----+	"fmt"
----+	"math"
----+	"time"
----+
----+	"github.com/gagliardetto/solana-go"
----+	"github.com/gagliardetto/solana-go/rpc"
----+	"go.uber.org/zap"
----+)
----+
----+type Sniper struct {
----+	client *RaydiumClient
----+	logger *zap.Logger
----+	config *SniperConfig // Конфигурация снайпинга
----+}
----+type SniperConfig struct {
----+	// Существующие поля
----+	maxSlippageBps   uint16
----+	minAmountSOL     float64
----+	maxAmountSOL     float64
----+	priorityFee      uint64
----+	waitConfirmation bool
----+	monitorInterval  time.Duration
----+	maxRetries       int
----+
----+	// Добавляем новые необходимые поля
----+	baseMint  solana.PublicKey // Mint address базового токена
----+	quoteMint solana.PublicKey // Mint address котируемого токена
----+}
----+
----+// TODO: можно добавить:
----+
----+// 1. Проверку цены перед свапом
----+// 2. Мониторинг состояния пула в реальном времени
----+// 3. Более сложную логику расчета суммы свапа
----+// 4. Обработку различных ошибок и ретраи
----+// 5. Асинхронное выполнение свапа
----+
----+func (s *Sniper) ExecuteSnipe() error {
----+	s.logger.Debug("starting snipe execution")
----+
----+	// 1. Получение пула и валидация параметров
----+	if err := s.ValidateAndPrepare(); err != nil {
----+		return fmt.Errorf("failed to validate parameters: %w", err)
----+	}
----+
----+	// 2. Получение информации о пуле и проверка его состояния
----+	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
----+	if err != nil {
----+		return fmt.Errorf("failed to get pool: %w", err)
----+	}
----+
----+	poolManager := NewPoolManager(s.client.client, s.logger, pool)
----+	if err := poolManager.ValidatePool(); err != nil {
----+		return fmt.Errorf("pool validation failed: %w", err)
----+	}
----+
----+	// 3. Расчет параметров свапа
----+	amounts, err := poolManager.CalculateAmounts()
----+	if err != nil {
----+		return fmt.Errorf("failed to calculate swap amounts: %w", err)
----+	}
----+
----+	// 4. Подготовка параметров для свапа
----+	swapParams := &SwapParams{
----+		UserWallet:          s.client.client.PrivateKey.PublicKey(),
----+		AmountIn:            amounts.AmountIn,
----+		MinAmountOut:        amounts.MinAmountOut,
----+		Pool:                pool,
----+		PriorityFeeLamports: s.config.priorityFee,
----+		// Здесь нужно добавить source и destination token accounts,
----+		// которые должны быть получены или созданы заранее
----+	}
----+
----+	// 5. Выполнение свапа
----+	signature, err := s.client.ExecuteSwap(swapParams)
----+	if err != nil {
----+		return fmt.Errorf("swap execution failed: %w", err)
----+	}
----+
----+	// Логируем успешное выполнение
----+	s.logger.Info("snipe executed successfully",
----+		zap.String("signature", signature),
----+		zap.Uint64("amountIn", amounts.AmountIn),
----+		zap.Uint64("amountOut", amounts.AmountOut),
----+		zap.Uint64("minAmountOut", amounts.MinAmountOut),
----+	)
----+
----+	return nil
----+}
----+
----+// TODO: Потенциальные улучшения на основе TS версии:
----+// 1. Добавить проверку и создание associated token accounts
----+// 2. Добавить проверку балансов SOL и токенов
----+// 3. Добавить валидацию параметров compute budget
----+// 4. Добавить проверку версии пула (V4)
----+// 5. Добавить расчет приоритетной комиссии на основе последних блоков
----+// 6. Добавить проверку и обработку wrapped SOL
----+func (s *Sniper) ValidateAndPrepare() error {
----+	s.logger.Debug("validating and preparing snipe parameters")
----+
----+	// Проверяем базовые параметры конфигурации
----+	if s.config.maxSlippageBps == 0 || s.config.maxSlippageBps > 10000 { // 10000 = 100%
----+		return fmt.Errorf("invalid slippage: must be between 0 and 10000")
----+	}
----+
----+	if s.config.minAmountSOL <= 0 || s.config.maxAmountSOL <= 0 {
----+		return fmt.Errorf("invalid amount parameters")
----+	}
----+
----+	if s.config.maxAmountSOL < s.config.minAmountSOL {
----+		return fmt.Errorf("maxAmount cannot be less than minAmount")
----+	}
----+
----+	// Проверяем mint addresses
----+	if s.config.baseMint.IsZero() || s.config.quoteMint.IsZero() {
----+		return fmt.Errorf("invalid mint addresses")
----+	}
----+
----+	// Проверяем наличие достаточного баланса
----+	balance, err := s.client.client.GetBalance(
----+		s.client.client.PrivateKey.PublicKey(),
----+		rpc.CommitmentConfirmed,
----+	)
----+	if err != nil {
----+		return fmt.Errorf("failed to get wallet balance: %w", err)
----+	}
----+
----+	if float64(balance.Value)/float64(solana.LAMPORTS_PER_SOL) < s.config.minAmountSOL {
----+		return fmt.Errorf("insufficient balance")
----+	}
----+
----+	// Проверяем параметры мониторинга
----+	if s.config.monitorInterval < time.Second {
----+		return fmt.Errorf("monitor interval too small")
----+	}
----+
----+	if s.config.maxRetries < 1 {
----+		return fmt.Errorf("invalid max retries value")
----+	}
----+
----+	return nil
----+}
----+
----+// TODO: Потенциальные улучшения на основе TS версии:
----+// 1. Добавить отслеживание изменений цены
----+// 2. Добавить отслеживание объема ликвидности
----+// 3. Добавить механизм подписки на события пула
----+// 4. Добавить отслеживание транзакций в мемпуле
----+// 5. Добавить механизм websocket подключения
----+// 6. Добавить механизм агрегации данных по нескольким RPC
----+func (s *Sniper) MonitorPoolChanges() error {
----+	s.logger.Debug("starting pool monitoring")
----+
----+	ticker := time.NewTicker(s.config.monitorInterval)
----+	defer ticker.Stop()
----+
----+	// Получаем начальное состояние пула
----+	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
----+	if err != nil {
----+		return fmt.Errorf("failed to get initial pool state: %w", err)
----+	}
----+
----+	poolManager := NewPoolManager(s.client.client, s.logger, pool)
----+	initialState, err := poolManager.GetPoolState()
----+	if err != nil {
----+		return fmt.Errorf("failed to get initial pool state: %w", err)
----+	}
----+
----+	var retryCount int
----+	for {
----+		select {
----+		case <-ticker.C:
----+			// Получаем текущее состояние пула
----+			currentState, err := poolManager.GetPoolState()
----+			if err != nil {
----+				retryCount++
----+				s.logger.Error("failed to get current pool state",
----+					zap.Error(err),
----+					zap.Int("retry", retryCount),
----+				)
----+				if retryCount >= s.config.maxRetries {
----+					return fmt.Errorf("max retries exceeded while monitoring pool")
----+				}
----+				continue
----+			}
----+			retryCount = 0
----+
----+			// Проверяем изменения в пуле
----+			if s.hasSignificantChanges(initialState, currentState) {
----+				s.logger.Info("detected significant pool changes",
----+					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
----+					zap.Uint64("newBaseReserve", currentState.BaseReserve),
----+					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
----+					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
----+				)
----+
----+				// Если пул неактивен, прекращаем мониторинг
----+				if currentState.Status != 1 {
----+					return fmt.Errorf("pool became inactive")
----+				}
----+
----+				// Обновляем начальное состояние
----+				initialState = currentState
----+			}
----+		}
----+	}
----+}
----+
----+// Вспомогательный метод для определения значительных изменений в пуле
----+func (s *Sniper) hasSignificantChanges(old, new *PoolState) bool {
----+	// Рассчитываем процент изменения для базового резерва
----+	baseChange := math.Abs(float64(new.BaseReserve)-float64(old.BaseReserve)) / float64(old.BaseReserve)
----+
----+	// Рассчитываем процент изменения для котируемого резерва
----+	quoteChange := math.Abs(float64(new.QuoteReserve)-float64(old.QuoteReserve)) / float64(old.QuoteReserve)
----+
----+	// Определяем порог значительных изменений (например, 1%)
----+	threshold := 0.01
----+
----+	return baseChange > threshold || quoteChange > threshold || new.Status != old.Status
----+}
----+
----+// inernal/dex/raydium/types.go - это пакет, который содержит в себе реализацию работы с декстерами Raydium
----+package raydium
----+
----+import "github.com/gagliardetto/solana-go"
----+
----+type RaydiumPool struct {
----+	ID            solana.PublicKey // Идентификатор пула
----+	Authority     solana.PublicKey // Публичный ключ, который имеет полномочия управлять пулом
----+	BaseMint      solana.PublicKey // Публичный ключ базового токена
----+	QuoteMint     solana.PublicKey // Публичный ключ котируемого токена
----+	BaseVault     solana.PublicKey // Публичный ключ хранилища базового токена
----+	QuoteVault    solana.PublicKey // Публичный ключ хранилища котируемого токена
----+	BaseDecimals  uint8            // Количество десятичных знаков базового токена
----+	QuoteDecimals uint8            // Количество десятичных знаков котируемого токена
----+	DefaultFeeBps uint16           // Комиссия по умолчанию в базисных пунктах (bps)
----+	// Только необходимые поля для V4
----+}
----+
----+type PoolState struct {
----+	BaseReserve  uint64 // Резерв базового токена в пуле
----+	QuoteReserve uint64 // Резерв котируемого токена в пуле
----+	Status       uint8  // Статус пула (например, активен или неактивен)
----+}
----+
----+type SwapParams struct {
----+	UserWallet              solana.PublicKey // Публичный ключ кошелька пользователя
----+	AmountIn                uint64           // Количество входного токена для обмена
----+	MinAmountOut            uint64           // Минимальное количество выходного токена, которое пользователь готов принять
----+	Pool                    *RaydiumPool     // Указатель на пул, в котором происходит обмен
----+	SourceTokenAccount      solana.PublicKey // Публичный ключ аккаунта исходного токена
----+	DestinationTokenAccount solana.PublicKey // Публичный ключ аккаунта целевого токена
----+	PriorityFeeLamports     uint64           // Приоритетная комиссия в лампортах
----+}
----+
----+// Основные ошибки
----+type SwapError struct {
----+	Stage   string // Этап, на котором произошла ошибка
----+	Message string // Сообщение об ошибке
----+	Err     error  // Вложенная ошибка
----+}
----diff --git a/internal/dex/raydium/sniper.go b/internal/dex/raydium/sniper.go
----new file mode 100644
----index 0000000..c9a6c55
------- /dev/null
----+++ b/internal/dex/raydium/sniper.go
----@@ -0,0 +1,225 @@
----+// internal/dex/raydium/sniper.go - это пакет, который содержит в себе реализацию снайпинга на декстере Raydium
----+package raydium
----+
----+import (
----+	"fmt"
----+	"math"
----+	"time"
----+
----+	"github.com/gagliardetto/solana-go"
----+	"github.com/gagliardetto/solana-go/rpc"
----+	"go.uber.org/zap"
----+)
----+
----+type Sniper struct {
----+	client *RaydiumClient
----+	logger *zap.Logger
----+	config *SniperConfig // Конфигурация снайпинга
----+}
----+type SniperConfig struct {
----+	// Существующие поля
----+	maxSlippageBps   uint16
----+	minAmountSOL     float64
----+	maxAmountSOL     float64
----+	priorityFee      uint64
----+	waitConfirmation bool
----+	monitorInterval  time.Duration
----+	maxRetries       int
----+
----+	// Добавляем новые необходимые поля
----+	baseMint  solana.PublicKey // Mint address базового токена
----+	quoteMint solana.PublicKey // Mint address котируемого токена
----+}
----+
----+// TODO: можно добавить:
----+
----+// 1. Проверку цены перед свапом
----+// 2. Мониторинг состояния пула в реальном времени
----+// 3. Более сложную логику расчета суммы свапа
----+// 4. Обработку различных ошибок и ретраи
----+// 5. Асинхронное выполнение свапа
----+
----+func (s *Sniper) ExecuteSnipe() error {
----+	s.logger.Debug("starting snipe execution")
----+
----+	// 1. Получение пула и валидация параметров
----+	if err := s.ValidateAndPrepare(); err != nil {
----+		return fmt.Errorf("failed to validate parameters: %w", err)
----+	}
----+
----+	// 2. Получение информации о пуле и проверка его состояния
----+	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
----+	if err != nil {
----+		return fmt.Errorf("failed to get pool: %w", err)
----+	}
----+
----+	poolManager := NewPoolManager(s.client.client, s.logger, pool)
----+	if err := poolManager.ValidatePool(); err != nil {
----+		return fmt.Errorf("pool validation failed: %w", err)
----+	}
----+
----+	// 3. Расчет параметров свапа
----+	amounts, err := poolManager.CalculateAmounts()
----+	if err != nil {
----+		return fmt.Errorf("failed to calculate swap amounts: %w", err)
----+	}
----+
----+	// 4. Подготовка параметров для свапа
----+	swapParams := &SwapParams{
----+		UserWallet:          s.client.client.PrivateKey.PublicKey(),
----+		AmountIn:            amounts.AmountIn,
----+		MinAmountOut:        amounts.MinAmountOut,
----+		Pool:                pool,
----+		PriorityFeeLamports: s.config.priorityFee,
----+		// Здесь нужно добавить source и destination token accounts,
----+		// которые должны быть получены или созданы заранее
----+	}
----+
----+	// 5. Выполнение свапа
----+	signature, err := s.client.ExecuteSwap(swapParams)
----+	if err != nil {
----+		return fmt.Errorf("swap execution failed: %w", err)
----+	}
----+
----+	// Логируем успешное выполнение
----+	s.logger.Info("snipe executed successfully",
----+		zap.String("signature", signature),
----+		zap.Uint64("amountIn", amounts.AmountIn),
----+		zap.Uint64("amountOut", amounts.AmountOut),
----+		zap.Uint64("minAmountOut", amounts.MinAmountOut),
----+	)
----+
----+	return nil
----+}
----+
----+// TODO: Потенциальные улучшения на основе TS версии:
----+// 1. Добавить проверку и создание associated token accounts
----+// 2. Добавить проверку балансов SOL и токенов
----+// 3. Добавить валидацию параметров compute budget
----+// 4. Добавить проверку версии пула (V4)
----+// 5. Добавить расчет приоритетной комиссии на основе последних блоков
----+// 6. Добавить проверку и обработку wrapped SOL
----+func (s *Sniper) ValidateAndPrepare() error {
----+	s.logger.Debug("validating and preparing snipe parameters")
----+
----+	// Проверяем базовые параметры конфигурации
----+	if s.config.maxSlippageBps == 0 || s.config.maxSlippageBps > 10000 { // 10000 = 100%
----+		return fmt.Errorf("invalid slippage: must be between 0 and 10000")
----+	}
----+
----+	if s.config.minAmountSOL <= 0 || s.config.maxAmountSOL <= 0 {
----+		return fmt.Errorf("invalid amount parameters")
----+	}
----+
----+	if s.config.maxAmountSOL < s.config.minAmountSOL {
----+		return fmt.Errorf("maxAmount cannot be less than minAmount")
----+	}
----+
----+	// Проверяем mint addresses
----+	if s.config.baseMint.IsZero() || s.config.quoteMint.IsZero() {
----+		return fmt.Errorf("invalid mint addresses")
----+	}
----+
----+	// Проверяем наличие достаточного баланса
----+	balance, err := s.client.client.GetBalance(
----+		s.client.client.PrivateKey.PublicKey(),
----+		rpc.CommitmentConfirmed,
----+	)
----+	if err != nil {
----+		return fmt.Errorf("failed to get wallet balance: %w", err)
----+	}
----+
----+	if float64(balance.Value)/float64(solana.LAMPORTS_PER_SOL) < s.config.minAmountSOL {
----+		return fmt.Errorf("insufficient balance")
----+	}
----+
----+	// Проверяем параметры мониторинга
----+	if s.config.monitorInterval < time.Second {
----+		return fmt.Errorf("monitor interval too small")
----+	}
----+
----+	if s.config.maxRetries < 1 {
----+		return fmt.Errorf("invalid max retries value")
----+	}
----+
----+	return nil
----+}
----+
----+// TODO: Потенциальные улучшения на основе TS версии:
----+// 1. Добавить отслеживание изменений цены
----+// 2. Добавить отслеживание объема ликвидности
----+// 3. Добавить механизм подписки на события пула
----+// 4. Добавить отслеживание транзакций в мемпуле
----+// 5. Добавить механизм websocket подключения
----+// 6. Добавить механизм агрегации данных по нескольким RPC
----+func (s *Sniper) MonitorPoolChanges() error {
----+	s.logger.Debug("starting pool monitoring")
----+
----+	ticker := time.NewTicker(s.config.monitorInterval)
----+	defer ticker.Stop()
----+
----+	// Получаем начальное состояние пула
----+	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
----+	if err != nil {
----+		return fmt.Errorf("failed to get initial pool state: %w", err)
----+	}
----+
----+	poolManager := NewPoolManager(s.client.client, s.logger, pool)
----+	initialState, err := poolManager.GetPoolState()
----+	if err != nil {
----+		return fmt.Errorf("failed to get initial pool state: %w", err)
----+	}
----+
----+	var retryCount int
----+	for {
----+		select {
----+		case <-ticker.C:
----+			// Получаем текущее состояние пула
----+			currentState, err := poolManager.GetPoolState()
----+			if err != nil {
----+				retryCount++
----+				s.logger.Error("failed to get current pool state",
----+					zap.Error(err),
----+					zap.Int("retry", retryCount),
----+				)
----+				if retryCount >= s.config.maxRetries {
----+					return fmt.Errorf("max retries exceeded while monitoring pool")
----+				}
----+				continue
----+			}
----+			retryCount = 0
----+
----+			// Проверяем изменения в пуле
----+			if s.hasSignificantChanges(initialState, currentState) {
----+				s.logger.Info("detected significant pool changes",
----+					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
----+					zap.Uint64("newBaseReserve", currentState.BaseReserve),
----+					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
----+					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
----+				)
----+
----+				// Если пул неактивен, прекращаем мониторинг
----+				if currentState.Status != 1 {
----+					return fmt.Errorf("pool became inactive")
----+				}
----+
----+				// Обновляем начальное состояние
----+				initialState = currentState
----+			}
----+		}
----+	}
----+}
----+
----+// Вспомогательный метод для определения значительных изменений в пуле
----+func (s *Sniper) hasSignificantChanges(old, new *PoolState) bool {
----+	// Рассчитываем процент изменения для базового резерва
----+	baseChange := math.Abs(float64(new.BaseReserve)-float64(old.BaseReserve)) / float64(old.BaseReserve)
----+
----+	// Рассчитываем процент изменения для котируемого резерва
----+	quoteChange := math.Abs(float64(new.QuoteReserve)-float64(old.QuoteReserve)) / float64(old.QuoteReserve)
----+
----+	// Определяем порог значительных изменений (например, 1%)
----+	threshold := 0.01
----+
----+	return baseChange > threshold || quoteChange > threshold || new.Status != old.Status
----+}
+--- type SwapParams struct {
+----	UserWallet              solana.PublicKey // Публичный ключ кошелька пользователя
+----	AmountIn                uint64           // Количество входного токена для обмена
+----	MinAmountOut            uint64           // Минимальное количество выходного токена, которое пользователь готов принять
+----	Pool                    *RaydiumPool     // Указатель на пул, в котором происходит обмен
+----	SourceTokenAccount      solana.PublicKey // Публичный ключ аккаунта исходного токена
+----	DestinationTokenAccount solana.PublicKey // Публичный ключ аккаунта целевого токена
+----	PriorityFeeLamports     uint64           // Приоритетная комиссия в лампортах
+---+	UserWallet              solana.PublicKey   // Публичный ключ кошелька пользователя
+---+	PrivateKey              *solana.PrivateKey // Приватный ключ для подписания транзакции
+---+	AmountIn                uint64             // Количество входного токена для обмена
+---+	MinAmountOut            uint64             // Минимальное количество выходного токена
+---+	Pool                    *RaydiumPool       // Указатель на пул для обмена
+---+	SourceTokenAccount      solana.PublicKey   // Аккаунт исходного токена
+---+	DestinationTokenAccount solana.PublicKey   // Аккаунт целевого токена
+---+	PriorityFeeLamports     uint64             // Приоритетная комиссия в лампортах
+--- }
+--- 
+--- // Основные ошибки
 ---diff --git a/newdif.txt b/newdif.txt
----index 59e3e66..e69de29 100644
+---index 4e87d10..babe755 100644
 ------ a/newdif.txt
 ---+++ b/newdif.txt
----@@ -1,6780 +0,0 @@
-----diff --git a/internal/blockchain/solbc/solana.go b/internal/blockchain/solbc/solana.go
-----index dec574a..cfede3e 100644
-------- a/internal/blockchain/solbc/solana.go
-----+++ b/internal/blockchain/solbc/solana.go
-----@@ -5,9 +5,6 @@ import (
+---@@ -1,9023 +0,0 @@
+----diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
+----index b28a72a..e059ba7 100644
+------- a/internal/blockchain/solbc/client.go
+----+++ b/internal/blockchain/solbc/client.go
+----@@ -4,6 +4,7 @@ package solbc
+---- import (
 ---- 	"context"
 ---- 	"fmt"
+----+	"time"
 ---- 
------	solanarpc "github.com/gagliardetto/solana-go/rpc"
------	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
------
 ---- 	"github.com/gagliardetto/solana-go"
----- 	"go.uber.org/zap"
----- )
-----@@ -63,19 +60,3 @@ func (c *Client) SimulateTransaction(tx string) (string, error) {
----- 	// Implement the method logic here
----- 	return "", nil
+---- 	solanarpc "github.com/gagliardetto/solana-go/rpc"
+----@@ -49,7 +50,6 @@ func (c *Client) GetRecentBlockhash(ctx context.Context) (solana.Hash, error) {
+---- 	return result.Value.Blockhash, nil
+---- }
+---- 
+-----// SendTransaction отправляет транзакцию
+---- // SendTransaction отправляет транзакцию с улучшенной обработкой ошибок
+---- func (c *Client) SendTransaction(ctx context.Context, tx *solana.Transaction) (solana.Signature, error) {
+---- 	signature, err := c.rpc.SendTransaction(ctx, tx)
+----@@ -80,3 +80,78 @@ func (c *Client) Close() error {
+---- func (c *Client) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
+---- 	return c.rpc.GetSignatureStatuses(ctx, signatures...)
+---- }
+----+
+----+// GetProgramAccounts получает аккаунты программы по заданным фильтрам
+----+func (c *Client) GetProgramAccounts(
+----+	ctx context.Context,
+----+	program solana.PublicKey,
+----+	opts solanarpc.GetProgramAccountsOpts,
+----+) ([]solanarpc.KeyedAccount, error) {
+----+	c.logger.Debug("getting program accounts",
+----+		zap.String("program", program.String()),
+----+	)
+----+
+----+	accounts, err := c.rpc.GetProgramAccounts(ctx, program, opts)
+----+	if err != nil {
+----+		c.metrics.IncrementFailedRequests()
+----+		c.metrics.LastError = err
+----+		c.metrics.LastErrorTime = time.Now()
+----+		return nil, fmt.Errorf("failed to get program accounts: %w", err)
+----+	}
+----+
+----+	c.metrics.IncrementProgramAccountRequests()
+----+	return accounts, nil
+----+}
+----+
+----+// GetTokenAccountBalance получает баланс токен-аккаунта
+----+func (c *Client) GetTokenAccountBalance(
+----+	ctx context.Context,
+----+	account solana.PublicKey,
+----+	commitment solanarpc.CommitmentType,
+----+) (*solanarpc.GetTokenAccountBalanceResult, error) {
+----+	c.logger.Debug("getting token account balance",
+----+		zap.String("account", account.String()),
+----+		zap.String("commitment", string(commitment)),
+----+	)
+----+
+----+	result, err := c.rpc.GetTokenAccountBalance(ctx, account, commitment)
+----+	if err != nil {
+----+		c.metrics.FailedRequests++
+----+		c.metrics.LastError = err
+----+		c.metrics.LastErrorTime = time.Now()
+----+		return nil, fmt.Errorf("failed to get token account balance: %w", err)
+----+	}
+----+
+----+	return result, nil
+----+}
+----+
+----+// SimulateTransaction симулирует выполнение транзакции
+----+func (c *Client) SimulateTransaction(
+----+	ctx context.Context,
+----+	tx *solana.Transaction,
+----+) (*blockchain.SimulationResult, error) {
+----+	c.logger.Debug("simulating transaction")
+----+
+----+	result, err := c.rpc.SimulateTransaction(ctx, tx)
+----+	if err != nil {
+----+		c.metrics.FailedRequests++
+----+		c.metrics.LastError = err
+----+		c.metrics.LastErrorTime = time.Now()
+----+		return nil, fmt.Errorf("failed to simulate transaction: %w", err)
+----+	}
+----+
+----+	// Обработаем возможный nil в UnitsConsumed
+----+	var unitsConsumed uint64
+----+	if result.Value.UnitsConsumed != nil {
+----+		unitsConsumed = *result.Value.UnitsConsumed
+----+	}
+----+
+----+	// Преобразуем результат в нужный формат
+----+	simulationResult := &blockchain.SimulationResult{
+----+		Err:           result.Value.Err,
+----+		Logs:          result.Value.Logs,
+----+		UnitsConsumed: unitsConsumed,
+----+	}
+----+
+----+	return simulationResult, nil
+----+}
+----diff --git a/internal/blockchain/solbc/rpc/rpc.go b/internal/blockchain/solbc/rpc/rpc.go
+----index 71fbdc2..1b027e2 100644
+------- a/internal/blockchain/solbc/rpc/rpc.go
+----+++ b/internal/blockchain/solbc/rpc/rpc.go
+----@@ -184,3 +184,86 @@ func (c *RPCClient) GetSignatureStatuses(ctx context.Context, signatures ...sola
+---- 
+---- // Close закрывает клиент
+---- func (c *RPCClient) Close() {}
+----+
+----+// GetProgramAccounts получает все аккаунты для заданной программы
+----+func (c *RPCClient) GetProgramAccounts(
+----+	ctx context.Context,
+----+	program solana.PublicKey,
+----+	opts solanarpc.GetProgramAccountsOpts,
+----+) ([]solanarpc.KeyedAccount, error) {
+----+	var accounts []solanarpc.KeyedAccount
+----+
+----+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
+----+		result, err := client.GetProgramAccountsWithOpts(
+----+			ctx,
+----+			program,
+----+			&opts,
+----+		)
+----+		if err != nil {
+----+			return err
+----+		}
+----+
+----+		// Преобразуем []*KeyedAccount в []KeyedAccount
+----+		accounts = make([]solanarpc.KeyedAccount, len(result))
+----+		for i, acc := range result {
+----+			accounts[i] = *acc
+----+		}
+----+
+----+		return nil
+----+	})
+----+
+----+	if err != nil {
+----+		return nil, fmt.Errorf("failed to get program accounts: %w", err)
+----+	}
+----+
+----+	return accounts, nil
+----+}
+----+
+----+// GetTokenAccountBalance получает баланс токен-аккаунта
+----+func (c *RPCClient) GetTokenAccountBalance(
+----+	ctx context.Context,
+----+	account solana.PublicKey,
+----+	commitment solanarpc.CommitmentType,
+----+) (*solanarpc.GetTokenAccountBalanceResult, error) {
+----+	var result *solanarpc.GetTokenAccountBalanceResult
+----+
+----+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
+----+		var err error
+----+		result, err = client.GetTokenAccountBalance(
+----+			ctx,
+----+			account,
+----+			commitment,
+----+		)
+----+		return err
+----+	})
+----+
+----+	if err != nil {
+----+		return nil, fmt.Errorf("failed to get token account balance: %w", err)
+----+	}
+----+
+----+	return result, nil
+----+}
+----+
+----+// SimulateTransaction симулирует выполнение транзакции
+----+func (c *RPCClient) SimulateTransaction(
+----+	ctx context.Context,
+----+	tx *solana.Transaction,
+----+) (*solanarpc.SimulateTransactionResponse, error) {
+----+	var result *solanarpc.SimulateTransactionResponse
+----+
+----+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
+----+		var err error
+----+		result, err = client.SimulateTransactionWithOpts(ctx, tx, &solanarpc.SimulateTransactionOpts{
+----+			SigVerify:              false,
+----+			Commitment:             solanarpc.CommitmentConfirmed,
+----+			ReplaceRecentBlockhash: false,
+----+		})
+----+		return err
+----+	})
+----+
+----+	if err != nil {
+----+		return nil, fmt.Errorf("failed to simulate transaction: %w", err)
+----+	}
+----+
+----+	return result, nil
+----+}
+----diff --git a/internal/blockchain/solbc/solana.go b/internal/blockchain/solbc/solana.go
+----index cfede3e..b24546f 100644
+------- a/internal/blockchain/solbc/solana.go
+----+++ b/internal/blockchain/solbc/solana.go
+----@@ -54,9 +54,3 @@ func (s *Blockchain) GetRecentBlockhash(ctx context.Context) (solana.Hash, error
+---- 	}
+---- 	return hash, nil
 ---- }
 -----
------func (c *Client) GetRpcClient() *solanarpc.Client {
------	if c.adapter == nil {
------		c.adapter = NewRpcAdapter(c.rpc)
------	}
------	return c.adapter
+-----// SimulateTransaction simulates a transaction on the Solana blockchain
+-----func (c *Client) SimulateTransaction(tx string) (string, error) {
+-----	// Implement the method logic here
+-----	return "", nil
+-----}
+----diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
+----index b3e342d..4d9d608 100644
+------- a/internal/blockchain/solbc/types.go
+----+++ b/internal/blockchain/solbc/types.go
+----@@ -3,6 +3,7 @@ package solbc
+---- 
+---- import (
+---- 	"sync"
+----+	"sync/atomic"
+---- 	"time"
+---- 
+---- 	"go.uber.org/zap"
+----@@ -27,11 +28,22 @@ type Client struct {
+---- }
+---- 
+---- type ClientMetrics struct {
+-----	AccountInfoRequests uint64
+-----	TransactionRequests uint64
+-----	FailedRequests      uint64
+-----	LastError           error
+-----	LastErrorTime       time.Time
+----+	AccountInfoRequests    uint64
+----+	TransactionRequests    uint64
+----+	FailedRequests         uint64
+----+	ProgramAccountRequests uint64 // Добавляем новое поле
+----+	LastError              error
+----+	LastErrorTime          time.Time
+----+}
+----+
+----+// IncrementProgramAccountRequests атомарно увеличивает счетчик запросов
+----+func (m *ClientMetrics) IncrementProgramAccountRequests() {
+----+	atomic.AddUint64(&m.ProgramAccountRequests, 1)
+----+}
+----+
+----+// IncrementFailedRequests атомарно увеличивает счетчик ошибок
+----+func (m *ClientMetrics) IncrementFailedRequests() {
+----+	atomic.AddUint64(&m.FailedRequests, 1)
+---- }
+---- 
+---- // Проверяем, что Client реализует blockchain.Client интерфейс
+----diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
+----index 81e8fb2..b702a54 100644
+------- a/internal/blockchain/types.go
+----+++ b/internal/blockchain/types.go
+----@@ -3,7 +3,6 @@ package blockchain
+---- 
+---- import (
+---- 	"context"
+-----	"encoding/base64"
+---- 
+---- 	"github.com/gagliardetto/solana-go"
+---- 	"github.com/gagliardetto/solana-go/rpc"
+----@@ -21,22 +20,6 @@ type SimulationResult struct {
+---- 	Err           interface{}
+---- 	Logs          []string
+---- 	UnitsConsumed uint64
+-----	ReturnData    *Base64Data
 -----}
 -----
------// RpcAdapter адаптирует наш RPCClient к интерфейсу solana-go/rpc.Client
------type RpcAdapter struct {
------	client *rpc.RPCClient
+-----// Base64Data представляет данные в формате Base64
+-----type Base64Data struct {
+-----	Data string
 -----}
 -----
------func NewRpcAdapter(client *rpc.RPCClient) *solanarpc.Client {
------	return solanarpc.New("") // Создаем пустой клиент
+-----// EncodeBase64 кодирует данные в Base64
+-----func (b *Base64Data) EncodeBase64(data []byte) {
+-----	b.Data = base64.StdEncoding.EncodeToString(data)
 -----}
-----diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
-----index 0355dc0..81e8fb2 100644
-------- a/internal/blockchain/types.go
-----+++ b/internal/blockchain/types.go
-----@@ -47,6 +47,5 @@ type Client interface {
----- 	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
+-----
+-----// DecodeBase64 декодирует данные из Base64
+-----func (b *Base64Data) DecodeBase64() ([]byte, error) {
+-----	return base64.StdEncoding.DecodeString(b.Data)
+---- }
+---- 
+---- // Client определяет общий интерфейс для клиентов блокчейна
+----@@ -48,4 +31,7 @@ type Client interface {
 ---- 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
 ---- 	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
------	GetRpcClient() *rpc.Client
 ---- 	GetTokenAccountBalance(ctx context.Context, account solana.PublicKey, commitment rpc.CommitmentType) (*rpc.GetTokenAccountBalanceResult, error)
+----+
+----+	// Добавляем новый метод для получения программных аккаунтов
+----+	GetProgramAccounts(ctx context.Context, program solana.PublicKey, opts rpc.GetProgramAccountsOpts) ([]rpc.KeyedAccount, error)
 ---- }
 ----diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
-----index 234fc23..342586c 100644
+----index 342586c..14041b4 100644
 ------- a/internal/dex/raydium/client.go
 ----+++ b/internal/dex/raydium/client.go
-----@@ -2,6 +2,8 @@
+----@@ -2,18 +2,24 @@
 ---- package raydium
 ---- 
 ---- import (
-----+	"encoding/binary"
-----+	"fmt"
+----+	"context"
+---- 	"encoding/binary"
+----+	"errors"
+---- 	"fmt"
 ---- 	"time"
 ---- 
+----+	bin "github.com/gagliardetto/binary"
 ---- 	"github.com/gagliardetto/solana-go"
-----@@ -10,6 +12,10 @@ import (
+----+	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
+---- 	"github.com/gagliardetto/solana-go/rpc"
+---- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+----+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
 ---- 	"go.uber.org/zap"
 ---- )
 ---- 
-----+const (
-----+	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
-----+)
-----+
+---- const (
+-----	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
+----+	RAYDIUM_V4_PROGRAM_ID  = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
+----+	MAX_COMPUTE_UNIT_LIMIT = 300000 // Из compute-budget/SetComputeUnitLimit.go
+---- )
+---- 
 ---- type RaydiumClient struct {
----- 	client  blockchain.Client
----- 	logger  *zap.Logger
-----@@ -22,26 +28,338 @@ type clientOptions struct {
----- 	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
+----@@ -35,56 +41,62 @@ type ComputeBudgetInstruction struct {
 ---- }
 ---- 
------func NewRaydiumClient() *RaydiumClient {
-----+// Вспомогательные структуры для инструкций
-----+type ComputeBudgetInstruction struct {
-----+	Units         uint32
-----+	MicroLamports uint64
-----+}
+---- type SwapInstruction struct {
+-----	Amount     uint64
+-----	MinimumOut uint64
+----+	Amount     *uint64
+----+	MinimumOut *uint64
 ----+
-----+type SwapInstruction struct {
-----+	Amount     uint64
-----+	MinimumOut uint64
+----+	// Slice для хранения аккаунтов, следуя паттерну из SDK
+----+	solana.AccountMetaSlice `bin:"-" borsh_skip:"true"`
+---- }
+---- 
+---- // NewRaydiumClient создает новый экземпляр клиента Raydium
+-----func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) *RaydiumClient {
+-----	// Инициализация с базовыми настройками
+----+func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) (*RaydiumClient, error) {
+----+	logger = logger.Named("raydium-client")
+----+
+----+	// Создаем базового клиента через фабрику
+----+	solClient, err := solbc.NewClient([]string{rpcEndpoint}, logger)
+----+	if err != nil {
+----+		return nil, fmt.Errorf("failed to create solana client: %w", err)
+----+	}
+---- 
+---- 	opts := &clientOptions{
+---- 		timeout:     30 * time.Second,
+---- 		retries:     3,
+-----		priorityFee: 1000, // базовое значение в лампортах
+----+		priorityFee: 1000,
+---- 		commitment:  rpc.CommitmentConfirmed,
+---- 	}
+---- 
+-----	client := blockchain.NewSolanaClient(rpcEndpoint, wallet)
+-----
+---- 	return &RaydiumClient{
+-----		client:  client,
+----+		client:  solClient,
+---- 		logger:  logger,
+---- 		options: opts,
+-----	}
+----+	}, nil
+---- }
+---- 
+---- // GetPool получает информацию о пуле по базовому и котируемому токенам
+-----func (c *RaydiumClient) GetPool(baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
+-----	// Получение информации о пуле
+-----
+----+func (c *RaydiumClient) GetPool(ctx context.Context, baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
+---- 	c.logger.Debug("getting raydium pool info",
+---- 		zap.String("baseMint", baseMint.String()),
+---- 		zap.String("quoteMint", quoteMint.String()),
+---- 	)
+---- 
+-----	// Получаем программные аккаунты по фильтрам
+----+	// Получаем программные аккаунты через интерфейс
+---- 	accounts, err := c.client.GetProgramAccounts(
+----+		ctx,
+---- 		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+---- 		rpc.GetProgramAccountsOpts{
+---- 			Filters: []rpc.RPCFilter{
+---- 				{
+-----					DataSize: 388, // размер аккаунта пула v4
+----+					DataSize: 388,
+---- 				},
+---- 				{
+---- 					Memcmp: &rpc.RPCFilterMemcmp{
+-----						Offset: 8, // смещение для baseMint
+----+						Offset: 8,
+---- 						Bytes:  baseMint.Bytes(),
+---- 					},
+---- 				},
+---- 				{
+---- 					Memcmp: &rpc.RPCFilterMemcmp{
+-----						Offset: 40, // смещение для quoteMint
+----+						Offset: 40,
+---- 						Bytes:  quoteMint.Bytes(),
+---- 					},
+---- 				},
+----@@ -120,16 +132,16 @@ func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
+---- 	)
+---- 
+---- 	// Получаем данные аккаунта пула
+-----	account, err := c.client.GetAccountInfo(pool.ID)
+----+	account, err := c.client.GetAccountInfo(context.Background(), pool.ID)
+---- 	if err != nil {
+---- 		return nil, fmt.Errorf("failed to get pool account: %w", err)
+---- 	}
+---- 
+---- 	// Парсим данные в структуру состояния
+---- 	state := &PoolState{
+-----		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // пример смещения
+-----		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // пример смещения
+-----		Status:       account.Data[88],                                // пример смещения
+----+		BaseReserve:  binary.LittleEndian.Uint64(account.Value.Data.GetBinary()[64:72]), // пример смещения
+----+		QuoteReserve: binary.LittleEndian.Uint64(account.Value.Data.GetBinary()[72:80]), // пример смещения
+----+		Status:       account.Value.Data.GetBinary()[88],                                // пример смещения
+---- 	}
+---- 
+---- 	return state, nil
+----@@ -143,53 +155,158 @@ func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
+---- // Обработку разных версий пулов
+---- // Расчет слиппажа и проверку лимитов
+---- 
+-----// CreateSwapInstructions создает набор инструкций для свапа
+----+// NewSwapInstructionBuilder создает новый билдер для SwapInstruction
+----+func NewSwapInstructionBuilder() *SwapInstruction {
+----+	return &SwapInstruction{
+----+		AccountMetaSlice: make(solana.AccountMetaSlice, 7), // 7 обязательных аккаунтов
+----+	}
+----+}
+----+
+----+// Методы для установки параметров, следуя паттерну из SDK
+----+func (inst *SwapInstruction) SetAmount(amount uint64) *SwapInstruction {
+----+	inst.Amount = &amount
+----+	return inst
+----+}
+----+
+----+func (inst *SwapInstruction) SetMinimumOut(minimumOut uint64) *SwapInstruction {
+----+	inst.MinimumOut = &minimumOut
+----+	return inst
+----+}
+----+
+----+// Методы для установки аккаунтов
+----+func (inst *SwapInstruction) SetAccounts(
+----+	pool solana.PublicKey,
+----+	authority solana.PublicKey,
+----+	userWallet solana.PublicKey,
+----+	sourceToken solana.PublicKey,
+----+	destToken solana.PublicKey,
+----+	baseVault solana.PublicKey,
+----+	quoteVault solana.PublicKey,
+----+) *SwapInstruction {
+----+	inst.AccountMetaSlice[0] = solana.Meta(pool).WRITE()
+----+	inst.AccountMetaSlice[1] = solana.Meta(authority)
+----+	inst.AccountMetaSlice[2] = solana.Meta(userWallet).WRITE().SIGNER()
+----+	inst.AccountMetaSlice[3] = solana.Meta(sourceToken).WRITE()
+----+	inst.AccountMetaSlice[4] = solana.Meta(destToken).WRITE()
+----+	inst.AccountMetaSlice[5] = solana.Meta(baseVault).WRITE()
+----+	inst.AccountMetaSlice[6] = solana.Meta(quoteVault).WRITE()
+----+	return inst
+----+}
+----+
+----+// Validate проверяет все необходимые параметры
+----+func (inst *SwapInstruction) Validate() error {
+----+	if inst.Amount == nil {
+----+		return errors.New("Amount is not set")
+----+	}
+----+	if inst.MinimumOut == nil {
+----+		return errors.New("MinimumOut is not set")
+----+	}
+----+
+----+	// Проверка всех аккаунтов
+----+	for i, acc := range inst.AccountMetaSlice {
+----+		if acc == nil {
+----+			return fmt.Errorf("account at index %d is not set", i)
+----+		}
+----+	}
+----+	return nil
+----+}
+----+
+----+// Build создает инструкцию
+----+func (inst *SwapInstruction) Build() (*solana.Instruction, error) {
+----+	if err := inst.Validate(); err != nil {
+----+		return nil, err
+----+	}
+----+
+----+	// Сериализация данных инструкции
+----+	data := make([]byte, 16)
+----+	binary.LittleEndian.PutUint64(data[0:8], *inst.Amount)
+----+	binary.LittleEndian.PutUint64(data[8:16], *inst.MinimumOut)
+----+
+----+	return &solana.Instruction{BaseVariant: bin.BaseVariant{
+----+		Impl: &solana.GenericInstruction{
+----+			AccountValues: inst.AccountMetaSlice,
+----+			ProgID:        solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+----+			DataBytes:     data,
+----+		},
+----+	}}, nil
+----+}
+----+
+----+// CreateSwapInstructions создает инструкции для свапа
+---- func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
+-----	c.logger.Debug("creating swap instructions",
+-----		zap.String("userWallet", params.UserWallet.String()),
+-----		zap.Uint64("amountIn", params.AmountIn),
+-----		zap.Uint64("minAmountOut", params.MinAmountOut),
+-----	)
+----+	if err := validateSwapParams(params); err != nil {
+----+		return nil, err
+----+	}
+---- 
+-----	// Создаем базовый массив инструкций
+---- 	instructions := make([]solana.Instruction, 0)
+---- 
+-----	// Создаем инструкцию для установки приоритета комиссии
+----+	// Добавляем инструкцию compute budget если указан приоритетный fee
+---- 	if params.PriorityFeeLamports > 0 {
+-----		computeBudgetIx := solana.NewInstruction(
+-----			solana.ComputeBudget,
+-----			&ComputeBudgetInstruction{
+-----				Units:         300000, // базовые compute units как в typescript
+-----				MicroLamports: params.PriorityFeeLamports,
+-----			},
+-----		)
+-----		instructions = append(instructions, computeBudgetIx)
+----+		computeLimitIx, err := computebudget.NewSetComputeUnitLimitInstructionBuilder().
+----+			SetUnits(MAX_COMPUTE_UNIT_LIMIT).
+----+			ValidateAndBuild()
+----+		if err != nil {
+----+			return nil, fmt.Errorf("failed to build compute limit instruction: %w", err)
+----+		}
+----+		instructions = append(instructions, computeLimitIx)
+----+
+----+		computePriceIx, err := computebudget.NewSetComputeUnitPriceInstructionBuilder().
+----+			SetMicroLamports(params.PriorityFeeLamports).
+----+			ValidateAndBuild()
+----+		if err != nil {
+----+			return nil, fmt.Errorf("failed to build compute price instruction: %w", err)
+----+		}
+----+		instructions = append(instructions, computePriceIx)
+----+	}
+----+
+----+	// Создаем инструкцию свапа
+----+	swapIx, err := NewSwapInstructionBuilder().
+----+		SetAmount(params.AmountIn).
+----+		SetMinimumOut(params.MinAmountOut).
+----+		SetAccounts(
+----+			params.Pool.ID,
+----+			params.Pool.Authority,
+----+			params.UserWallet,
+----+			params.SourceTokenAccount,
+----+			params.DestinationTokenAccount,
+----+			params.Pool.BaseVault,
+----+			params.Pool.QuoteVault,
+----+		).
+----+		Build()
+----+	if err != nil {
+----+		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
+---- 	}
+---- 
+-----	// Создаем основную инструкцию свапа
+-----	swapIx := solana.NewInstruction(
+-----		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+-----		&SwapInstruction{
+-----			Amount:     params.AmountIn,
+-----			MinimumOut: params.MinAmountOut,
+-----		},
+-----		// Добавляем необходимые аккаунты
+-----		[]solana.AccountMeta{
+-----			{PublicKey: params.Pool.ID, IsWritable: true, IsSigner: false},
+-----			{PublicKey: params.Pool.Authority, IsWritable: false, IsSigner: false},
+-----			{PublicKey: params.UserWallet, IsWritable: true, IsSigner: true},
+-----			{PublicKey: params.SourceTokenAccount, IsWritable: true, IsSigner: false},
+-----			{PublicKey: params.DestinationTokenAccount, IsWritable: true, IsSigner: false},
+-----			{PublicKey: params.Pool.BaseVault, IsWritable: true, IsSigner: false},
+-----			{PublicKey: params.Pool.QuoteVault, IsWritable: true, IsSigner: false},
+-----			// Добавляем остальные необходимые аккаунты
+-----		},
+-----	)
+---- 	instructions = append(instructions, swapIx)
+---- 
+---- 	return instructions, nil
+---- }
+---- 
+----+// validateSwapParams проверяет входные параметры
+----+func validateSwapParams(params *SwapParams) error {
+----+	if params == nil {
+----+		return errors.New("params cannot be nil")
+----+	}
+----+	if params.Pool == nil {
+----+		return errors.New("pool cannot be nil")
+----+	}
+----+	if params.UserWallet.IsZero() {
+----+		return errors.New("user wallet is required")
+----+	}
+----+	if params.SourceTokenAccount.IsZero() {
+----+		return errors.New("source token account is required")
+----+	}
+----+	if params.DestinationTokenAccount.IsZero() {
+----+		return errors.New("destination token account is required")
+----+	}
+----+	if params.AmountIn == 0 {
+----+		return errors.New("amount in must be greater than 0")
+----+	}
+----+	if params.MinAmountOut == 0 {
+----+		return errors.New("minimum amount out must be greater than 0")
+----+	}
+----+	return nil
+----+}
+----+
+---- // SimulateSwap выполняет симуляцию транзакции свапа
+---- func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
+---- 	c.logger.Debug("simulating swap transaction")
+----diff --git a/internal/dex/raydium/newSwap.txt b/internal/dex/raydium/newSwap.txt
+----new file mode 100644
+----index 0000000..5a4ec8f
+------- /dev/null
+----+++ b/internal/dex/raydium/newSwap.txt
+----@@ -0,0 +1,760 @@
+----+// internal/dex/raydium/client.go - это пакет, который содержит в себе реализацию клиента для работы с декстером Raydium
+----+package raydium
+----+
+----+import (
+----+	"encoding/binary"
+----+	"fmt"
+----+	"time"
+----+
+----+	"github.com/gagliardetto/solana-go"
+----+	"github.com/gagliardetto/solana-go/rpc"
+----+	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+----+	"go.uber.org/zap"
+----+)
+----+
+----+const (
+----+	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
+----+)
+----+
+----+type RaydiumClient struct {
+----+	client  blockchain.Client
+----+	logger  *zap.Logger
+----+	options *clientOptions // Базовые настройки таймаутов и retry
+----+}
+----+type clientOptions struct {
+----+	timeout     time.Duration      // Таймаут для операций
+----+	retries     int                // Количество повторных попыток
+----+	priorityFee uint64             // Приоритетная комиссия в лампортах
+----+	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
+----+}
+----+
+----+// Вспомогательные структуры для инструкций
+----+type ComputeBudgetInstruction struct {
+----+	Units         uint32
+----+	MicroLamports uint64
+----+}
+----+
+----+type SwapInstruction struct {
+----+	Amount     uint64
+----+	MinimumOut uint64
 ----+}
 ----+
 ----+// NewRaydiumClient создает новый экземпляр клиента Raydium
 ----+func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) *RaydiumClient {
----- 	// Инициализация с базовыми настройками
+----+	// Инициализация с базовыми настройками
 ----+
 ----+	opts := &clientOptions{
 ----+		timeout:     30 * time.Second,
@@ -3353,12 +2557,11 @@ index 8e5c180..4ae4320 100644
 ----+		logger:  logger,
 ----+		options: opts,
 ----+	}
----- }
----- 
------func (c *RaydiumClient) GetPool() (*RaydiumPool, error) {
+----+}
+----+
 ----+// GetPool получает информацию о пуле по базовому и котируемому токенам
 ----+func (c *RaydiumClient) GetPool(baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
----- 	// Получение информации о пуле
+----+	// Получение информации о пуле
 ----+
 ----+	c.logger.Debug("getting raydium pool info",
 ----+		zap.String("baseMint", baseMint.String()),
@@ -3408,10 +2611,8 @@ index 8e5c180..4ae4320 100644
 ----+	}
 ----+
 ----+	return pool, nil
----- }
----- 
------func (c *RaydiumClient) GetPoolState() (*PoolState, error) {
------	// Получение текущего состояния пула
+----+}
+----+
 ----+// GetPoolState получает текущее состояние пула
 ----+func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
 ----+	c.logger.Debug("getting pool state",
@@ -3432,10 +2633,8 @@ index 8e5c180..4ae4320 100644
 ----+	}
 ----+
 ----+	return state, nil
----- }
----- 
------func (c *RaydiumClient) CreateSwapInstructions() ([]solana.Instruction, error) {
------	// Создание инструкций для свапа
+----+}
+----+
 ----+// TODO:
 ----+// Для полноценной работы нужно добавить:
 ----+// Корректную сериализацию инструкций (согласно протоколу Raydium)
@@ -3489,10 +2688,8 @@ index 8e5c180..4ae4320 100644
 ----+	instructions = append(instructions, swapIx)
 ----+
 ----+	return instructions, nil
----- }
----- 
------func (c *RaydiumClient) SimulateSwap() error {
------	// Симуляция свапа
+----+}
+----+
 ----+// SimulateSwap выполняет симуляцию транзакции свапа
 ----+func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
 ----+	c.logger.Debug("simulating swap transaction")
@@ -3637,10 +2834,8 @@ index 8e5c180..4ae4320 100644
 ----+	}
 ----+
 ----+	return sig, nil
----- }
----- 
------func (c *RaydiumClient) ExecuteSwap() (string, error) {
------	// Выполнение свапа
+----+}
+----+
 ----+// logUpdatedBalances вспомогательный метод для логирования балансов после свапа
 ----+func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
 ----+	// Получаем баланс SOL
@@ -3667,32 +2862,29 @@ index 8e5c180..4ae4320 100644
 ----+	)
 ----+
 ----+	return nil
----- }
-----diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
-----index 330c82d..50959de 100644
-------- a/internal/dex/raydium/pool.go
-----+++ b/internal/dex/raydium/pool.go
-----@@ -2,23 +2,126 @@
----- package raydium
----- 
----- import (
+----+}
+----+
+----+// internal/dex/raydium/pool.go - это пакет, который содержит в себе реализацию работы с пулами Raydium
+----+package raydium
+----+
+----+import (
 ----+	"encoding/binary"
 ----+	"fmt"
 ----+
 ----+	"github.com/gagliardetto/solana-go"
----- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
----- 	"go.uber.org/zap"
----- )
----- 
+----+	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+----+	"go.uber.org/zap"
+----+)
+----+
 ----+type SwapAmounts struct {
 ----+	AmountIn     uint64 // Количество входных токенов
 ----+	AmountOut    uint64 // Ожидаемое количество выходных токенов
 ----+	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
 ----+}
 ----+
----- type PoolManager struct {
----- 	client blockchain.Client
----- 	logger *zap.Logger
+----+type PoolManager struct {
+----+	client blockchain.Client
+----+	logger *zap.Logger
 ----+	pool   *RaydiumPool
 ----+}
 ----+
@@ -3703,8 +2895,8 @@ index 8e5c180..4ae4320 100644
 ----+		logger: logger,
 ----+		pool:   pool,
 ----+	}
----- }
----- 
+----+}
+----+
 ----+// TODO: В дальнейшем этот код можно расширить:
 ----+// 1. Добавить более сложную формулу расчета с учетом комиссий
 ----+// 2. Реализовать кэширование состояния пула
@@ -3712,8 +2904,7 @@ index 8e5c180..4ae4320 100644
 ----+// 4. Улучшить обработку ошибок и логирование
 ----+
 ----+// GetPoolState получает актуальное состояние пула
----- func (pm *PoolManager) GetPoolState() (*PoolState, error) {
------	// Получение состояния пула
+----+func (pm *PoolManager) GetPoolState() (*PoolState, error) {
 ----+	pm.logger.Debug("getting pool state",
 ----+		zap.String("poolId", pm.pool.ID.String()),
 ----+	)
@@ -3732,11 +2923,10 @@ index 8e5c180..4ae4320 100644
 ----+	}
 ----+
 ----+	return state, nil
----- }
----- 
+----+}
+----+
 ----+// CalculateAmounts рассчитывает количество выходных токенов и минимальный выход
----- func (pm *PoolManager) CalculateAmounts() (*SwapAmounts, error) {
------	// Расчет amount out и минимального получения
+----+func (pm *PoolManager) CalculateAmounts() (*SwapAmounts, error) {
 ----+	// Получаем текущее состояние пула
 ----+	state, err := pm.GetPoolState()
 ----+	if err != nil {
@@ -3762,11 +2952,10 @@ index 8e5c180..4ae4320 100644
 ----+		AmountOut:    amountOut,
 ----+		MinAmountOut: minAmountOut,
 ----+	}, nil
----- }
----- 
+----+}
+----+
 ----+// ValidatePool проверяет валидность параметров пула
----- func (pm *PoolManager) ValidatePool() error {
------	// Валидация параметров пула
+----+func (pm *PoolManager) ValidatePool() error {
 ----+	// Проверяем существование всех необходимых аккаунтов
 ----+	accounts := []solana.PublicKey{
 ----+		pm.pool.ID,
@@ -3801,6862 +2990,7945 @@ index 8e5c180..4ae4320 100644
 ----+	}
 ----+
 ----+	return nil
----- }
-----diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
-----index 2c184ce..55c2206 100644
-------- a/internal/dex/raydium/types.go
-----+++ b/internal/dex/raydium/types.go
-----@@ -1,4 +1,4 @@
------// inernal/dex/raydium - это пакет, который содержит в себе реализацию работы с декстерами Raydium
+----+}
+----+
+----+// internal/dex/raydium/sniper.go - это пакет, который содержит в себе реализацию снайпинга на декстере Raydium
+----+package raydium
+----+
+----+import (
+----+	"fmt"
+----+	"math"
+----+	"time"
+----+
+----+	"github.com/gagliardetto/solana-go"
+----+	"github.com/gagliardetto/solana-go/rpc"
+----+	"go.uber.org/zap"
+----+)
+----+
+----+type Sniper struct {
+----+	client *RaydiumClient
+----+	logger *zap.Logger
+----+	config *SniperConfig // Конфигурация снайпинга
+----+}
+----+type SniperConfig struct {
+----+	// Существующие поля
+----+	maxSlippageBps   uint16
+----+	minAmountSOL     float64
+----+	maxAmountSOL     float64
+----+	priorityFee      uint64
+----+	waitConfirmation bool
+----+	monitorInterval  time.Duration
+----+	maxRetries       int
+----+
+----+	// Добавляем новые необходимые поля
+----+	baseMint  solana.PublicKey // Mint address базового токена
+----+	quoteMint solana.PublicKey // Mint address котируемого токена
+----+}
+----+
+----+// TODO: можно добавить:
+----+
+----+// 1. Проверку цены перед свапом
+----+// 2. Мониторинг состояния пула в реальном времени
+----+// 3. Более сложную логику расчета суммы свапа
+----+// 4. Обработку различных ошибок и ретраи
+----+// 5. Асинхронное выполнение свапа
+----+
+----+func (s *Sniper) ExecuteSnipe() error {
+----+	s.logger.Debug("starting snipe execution")
+----+
+----+	// 1. Получение пула и валидация параметров
+----+	if err := s.ValidateAndPrepare(); err != nil {
+----+		return fmt.Errorf("failed to validate parameters: %w", err)
+----+	}
+----+
+----+	// 2. Получение информации о пуле и проверка его состояния
+----+	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
+----+	if err != nil {
+----+		return fmt.Errorf("failed to get pool: %w", err)
+----+	}
+----+
+----+	poolManager := NewPoolManager(s.client.client, s.logger, pool)
+----+	if err := poolManager.ValidatePool(); err != nil {
+----+		return fmt.Errorf("pool validation failed: %w", err)
+----+	}
+----+
+----+	// 3. Расчет параметров свапа
+----+	amounts, err := poolManager.CalculateAmounts()
+----+	if err != nil {
+----+		return fmt.Errorf("failed to calculate swap amounts: %w", err)
+----+	}
+----+
+----+	// 4. Подготовка параметров для свапа
+----+	swapParams := &SwapParams{
+----+		UserWallet:          s.client.client.PrivateKey.PublicKey(),
+----+		AmountIn:            amounts.AmountIn,
+----+		MinAmountOut:        amounts.MinAmountOut,
+----+		Pool:                pool,
+----+		PriorityFeeLamports: s.config.priorityFee,
+----+		// Здесь нужно добавить source и destination token accounts,
+----+		// которые должны быть получены или созданы заранее
+----+	}
+----+
+----+	// 5. Выполнение свапа
+----+	signature, err := s.client.ExecuteSwap(swapParams)
+----+	if err != nil {
+----+		return fmt.Errorf("swap execution failed: %w", err)
+----+	}
+----+
+----+	// Логируем успешное выполнение
+----+	s.logger.Info("snipe executed successfully",
+----+		zap.String("signature", signature),
+----+		zap.Uint64("amountIn", amounts.AmountIn),
+----+		zap.Uint64("amountOut", amounts.AmountOut),
+----+		zap.Uint64("minAmountOut", amounts.MinAmountOut),
+----+	)
+----+
+----+	return nil
+----+}
+----+
+----+// TODO: Потенциальные улучшения на основе TS версии:
+----+// 1. Добавить проверку и создание associated token accounts
+----+// 2. Добавить проверку балансов SOL и токенов
+----+// 3. Добавить валидацию параметров compute budget
+----+// 4. Добавить проверку версии пула (V4)
+----+// 5. Добавить расчет приоритетной комиссии на основе последних блоков
+----+// 6. Добавить проверку и обработку wrapped SOL
+----+func (s *Sniper) ValidateAndPrepare() error {
+----+	s.logger.Debug("validating and preparing snipe parameters")
+----+
+----+	// Проверяем базовые параметры конфигурации
+----+	if s.config.maxSlippageBps == 0 || s.config.maxSlippageBps > 10000 { // 10000 = 100%
+----+		return fmt.Errorf("invalid slippage: must be between 0 and 10000")
+----+	}
+----+
+----+	if s.config.minAmountSOL <= 0 || s.config.maxAmountSOL <= 0 {
+----+		return fmt.Errorf("invalid amount parameters")
+----+	}
+----+
+----+	if s.config.maxAmountSOL < s.config.minAmountSOL {
+----+		return fmt.Errorf("maxAmount cannot be less than minAmount")
+----+	}
+----+
+----+	// Проверяем mint addresses
+----+	if s.config.baseMint.IsZero() || s.config.quoteMint.IsZero() {
+----+		return fmt.Errorf("invalid mint addresses")
+----+	}
+----+
+----+	// Проверяем наличие достаточного баланса
+----+	balance, err := s.client.client.GetBalance(
+----+		s.client.client.PrivateKey.PublicKey(),
+----+		rpc.CommitmentConfirmed,
+----+	)
+----+	if err != nil {
+----+		return fmt.Errorf("failed to get wallet balance: %w", err)
+----+	}
+----+
+----+	if float64(balance.Value)/float64(solana.LAMPORTS_PER_SOL) < s.config.minAmountSOL {
+----+		return fmt.Errorf("insufficient balance")
+----+	}
+----+
+----+	// Проверяем параметры мониторинга
+----+	if s.config.monitorInterval < time.Second {
+----+		return fmt.Errorf("monitor interval too small")
+----+	}
+----+
+----+	if s.config.maxRetries < 1 {
+----+		return fmt.Errorf("invalid max retries value")
+----+	}
+----+
+----+	return nil
+----+}
+----+
+----+// TODO: Потенциальные улучшения на основе TS версии:
+----+// 1. Добавить отслеживание изменений цены
+----+// 2. Добавить отслеживание объема ликвидности
+----+// 3. Добавить механизм подписки на события пула
+----+// 4. Добавить отслеживание транзакций в мемпуле
+----+// 5. Добавить механизм websocket подключения
+----+// 6. Добавить механизм агрегации данных по нескольким RPC
+----+func (s *Sniper) MonitorPoolChanges() error {
+----+	s.logger.Debug("starting pool monitoring")
+----+
+----+	ticker := time.NewTicker(s.config.monitorInterval)
+----+	defer ticker.Stop()
+----+
+----+	// Получаем начальное состояние пула
+----+	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
+----+	if err != nil {
+----+		return fmt.Errorf("failed to get initial pool state: %w", err)
+----+	}
+----+
+----+	poolManager := NewPoolManager(s.client.client, s.logger, pool)
+----+	initialState, err := poolManager.GetPoolState()
+----+	if err != nil {
+----+		return fmt.Errorf("failed to get initial pool state: %w", err)
+----+	}
+----+
+----+	var retryCount int
+----+	for {
+----+		select {
+----+		case <-ticker.C:
+----+			// Получаем текущее состояние пула
+----+			currentState, err := poolManager.GetPoolState()
+----+			if err != nil {
+----+				retryCount++
+----+				s.logger.Error("failed to get current pool state",
+----+					zap.Error(err),
+----+					zap.Int("retry", retryCount),
+----+				)
+----+				if retryCount >= s.config.maxRetries {
+----+					return fmt.Errorf("max retries exceeded while monitoring pool")
+----+				}
+----+				continue
+----+			}
+----+			retryCount = 0
+----+
+----+			// Проверяем изменения в пуле
+----+			if s.hasSignificantChanges(initialState, currentState) {
+----+				s.logger.Info("detected significant pool changes",
+----+					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
+----+					zap.Uint64("newBaseReserve", currentState.BaseReserve),
+----+					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
+----+					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
+----+				)
+----+
+----+				// Если пул неактивен, прекращаем мониторинг
+----+				if currentState.Status != 1 {
+----+					return fmt.Errorf("pool became inactive")
+----+				}
+----+
+----+				// Обновляем начальное состояние
+----+				initialState = currentState
+----+			}
+----+		}
+----+	}
+----+}
+----+
+----+// Вспомогательный метод для определения значительных изменений в пуле
+----+func (s *Sniper) hasSignificantChanges(old, new *PoolState) bool {
+----+	// Рассчитываем процент изменения для базового резерва
+----+	baseChange := math.Abs(float64(new.BaseReserve)-float64(old.BaseReserve)) / float64(old.BaseReserve)
+----+
+----+	// Рассчитываем процент изменения для котируемого резерва
+----+	quoteChange := math.Abs(float64(new.QuoteReserve)-float64(old.QuoteReserve)) / float64(old.QuoteReserve)
+----+
+----+	// Определяем порог значительных изменений (например, 1%)
+----+	threshold := 0.01
+----+
+----+	return baseChange > threshold || quoteChange > threshold || new.Status != old.Status
+----+}
+----+
 ----+// inernal/dex/raydium/types.go - это пакет, который содержит в себе реализацию работы с декстерами Raydium
----- package raydium
----- 
----- import "github.com/gagliardetto/solana-go"
-----diff --git a/newdif.txt b/newdif.txt
-----index 916f03e..5cdad43 100644
-------- a/newdif.txt
-----+++ b/newdif.txt
-----@@ -1,6213 +0,0 @@
------diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
------index 45d076b..0355dc0 100644
--------- a/internal/blockchain/types.go
------+++ b/internal/blockchain/types.go
------@@ -48,4 +48,5 @@ type Client interface {
------ 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
------ 	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
------ 	GetRpcClient() *rpc.Client
------+	GetTokenAccountBalance(ctx context.Context, account solana.PublicKey, commitment rpc.CommitmentType) (*rpc.GetTokenAccountBalanceResult, error)
------ }
------diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
------index 26e8e25..8ff9022 100644
--------- a/internal/dex/raydium/pool.go
------+++ b/internal/dex/raydium/pool.go
------@@ -3,13 +3,16 @@ package raydium
------ 
------ import (
------ 	"context"
------+	"encoding/json"
------ 	"fmt"
------ 	"math"
------ 	"math/big"
------+	"strconv"
------ 	"time"
------ 
------ 	"github.com/gagliardetto/solana-go"
------ 	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
------+	"github.com/gagliardetto/solana-go/rpc"
------ 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
------ 	"go.uber.org/zap"
------ )
------@@ -23,6 +26,7 @@ import (
------ type PoolManager struct {
------ 	client blockchain.Client
------ 	logger *zap.Logger
------+	pool   *RaydiumV5Pool // Текущий активный пул
------ }
------ 
------ // NewPoolManager создает новый менеджер пула
------@@ -30,6 +34,7 @@ func NewPoolManager(client blockchain.Client, logger *zap.Logger) *PoolManager {
------ 	return &PoolManager{
------ 		client: client,
------ 		logger: logger.Named("pool-manager"),
------+		pool:   nil,
------ 	}
------ }
------ 
------@@ -331,27 +336,349 @@ func (pc *PoolCalculator) GetMarketPrice() float64 {
------ 	return (quoteF / quoteDecimalAdj) / (baseF / baseDecimalAdj)
------ }
------ 
-------// Добавить в pool.go:
------+// RaydiumV5Pool представляет пул Raydium версии 5
------ type RaydiumV5Pool struct {
-------	RaydiumPool
-------	PnlOwner    solana.PublicKey
-------	ModelDataId solana.PublicKey
-------	RecentRoot  *big.Int
-------	MaxOrders   uint64
-------	OrderStates []*big.Int
-------	TickSpacing uint16
-------}
-------
-------// Методы для работы с v5 пулами
-------func (pm *PoolManager) InitializeV5Pool(ctx context.Context, params *RaydiumPoolV5) error {
-------	// TODO: implement
------+	RaydiumPool // Встраиваем базовую структуру пула
------+
------+	// Основные параметры V5
------+	PnlOwner    solana.PublicKey // Владелец PnL (Profit and Loss)
------+	ModelDataId solana.PublicKey // ID модели данных пула
------+	RecentRoot  *big.Int         // Последний корневой хеш состояния пула
------+	MaxOrders   uint64           // Максимальное количество ордеров
------+	OrderStates []*big.Int       // Состояния ордеров
------+	TickSpacing uint16           // Шаг тиков цены
------+
------+	// Дополнительные параметры V5
------+	LPMint       solana.PublicKey    // Минт LP токенов
------+	AdminKey     solana.PublicKey    // Ключ администратора пула
------+	ConfigParams V5ConfigParams      // Параметры конфигурации
------+	FeeAccounts  V5FeeAccounts       // Аккаунты для комиссий
------+	PoolState    V5PoolState         // Состояние пула
------+	PriceHistory []PriceHistoryPoint // История цен
------+}
------+
------+// V5ConfigParams содержит параметры конфигурации пула V5
------+type V5ConfigParams struct {
------+	MinPriceRatio  *big.Int // Минимальное соотношение цен
------+	MaxPriceRatio  *big.Int // Максимальное соотношение цен
------+	MinBaseAmount  uint64   // Минимальное количество базового токена
------+	MinQuoteAmount uint64   // Минимальное количество котируемого токена
------+	MaxSlippageBps uint16   // Максимальный проскальзывание в базисных пунктах
------+	MaxLeverage    uint16   // Максимальное плечо
------+	ProtocolFee    uint16   // Комиссия протокола в базисных пунктах
------+	MinOrderSize   uint64   // Минимальный размер ордера
------+}
------+
------+// V5FeeAccounts содержит аккаунты для комиссий
------+type V5FeeAccounts struct {
------+	ProtocolFeeAccount solana.PublicKey // Аккаунт для комиссий протокола
------+	TraderFeeAccount   solana.PublicKey // Аккаунт для комиссий трейдера
------+	LPFeeAccount       solana.PublicKey // Аккаунт для комиссий провайдеров ликвидности
------+}
------+
------+// V5PoolState содержит текущее состояние пула
------+type V5PoolState struct {
------+	BaseReserve     uint64     // Резерв базового токена
------+	QuoteReserve    uint64     // Резерв котируемого токена
------+	LPSupply        uint64     // Общее предложение LP токенов
------+	LastUpdateSlot  uint64     // Слот последнего обновления
------+	SwapEnabled     bool       // Включен ли свап
------+	PriceMultiplier *big.Int   // Мультипликатор цены
------+	CurrentPrice    *big.Float // Текущая цена
------+	TVL             *big.Float // Total Value Locked
------+}
------+
------+// PriceHistoryPoint представляет точку в истории цен
------+type PriceHistoryPoint struct {
------+	Timestamp time.Time  // Временная метка
------+	Price     *big.Float // Цена
------+	Volume    uint64     // Объем
+----+package raydium
+----+
+----+import "github.com/gagliardetto/solana-go"
+----+
+----+type RaydiumPool struct {
+----+	ID            solana.PublicKey // Идентификатор пула
+----+	Authority     solana.PublicKey // Публичный ключ, который имеет полномочия управлять пулом
+----+	BaseMint      solana.PublicKey // Публичный ключ базового токена
+----+	QuoteMint     solana.PublicKey // Публичный ключ котируемого токена
+----+	BaseVault     solana.PublicKey // Публичный ключ хранилища базового токена
+----+	QuoteVault    solana.PublicKey // Публичный ключ хранилища котируемого токена
+----+	BaseDecimals  uint8            // Количество десятичных знаков базового токена
+----+	QuoteDecimals uint8            // Количество десятичных знаков котируемого токена
+----+	DefaultFeeBps uint16           // Комиссия по умолчанию в базисных пунктах (bps)
+----+	// Только необходимые поля для V4
+----+}
+----+
+----+type PoolState struct {
+----+	BaseReserve  uint64 // Резерв базового токена в пуле
+----+	QuoteReserve uint64 // Резерв котируемого токена в пуле
+----+	Status       uint8  // Статус пула (например, активен или неактивен)
+----+}
+----+
+----+type SwapParams struct {
+----+	UserWallet              solana.PublicKey // Публичный ключ кошелька пользователя
+----+	AmountIn                uint64           // Количество входного токена для обмена
+----+	MinAmountOut            uint64           // Минимальное количество выходного токена, которое пользователь готов принять
+----+	Pool                    *RaydiumPool     // Указатель на пул, в котором происходит обмен
+----+	SourceTokenAccount      solana.PublicKey // Публичный ключ аккаунта исходного токена
+----+	DestinationTokenAccount solana.PublicKey // Публичный ключ аккаунта целевого токена
+----+	PriorityFeeLamports     uint64           // Приоритетная комиссия в лампортах
+----+}
+----+
+----+// Основные ошибки
+----+type SwapError struct {
+----+	Stage   string // Этап, на котором произошла ошибка
+----+	Message string // Сообщение об ошибке
+----+	Err     error  // Вложенная ошибка
+----+}
+----diff --git a/internal/dex/raydium/sniper.go b/internal/dex/raydium/sniper.go
+----new file mode 100644
+----index 0000000..c9a6c55
+------- /dev/null
+----+++ b/internal/dex/raydium/sniper.go
+----@@ -0,0 +1,225 @@
+----+// internal/dex/raydium/sniper.go - это пакет, который содержит в себе реализацию снайпинга на декстере Raydium
+----+package raydium
+----+
+----+import (
+----+	"fmt"
+----+	"math"
+----+	"time"
+----+
+----+	"github.com/gagliardetto/solana-go"
+----+	"github.com/gagliardetto/solana-go/rpc"
+----+	"go.uber.org/zap"
+----+)
+----+
+----+type Sniper struct {
+----+	client *RaydiumClient
+----+	logger *zap.Logger
+----+	config *SniperConfig // Конфигурация снайпинга
+----+}
+----+type SniperConfig struct {
+----+	// Существующие поля
+----+	maxSlippageBps   uint16
+----+	minAmountSOL     float64
+----+	maxAmountSOL     float64
+----+	priorityFee      uint64
+----+	waitConfirmation bool
+----+	monitorInterval  time.Duration
+----+	maxRetries       int
+----+
+----+	// Добавляем новые необходимые поля
+----+	baseMint  solana.PublicKey // Mint address базового токена
+----+	quoteMint solana.PublicKey // Mint address котируемого токена
+----+}
+----+
+----+// TODO: можно добавить:
+----+
+----+// 1. Проверку цены перед свапом
+----+// 2. Мониторинг состояния пула в реальном времени
+----+// 3. Более сложную логику расчета суммы свапа
+----+// 4. Обработку различных ошибок и ретраи
+----+// 5. Асинхронное выполнение свапа
+----+
+----+func (s *Sniper) ExecuteSnipe() error {
+----+	s.logger.Debug("starting snipe execution")
+----+
+----+	// 1. Получение пула и валидация параметров
+----+	if err := s.ValidateAndPrepare(); err != nil {
+----+		return fmt.Errorf("failed to validate parameters: %w", err)
+----+	}
+----+
+----+	// 2. Получение информации о пуле и проверка его состояния
+----+	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
+----+	if err != nil {
+----+		return fmt.Errorf("failed to get pool: %w", err)
+----+	}
+----+
+----+	poolManager := NewPoolManager(s.client.client, s.logger, pool)
+----+	if err := poolManager.ValidatePool(); err != nil {
+----+		return fmt.Errorf("pool validation failed: %w", err)
+----+	}
+----+
+----+	// 3. Расчет параметров свапа
+----+	amounts, err := poolManager.CalculateAmounts()
+----+	if err != nil {
+----+		return fmt.Errorf("failed to calculate swap amounts: %w", err)
+----+	}
+----+
+----+	// 4. Подготовка параметров для свапа
+----+	swapParams := &SwapParams{
+----+		UserWallet:          s.client.client.PrivateKey.PublicKey(),
+----+		AmountIn:            amounts.AmountIn,
+----+		MinAmountOut:        amounts.MinAmountOut,
+----+		Pool:                pool,
+----+		PriorityFeeLamports: s.config.priorityFee,
+----+		// Здесь нужно добавить source и destination token accounts,
+----+		// которые должны быть получены или созданы заранее
+----+	}
+----+
+----+	// 5. Выполнение свапа
+----+	signature, err := s.client.ExecuteSwap(swapParams)
+----+	if err != nil {
+----+		return fmt.Errorf("swap execution failed: %w", err)
+----+	}
+----+
+----+	// Логируем успешное выполнение
+----+	s.logger.Info("snipe executed successfully",
+----+		zap.String("signature", signature),
+----+		zap.Uint64("amountIn", amounts.AmountIn),
+----+		zap.Uint64("amountOut", amounts.AmountOut),
+----+		zap.Uint64("minAmountOut", amounts.MinAmountOut),
+----+	)
+----+
+----+	return nil
+----+}
+----+
+----+// TODO: Потенциальные улучшения на основе TS версии:
+----+// 1. Добавить проверку и создание associated token accounts
+----+// 2. Добавить проверку балансов SOL и токенов
+----+// 3. Добавить валидацию параметров compute budget
+----+// 4. Добавить проверку версии пула (V4)
+----+// 5. Добавить расчет приоритетной комиссии на основе последних блоков
+----+// 6. Добавить проверку и обработку wrapped SOL
+----+func (s *Sniper) ValidateAndPrepare() error {
+----+	s.logger.Debug("validating and preparing snipe parameters")
+----+
+----+	// Проверяем базовые параметры конфигурации
+----+	if s.config.maxSlippageBps == 0 || s.config.maxSlippageBps > 10000 { // 10000 = 100%
+----+		return fmt.Errorf("invalid slippage: must be between 0 and 10000")
+----+	}
+----+
+----+	if s.config.minAmountSOL <= 0 || s.config.maxAmountSOL <= 0 {
+----+		return fmt.Errorf("invalid amount parameters")
+----+	}
+----+
+----+	if s.config.maxAmountSOL < s.config.minAmountSOL {
+----+		return fmt.Errorf("maxAmount cannot be less than minAmount")
+----+	}
+----+
+----+	// Проверяем mint addresses
+----+	if s.config.baseMint.IsZero() || s.config.quoteMint.IsZero() {
+----+		return fmt.Errorf("invalid mint addresses")
+----+	}
+----+
+----+	// Проверяем наличие достаточного баланса
+----+	balance, err := s.client.client.GetBalance(
+----+		s.client.client.PrivateKey.PublicKey(),
+----+		rpc.CommitmentConfirmed,
+----+	)
+----+	if err != nil {
+----+		return fmt.Errorf("failed to get wallet balance: %w", err)
+----+	}
+----+
+----+	if float64(balance.Value)/float64(solana.LAMPORTS_PER_SOL) < s.config.minAmountSOL {
+----+		return fmt.Errorf("insufficient balance")
+----+	}
+----+
+----+	// Проверяем параметры мониторинга
+----+	if s.config.monitorInterval < time.Second {
+----+		return fmt.Errorf("monitor interval too small")
+----+	}
+----+
+----+	if s.config.maxRetries < 1 {
+----+		return fmt.Errorf("invalid max retries value")
+----+	}
+----+
+----+	return nil
+----+}
+----+
+----+// TODO: Потенциальные улучшения на основе TS версии:
+----+// 1. Добавить отслеживание изменений цены
+----+// 2. Добавить отслеживание объема ликвидности
+----+// 3. Добавить механизм подписки на события пула
+----+// 4. Добавить отслеживание транзакций в мемпуле
+----+// 5. Добавить механизм websocket подключения
+----+// 6. Добавить механизм агрегации данных по нескольким RPC
+----+func (s *Sniper) MonitorPoolChanges() error {
+----+	s.logger.Debug("starting pool monitoring")
+----+
+----+	ticker := time.NewTicker(s.config.monitorInterval)
+----+	defer ticker.Stop()
+----+
+----+	// Получаем начальное состояние пула
+----+	pool, err := s.client.GetPool(s.config.baseMint, s.config.quoteMint)
+----+	if err != nil {
+----+		return fmt.Errorf("failed to get initial pool state: %w", err)
+----+	}
+----+
+----+	poolManager := NewPoolManager(s.client.client, s.logger, pool)
+----+	initialState, err := poolManager.GetPoolState()
+----+	if err != nil {
+----+		return fmt.Errorf("failed to get initial pool state: %w", err)
+----+	}
+----+
+----+	var retryCount int
+----+	for {
+----+		select {
+----+		case <-ticker.C:
+----+			// Получаем текущее состояние пула
+----+			currentState, err := poolManager.GetPoolState()
+----+			if err != nil {
+----+				retryCount++
+----+				s.logger.Error("failed to get current pool state",
+----+					zap.Error(err),
+----+					zap.Int("retry", retryCount),
+----+				)
+----+				if retryCount >= s.config.maxRetries {
+----+					return fmt.Errorf("max retries exceeded while monitoring pool")
+----+				}
+----+				continue
+----+			}
+----+			retryCount = 0
+----+
+----+			// Проверяем изменения в пуле
+----+			if s.hasSignificantChanges(initialState, currentState) {
+----+				s.logger.Info("detected significant pool changes",
+----+					zap.Uint64("oldBaseReserve", initialState.BaseReserve),
+----+					zap.Uint64("newBaseReserve", currentState.BaseReserve),
+----+					zap.Uint64("oldQuoteReserve", initialState.QuoteReserve),
+----+					zap.Uint64("newQuoteReserve", currentState.QuoteReserve),
+----+				)
+----+
+----+				// Если пул неактивен, прекращаем мониторинг
+----+				if currentState.Status != 1 {
+----+					return fmt.Errorf("pool became inactive")
+----+				}
+----+
+----+				// Обновляем начальное состояние
+----+				initialState = currentState
+----+			}
+----+		}
+----+	}
+----+}
+----+
+----+// Вспомогательный метод для определения значительных изменений в пуле
+----+func (s *Sniper) hasSignificantChanges(old, new *PoolState) bool {
+----+	// Рассчитываем процент изменения для базового резерва
+----+	baseChange := math.Abs(float64(new.BaseReserve)-float64(old.BaseReserve)) / float64(old.BaseReserve)
+----+
+----+	// Рассчитываем процент изменения для котируемого резерва
+----+	quoteChange := math.Abs(float64(new.QuoteReserve)-float64(old.QuoteReserve)) / float64(old.QuoteReserve)
+----+
+----+	// Определяем порог значительных изменений (например, 1%)
+----+	threshold := 0.01
+----+
+----+	return baseChange > threshold || quoteChange > threshold || new.Status != old.Status
+----+}
+----diff --git a/newdif.txt b/newdif.txt
+----index 59e3e66..e69de29 100644
+------- a/newdif.txt
+----+++ b/newdif.txt
+----@@ -1,6780 +0,0 @@
+-----diff --git a/internal/blockchain/solbc/solana.go b/internal/blockchain/solbc/solana.go
+-----index dec574a..cfede3e 100644
+-------- a/internal/blockchain/solbc/solana.go
+-----+++ b/internal/blockchain/solbc/solana.go
+-----@@ -5,9 +5,6 @@ import (
+----- 	"context"
+----- 	"fmt"
+----- 
+------	solanarpc "github.com/gagliardetto/solana-go/rpc"
+------	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
+------
+----- 	"github.com/gagliardetto/solana-go"
+----- 	"go.uber.org/zap"
+----- )
+-----@@ -63,19 +60,3 @@ func (c *Client) SimulateTransaction(tx string) (string, error) {
+----- 	// Implement the method logic here
+----- 	return "", nil
+----- }
+------
+------func (c *Client) GetRpcClient() *solanarpc.Client {
+------	if c.adapter == nil {
+------		c.adapter = NewRpcAdapter(c.rpc)
+------	}
+------	return c.adapter
+------}
+------
+------// RpcAdapter адаптирует наш RPCClient к интерфейсу solana-go/rpc.Client
+------type RpcAdapter struct {
+------	client *rpc.RPCClient
+------}
+------
+------func NewRpcAdapter(client *rpc.RPCClient) *solanarpc.Client {
+------	return solanarpc.New("") // Создаем пустой клиент
+------}
+-----diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
+-----index 0355dc0..81e8fb2 100644
+-------- a/internal/blockchain/types.go
+-----+++ b/internal/blockchain/types.go
+-----@@ -47,6 +47,5 @@ type Client interface {
+----- 	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
+----- 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
+----- 	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
+------	GetRpcClient() *rpc.Client
+----- 	GetTokenAccountBalance(ctx context.Context, account solana.PublicKey, commitment rpc.CommitmentType) (*rpc.GetTokenAccountBalanceResult, error)
+----- }
+-----diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
+-----index 234fc23..342586c 100644
+-------- a/internal/dex/raydium/client.go
+-----+++ b/internal/dex/raydium/client.go
+-----@@ -2,6 +2,8 @@
+----- package raydium
+----- 
+----- import (
+-----+	"encoding/binary"
+-----+	"fmt"
+----- 	"time"
+----- 
+----- 	"github.com/gagliardetto/solana-go"
+-----@@ -10,6 +12,10 @@ import (
+----- 	"go.uber.org/zap"
+----- )
+----- 
+-----+const (
+-----+	RAYDIUM_V4_PROGRAM_ID = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"
+-----+)
+-----+
+----- type RaydiumClient struct {
+----- 	client  blockchain.Client
+----- 	logger  *zap.Logger
+-----@@ -22,26 +28,338 @@ type clientOptions struct {
+----- 	commitment  rpc.CommitmentType // Уровень подтверждения транзакций
+----- }
+----- 
+------func NewRaydiumClient() *RaydiumClient {
+-----+// Вспомогательные структуры для инструкций
+-----+type ComputeBudgetInstruction struct {
+-----+	Units         uint32
+-----+	MicroLamports uint64
 -----+}
 -----+
------+// Методы для работы с V5Pool
+-----+type SwapInstruction struct {
+-----+	Amount     uint64
+-----+	MinimumOut uint64
+-----+}
 -----+
------+// NewRaydiumV5Pool создает новый экземпляр V5 пула
------+func NewRaydiumV5Pool(baseParams *RaydiumPool) *RaydiumV5Pool {
------+	return &RaydiumV5Pool{
------+		RaydiumPool: *baseParams,
------+		ConfigParams: V5ConfigParams{
------+			MinPriceRatio: new(big.Int),
------+			MaxPriceRatio: new(big.Int),
------+		},
------+		PoolState: V5PoolState{
------+			PriceMultiplier: new(big.Int),
------+			CurrentPrice:    new(big.Float),
------+			TVL:             new(big.Float),
------+		},
------+		PriceHistory: make([]PriceHistoryPoint, 0),
+-----+// NewRaydiumClient создает новый экземпляр клиента Raydium
+-----+func NewRaydiumClient(rpcEndpoint string, wallet solana.PrivateKey, logger *zap.Logger) *RaydiumClient {
+----- 	// Инициализация с базовыми настройками
+-----+
+-----+	opts := &clientOptions{
+-----+		timeout:     30 * time.Second,
+-----+		retries:     3,
+-----+		priorityFee: 1000, // базовое значение в лампортах
+-----+		commitment:  rpc.CommitmentConfirmed,
 -----+	}
------+}
 -----+
------+// GetCurrentState возвращает текущее состояние пула
------+func (p *RaydiumV5Pool) GetCurrentState() V5PoolState {
------+	return p.PoolState
------+}
+-----+	client := blockchain.NewSolanaClient(rpcEndpoint, wallet)
 -----+
------+// UpdateState обновляет состояние пула
------+func (p *RaydiumV5Pool) UpdateState(newState V5PoolState) {
------+	p.PoolState = newState
------+	// Добавляем точку в историю цен
------+	p.PriceHistory = append(p.PriceHistory, PriceHistoryPoint{
------+		Timestamp: time.Now(),
------+		Price:     newState.CurrentPrice,
------+		Volume:    0, // Нужно добавить расчет объема
------+	})
------+}
+-----+	return &RaydiumClient{
+-----+		client:  client,
+-----+		logger:  logger,
+-----+		options: opts,
+-----+	}
+----- }
+----- 
+------func (c *RaydiumClient) GetPool() (*RaydiumPool, error) {
+-----+// GetPool получает информацию о пуле по базовому и котируемому токенам
+-----+func (c *RaydiumClient) GetPool(baseMint, quoteMint solana.PublicKey) (*RaydiumPool, error) {
+----- 	// Получение информации о пуле
 -----+
------+// GetFeeAccounts возвращает аккаунты для комиссий
------+func (p *RaydiumV5Pool) GetFeeAccounts() V5FeeAccounts {
------+	return p.FeeAccounts
------+}
+-----+	c.logger.Debug("getting raydium pool info",
+-----+		zap.String("baseMint", baseMint.String()),
+-----+		zap.String("quoteMint", quoteMint.String()),
+-----+	)
 -----+
------+// IsSwapEnabled проверяет, включен ли свап в пуле
------+func (p *RaydiumV5Pool) IsSwapEnabled() bool {
------+	return p.PoolState.SwapEnabled
------+}
+-----+	// Получаем программные аккаунты по фильтрам
+-----+	accounts, err := c.client.GetProgramAccounts(
+-----+		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+-----+		rpc.GetProgramAccountsOpts{
+-----+			Filters: []rpc.RPCFilter{
+-----+				{
+-----+					DataSize: 388, // размер аккаунта пула v4
+-----+				},
+-----+				{
+-----+					Memcmp: &rpc.RPCFilterMemcmp{
+-----+						Offset: 8, // смещение для baseMint
+-----+						Bytes:  baseMint.Bytes(),
+-----+					},
+-----+				},
+-----+				{
+-----+					Memcmp: &rpc.RPCFilterMemcmp{
+-----+						Offset: 40, // смещение для quoteMint
+-----+						Bytes:  quoteMint.Bytes(),
+-----+					},
+-----+				},
+-----+			},
+-----+		},
+-----+	)
+-----+	if err != nil {
+-----+		return nil, fmt.Errorf("failed to get program accounts: %w", err)
+-----+	}
 -----+
------+// GetTVL возвращает Total Value Locked
------+func (p *RaydiumV5Pool) GetTVL() *big.Float {
------+	return p.PoolState.TVL
------+}
+-----+	if len(accounts) == 0 {
+-----+		return nil, fmt.Errorf("pool not found")
+-----+	}
 -----+
------+// Вспомогательный метод для валидации model data
------+func (pm *PoolManager) validateModelData(ctx context.Context, modelDataId solana.PublicKey) error {
------+	if modelDataId.IsZero() {
------+		return fmt.Errorf("model data ID cannot be zero")
+-----+	// Берем первый найденный пул
+-----+	poolAccount := accounts[0]
+-----+
+-----+	// Парсим данные аккаунта в структуру пула
+-----+	pool := &RaydiumPool{
+-----+		ID:        poolAccount.PublicKey,
+-----+		BaseMint:  baseMint,
+-----+		QuoteMint: quoteMint,
+-----+		// ... заполнение остальных полей из данных аккаунта
 -----+	}
 -----+
------+	// Проверяем существование аккаунта
------+	account, err := pm.client.GetAccountInfo(ctx, modelDataId)
+-----+	return pool, nil
+----- }
+----- 
+------func (c *RaydiumClient) GetPoolState() (*PoolState, error) {
+------	// Получение текущего состояния пула
+-----+// GetPoolState получает текущее состояние пула
+-----+func (c *RaydiumClient) GetPoolState(pool *RaydiumPool) (*PoolState, error) {
+-----+	c.logger.Debug("getting pool state",
+-----+		zap.String("poolId", pool.ID.String()),
+-----+	)
+-----+
+-----+	// Получаем данные аккаунта пула
+-----+	account, err := c.client.GetAccountInfo(pool.ID)
 -----+	if err != nil {
------+		return fmt.Errorf("failed to get model data account: %w", err)
+-----+		return nil, fmt.Errorf("failed to get pool account: %w", err)
 -----+	}
 -----+
------+	if account == nil || account.Value == nil {
------+		return fmt.Errorf("model data account not found")
+-----+	// Парсим данные в структуру состояния
+-----+	state := &PoolState{
+-----+		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // пример смещения
+-----+		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // пример смещения
+-----+		Status:       account.Data[88],                                // пример смещения
 -----+	}
 -----+
------+	// Здесь можно добавить дополнительную валидацию данных модели
------+	// в зависимости от требований
+-----+	return state, nil
+----- }
+----- 
+------func (c *RaydiumClient) CreateSwapInstructions() ([]solana.Instruction, error) {
+------	// Создание инструкций для свапа
+-----+// TODO:
+-----+// Для полноценной работы нужно добавить:
+-----+// Корректную сериализацию инструкций (согласно протоколу Raydium)
+-----+// Детальную обработку различных типов ошибок
+-----+// Валидацию параметров свапа
+-----+// Обработку разных версий пулов
+-----+// Расчет слиппажа и проверку лимитов
 -----+
------+	return nil
------+}
+-----+// CreateSwapInstructions создает набор инструкций для свапа
+-----+func (c *RaydiumClient) CreateSwapInstructions(params *SwapParams) ([]solana.Instruction, error) {
+-----+	c.logger.Debug("creating swap instructions",
+-----+		zap.String("userWallet", params.UserWallet.String()),
+-----+		zap.Uint64("amountIn", params.AmountIn),
+-----+		zap.Uint64("minAmountOut", params.MinAmountOut),
+-----+	)
 -----+
------+// SetPool устанавливает текущий активный пул
------+func (pm *PoolManager) SetPool(pool *RaydiumV5Pool) {
------+	pm.pool = pool
------+}
+-----+	// Создаем базовый массив инструкций
+-----+	instructions := make([]solana.Instruction, 0)
 -----+
------+// GetPool возвращает текущий активный пул
------+func (pm *PoolManager) GetPool() *RaydiumV5Pool {
------+	return pm.pool
------+}
+-----+	// Создаем инструкцию для установки приоритета комиссии
+-----+	if params.PriorityFeeLamports > 0 {
+-----+		computeBudgetIx := solana.NewInstruction(
+-----+			solana.ComputeBudget,
+-----+			&ComputeBudgetInstruction{
+-----+				Units:         300000, // базовые compute units как в typescript
+-----+				MicroLamports: params.PriorityFeeLamports,
+-----+			},
+-----+		)
+-----+		instructions = append(instructions, computeBudgetIx)
+-----+	}
 -----+
------+// InitializeV5Pool инициализирует пул версии 5 Raydium
------+func (pm *PoolManager) InitializeV5Pool(ctx context.Context, params *RaydiumV5Pool) error {
------+	logger := pm.logger.With(
------+		zap.String("base_mint", params.BaseMint.String()),
------+		zap.String("quote_mint", params.QuoteMint.String()),
------+		zap.String("pnl_owner", params.PnlOwner.String()),
+-----+	// Создаем основную инструкцию свапа
+-----+	swapIx := solana.NewInstruction(
+-----+		solana.MustPublicKeyFromBase58(RAYDIUM_V4_PROGRAM_ID),
+-----+		&SwapInstruction{
+-----+			Amount:     params.AmountIn,
+-----+			MinimumOut: params.MinAmountOut,
+-----+		},
+-----+		// Добавляем необходимые аккаунты
+-----+		[]solana.AccountMeta{
+-----+			{PublicKey: params.Pool.ID, IsWritable: true, IsSigner: false},
+-----+			{PublicKey: params.Pool.Authority, IsWritable: false, IsSigner: false},
+-----+			{PublicKey: params.UserWallet, IsWritable: true, IsSigner: true},
+-----+			{PublicKey: params.SourceTokenAccount, IsWritable: true, IsSigner: false},
+-----+			{PublicKey: params.DestinationTokenAccount, IsWritable: true, IsSigner: false},
+-----+			{PublicKey: params.Pool.BaseVault, IsWritable: true, IsSigner: false},
+-----+			{PublicKey: params.Pool.QuoteVault, IsWritable: true, IsSigner: false},
+-----+			// Добавляем остальные необходимые аккаунты
+-----+		},
 -----+	)
------+	logger.Debug("Initializing new V5 pool")
+-----+	instructions = append(instructions, swapIx)
 -----+
------+	// Проверяем базовые параметры пула
------+	if err := pm.validatePoolParameters(&params.RaydiumPool); err != nil {
------+		return &PoolError{
------+			Stage:   "initialize_v5",
------+			Message: "invalid pool parameters",
------+			Err:     err,
------+		}
+-----+	return instructions, nil
+----- }
+----- 
+------func (c *RaydiumClient) SimulateSwap() error {
+------	// Симуляция свапа
+-----+// SimulateSwap выполняет симуляцию транзакции свапа
+-----+func (c *RaydiumClient) SimulateSwap(params *SwapParams) error {
+-----+	c.logger.Debug("simulating swap transaction")
+-----+
+-----+	// Получаем инструкции для свапа
+-----+	instructions, err := c.CreateSwapInstructions(params)
+-----+	if err != nil {
+-----+		return fmt.Errorf("failed to create swap instructions: %w", err)
 -----+	}
 -----+
------+	// Дополнительная валидация параметров V5
------+	if err := pm.validateV5Parameters(params); err != nil {
------+		return &PoolError{
------+			Stage:   "initialize_v5",
------+			Message: "invalid v5 specific parameters",
------+			Err:     err,
------+		}
+-----+	// Создаем транзакцию
+-----+	recent, err := c.client.GetRecentBlockhash()
+-----+	if err != nil {
+-----+		return fmt.Errorf("failed to get recent blockhash: %w", err)
 -----+	}
 -----+
------+	// Загружаем lookup table если она указана
------+	if err := pm.LoadPoolLookupTable(ctx, &params.RaydiumPool); err != nil {
------+		return err
+-----+	tx := solana.NewTransaction(
+-----+		instructions,
+-----+		recent.Value.Blockhash,
+-----+		solana.TransactionPayer(params.UserWallet),
+-----+	)
+-----+
+-----+	// Симулируем транзакцию
+-----+	sim, err := c.client.SimulateTransaction(tx, &rpc.SimulateTransactionOpts{
+-----+		SigVerify:              false,
+-----+		Commitment:             c.options.commitment,
+-----+		ReplaceRecentBlockhash: true,
+-----+	})
+-----+	if err != nil {
+-----+		return fmt.Errorf("failed to simulate transaction: %w", err)
 -----+	}
 -----+
------+	// Проверяем наличие и валидность model data account
------+	if err := pm.validateModelData(ctx, params.ModelDataId); err != nil {
------+		return &PoolError{
------+			Stage:   "initialize_v5",
------+			Message: "invalid model data account",
------+			Err:     err,
------+		}
+-----+	// Проверяем результат симуляции
+-----+	if sim.Value.Err != nil {
+-----+		return fmt.Errorf("simulation failed: %s", sim.Value.Err)
+-----+	}
+-----+
+-----+	// Анализируем логи симуляции
+-----+	for _, log := range sim.Value.Logs {
+-----+		c.logger.Debug("simulation log", zap.String("log", log))
 -----+	}
 -----+
+-----+	c.logger.Info("swap simulation successful",
+-----+		zap.Uint64("unitsConsumed", sim.Value.UnitsConsumed),
+-----+	)
+-----+
 -----+	return nil
 -----+}
 -----+
------+// validateV5Parameters проверяет специфичные для V5 параметры
------+func (pm *PoolManager) validateV5Parameters(pool *RaydiumV5Pool) error {
------+	if pool.PnlOwner.IsZero() {
------+		return fmt.Errorf("pnl owner cannot be zero")
+-----+// TODO:
+-----+// Основные улучшения, которые можно добавить:
+-----+// Retry логика для случаев временных сбоев
+-----+// Более детальная валидация результатов транзакции
+-----+// Механизм отмены операции по таймауту
+-----+// Сохранение истории транзакций
+-----+// Метрики выполнения свапов
+-----+
+-----+// ExecuteSwap выполняет свап и возвращает signature транзакции
+-----+func (c *RaydiumClient) ExecuteSwap(params *SwapParams) (string, error) {
+-----+	c.logger.Debug("executing swap",
+-----+		zap.String("userWallet", params.UserWallet.String()),
+-----+		zap.Uint64("amountIn", params.AmountIn),
+-----+		zap.Uint64("minAmountOut", params.MinAmountOut),
+-----+	)
+-----+
+-----+	// Сначала симулируем транзакцию
+-----+	if err := c.SimulateSwap(params); err != nil {
+-----+		return "", fmt.Errorf("swap simulation failed: %w", err)
 -----+	}
 -----+
------+	if pool.ModelDataId.IsZero() {
------+		return fmt.Errorf("model data id cannot be zero")
+-----+	// Получаем инструкции для свапа
+-----+	instructions, err := c.CreateSwapInstructions(params)
+-----+	if err != nil {
+-----+		return "", fmt.Errorf("failed to create swap instructions: %w", err)
 -----+	}
 -----+
------+	if pool.MaxOrders == 0 {
------+		return fmt.Errorf("max orders must be greater than zero")
+-----+	// Получаем последний блокхэш
+-----+	recent, err := c.client.GetRecentBlockhash()
+-----+	if err != nil {
+-----+		return "", fmt.Errorf("failed to get recent blockhash: %w", err)
 -----+	}
 -----+
------+	if pool.TickSpacing == 0 {
------+		return fmt.Errorf("tick spacing must be greater than zero")
+-----+	// Создаем транзакцию
+-----+	tx := solana.NewTransaction(
+-----+		instructions,
+-----+		recent.Value.Blockhash,
+-----+		solana.TransactionPayer(params.UserWallet),
+-----+	)
+-----+
+-----+	// Подписываем транзакцию
+-----+	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+-----+		if key.Equals(params.UserWallet) {
+-----+			return &c.client.PrivateKey
+-----+		}
+-----+		return nil
+-----+	})
+-----+	if err != nil {
+-----+		return "", fmt.Errorf("failed to sign transaction: %w", err)
 -----+	}
 -----+
------+	return nil
------+}
+-----+	// Отправляем транзакцию
+-----+	sig, err := c.client.SendTransaction(tx, &rpc.SendTransactionOpts{
+-----+		SkipPreflight:       true,
+-----+		PreflightCommitment: c.options.commitment,
+-----+	})
+-----+	if err != nil {
+-----+		return "", fmt.Errorf("failed to send transaction: %w", err)
+-----+	}
 -----+
------+// UiTokenAmount представляет количество токенов с учетом десятичных знаков
------+type UiTokenAmount struct {
------+	// Точное количество токенов в виде строки для предотвращения потери точности
------+	Amount string `json:"amount"`
+-----+	// Ждем подтверждения транзакции
+-----+	confirmationStrategy := rpc.TransactionConfirmationStrategy{
+-----+		Signature:            sig,
+-----+		Commitment:           c.options.commitment,
+-----+		LastValidBlockHeight: recent.Value.LastValidBlockHeight,
+-----+	}
 -----+
------+	// Количество десятичных знаков токена
------+	Decimals uint8 `json:"decimals"`
+-----+	startTime := time.Now()
+-----+	confirmation, err := c.client.ConfirmTransaction(
+-----+		confirmationStrategy,
+-----+		&rpc.ConfirmTransactionOpts{
+-----+			MaxRetries: c.options.retries,
+-----+			Timeout:    c.options.timeout,
+-----+		},
+-----+	)
+-----+	if err != nil {
+-----+		return sig, fmt.Errorf("failed to confirm transaction: %w", err)
+-----+	}
 -----+
------+	// Форматированное количество токенов с учетом десятичных знаков
------+	UiAmount float64 `json:"uiAmount"`
+-----+	// Проверяем статус подтверждения
+-----+	if confirmation.Value.Err != nil {
+-----+		return sig, fmt.Errorf("transaction confirmed with error: %v", confirmation.Value.Err)
+-----+	}
 -----+
------+	// Форматированное количество в виде строки
------+	UiAmountString string `json:"uiAmountString"`
------+}
+-----+	c.logger.Info("swap executed successfully",
+-----+		zap.String("signature", sig),
+-----+		zap.Duration("duration", time.Since(startTime)),
+-----+	)
 -----+
------+// NewUiTokenAmount создает новый UiTokenAmount
------+func NewUiTokenAmount(amount uint64, decimals uint8) *UiTokenAmount {
------+	// Конвертируем amount в float64 с учетом decimals
------+	uiAmount := float64(amount) / math.Pow10(int(decimals))
+-----+	// Опционально: получаем и логируем новые балансы
+-----+	if err := c.logUpdatedBalances(params); err != nil {
+-----+		c.logger.Warn("failed to get updated balances", zap.Error(err))
+-----+	}
 -----+
------+	return &UiTokenAmount{
------+		Amount:         strconv.FormatUint(amount, 10),
------+		Decimals:       decimals,
------+		UiAmount:       uiAmount,
------+		UiAmountString: fmt.Sprintf("%f", uiAmount),
+-----+	return sig, nil
+----- }
+----- 
+------func (c *RaydiumClient) ExecuteSwap() (string, error) {
+------	// Выполнение свапа
+-----+// logUpdatedBalances вспомогательный метод для логирования балансов после свапа
+-----+func (c *RaydiumClient) logUpdatedBalances(params *SwapParams) error {
+-----+	// Получаем баланс SOL
+-----+	solBalance, err := c.client.GetBalance(
+-----+		params.UserWallet,
+-----+		rpc.CommitmentConfirmed,
+-----+	)
+-----+	if err != nil {
+-----+		return fmt.Errorf("failed to get SOL balance: %w", err)
 -----+	}
------+}
 -----+
------+// ToUint64 конвертирует UiAmount обратно в uint64
------+func (u *UiTokenAmount) ToUint64() (uint64, error) {
------+	return strconv.ParseUint(u.Amount, 10, 64)
------+}
+-----+	// Получаем баланс токена
+-----+	tokenBalance, err := c.client.GetTokenAccountBalance(
+-----+		params.DestinationTokenAccount,
+-----+		rpc.CommitmentConfirmed,
+-----+	)
+-----+	if err != nil {
+-----+		return fmt.Errorf("failed to get token balance: %w", err)
+-----+	}
+-----+
+-----+	c.logger.Info("updated balances",
+-----+		zap.Float64("solBalance", float64(solBalance.Value)/float64(solana.LAMPORTS_PER_SOL)),
+-----+		zap.String("tokenBalance", tokenBalance.Value.UiAmountString),
+-----+	)
+-----+
+-----+	return nil
+----- }
+-----diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
+-----index 330c82d..50959de 100644
+-------- a/internal/dex/raydium/pool.go
+-----+++ b/internal/dex/raydium/pool.go
+-----@@ -2,23 +2,126 @@
+----- package raydium
+----- 
+----- import (
+-----+	"encoding/binary"
+-----+	"fmt"
 -----+
------+// String возвращает строковое представление количества токенов
------+func (u *UiTokenAmount) String() string {
------+	return u.UiAmountString
+-----+	"github.com/gagliardetto/solana-go"
+----- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+----- 	"go.uber.org/zap"
+----- )
+----- 
+-----+type SwapAmounts struct {
+-----+	AmountIn     uint64 // Количество входных токенов
+-----+	AmountOut    uint64 // Ожидаемое количество выходных токенов
+-----+	MinAmountOut uint64 // Минимальное количество выходных токенов с учетом проскальзывания
 -----+}
 -----+
------+// FromDecimals создает UiTokenAmount из количества и decimals
------+func FromDecimals(amount uint64, decimals uint8) *UiTokenAmount {
------+	return NewUiTokenAmount(amount, decimals)
+----- type PoolManager struct {
+----- 	client blockchain.Client
+----- 	logger *zap.Logger
+-----+	pool   *RaydiumPool
 -----+}
 -----+
------+// Parse парсит значение из JSON
------+func (u *UiTokenAmount) UnmarshalJSON(data []byte) error {
------+	// Временная структура для парсинга
------+	type Alias UiTokenAmount
------+	aux := &struct {
------+		Amount         string  `json:"amount"`
------+		Decimals       uint8   `json:"decimals"`
------+		UiAmount       float64 `json:"uiAmount"`
------+		UiAmountString string  `json:"uiAmountString"`
------+	}{}
+-----+// NewPoolManager создает новый менеджер пула
+-----+func NewPoolManager(client blockchain.Client, logger *zap.Logger, pool *RaydiumPool) *PoolManager {
+-----+	return &PoolManager{
+-----+		client: client,
+-----+		logger: logger,
+-----+		pool:   pool,
+-----+	}
+----- }
+----- 
+-----+// TODO: В дальнейшем этот код можно расширить:
+-----+// 1. Добавить более сложную формулу расчета с учетом комиссий
+-----+// 2. Реализовать кэширование состояния пула
+-----+// 3. Добавить больше проверок валидации
+-----+// 4. Улучшить обработку ошибок и логирование
+-----+
+-----+// GetPoolState получает актуальное состояние пула
+----- func (pm *PoolManager) GetPoolState() (*PoolState, error) {
+------	// Получение состояния пула
+-----+	pm.logger.Debug("getting pool state",
+-----+		zap.String("poolId", pm.pool.ID.String()),
+-----+	)
 -----+
------+	if err := json.Unmarshal(data, &aux); err != nil {
------+		return err
+-----+	// Получаем данные аккаунта пула
+-----+	account, err := pm.client.GetAccountInfo(pm.pool.ID)
+-----+	if err != nil {
+-----+		return nil, fmt.Errorf("failed to get pool account: %w", err)
 -----+	}
 -----+
------+	// Просто присваиваем строковые значения
------+	u.Amount = aux.Amount
------+	u.Decimals = aux.Decimals
------+	u.UiAmount = aux.UiAmount
------+	u.UiAmountString = aux.UiAmountString
+-----+	// Парсим данные в структуру состояния
+-----+	state := &PoolState{
+-----+		BaseReserve:  binary.LittleEndian.Uint64(account.Data[64:72]), // резервы base токена
+-----+		QuoteReserve: binary.LittleEndian.Uint64(account.Data[72:80]), // резервы quote токена
+-----+		Status:       account.Data[88],                                // статус пула
+-----+	}
 -----+
------ 	return nil
+-----+	return state, nil
 ----- }
 ----- 
------+// MarshalJSON конвертирует в JSON
------+func (u UiTokenAmount) MarshalJSON() ([]byte, error) {
------+	// Временная структура для маршалинга
------+	return json.Marshal(&struct {
------+		Amount         string  `json:"amount"`
------+		Decimals       uint8   `json:"decimals"`
------+		UiAmount       float64 `json:"uiAmount"`
------+		UiAmountString string  `json:"uiAmountString"`
------+	}{
------+		Amount:         u.Amount,
------+		Decimals:       u.Decimals,
------+		UiAmount:       u.UiAmount,
------+		UiAmountString: u.UiAmountString,
------+	})
------+}
+-----+// CalculateAmounts рассчитывает количество выходных токенов и минимальный выход
+----- func (pm *PoolManager) CalculateAmounts() (*SwapAmounts, error) {
+------	// Расчет amount out и минимального получения
+-----+	// Получаем текущее состояние пула
+-----+	state, err := pm.GetPoolState()
+-----+	if err != nil {
+-----+		return nil, fmt.Errorf("failed to get pool state: %w", err)
+-----+	}
 -----+
------ // Методы для работы с LP токенами
------+// GetLPTokenBalance получает баланс LP токенов для указанного владельца
------ func (pm *PoolManager) GetLPTokenBalance(ctx context.Context, owner solana.PublicKey) (uint64, error) {
-------	// TODO: implement
-------	return 0, nil
------+	if pm.pool == nil {
------+		return 0, &PoolError{
------+			Stage:   "get_lp_balance",
------+			Message: "no active pool set",
------+		}
+-----+	// Проверяем, что пул активен
+-----+	if state.Status != 1 { // предполагаем, что 1 = активный статус
+-----+		return nil, fmt.Errorf("pool is not active")
 -----+	}
 -----+
------+	logger := pm.logger.With(
------+		zap.String("owner", owner.String()),
------+		zap.String("lp_mint", pm.pool.LPMint.String()),
------+	)
------+	logger.Debug("Getting LP token balance")
+-----+	// Расчет по формуле: amountOut = (amountIn * outputReserve) / (inputReserve + amountIn)
+-----+	// Это упрощенная формула для начала
+-----+	amountIn := uint64(1000000) // пример входного количества
+-----+	amountOut := (amountIn * state.QuoteReserve) / (state.BaseReserve + amountIn)
 -----+
------+	// Получаем associated token address для LP токенов
------+	lpTokenATA, _, err := solana.FindAssociatedTokenAddress(owner, pm.pool.LPMint)
------+	if err != nil {
------+		return 0, &PoolError{
------+			Stage:   "get_lp_balance",
------+			Message: "failed to find LP token ATA",
------+			Err:     err,
+-----+	// Учитываем проскальзывание (например, 1%)
+-----+	slippage := uint64(100) // 1%
+-----+	minAmountOut := amountOut - (amountOut * slippage / 10000)
+-----+
+-----+	return &SwapAmounts{
+-----+		AmountIn:     amountIn,
+-----+		AmountOut:    amountOut,
+-----+		MinAmountOut: minAmountOut,
+-----+	}, nil
+----- }
+----- 
+-----+// ValidatePool проверяет валидность параметров пула
+----- func (pm *PoolManager) ValidatePool() error {
+------	// Валидация параметров пула
+-----+	// Проверяем существование всех необходимых аккаунтов
+-----+	accounts := []solana.PublicKey{
+-----+		pm.pool.ID,
+-----+		pm.pool.Authority,
+-----+		pm.pool.BaseMint,
+-----+		pm.pool.QuoteMint,
+-----+		pm.pool.BaseVault,
+-----+		pm.pool.QuoteVault,
+-----+	}
+-----+
+-----+	for _, acc := range accounts {
+-----+		if acc.IsZero() {
+-----+			return fmt.Errorf("invalid pool account: %s is zero", acc.String())
 -----+		}
 -----+	}
 -----+
------+	balance, err := pm.client.GetTokenAccountBalance(
------+		ctx,
------+		lpTokenATA,
------+		rpc.CommitmentConfirmed,
------+	)
+-----+	// Проверяем состояние пула
+-----+	state, err := pm.GetPoolState()
 -----+	if err != nil {
------+		return 0, &PoolError{
------+			Stage:   "get_lp_balance",
------+			Message: "failed to get token balance",
------+			Err:     err,
------+		}
+-----+		return fmt.Errorf("failed to get pool state: %w", err)
 -----+	}
 -----+
------+	if balance == nil || balance.Value == nil {
------+		return 0, nil
+-----+	// Проверяем резервы
+-----+	if state.BaseReserve == 0 || state.QuoteReserve == 0 {
+-----+		return fmt.Errorf("pool reserves are empty: base=%d, quote=%d",
+-----+			state.BaseReserve, state.QuoteReserve)
 -----+	}
 -----+
------+	// Конвертируем строковое значение в uint64
------+	amount, err := strconv.ParseUint(balance.Value.Amount, 10, 64)
------+	if err != nil {
------+		return 0, &PoolError{
------+			Stage:   "get_lp_balance",
------+			Message: "failed to parse token amount",
------+			Err:     err,
------+		}
+-----+	// Проверяем статус
+-----+	if state.Status != 1 { // предполагаем, что 1 = активный статус
+-----+		return fmt.Errorf("pool is not active")
 -----+	}
 -----+
------+	return amount, nil
+-----+	return nil
 ----- }
------ 
------ // Улучшить кэширование в pool.go:
 -----diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
------index 6bb4e16..59aa82b 100644
+-----index 2c184ce..55c2206 100644
 -------- a/internal/dex/raydium/types.go
 -----+++ b/internal/dex/raydium/types.go
------@@ -197,11 +197,6 @@ func (e *SwapError) Unwrap() error {
------ 	return e.Err
------ }
+-----@@ -1,4 +1,4 @@
+------// inernal/dex/raydium - это пакет, который содержит в себе реализацию работы с декстерами Raydium
+-----+// inernal/dex/raydium/types.go - это пакет, который содержит в себе реализацию работы с декстерами Raydium
+----- package raydium
 ----- 
-------// Типы для v5 пулов
-------type RaydiumPoolV5 struct {
-------	// Новые поля v5
-------}
-------
------ // Типы для маркет-мейкинга
------ type MarketMakingParams struct {
------ 	// Параметры для MM
+----- import "github.com/gagliardetto/solana-go"
 -----diff --git a/newdif.txt b/newdif.txt
------index 19f71dd..9baa9ce 100644
+-----index 916f03e..5cdad43 100644
 -------- a/newdif.txt
 -----+++ b/newdif.txt
------@@ -1,5780 +0,0 @@
-------diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
-------index eafb611..612da49 100644
---------- a/internal/dex/raydium/client.go
-------+++ b/internal/dex/raydium/client.go
-------@@ -5,6 +5,7 @@ import (
+-----@@ -1,6213 +0,0 @@
+------diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
+------index 45d076b..0355dc0 100644
+--------- a/internal/blockchain/types.go
+------+++ b/internal/blockchain/types.go
+------@@ -48,4 +48,5 @@ type Client interface {
+------ 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
+------ 	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
+------ 	GetRpcClient() *rpc.Client
+------+	GetTokenAccountBalance(ctx context.Context, account solana.PublicKey, commitment rpc.CommitmentType) (*rpc.GetTokenAccountBalanceResult, error)
+------ }
+------diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
+------index 26e8e25..8ff9022 100644
+--------- a/internal/dex/raydium/pool.go
+------+++ b/internal/dex/raydium/pool.go
+------@@ -3,13 +3,16 @@ package raydium
+------ 
+------ import (
 ------ 	"context"
------- 	"encoding/binary"
+------+	"encoding/json"
 ------ 	"fmt"
-------+	"sync"
+------ 	"math"
+------ 	"math/big"
+------+	"strconv"
 ------ 	"time"
 ------ 
 ------ 	"github.com/gagliardetto/solana-go"
-------@@ -13,9 +14,15 @@ import (
------- 	"github.com/gagliardetto/solana-go/rpc"
------- 	"github.com/gagliardetto/solana-go/rpc/jsonrpc"
+------ 	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
+------+	"github.com/gagliardetto/solana-go/rpc"
 ------ 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
-------+	"github.com/rovshanmuradov/solana-bot/internal/eventlistener"
 ------ 	"go.uber.org/zap"
 ------ )
------- 
-------+// TODO: client.go:
-------+// - Добавить метод для batch-запросов GetMultiplePools
-------+// - Реализовать интерфейс для работы с WebSocket
-------+// - Добавить кэширование с TTL для пулов
-------+
------- const (
------- 	maxRetries          = 3
------- 	retryDelay          = 500 * time.Millisecond
-------@@ -28,6 +35,9 @@ type clientOptions struct {
------- 	timeout         time.Duration
------- 	retries         int
------- 	commitmentLevel rpc.CommitmentType
-------+
-------+	cacheLifetime time.Duration
-------+	wsURL         string
------- }
------- 
------- // ClientOption определяет функцию для настройки клиента
-------@@ -68,6 +78,16 @@ type RaydiumClient struct {
------- 	client  blockchain.Client
------- 	logger  *zap.Logger
------- 	options *clientOptions
-------+
-------+	// Добавляем поля для кэширования
-------+	poolCache     map[string]*poolCacheEntry
-------+	cacheMutex    sync.RWMutex
-------+	cacheLifetime time.Duration
-------+
-------+	// Добавляем поля для WebSocket
-------+	eventListener *eventlistener.EventListener
-------+	subscribers   map[string][]chan PoolUpdate
-------+	subMutex      sync.RWMutex
+------@@ -23,6 +26,7 @@ import (
+------ type PoolManager struct {
+------ 	client blockchain.Client
+------ 	logger *zap.Logger
+------+	pool   *RaydiumV5Pool // Текущий активный пул
 ------ }
 ------ 
------- // NewRaydiumClient создает новый экземпляр клиента с опциями
-------@@ -84,11 +104,23 @@ func NewRaydiumClient(client blockchain.Client, logger *zap.Logger, opts ...Clie
------- 		opt(options)
+------ // NewPoolManager создает новый менеджер пула
+------@@ -30,6 +34,7 @@ func NewPoolManager(client blockchain.Client, logger *zap.Logger) *PoolManager {
+------ 	return &PoolManager{
+------ 		client: client,
+------ 		logger: logger.Named("pool-manager"),
+------+		pool:   nil,
 ------ 	}
------- 
--------	return &RaydiumClient{
--------		client:  client,
--------		logger:  logger.Named("raydium-client"),
--------		options: options,
--------	}, nil
-------+	rc := &RaydiumClient{
-------+		client:        client,
-------+		logger:        logger.Named("raydium-client"),
-------+		options:       options,
-------+		poolCache:     make(map[string]*poolCacheEntry),
-------+		cacheLifetime: options.cacheLifetime,
-------+		subscribers:   make(map[string][]chan PoolUpdate),
-------+	}
-------+
-------+	// Инициализируем WebSocket если указан URL
-------+	if options.wsURL != "" {
-------+		if err := rc.initWebSocket(options.wsURL); err != nil {
-------+			return nil, fmt.Errorf("failed to initialize websocket: %w", err)
-------+		}
-------+	}
-------+
-------+	return rc, nil
 ------ }
 ------ 
------- // GetPool получает информацию о пуле по его ID
-------@@ -96,34 +128,37 @@ func (c *RaydiumClient) GetPool(ctx context.Context, poolID solana.PublicKey) (*
------- 	logger := c.logger.With(zap.String("pool_id", poolID.String()))
------- 	logger.Debug("Getting pool information")
------- 
--------	ctx, cancel := context.WithTimeout(ctx, c.options.timeout)
--------	defer cancel()
--------
--------	account, err := c.client.GetAccountInfo(ctx, poolID)
--------	if err != nil {
--------		return nil, &SwapError{
--------			Stage:   "get_pool",
--------			Message: "failed to get pool account",
--------			Err:     err,
--------		}
-------+	// Проверяем кэш первым делом
-------+	if entry, ok := c.getCached(poolID.String()); ok {
-------+		logger.Debug("Pool found in cache")
-------+		return entry.pool, nil
------- 	}
+------@@ -331,27 +336,349 @@ func (pc *PoolCalculator) GetMarketPrice() float64 {
+------ 	return (quoteF / quoteDecimalAdj) / (baseF / baseDecimalAdj)
+------ }
 ------ 
--------	if account.Value == nil || len(account.Value.Data.GetBinary()) == 0 {
--------		return nil, &SwapError{
--------			Stage:   "get_pool",
--------			Message: "pool account not found or empty",
--------		}
--------	}
+-------// Добавить в pool.go:
+------+// RaydiumV5Pool представляет пул Raydium версии 5
+------ type RaydiumV5Pool struct {
+-------	RaydiumPool
+-------	PnlOwner    solana.PublicKey
+-------	ModelDataId solana.PublicKey
+-------	RecentRoot  *big.Int
+-------	MaxOrders   uint64
+-------	OrderStates []*big.Int
+-------	TickSpacing uint16
+-------}
 -------
--------	pool := &RaydiumPool{
--------		ID: poolID,
-------+	// Если нет в кэше, получаем из блокчейна
-------+	pool, err := c.fetchPoolFromChain(ctx, poolID)
-------+	if err != nil {
-------+		return nil, err
------- 	}
------- 
--------	if err := c.decodePoolData(account.Value.Data.GetBinary(), pool); err != nil {
--------		return nil, &SwapError{
--------			Stage:   "get_pool",
--------			Message: "failed to decode pool data",
--------			Err:     err,
-------+	// Получаем актуальное состояние
-------+	state, err := c.GetPoolState(ctx, pool)
-------+	if err != nil {
-------+		logger.Warn("Failed to get pool state", zap.Error(err))
-------+		// Продолжаем без состояния
-------+	} else {
-------+		// Обновляем кэш с состоянием
-------+		c.updateCache(poolID.String(), pool, state)
-------+	}
+-------// Методы для работы с v5 пулами
+-------func (pm *PoolManager) InitializeV5Pool(ctx context.Context, params *RaydiumPoolV5) error {
+-------	// TODO: implement
+------+	RaydiumPool // Встраиваем базовую структуру пула
 ------+
-------+	// Подписываемся на обновления пула через WebSocket, если есть слушатель
-------+	if c.eventListener != nil {
-------+		if _, exists := c.subscribers[poolID.String()]; !exists {
-------+			updates := make(chan PoolUpdate, 100)
-------+			c.subMutex.Lock()
-------+			c.subscribers[poolID.String()] = append(c.subscribers[poolID.String()], updates)
-------+			c.subMutex.Unlock()
+------+	// Основные параметры V5
+------+	PnlOwner    solana.PublicKey // Владелец PnL (Profit and Loss)
+------+	ModelDataId solana.PublicKey // ID модели данных пула
+------+	RecentRoot  *big.Int         // Последний корневой хеш состояния пула
+------+	MaxOrders   uint64           // Максимальное количество ордеров
+------+	OrderStates []*big.Int       // Состояния ордеров
+------+	TickSpacing uint16           // Шаг тиков цены
 ------+
-------+			logger.Debug("Subscribed to pool updates via WebSocket")
------- 		}
------- 	}
------- 
-------@@ -592,3 +627,112 @@ func (c *RaydiumClient) GetPoolLookupTable(
------- 
------- 	return result, nil
------- }
+------+	// Дополнительные параметры V5
+------+	LPMint       solana.PublicKey    // Минт LP токенов
+------+	AdminKey     solana.PublicKey    // Ключ администратора пула
+------+	ConfigParams V5ConfigParams      // Параметры конфигурации
+------+	FeeAccounts  V5FeeAccounts       // Аккаунты для комиссий
+------+	PoolState    V5PoolState         // Состояние пула
+------+	PriceHistory []PriceHistoryPoint // История цен
+------+}
 ------+
-------+// Реализуем метод для получения множества пулов
-------+func (c *RaydiumClient) GetMultiplePools(ctx context.Context, poolIDs []solana.PublicKey) ([]*RaydiumPool, error) {
-------+	logger := c.logger.With(zap.Int("pool_count", len(poolIDs)))
-------+	logger.Debug("Getting multiple pools")
+------+// V5ConfigParams содержит параметры конфигурации пула V5
+------+type V5ConfigParams struct {
+------+	MinPriceRatio  *big.Int // Минимальное соотношение цен
+------+	MaxPriceRatio  *big.Int // Максимальное соотношение цен
+------+	MinBaseAmount  uint64   // Минимальное количество базового токена
+------+	MinQuoteAmount uint64   // Минимальное количество котируемого токена
+------+	MaxSlippageBps uint16   // Максимальный проскальзывание в базисных пунктах
+------+	MaxLeverage    uint16   // Максимальное плечо
+------+	ProtocolFee    uint16   // Комиссия протокола в базисных пунктах
+------+	MinOrderSize   uint64   // Минимальный размер ордера
+------+}
 ------+
-------+	type poolResult struct {
-------+		pool *RaydiumPool
-------+		err  error
-------+		idx  int
-------+	}
+------+// V5FeeAccounts содержит аккаунты для комиссий
+------+type V5FeeAccounts struct {
+------+	ProtocolFeeAccount solana.PublicKey // Аккаунт для комиссий протокола
+------+	TraderFeeAccount   solana.PublicKey // Аккаунт для комиссий трейдера
+------+	LPFeeAccount       solana.PublicKey // Аккаунт для комиссий провайдеров ликвидности
+------+}
 ------+
-------+	// Создаем каналы для результатов и ошибок
-------+	results := make(chan poolResult, len(poolIDs))
-------+	semaphore := make(chan struct{}, 10) // Ограничиваем параллельные запросы
+------+// V5PoolState содержит текущее состояние пула
+------+type V5PoolState struct {
+------+	BaseReserve     uint64     // Резерв базового токена
+------+	QuoteReserve    uint64     // Резерв котируемого токена
+------+	LPSupply        uint64     // Общее предложение LP токенов
+------+	LastUpdateSlot  uint64     // Слот последнего обновления
+------+	SwapEnabled     bool       // Включен ли свап
+------+	PriceMultiplier *big.Int   // Мультипликатор цены
+------+	CurrentPrice    *big.Float // Текущая цена
+------+	TVL             *big.Float // Total Value Locked
+------+}
 ------+
-------+	// Запускаем горутины для получения пулов
-------+	for i, poolID := range poolIDs {
-------+		go func(index int, id solana.PublicKey) {
-------+			semaphore <- struct{}{}        // Захватываем слот
-------+			defer func() { <-semaphore }() // Освобождаем слот
+------+// PriceHistoryPoint представляет точку в истории цен
+------+type PriceHistoryPoint struct {
+------+	Timestamp time.Time  // Временная метка
+------+	Price     *big.Float // Цена
+------+	Volume    uint64     // Объем
+------+}
 ------+
-------+			// Проверяем кэш
-------+			if entry, ok := c.getCached(id.String()); ok {
-------+				results <- poolResult{pool: entry.pool, idx: index}
-------+				return
-------+			}
+------+// Методы для работы с V5Pool
 ------+
-------+			// Если нет в кэше, получаем из блокчейна
-------+			pool, err := c.fetchPoolFromChain(ctx, id)
-------+			results <- poolResult{pool: pool, err: err, idx: index}
-------+		}(i, poolID)
+------+// NewRaydiumV5Pool создает новый экземпляр V5 пула
+------+func NewRaydiumV5Pool(baseParams *RaydiumPool) *RaydiumV5Pool {
+------+	return &RaydiumV5Pool{
+------+		RaydiumPool: *baseParams,
+------+		ConfigParams: V5ConfigParams{
+------+			MinPriceRatio: new(big.Int),
+------+			MaxPriceRatio: new(big.Int),
+------+		},
+------+		PoolState: V5PoolState{
+------+			PriceMultiplier: new(big.Int),
+------+			CurrentPrice:    new(big.Float),
+------+			TVL:             new(big.Float),
+------+		},
+------+		PriceHistory: make([]PriceHistoryPoint, 0),
 ------+	}
+------+}
+------+
+------+// GetCurrentState возвращает текущее состояние пула
+------+func (p *RaydiumV5Pool) GetCurrentState() V5PoolState {
+------+	return p.PoolState
+------+}
 ------+
-------+	// Собираем результаты
-------+	pools := make([]*RaydiumPool, len(poolIDs))
-------+	var errors []error
+------+// UpdateState обновляет состояние пула
+------+func (p *RaydiumV5Pool) UpdateState(newState V5PoolState) {
+------+	p.PoolState = newState
+------+	// Добавляем точку в историю цен
+------+	p.PriceHistory = append(p.PriceHistory, PriceHistoryPoint{
+------+		Timestamp: time.Now(),
+------+		Price:     newState.CurrentPrice,
+------+		Volume:    0, // Нужно добавить расчет объема
+------+	})
+------+}
 ------+
-------+	for i := 0; i < len(poolIDs); i++ {
-------+		select {
-------+		case <-ctx.Done():
-------+			return nil, ctx.Err()
-------+		case result := <-results:
-------+			if result.err != nil {
-------+				errors = append(errors, fmt.Errorf("pool %s: %w", poolIDs[result.idx], result.err))
-------+				continue
-------+			}
-------+			pools[result.idx] = result.pool
+------+// GetFeeAccounts возвращает аккаунты для комиссий
+------+func (p *RaydiumV5Pool) GetFeeAccounts() V5FeeAccounts {
+------+	return p.FeeAccounts
+------+}
 ------+
-------+			// Получаем состояние и обновляем кэш асинхронно
-------+			go func(p *RaydiumPool) {
-------+				if state, err := c.GetPoolState(ctx, p); err == nil {
-------+					c.updateCache(p.ID.String(), p, state)
-------+				}
-------+			}(result.pool)
-------+		}
+------+// IsSwapEnabled проверяет, включен ли свап в пуле
+------+func (p *RaydiumV5Pool) IsSwapEnabled() bool {
+------+	return p.PoolState.SwapEnabled
+------+}
+------+
+------+// GetTVL возвращает Total Value Locked
+------+func (p *RaydiumV5Pool) GetTVL() *big.Float {
+------+	return p.PoolState.TVL
+------+}
+------+
+------+// Вспомогательный метод для валидации model data
+------+func (pm *PoolManager) validateModelData(ctx context.Context, modelDataId solana.PublicKey) error {
+------+	if modelDataId.IsZero() {
+------+		return fmt.Errorf("model data ID cannot be zero")
+------+	}
+------+
+------+	// Проверяем существование аккаунта
+------+	account, err := pm.client.GetAccountInfo(ctx, modelDataId)
+------+	if err != nil {
+------+		return fmt.Errorf("failed to get model data account: %w", err)
 ------+	}
 ------+
-------+	// Если есть ошибки, но получили хотя бы один пул
-------+	if len(errors) > 0 && len(errors) < len(poolIDs) {
-------+		logger.Warn("Some pools failed to load",
-------+			zap.Int("error_count", len(errors)),
-------+			zap.Errors("errors", errors))
-------+	} else if len(errors) == len(poolIDs) {
-------+		// Если все запросы завершились с ошибкой
-------+		return nil, fmt.Errorf("all pool requests failed: %v", errors)
+------+	if account == nil || account.Value == nil {
+------+		return fmt.Errorf("model data account not found")
 ------+	}
 ------+
-------+	logger.Debug("Successfully retrieved pools",
-------+		zap.Int("success_count", len(poolIDs)-len(errors)))
+------+	// Здесь можно добавить дополнительную валидацию данных модели
+------+	// в зависимости от требований
+------+
+------+	return nil
+------+}
 ------+
-------+	return pools, nil
+------+// SetPool устанавливает текущий активный пул
+------+func (pm *PoolManager) SetPool(pool *RaydiumV5Pool) {
+------+	pm.pool = pool
 ------+}
 ------+
-------+// Реализуем вспомогательный метод для получения пула из блокчейна
-------+func (c *RaydiumClient) fetchPoolFromChain(ctx context.Context, poolID solana.PublicKey) (*RaydiumPool, error) {
-------+	ctx, cancel := context.WithTimeout(ctx, c.options.timeout)
-------+	defer cancel()
+------+// GetPool возвращает текущий активный пул
+------+func (pm *PoolManager) GetPool() *RaydiumV5Pool {
+------+	return pm.pool
+------+}
 ------+
-------+	account, err := c.client.GetAccountInfo(ctx, poolID)
-------+	if err != nil {
-------+		return nil, &SwapError{
-------+			Stage:   "get_pool",
-------+			Message: "failed to get pool account",
+------+// InitializeV5Pool инициализирует пул версии 5 Raydium
+------+func (pm *PoolManager) InitializeV5Pool(ctx context.Context, params *RaydiumV5Pool) error {
+------+	logger := pm.logger.With(
+------+		zap.String("base_mint", params.BaseMint.String()),
+------+		zap.String("quote_mint", params.QuoteMint.String()),
+------+		zap.String("pnl_owner", params.PnlOwner.String()),
+------+	)
+------+	logger.Debug("Initializing new V5 pool")
+------+
+------+	// Проверяем базовые параметры пула
+------+	if err := pm.validatePoolParameters(&params.RaydiumPool); err != nil {
+------+		return &PoolError{
+------+			Stage:   "initialize_v5",
+------+			Message: "invalid pool parameters",
 ------+			Err:     err,
 ------+		}
 ------+	}
 ------+
-------+	if account.Value == nil || len(account.Value.Data.GetBinary()) == 0 {
-------+		return nil, &SwapError{
-------+			Stage:   "get_pool",
-------+			Message: "pool account not found or empty",
+------+	// Дополнительная валидация параметров V5
+------+	if err := pm.validateV5Parameters(params); err != nil {
+------+		return &PoolError{
+------+			Stage:   "initialize_v5",
+------+			Message: "invalid v5 specific parameters",
+------+			Err:     err,
 ------+		}
 ------+	}
 ------+
-------+	pool := &RaydiumPool{
-------+		ID: poolID,
+------+	// Загружаем lookup table если она указана
+------+	if err := pm.LoadPoolLookupTable(ctx, &params.RaydiumPool); err != nil {
+------+		return err
 ------+	}
 ------+
-------+	if err := c.decodePoolData(account.Value.Data.GetBinary(), pool); err != nil {
-------+		return nil, &SwapError{
-------+			Stage:   "get_pool",
-------+			Message: "failed to decode pool data",
+------+	// Проверяем наличие и валидность model data account
+------+	if err := pm.validateModelData(ctx, params.ModelDataId); err != nil {
+------+		return &PoolError{
+------+			Stage:   "initialize_v5",
+------+			Message: "invalid model data account",
 ------+			Err:     err,
 ------+		}
 ------+	}
 ------+
-------+	return pool, nil
-------+}
-------diff --git a/internal/dex/raydium/instruction.go b/internal/dex/raydium/instruction.go
-------index f8f7886..82754f9 100644
---------- a/internal/dex/raydium/instruction.go
-------+++ b/internal/dex/raydium/instruction.go
-------@@ -12,6 +12,10 @@ import (
------- 	"go.uber.org/zap"
------- )
------- 
-------+//TODO:instruction.go:
-------+//- Упростить BuildSwapInstruction, вынести часть логики в отдельные методы
-------+// - Добавить поддержку batch-инструкций
-------+
------- // InstructionType определяет тип инструкции Raydium
------- type InstructionType uint8
------- 
-------diff --git a/internal/dex/raydium/order_book.go b/internal/dex/raydium/order_book.go
-------index 6bc8459..4e5d4d0 100644
---------- a/internal/dex/raydium/order_book.go
-------+++ b/internal/dex/raydium/order_book.go
-------@@ -13,6 +13,10 @@ import (
------- 	"go.uber.org/zap"
------- )
------- 
-------+// TODO: order_book.go:
-------+// - Упростить структуру, использовать более эффективные структуры данных
-------+// - Добавить методы для работы с orderbook snapshots
-------+
------- // Константы для Serum OrderBook
------- const (
------- 	ORDER_BOOK_LAYOUT_SIZE = 5132
-------diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
-------index 2dcdd64..26e8e25 100644
---------- a/internal/dex/raydium/pool.go
-------+++ b/internal/dex/raydium/pool.go
-------@@ -6,6 +6,7 @@ import (
------- 	"fmt"
------- 	"math"
------- 	"math/big"
-------+	"time"
------- 
------- 	"github.com/gagliardetto/solana-go"
------- 	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
-------@@ -13,6 +14,11 @@ import (
------- 	"go.uber.org/zap"
------- )
------- 
-------+// TODO: pool.go
-------+// - Добавить поддержку новых типов пулов
-------+// - Реализовать методы для работы с concentrated liquidity
-------+// - Добавить методы для анализа ликвидности
-------+
------- // PoolManager управляет операциями с пулом ликвидности
------- type PoolManager struct {
------- 	client blockchain.Client
-------@@ -347,3 +353,29 @@ func (pm *PoolManager) GetLPTokenBalance(ctx context.Context, owner solana.Publi
------- 	// TODO: implement
------- 	return 0, nil
------- }
-------+
-------+// Улучшить кэширование в pool.go:
-------+type PoolCache struct {
-------+	pool      *RaydiumPool
-------+	state     *PoolState
-------+	updatedAt time.Time
-------+	ttl       time.Duration
+------+	return nil
 ------+}
 ------+
-------+// Добавить методы для анализа ликвидности:
+------+// validateV5Parameters проверяет специфичные для V5 параметры
+------+func (pm *PoolManager) validateV5Parameters(pool *RaydiumV5Pool) error {
+------+	if pool.PnlOwner.IsZero() {
+------+		return fmt.Errorf("pnl owner cannot be zero")
+------+	}
 ------+
-------+func (p *PoolManager) GetLiquidityDepth(ctx context.Context, pool *RaydiumPool) (*LiquidityDepth, error) {
-------+	// TODO: реализовать
-------+	return nil, nil
-------+}
+------+	if pool.ModelDataId.IsZero() {
+------+		return fmt.Errorf("model data id cannot be zero")
+------+	}
 ------+
-------+// Реализовать concentrated liquidity:
+------+	if pool.MaxOrders == 0 {
+------+		return fmt.Errorf("max orders must be greater than zero")
+------+	}
 ------+
-------+type ConcentratedLiquidityPool struct {
-------+	// TODO: определить структуру
-------+}
+------+	if pool.TickSpacing == 0 {
+------+		return fmt.Errorf("tick spacing must be greater than zero")
+------+	}
 ------+
-------+func (p *PoolManager) InitializeConcentratedPool(ctx context.Context, params *ConcentratedPoolParams) error {
-------+	// TODO: реализовать
 ------+	return nil
 ------+}
-------diff --git a/internal/dex/raydium/state.go b/internal/dex/raydium/state.go
-------index cff0664..ed5730d 100644
---------- a/internal/dex/raydium/state.go
-------+++ b/internal/dex/raydium/state.go
-------@@ -10,6 +10,10 @@ import (
------- 	"go.uber.org/zap"
------- )
------- 
-------+// TODO: stage.go:
-------+// - Добавить поддержку сериализации/десериализации для всех версий
-------+// - Улучшить валидацию состояний
 ------+
------- // StateVersion определяет версию структуры состояния
------- type StateVersion uint8
------- 
-------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
-------index 6100e4c..6bb4e16 100644
---------- a/internal/dex/raydium/types.go
-------+++ b/internal/dex/raydium/types.go
-------@@ -11,6 +11,10 @@ import (
------- 	"go.uber.org/zap"
------- )
------- 
-------+// TODO: types.go
-------+// - Добавить типы для новых функций
-------+// - Расширить интерфейсы для поддержки новых операций
+------+// UiTokenAmount представляет количество токенов с учетом десятичных знаков
+------+type UiTokenAmount struct {
+------+	// Точное количество токенов в виде строки для предотвращения потери точности
+------+	Amount string `json:"amount"`
 ------+
------- // Layout константы для правильного чтения данных из аккаунта пула
------- const (
------- 	// Базовые смещения
-------diff --git a/internal/dex/raydium/utils.go b/internal/dex/raydium/utils.go
-------index 104cc1d..57438ca 100644
---------- a/internal/dex/raydium/utils.go
-------+++ b/internal/dex/raydium/utils.go
-------@@ -11,6 +11,7 @@ import (
------- 	"time"
------- 
------- 	"github.com/gagliardetto/solana-go"
-------+	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
------- 	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
------- 	token "github.com/gagliardetto/solana-go/programs/token"
------- 	"github.com/shopspring/decimal"
-------@@ -19,6 +20,10 @@ import (
------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
------- )
------- 
-------+// TODO: utils.go
-------+// - Добавить больше helpers для работы с числами
-------+// - Оптимизировать конвертации между типами
+------+	// Количество десятичных знаков токена
+------+	Decimals uint8 `json:"decimals"`
 ------+
------- // TokenAmountConfig содержит конфигурацию для работы с суммами токенов
------- type TokenAmountConfig struct {
------- 	Amount   uint64
-------@@ -311,14 +316,110 @@ func ConvertBigFloatToUint64(value *big.Float) (uint64, error) {
------- }
------- 
------- // Утилиты для версионированных транзакций
--------// TODO: Implement the method logic
--------func CreateVersionedTransaction(instructions []solana.Instruction, lookupTables []solana.AddressLookupTable) (*solana.VersionedTransaction, error) {
--------	// Создаем транзакцию
--------	return nil, nil
-------+// В начале файла добавим структуру для V5 комиссий
-------+type V5FeeParams struct {
-------+	BaseFee     uint64 // Базовая комиссия
-------+	MaxFee      uint64 // Максимальная комиссия
-------+	AmmFee      uint16 // Комиссия AMM в базовых пунктах
-------+	PriceImpact uint16 // Максимальное влияние на цену в базовых пунктах
------- }
------- 
--------// Утилиты для работы с новыми комиссиями
--------// TODO: Implement the method logic
-------+// CreateVersionedTransaction создает транзакцию с поддержкой lookup tables
-------+func CreateVersionedTransaction(
-------+	instructions []solana.Instruction,
-------+	lookupTables map[solana.PublicKey]solana.PublicKeySlice,
-------+) (*solana.Transaction, error) {
-------+	if len(instructions) == 0 {
-------+		return nil, fmt.Errorf("no instructions provided")
-------+	}
+------+	// Форматированное количество токенов с учетом десятичных знаков
+------+	UiAmount float64 `json:"uiAmount"`
 ------+
-------+	// Создаем билдер транзакции
-------+	tx := solana.NewTransactionBuilder()
+------+	// Форматированное количество в виде строки
+------+	UiAmountString string `json:"uiAmountString"`
+------+}
 ------+
-------+	// Добавляем все инструкции
-------+	for _, instruction := range instructions {
-------+		tx.AddInstruction(instruction)
-------+	}
+------+// NewUiTokenAmount создает новый UiTokenAmount
+------+func NewUiTokenAmount(amount uint64, decimals uint8) *UiTokenAmount {
+------+	// Конвертируем amount в float64 с учетом decimals
+------+	uiAmount := float64(amount) / math.Pow10(int(decimals))
 ------+
-------+	// Если есть lookup tables, добавляем их через опцию
-------+	if len(lookupTables) > 0 {
-------+		tx.WithOpt(solana.TransactionAddressTables(lookupTables))
+------+	return &UiTokenAmount{
+------+		Amount:         strconv.FormatUint(amount, 10),
+------+		Decimals:       decimals,
+------+		UiAmount:       uiAmount,
+------+		UiAmountString: fmt.Sprintf("%f", uiAmount),
 ------+	}
+------+}
 ------+
-------+	// Строим транзакцию
-------+	transaction, err := tx.Build()
-------+	if err != nil {
-------+		return nil, fmt.Errorf("failed to build transaction: %w", err)
-------+	}
+------+// ToUint64 конвертирует UiAmount обратно в uint64
+------+func (u *UiTokenAmount) ToUint64() (uint64, error) {
+------+	return strconv.ParseUint(u.Amount, 10, 64)
+------+}
 ------+
-------+	return transaction, nil
+------+// String возвращает строковое представление количества токенов
+------+func (u *UiTokenAmount) String() string {
+------+	return u.UiAmountString
 ------+}
 ------+
-------+// CalculateV5Fees вычисляет комиссии для V5 пулов
------- func CalculateV5Fees(amount uint64, feeParams V5FeeParams) uint64 {
--------	return 0
-------+	// Базовая комиссия всегда взимается
-------+	totalFee := feeParams.BaseFee
+------+// FromDecimals создает UiTokenAmount из количества и decimals
+------+func FromDecimals(amount uint64, decimals uint8) *UiTokenAmount {
+------+	return NewUiTokenAmount(amount, decimals)
+------+}
 ------+
-------+	// Добавляем комиссию AMM
-------+	ammFee := new(big.Float).SetUint64(amount)
-------+	ammFee = ammFee.Mul(ammFee, new(big.Float).SetFloat64(float64(feeParams.AmmFee)/10000.0))
-------+	ammFeeUint, _ := ammFee.Uint64()
-------+	totalFee += ammFeeUint
+------+// Parse парсит значение из JSON
+------+func (u *UiTokenAmount) UnmarshalJSON(data []byte) error {
+------+	// Временная структура для парсинга
+------+	type Alias UiTokenAmount
+------+	aux := &struct {
+------+		Amount         string  `json:"amount"`
+------+		Decimals       uint8   `json:"decimals"`
+------+		UiAmount       float64 `json:"uiAmount"`
+------+		UiAmountString string  `json:"uiAmountString"`
+------+	}{}
 ------+
-------+	// Добавляем влияние на цену, если оно есть
-------+	if feeParams.PriceImpact > 0 {
-------+		priceImpactFee := new(big.Float).SetUint64(amount)
-------+		priceImpactFee = priceImpactFee.Mul(priceImpactFee, new(big.Float).SetFloat64(float64(feeParams.PriceImpact)/10000.0))
-------+		priceImpactFeeUint, _ := priceImpactFee.Uint64()
-------+		totalFee += priceImpactFeeUint
+------+	if err := json.Unmarshal(data, &aux); err != nil {
+------+		return err
 ------+	}
 ------+
-------+	// Проверяем, не превышает ли общая комиссия максимальную
-------+	if totalFee > feeParams.MaxFee {
-------+		return feeParams.MaxFee
-------+	}
+------+	// Просто присваиваем строковые значения
+------+	u.Amount = aux.Amount
+------+	u.Decimals = aux.Decimals
+------+	u.UiAmount = aux.UiAmount
+------+	u.UiAmountString = aux.UiAmountString
 ------+
-------+	return totalFee
+------ 	return nil
+------ }
+------ 
+------+// MarshalJSON конвертирует в JSON
+------+func (u UiTokenAmount) MarshalJSON() ([]byte, error) {
+------+	// Временная структура для маршалинга
+------+	return json.Marshal(&struct {
+------+		Amount         string  `json:"amount"`
+------+		Decimals       uint8   `json:"decimals"`
+------+		UiAmount       float64 `json:"uiAmount"`
+------+		UiAmountString string  `json:"uiAmountString"`
+------+	}{
+------+		Amount:         u.Amount,
+------+		Decimals:       u.Decimals,
+------+		UiAmount:       u.UiAmount,
+------+		UiAmountString: u.UiAmountString,
+------+	})
 ------+}
 ------+
-------+// Вспомогательная функция для получения состояния lookup table
-------+func GetAddressLookupTableState(
-------+	ctx context.Context,
-------+	client blockchain.Client,
-------+	tableAddress solana.PublicKey,
-------+) (*addresslookuptable.AddressLookupTableState, error) {
-------+	// Получаем RPC клиент из blockchain.Client
-------+	rpcClient := client.GetRpcClient()
+------ // Методы для работы с LP токенами
+------+// GetLPTokenBalance получает баланс LP токенов для указанного владельца
+------ func (pm *PoolManager) GetLPTokenBalance(ctx context.Context, owner solana.PublicKey) (uint64, error) {
+-------	// TODO: implement
+-------	return 0, nil
+------+	if pm.pool == nil {
+------+		return 0, &PoolError{
+------+			Stage:   "get_lp_balance",
+------+			Message: "no active pool set",
+------+		}
+------+	}
 ------+
-------+	// Получаем состояние lookup table
-------+	state, err := addresslookuptable.GetAddressLookupTable(
-------+		ctx,
-------+		rpcClient,
-------+		tableAddress,
+------+	logger := pm.logger.With(
+------+		zap.String("owner", owner.String()),
+------+		zap.String("lp_mint", pm.pool.LPMint.String()),
 ------+	)
+------+	logger.Debug("Getting LP token balance")
+------+
+------+	// Получаем associated token address для LP токенов
+------+	lpTokenATA, _, err := solana.FindAssociatedTokenAddress(owner, pm.pool.LPMint)
 ------+	if err != nil {
-------+		return nil, fmt.Errorf("failed to get lookup table state: %w", err)
+------+		return 0, &PoolError{
+------+			Stage:   "get_lp_balance",
+------+			Message: "failed to find LP token ATA",
+------+			Err:     err,
+------+		}
 ------+	}
 ------+
-------+	return state, nil
-------+}
+------+	balance, err := pm.client.GetTokenAccountBalance(
+------+		ctx,
+------+		lpTokenATA,
+------+		rpc.CommitmentConfirmed,
+------+	)
+------+	if err != nil {
+------+		return 0, &PoolError{
+------+			Stage:   "get_lp_balance",
+------+			Message: "failed to get token balance",
+------+			Err:     err,
+------+		}
+------+	}
 ------+
-------+// Вспомогательная функция для подготовки lookup tables к транзакции
-------+func PrepareLookupTables(
-------+	ctx context.Context,
-------+	client blockchain.Client,
-------+	tableAddresses []solana.PublicKey,
-------+) (map[solana.PublicKey]solana.PublicKeySlice, error) {
-------+	lookupTables := make(map[solana.PublicKey]solana.PublicKeySlice)
+------+	if balance == nil || balance.Value == nil {
+------+		return 0, nil
+------+	}
 ------+
-------+	for _, tableAddr := range tableAddresses {
-------+		state, err := GetAddressLookupTableState(ctx, client, tableAddr)
-------+		if err != nil {
-------+			return nil, fmt.Errorf("failed to prepare lookup table %s: %w", tableAddr, err)
+------+	// Конвертируем строковое значение в uint64
+------+	amount, err := strconv.ParseUint(balance.Value.Amount, 10, 64)
+------+	if err != nil {
+------+		return 0, &PoolError{
+------+			Stage:   "get_lp_balance",
+------+			Message: "failed to parse token amount",
+------+			Err:     err,
 ------+		}
-------+
-------+		lookupTables[tableAddr] = state.Addresses
 ------+	}
 ------+
-------+	return lookupTables, nil
+------+	return amount, nil
 ------ }
-------diff --git a/internal/eventlistener/listener.go b/internal/eventlistener/listener.go
-------index a63190c..1aca89b 100644
---------- a/internal/eventlistener/listener.go
-------+++ b/internal/eventlistener/listener.go
-------@@ -1,3 +1,4 @@
-------+// internal/eventlistener/listener.go
------- package eventlistener
 ------ 
------- import (
-------diff --git a/internal/eventlistener/types.go b/internal/eventlistener/types.go
-------index 62f1192..13fac2d 100644
---------- a/internal/eventlistener/types.go
-------+++ b/internal/eventlistener/types.go
-------@@ -1,3 +1,4 @@
-------+// internal/eventlistener/types.go
------- package eventlistener
+------ // Улучшить кэширование в pool.go:
+------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
+------index 6bb4e16..59aa82b 100644
+--------- a/internal/dex/raydium/types.go
+------+++ b/internal/dex/raydium/types.go
+------@@ -197,11 +197,6 @@ func (e *SwapError) Unwrap() error {
+------ 	return e.Err
+------ }
 ------ 
------- import (
+-------// Типы для v5 пулов
+-------type RaydiumPoolV5 struct {
+-------	// Новые поля v5
+-------}
+-------
+------ // Типы для маркет-мейкинга
+------ type MarketMakingParams struct {
+------ 	// Параметры для MM
 ------diff --git a/newdif.txt b/newdif.txt
-------index c94e4d6..67d0314 100644
+------index 19f71dd..9baa9ce 100644
 --------- a/newdif.txt
 ------+++ b/newdif.txt
-------@@ -1,5243 +0,0 @@
--------diff --git a/internal/dex/raydium/instruction.go b/internal/dex/raydium/instruction.go
--------index ffb819e..f8f7886 100644
----------- a/internal/dex/raydium/instruction.go
--------+++ b/internal/dex/raydium/instruction.go
--------@@ -508,7 +508,7 @@ func (b *SwapInstructionBuilder) BuildVersionedSwapInstruction(
-------- 	ctx context.Context,
-------- 	params SwapParams,
-------- 	accounts SwapInstructionAccounts,
---------) (*solana.VersionedTransaction, error) {
--------+) (*solana.Transaction, error) {
-------- 	logger := b.logger.With(
-------- 		zap.String("user", accounts.UserAuthority.String()),
-------- 		zap.Uint64("amount_in", params.AmountIn),
--------@@ -522,32 +522,35 @@ func (b *SwapInstructionBuilder) BuildVersionedSwapInstruction(
-------- 		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
-------- 	}
+------@@ -1,5780 +0,0 @@
+-------diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
+-------index eafb611..612da49 100644
+---------- a/internal/dex/raydium/client.go
+-------+++ b/internal/dex/raydium/client.go
+-------@@ -5,6 +5,7 @@ import (
+------- 	"context"
+------- 	"encoding/binary"
+------- 	"fmt"
+-------+	"sync"
+------- 	"time"
 ------- 
---------	// Создаем message для транзакции
---------	message := solana.NewMessage(
---------		solana.MessageV0, // используем версию 0 для версионированных транзакций
---------		[]solana.Instruction{instruction},
---------		accounts.UserAuthority, // fee payer
---------	)
--------+	// Создаем новый транзакционный билдер
--------+	tx := solana.NewTransactionBuilder()
+------- 	"github.com/gagliardetto/solana-go"
+-------@@ -13,9 +14,15 @@ import (
+------- 	"github.com/gagliardetto/solana-go/rpc"
+------- 	"github.com/gagliardetto/solana-go/rpc/jsonrpc"
+------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+-------+	"github.com/rovshanmuradov/solana-bot/internal/eventlistener"
+------- 	"go.uber.org/zap"
+------- )
+------- 
+-------+// TODO: client.go:
+-------+// - Добавить метод для batch-запросов GetMultiplePools
+-------+// - Реализовать интерфейс для работы с WebSocket
+-------+// - Добавить кэширование с TTL для пулов
 -------+
--------+	// Добавляем instruction
--------+	tx.AddInstruction(instruction)
+------- const (
+------- 	maxRetries          = 3
+------- 	retryDelay          = 500 * time.Millisecond
+-------@@ -28,6 +35,9 @@ type clientOptions struct {
+------- 	timeout         time.Duration
+------- 	retries         int
+------- 	commitmentLevel rpc.CommitmentType
+-------+
+-------+	cacheLifetime time.Duration
+-------+	wsURL         string
+------- }
 ------- 
---------	// Если есть lookup table, добавляем её
--------+	// Устанавливаем fee payer
--------+	tx.SetFeePayer(accounts.UserAuthority)
+------- // ClientOption определяет функцию для настройки клиента
+-------@@ -68,6 +78,16 @@ type RaydiumClient struct {
+------- 	client  blockchain.Client
+------- 	logger  *zap.Logger
+------- 	options *clientOptions
 -------+
--------+	// Если у нас есть lookup table, добавляем её через TransactionAddressTables option
-------- 	if !b.pool.LookupTableID.IsZero() {
---------		addressLookupTable := &solana.MessageAddressTableLookup{
---------			AccountKey:      b.pool.LookupTableID,
---------			WritableIndexes: []uint8{}, // заполнить необходимыми индексами
---------			ReadonlyIndexes: []uint8{}, // заполнить необходимыми индексами
---------		}
---------		message.AddressTableLookups = append(message.AddressTableLookups, addressLookupTable)
--------+		// Создаем мапу с адресами для lookup table
--------+		addressTables := make(map[solana.PublicKey]solana.PublicKeySlice)
+-------+	// Добавляем поля для кэширования
+-------+	poolCache     map[string]*poolCacheEntry
+-------+	cacheMutex    sync.RWMutex
+-------+	cacheLifetime time.Duration
+-------+
+-------+	// Добавляем поля для WebSocket
+-------+	eventListener *eventlistener.EventListener
+-------+	subscribers   map[string][]chan PoolUpdate
+-------+	subMutex      sync.RWMutex
+------- }
+------- 
+------- // NewRaydiumClient создает новый экземпляр клиента с опциями
+-------@@ -84,11 +104,23 @@ func NewRaydiumClient(client blockchain.Client, logger *zap.Logger, opts ...Clie
+------- 		opt(options)
+------- 	}
+------- 
+--------	return &RaydiumClient{
+--------		client:  client,
+--------		logger:  logger.Named("raydium-client"),
+--------		options: options,
+--------	}, nil
+-------+	rc := &RaydiumClient{
+-------+		client:        client,
+-------+		logger:        logger.Named("raydium-client"),
+-------+		options:       options,
+-------+		poolCache:     make(map[string]*poolCacheEntry),
+-------+		cacheLifetime: options.cacheLifetime,
+-------+		subscribers:   make(map[string][]chan PoolUpdate),
+-------+	}
 -------+
--------+		// Получаем адреса lookup table из пула и добавляем их в мапу
--------+		addressTables[b.pool.LookupTableID] = b.pool.LookupTableAddresses
+-------+	// Инициализируем WebSocket если указан URL
+-------+	if options.wsURL != "" {
+-------+		if err := rc.initWebSocket(options.wsURL); err != nil {
+-------+			return nil, fmt.Errorf("failed to initialize websocket: %w", err)
+-------+		}
+-------+	}
 -------+
--------+		// Добавляем опцию с address tables
--------+		tx.WithOpt(solana.TransactionAddressTables(addressTables))
+-------+	return rc, nil
+------- }
+------- 
+------- // GetPool получает информацию о пуле по его ID
+-------@@ -96,34 +128,37 @@ func (c *RaydiumClient) GetPool(ctx context.Context, poolID solana.PublicKey) (*
+------- 	logger := c.logger.With(zap.String("pool_id", poolID.String()))
+------- 	logger.Debug("Getting pool information")
+------- 
+--------	ctx, cancel := context.WithTimeout(ctx, c.options.timeout)
+--------	defer cancel()
+--------
+--------	account, err := c.client.GetAccountInfo(ctx, poolID)
+--------	if err != nil {
+--------		return nil, &SwapError{
+--------			Stage:   "get_pool",
+--------			Message: "failed to get pool account",
+--------			Err:     err,
+--------		}
+-------+	// Проверяем кэш первым делом
+-------+	if entry, ok := c.getCached(poolID.String()); ok {
+-------+		logger.Debug("Pool found in cache")
+-------+		return entry.pool, nil
 ------- 	}
 ------- 
---------	// Создаем версионированную транзакцию
---------	tx := &solana.VersionedTransaction{
---------		Message:    message,
---------		Signatures: make([]solana.Signature, message.Header.NumRequiredSignatures),
--------+	// Строим транзакцию
--------+	transaction, err := tx.Build()
+--------	if account.Value == nil || len(account.Value.Data.GetBinary()) == 0 {
+--------		return nil, &SwapError{
+--------			Stage:   "get_pool",
+--------			Message: "pool account not found or empty",
+--------		}
+--------	}
+--------
+--------	pool := &RaydiumPool{
+--------		ID: poolID,
+-------+	// Если нет в кэше, получаем из блокчейна
+-------+	pool, err := c.fetchPoolFromChain(ctx, poolID)
 -------+	if err != nil {
--------+		return nil, fmt.Errorf("failed to build transaction: %w", err)
+-------+		return nil, err
 ------- 	}
 ------- 
-------- 	logger.Debug("Versioned swap transaction built successfully")
---------
---------	return tx, nil
--------+	return transaction, nil
-------- }
+--------	if err := c.decodePoolData(account.Value.Data.GetBinary(), pool); err != nil {
+--------		return nil, &SwapError{
+--------			Stage:   "get_pool",
+--------			Message: "failed to decode pool data",
+--------			Err:     err,
+-------+	// Получаем актуальное состояние
+-------+	state, err := c.GetPoolState(ctx, pool)
+-------+	if err != nil {
+-------+		logger.Warn("Failed to get pool state", zap.Error(err))
+-------+		// Продолжаем без состояния
+-------+	} else {
+-------+		// Обновляем кэш с состоянием
+-------+		c.updateCache(poolID.String(), pool, state)
+-------+	}
+-------+
+-------+	// Подписываемся на обновления пула через WebSocket, если есть слушатель
+-------+	if c.eventListener != nil {
+-------+		if _, exists := c.subscribers[poolID.String()]; !exists {
+-------+			updates := make(chan PoolUpdate, 100)
+-------+			c.subMutex.Lock()
+-------+			c.subscribers[poolID.String()] = append(c.subscribers[poolID.String()], updates)
+-------+			c.subMutex.Unlock()
+-------+
+-------+			logger.Debug("Subscribed to pool updates via WebSocket")
+------- 		}
+------- 	}
 ------- 
-------- // DepositInstructionAccounts аккаунты, необходимые для депозита
--------diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
--------index 2851f20..2dcdd64 100644
----------- a/internal/dex/raydium/pool.go
--------+++ b/internal/dex/raydium/pool.go
--------@@ -8,6 +8,7 @@ import (
-------- 	"math/big"
+-------@@ -592,3 +627,112 @@ func (c *RaydiumClient) GetPoolLookupTable(
 ------- 
-------- 	"github.com/gagliardetto/solana-go"
--------+	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
-------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
-------- 	"go.uber.org/zap"
-------- )
--------@@ -26,7 +27,46 @@ func NewPoolManager(client blockchain.Client, logger *zap.Logger) *PoolManager {
-------- 	}
+------- 	return result, nil
 ------- }
-------- 
---------// InitializePool создает новый пул с заданными параметрами
--------+// Добавляем метод для загрузки состояния lookup table в PoolManager
--------+func (pm *PoolManager) LoadPoolLookupTable(
--------+	ctx context.Context,
--------+	pool *RaydiumPool,
--------+) error {
--------+	if pool.LookupTableID.IsZero() {
--------+		return nil
+-------+
+-------+// Реализуем метод для получения множества пулов
+-------+func (c *RaydiumClient) GetMultiplePools(ctx context.Context, poolIDs []solana.PublicKey) ([]*RaydiumPool, error) {
+-------+	logger := c.logger.With(zap.Int("pool_count", len(poolIDs)))
+-------+	logger.Debug("Getting multiple pools")
+-------+
+-------+	type poolResult struct {
+-------+		pool *RaydiumPool
+-------+		err  error
+-------+		idx  int
 -------+	}
 -------+
--------+	logger := pm.logger.With(
--------+		zap.String("lookup_table_id", pool.LookupTableID.String()),
--------+	)
--------+	logger.Debug("Loading lookup table")
+-------+	// Создаем каналы для результатов и ошибок
+-------+	results := make(chan poolResult, len(poolIDs))
+-------+	semaphore := make(chan struct{}, 10) // Ограничиваем параллельные запросы
 -------+
--------+	// Загружаем состояние lookup table
--------+	rpcClient := pm.client.GetRpcClient()
--------+	lookupTable, err := addresslookuptable.GetAddressLookupTable(
--------+		ctx,
--------+		rpcClient,
--------+		pool.LookupTableID,
--------+	)
--------+	if err != nil {
--------+		return &PoolError{
--------+			Stage:   "load_lookup_table",
--------+			Message: "failed to load lookup table",
--------+			Err:     err,
+-------+	// Запускаем горутины для получения пулов
+-------+	for i, poolID := range poolIDs {
+-------+		go func(index int, id solana.PublicKey) {
+-------+			semaphore <- struct{}{}        // Захватываем слот
+-------+			defer func() { <-semaphore }() // Освобождаем слот
+-------+
+-------+			// Проверяем кэш
+-------+			if entry, ok := c.getCached(id.String()); ok {
+-------+				results <- poolResult{pool: entry.pool, idx: index}
+-------+				return
+-------+			}
+-------+
+-------+			// Если нет в кэше, получаем из блокчейна
+-------+			pool, err := c.fetchPoolFromChain(ctx, id)
+-------+			results <- poolResult{pool: pool, err: err, idx: index}
+-------+		}(i, poolID)
+-------+	}
+-------+
+-------+	// Собираем результаты
+-------+	pools := make([]*RaydiumPool, len(poolIDs))
+-------+	var errors []error
+-------+
+-------+	for i := 0; i < len(poolIDs); i++ {
+-------+		select {
+-------+		case <-ctx.Done():
+-------+			return nil, ctx.Err()
+-------+		case result := <-results:
+-------+			if result.err != nil {
+-------+				errors = append(errors, fmt.Errorf("pool %s: %w", poolIDs[result.idx], result.err))
+-------+				continue
+-------+			}
+-------+			pools[result.idx] = result.pool
+-------+
+-------+			// Получаем состояние и обновляем кэш асинхронно
+-------+			go func(p *RaydiumPool) {
+-------+				if state, err := c.GetPoolState(ctx, p); err == nil {
+-------+					c.updateCache(p.ID.String(), p, state)
+-------+				}
+-------+			}(result.pool)
 -------+		}
 -------+	}
 -------+
--------+	// Сохраняем адреса
--------+	pool.LookupTableAddresses = lookupTable.Addresses
+-------+	// Если есть ошибки, но получили хотя бы один пул
+-------+	if len(errors) > 0 && len(errors) < len(poolIDs) {
+-------+		logger.Warn("Some pools failed to load",
+-------+			zap.Int("error_count", len(errors)),
+-------+			zap.Errors("errors", errors))
+-------+	} else if len(errors) == len(poolIDs) {
+-------+		// Если все запросы завершились с ошибкой
+-------+		return nil, fmt.Errorf("all pool requests failed: %v", errors)
+-------+	}
 -------+
--------+	logger.Debug("Lookup table loaded successfully",
--------+		zap.Int("addresses_count", len(pool.LookupTableAddresses)),
--------+	)
+-------+	logger.Debug("Successfully retrieved pools",
+-------+		zap.Int("success_count", len(poolIDs)-len(errors)))
 -------+
--------+	return nil
+-------+	return pools, nil
 -------+}
 -------+
--------+// Модифицируем существующий метод инициализации пула
-------- func (pm *PoolManager) InitializePool(ctx context.Context, params *RaydiumPool) error {
-------- 	logger := pm.logger.With(
-------- 		zap.String("base_mint", params.BaseMint.String()),
--------@@ -42,6 +82,11 @@ func (pm *PoolManager) InitializePool(ctx context.Context, params *RaydiumPool)
-------- 		}
-------- 	}
-------- 
--------+	// Добавляем загрузку lookup table после валидации параметров
--------+	if err := pm.LoadPoolLookupTable(ctx, params); err != nil {
--------+		return err
+-------+// Реализуем вспомогательный метод для получения пула из блокчейна
+-------+func (c *RaydiumClient) fetchPoolFromChain(ctx context.Context, poolID solana.PublicKey) (*RaydiumPool, error) {
+-------+	ctx, cancel := context.WithTimeout(ctx, c.options.timeout)
+-------+	defer cancel()
+-------+
+-------+	account, err := c.client.GetAccountInfo(ctx, poolID)
+-------+	if err != nil {
+-------+		return nil, &SwapError{
+-------+			Stage:   "get_pool",
+-------+			Message: "failed to get pool account",
+-------+			Err:     err,
+-------+		}
 -------+	}
 -------+
-------- 	return nil
-------- }
-------- 
--------@@ -216,6 +261,14 @@ func (pm *PoolManager) validatePoolParameters(pool *RaydiumPool) error {
-------- 		return fmt.Errorf("invalid market parameters")
-------- 	}
-------- 
--------+	// Если указан lookup table ID, проверяем что он валидный
--------+	if !pool.LookupTableID.IsZero() {
--------+		// Проверка существования lookup table будет выполнена при загрузке
--------+		logger := pm.logger.With(
--------+			zap.String("lookup_table_id", pool.LookupTableID.String()),
--------+		)
--------+		logger.Debug("Pool has lookup table configuration")
+-------+	if account.Value == nil || len(account.Value.Data.GetBinary()) == 0 {
+-------+		return nil, &SwapError{
+-------+			Stage:   "get_pool",
+-------+			Message: "pool account not found or empty",
+-------+		}
+-------+	}
+-------+
+-------+	pool := &RaydiumPool{
+-------+		ID: poolID,
+-------+	}
+-------+
+-------+	if err := c.decodePoolData(account.Value.Data.GetBinary(), pool); err != nil {
+-------+		return nil, &SwapError{
+-------+			Stage:   "get_pool",
+-------+			Message: "failed to decode pool data",
+-------+			Err:     err,
+-------+		}
 -------+	}
-------- 	return nil
-------- }
-------- 
--------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
--------index a2965fa..6100e4c 100644
----------- a/internal/dex/raydium/types.go
--------+++ b/internal/dex/raydium/types.go
--------@@ -78,7 +78,10 @@ type RaydiumPool struct {
-------- 	MarketAsks       solana.PublicKey
-------- 	MarketEventQueue solana.PublicKey
-------- 	MarketVersion    uint8
---------	LookupTableID    solana.PublicKey
 -------+
--------+	// Lookup Table конфигурация
--------+	LookupTableID        solana.PublicKey
--------+	LookupTableAddresses solana.PublicKeySlice // добавляем это поле
+-------+	return pool, nil
+-------+}
+-------diff --git a/internal/dex/raydium/instruction.go b/internal/dex/raydium/instruction.go
+-------index f8f7886..82754f9 100644
+---------- a/internal/dex/raydium/instruction.go
+-------+++ b/internal/dex/raydium/instruction.go
+-------@@ -12,6 +12,10 @@ import (
+------- 	"go.uber.org/zap"
+------- )
 ------- 
-------- 	// Версионирование и инструкции
-------- 	Version              uint8
--------diff --git a/internal/dex/raydium/utils.go b/internal/dex/raydium/utils.go
--------index 9739bad..104cc1d 100644
----------- a/internal/dex/raydium/utils.go
--------+++ b/internal/dex/raydium/utils.go
--------@@ -311,12 +311,14 @@ func ConvertBigFloatToUint64(value *big.Float) (uint64, error) {
-------- }
+-------+//TODO:instruction.go:
+-------+//- Упростить BuildSwapInstruction, вынести часть логики в отдельные методы
+-------+// - Добавить поддержку batch-инструкций
+-------+
+------- // InstructionType определяет тип инструкции Raydium
+------- type InstructionType uint8
 ------- 
-------- // Утилиты для версионированных транзакций
--------+// TODO: Implement the method logic
-------- func CreateVersionedTransaction(instructions []solana.Instruction, lookupTables []solana.AddressLookupTable) (*solana.VersionedTransaction, error) {
-------- 	// Создаем транзакцию
-------- 	return nil, nil
-------- }
+-------diff --git a/internal/dex/raydium/order_book.go b/internal/dex/raydium/order_book.go
+-------index 6bc8459..4e5d4d0 100644
+---------- a/internal/dex/raydium/order_book.go
+-------+++ b/internal/dex/raydium/order_book.go
+-------@@ -13,6 +13,10 @@ import (
+------- 	"go.uber.org/zap"
+------- )
 ------- 
-------- // Утилиты для работы с новыми комиссиями
--------+// TODO: Implement the method logic
-------- func CalculateV5Fees(amount uint64, feeParams V5FeeParams) uint64 {
-------- 	return 0
+-------+// TODO: order_book.go:
+-------+// - Упростить структуру, использовать более эффективные структуры данных
+-------+// - Добавить методы для работы с orderbook snapshots
+-------+
+------- // Константы для Serum OrderBook
+------- const (
+------- 	ORDER_BOOK_LAYOUT_SIZE = 5132
+-------diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
+-------index 2dcdd64..26e8e25 100644
+---------- a/internal/dex/raydium/pool.go
+-------+++ b/internal/dex/raydium/pool.go
+-------@@ -6,6 +6,7 @@ import (
+------- 	"fmt"
+------- 	"math"
+------- 	"math/big"
+-------+	"time"
+------- 
+------- 	"github.com/gagliardetto/solana-go"
+------- 	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
+-------@@ -13,6 +14,11 @@ import (
+------- 	"go.uber.org/zap"
+------- )
+------- 
+-------+// TODO: pool.go
+-------+// - Добавить поддержку новых типов пулов
+-------+// - Реализовать методы для работы с concentrated liquidity
+-------+// - Добавить методы для анализа ликвидности
+-------+
+------- // PoolManager управляет операциями с пулом ликвидности
+------- type PoolManager struct {
+------- 	client blockchain.Client
+-------@@ -347,3 +353,29 @@ func (pm *PoolManager) GetLPTokenBalance(ctx context.Context, owner solana.Publi
+------- 	// TODO: implement
+------- 	return 0, nil
+------- }
+-------+
+-------+// Улучшить кэширование в pool.go:
+-------+type PoolCache struct {
+-------+	pool      *RaydiumPool
+-------+	state     *PoolState
+-------+	updatedAt time.Time
+-------+	ttl       time.Duration
+-------+}
+-------+
+-------+// Добавить методы для анализа ликвидности:
+-------+
+-------+func (p *PoolManager) GetLiquidityDepth(ctx context.Context, pool *RaydiumPool) (*LiquidityDepth, error) {
+-------+	// TODO: реализовать
+-------+	return nil, nil
+-------+}
+-------+
+-------+// Реализовать concentrated liquidity:
+-------+
+-------+type ConcentratedLiquidityPool struct {
+-------+	// TODO: определить структуру
+-------+}
+-------+
+-------+func (p *PoolManager) InitializeConcentratedPool(ctx context.Context, params *ConcentratedPoolParams) error {
+-------+	// TODO: реализовать
+-------+	return nil
+-------+}
+-------diff --git a/internal/dex/raydium/state.go b/internal/dex/raydium/state.go
+-------index cff0664..ed5730d 100644
+---------- a/internal/dex/raydium/state.go
+-------+++ b/internal/dex/raydium/state.go
+-------@@ -10,6 +10,10 @@ import (
+------- 	"go.uber.org/zap"
+------- )
+------- 
+-------+// TODO: stage.go:
+-------+// - Добавить поддержку сериализации/десериализации для всех версий
+-------+// - Улучшить валидацию состояний
+-------+
+------- // StateVersion определяет версию структуры состояния
+------- type StateVersion uint8
+------- 
+-------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
+-------index 6100e4c..6bb4e16 100644
+---------- a/internal/dex/raydium/types.go
+-------+++ b/internal/dex/raydium/types.go
+-------@@ -11,6 +11,10 @@ import (
+------- 	"go.uber.org/zap"
+------- )
+------- 
+-------+// TODO: types.go
+-------+// - Добавить типы для новых функций
+-------+// - Расширить интерфейсы для поддержки новых операций
+-------+
+------- // Layout константы для правильного чтения данных из аккаунта пула
+------- const (
+------- 	// Базовые смещения
+-------diff --git a/internal/dex/raydium/utils.go b/internal/dex/raydium/utils.go
+-------index 104cc1d..57438ca 100644
+---------- a/internal/dex/raydium/utils.go
+-------+++ b/internal/dex/raydium/utils.go
+-------@@ -11,6 +11,7 @@ import (
+------- 	"time"
+------- 
+------- 	"github.com/gagliardetto/solana-go"
+-------+	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
+------- 	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
+------- 	token "github.com/gagliardetto/solana-go/programs/token"
+------- 	"github.com/shopspring/decimal"
+-------@@ -19,6 +20,10 @@ import (
+------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+------- )
+------- 
+-------+// TODO: utils.go
+-------+// - Добавить больше helpers для работы с числами
+-------+// - Оптимизировать конвертации между типами
+-------+
+------- // TokenAmountConfig содержит конфигурацию для работы с суммами токенов
+------- type TokenAmountConfig struct {
+------- 	Amount   uint64
+-------@@ -311,14 +316,110 @@ func ConvertBigFloatToUint64(value *big.Float) (uint64, error) {
+------- }
+------- 
+------- // Утилиты для версионированных транзакций
+--------// TODO: Implement the method logic
+--------func CreateVersionedTransaction(instructions []solana.Instruction, lookupTables []solana.AddressLookupTable) (*solana.VersionedTransaction, error) {
+--------	// Создаем транзакцию
+--------	return nil, nil
+-------+// В начале файла добавим структуру для V5 комиссий
+-------+type V5FeeParams struct {
+-------+	BaseFee     uint64 // Базовая комиссия
+-------+	MaxFee      uint64 // Максимальная комиссия
+-------+	AmmFee      uint16 // Комиссия AMM в базовых пунктах
+-------+	PriceImpact uint16 // Максимальное влияние на цену в базовых пунктах
+------- }
+------- 
+--------// Утилиты для работы с новыми комиссиями
+--------// TODO: Implement the method logic
+-------+// CreateVersionedTransaction создает транзакцию с поддержкой lookup tables
+-------+func CreateVersionedTransaction(
+-------+	instructions []solana.Instruction,
+-------+	lookupTables map[solana.PublicKey]solana.PublicKeySlice,
+-------+) (*solana.Transaction, error) {
+-------+	if len(instructions) == 0 {
+-------+		return nil, fmt.Errorf("no instructions provided")
+-------+	}
+-------+
+-------+	// Создаем билдер транзакции
+-------+	tx := solana.NewTransactionBuilder()
+-------+
+-------+	// Добавляем все инструкции
+-------+	for _, instruction := range instructions {
+-------+		tx.AddInstruction(instruction)
+-------+	}
+-------+
+-------+	// Если есть lookup tables, добавляем их через опцию
+-------+	if len(lookupTables) > 0 {
+-------+		tx.WithOpt(solana.TransactionAddressTables(lookupTables))
+-------+	}
+-------+
+-------+	// Строим транзакцию
+-------+	transaction, err := tx.Build()
+-------+	if err != nil {
+-------+		return nil, fmt.Errorf("failed to build transaction: %w", err)
+-------+	}
+-------+
+-------+	return transaction, nil
+-------+}
+-------+
+-------+// CalculateV5Fees вычисляет комиссии для V5 пулов
+------- func CalculateV5Fees(amount uint64, feeParams V5FeeParams) uint64 {
+--------	return 0
+-------+	// Базовая комиссия всегда взимается
+-------+	totalFee := feeParams.BaseFee
+-------+
+-------+	// Добавляем комиссию AMM
+-------+	ammFee := new(big.Float).SetUint64(amount)
+-------+	ammFee = ammFee.Mul(ammFee, new(big.Float).SetFloat64(float64(feeParams.AmmFee)/10000.0))
+-------+	ammFeeUint, _ := ammFee.Uint64()
+-------+	totalFee += ammFeeUint
+-------+
+-------+	// Добавляем влияние на цену, если оно есть
+-------+	if feeParams.PriceImpact > 0 {
+-------+		priceImpactFee := new(big.Float).SetUint64(amount)
+-------+		priceImpactFee = priceImpactFee.Mul(priceImpactFee, new(big.Float).SetFloat64(float64(feeParams.PriceImpact)/10000.0))
+-------+		priceImpactFeeUint, _ := priceImpactFee.Uint64()
+-------+		totalFee += priceImpactFeeUint
+-------+	}
+-------+
+-------+	// Проверяем, не превышает ли общая комиссия максимальную
+-------+	if totalFee > feeParams.MaxFee {
+-------+		return feeParams.MaxFee
+-------+	}
+-------+
+-------+	return totalFee
+-------+}
+-------+
+-------+// Вспомогательная функция для получения состояния lookup table
+-------+func GetAddressLookupTableState(
+-------+	ctx context.Context,
+-------+	client blockchain.Client,
+-------+	tableAddress solana.PublicKey,
+-------+) (*addresslookuptable.AddressLookupTableState, error) {
+-------+	// Получаем RPC клиент из blockchain.Client
+-------+	rpcClient := client.GetRpcClient()
+-------+
+-------+	// Получаем состояние lookup table
+-------+	state, err := addresslookuptable.GetAddressLookupTable(
+-------+		ctx,
+-------+		rpcClient,
+-------+		tableAddress,
+-------+	)
+-------+	if err != nil {
+-------+		return nil, fmt.Errorf("failed to get lookup table state: %w", err)
+-------+	}
+-------+
+-------+	return state, nil
+-------+}
+-------+
+-------+// Вспомогательная функция для подготовки lookup tables к транзакции
+-------+func PrepareLookupTables(
+-------+	ctx context.Context,
+-------+	client blockchain.Client,
+-------+	tableAddresses []solana.PublicKey,
+-------+) (map[solana.PublicKey]solana.PublicKeySlice, error) {
+-------+	lookupTables := make(map[solana.PublicKey]solana.PublicKeySlice)
+-------+
+-------+	for _, tableAddr := range tableAddresses {
+-------+		state, err := GetAddressLookupTableState(ctx, client, tableAddr)
+-------+		if err != nil {
+-------+			return nil, fmt.Errorf("failed to prepare lookup table %s: %w", tableAddr, err)
+-------+		}
+-------+
+-------+		lookupTables[tableAddr] = state.Addresses
+-------+	}
+-------+
+-------+	return lookupTables, nil
 ------- }
+-------diff --git a/internal/eventlistener/listener.go b/internal/eventlistener/listener.go
+-------index a63190c..1aca89b 100644
+---------- a/internal/eventlistener/listener.go
+-------+++ b/internal/eventlistener/listener.go
+-------@@ -1,3 +1,4 @@
+-------+// internal/eventlistener/listener.go
+------- package eventlistener
+------- 
+------- import (
+-------diff --git a/internal/eventlistener/types.go b/internal/eventlistener/types.go
+-------index 62f1192..13fac2d 100644
+---------- a/internal/eventlistener/types.go
+-------+++ b/internal/eventlistener/types.go
+-------@@ -1,3 +1,4 @@
+-------+// internal/eventlistener/types.go
+------- package eventlistener
+------- 
+------- import (
 -------diff --git a/newdif.txt b/newdif.txt
--------index 94ec35e..dd1019e 100644
+-------index c94e4d6..67d0314 100644
 ---------- a/newdif.txt
 -------+++ b/newdif.txt
--------@@ -1,5048 +0,0 @@
---------diff --git a/internal/blockchain/solbc/solana.go b/internal/blockchain/solbc/solana.go
---------index b764d85..dec574a 100644
------------ a/internal/blockchain/solbc/solana.go
---------+++ b/internal/blockchain/solbc/solana.go
---------@@ -1,10 +1,13 @@
----------// internal/blockchain/solbc/solana.go:
---------+// internal/blockchain/solbc/solana.go
--------- package solbc
--------- 
--------- import (
--------- 	"context"
--------- 	"fmt"
--------- 
---------+	solanarpc "github.com/gagliardetto/solana-go/rpc"
---------+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
---------+
--------- 	"github.com/gagliardetto/solana-go"
--------- 	"go.uber.org/zap"
--------- )
---------@@ -54,3 +57,25 @@ func (s *Blockchain) GetRecentBlockhash(ctx context.Context) (solana.Hash, error
+-------@@ -1,5243 +0,0 @@
+--------diff --git a/internal/dex/raydium/instruction.go b/internal/dex/raydium/instruction.go
+--------index ffb819e..f8f7886 100644
+----------- a/internal/dex/raydium/instruction.go
+--------+++ b/internal/dex/raydium/instruction.go
+--------@@ -508,7 +508,7 @@ func (b *SwapInstructionBuilder) BuildVersionedSwapInstruction(
+-------- 	ctx context.Context,
+-------- 	params SwapParams,
+-------- 	accounts SwapInstructionAccounts,
+---------) (*solana.VersionedTransaction, error) {
+--------+) (*solana.Transaction, error) {
+-------- 	logger := b.logger.With(
+-------- 		zap.String("user", accounts.UserAuthority.String()),
+-------- 		zap.Uint64("amount_in", params.AmountIn),
+--------@@ -522,32 +522,35 @@ func (b *SwapInstructionBuilder) BuildVersionedSwapInstruction(
+-------- 		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
 -------- 	}
--------- 	return hash, nil
--------- }
+-------- 
+---------	// Создаем message для транзакции
+---------	message := solana.NewMessage(
+---------		solana.MessageV0, // используем версию 0 для версионированных транзакций
+---------		[]solana.Instruction{instruction},
+---------		accounts.UserAuthority, // fee payer
+---------	)
+--------+	// Создаем новый транзакционный билдер
+--------+	tx := solana.NewTransactionBuilder()
 --------+
---------+// SimulateTransaction simulates a transaction on the Solana blockchain
---------+func (c *Client) SimulateTransaction(tx string) (string, error) {
---------+	// Implement the method logic here
---------+	return "", nil
---------+}
+--------+	// Добавляем instruction
+--------+	tx.AddInstruction(instruction)
+-------- 
+---------	// Если есть lookup table, добавляем её
+--------+	// Устанавливаем fee payer
+--------+	tx.SetFeePayer(accounts.UserAuthority)
 --------+
---------+func (c *Client) GetRpcClient() *solanarpc.Client {
---------+	if c.adapter == nil {
---------+		c.adapter = NewRpcAdapter(c.rpc)
---------+	}
---------+	return c.adapter
---------+}
+--------+	// Если у нас есть lookup table, добавляем её через TransactionAddressTables option
+-------- 	if !b.pool.LookupTableID.IsZero() {
+---------		addressLookupTable := &solana.MessageAddressTableLookup{
+---------			AccountKey:      b.pool.LookupTableID,
+---------			WritableIndexes: []uint8{}, // заполнить необходимыми индексами
+---------			ReadonlyIndexes: []uint8{}, // заполнить необходимыми индексами
+---------		}
+---------		message.AddressTableLookups = append(message.AddressTableLookups, addressLookupTable)
+--------+		// Создаем мапу с адресами для lookup table
+--------+		addressTables := make(map[solana.PublicKey]solana.PublicKeySlice)
 --------+
---------+// RpcAdapter адаптирует наш RPCClient к интерфейсу solana-go/rpc.Client
---------+type RpcAdapter struct {
---------+	client *rpc.RPCClient
---------+}
+--------+		// Получаем адреса lookup table из пула и добавляем их в мапу
+--------+		addressTables[b.pool.LookupTableID] = b.pool.LookupTableAddresses
 --------+
---------+func NewRpcAdapter(client *rpc.RPCClient) *solanarpc.Client {
---------+	return solanarpc.New("") // Создаем пустой клиент
---------+}
---------diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
---------index 42debad..b3e342d 100644
------------ a/internal/blockchain/solbc/types.go
---------+++ b/internal/blockchain/solbc/types.go
---------@@ -7,6 +7,7 @@ import (
+--------+		// Добавляем опцию с address tables
+--------+		tx.WithOpt(solana.TransactionAddressTables(addressTables))
+-------- 	}
 -------- 
--------- 	"go.uber.org/zap"
+---------	// Создаем версионированную транзакцию
+---------	tx := &solana.VersionedTransaction{
+---------		Message:    message,
+---------		Signatures: make([]solana.Signature, message.Header.NumRequiredSignatures),
+--------+	// Строим транзакцию
+--------+	transaction, err := tx.Build()
+--------+	if err != nil {
+--------+		return nil, fmt.Errorf("failed to build transaction: %w", err)
+-------- 	}
 -------- 
---------+	solanarpc "github.com/gagliardetto/solana-go/rpc"
--------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
--------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
--------- )
---------@@ -20,6 +21,7 @@ type TokenMetadataCache struct {
--------- // Client представляет основной клиент Solana
--------- type Client struct {
--------- 	rpc     *rpc.RPCClient
---------+	adapter *solanarpc.Client
--------- 	logger  *zap.Logger
--------- 	metrics *ClientMetrics
+-------- 	logger.Debug("Versioned swap transaction built successfully")
+---------
+---------	return tx, nil
+--------+	return transaction, nil
 -------- }
---------diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
---------index 03c15ac..45d076b 100644
------------ a/internal/blockchain/types.go
---------+++ b/internal/blockchain/types.go
---------@@ -3,6 +3,7 @@ package blockchain
 -------- 
--------- import (
--------- 	"context"
---------+	"encoding/base64"
+-------- // DepositInstructionAccounts аккаунты, необходимые для депозита
+--------diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
+--------index 2851f20..2dcdd64 100644
+----------- a/internal/dex/raydium/pool.go
+--------+++ b/internal/dex/raydium/pool.go
+--------@@ -8,6 +8,7 @@ import (
+-------- 	"math/big"
 -------- 
 -------- 	"github.com/gagliardetto/solana-go"
--------- 	"github.com/gagliardetto/solana-go/rpc"
---------@@ -14,6 +15,30 @@ type TransactionOptions struct {
--------- 	PreflightCommitment rpc.CommitmentType
--------- }
--------- 
---------+// SimulationResult представляет результат симуляции транзакции
---------+// Обновляем структуру SimulationResult
---------+type SimulationResult struct {
---------+	Err           interface{}
---------+	Logs          []string
---------+	UnitsConsumed uint64
---------+	ReturnData    *Base64Data
---------+}
---------+
---------+// Base64Data представляет данные в формате Base64
---------+type Base64Data struct {
---------+	Data string
---------+}
---------+
---------+// EncodeBase64 кодирует данные в Base64
---------+func (b *Base64Data) EncodeBase64(data []byte) {
---------+	b.Data = base64.StdEncoding.EncodeToString(data)
---------+}
---------+
---------+// DecodeBase64 декодирует данные из Base64
---------+func (b *Base64Data) DecodeBase64() ([]byte, error) {
---------+	return base64.StdEncoding.DecodeString(b.Data)
---------+}
---------+
--------- // Client определяет общий интерфейс для клиентов блокчейна
--------- type Client interface {
--------- 	GetRecentBlockhash(ctx context.Context) (solana.Hash, error)
---------@@ -21,4 +46,6 @@ type Client interface {
--------- 	GetAccountInfo(ctx context.Context, pubkey solana.PublicKey) (*rpc.GetAccountInfoResult, error)
--------- 	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
--------- 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
---------+	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
---------+	GetRpcClient() *rpc.Client
--------- }
---------diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
---------index e7de9a0..eafb611 100644
------------ a/internal/dex/raydium/client.go
---------+++ b/internal/dex/raydium/client.go
---------@@ -12,9 +12,8 @@ import (
--------- 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
--------- 	"github.com/gagliardetto/solana-go/rpc"
--------- 	"github.com/gagliardetto/solana-go/rpc/jsonrpc"
----------	"go.uber.org/zap"
----------
+--------+	addresslookuptable "github.com/gagliardetto/solana-go/programs/address-lookup-table"
 -------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
---------+	"go.uber.org/zap"
+-------- 	"go.uber.org/zap"
 -------- )
--------- 
--------- const (
---------@@ -217,7 +216,8 @@ func (c *RaydiumClient) CreateSwapInstructions(ctx context.Context, params SwapP
--------- 
--------- // SimulateSwap симулирует выполнение свапа
--------- func (c *RaydiumClient) SimulateSwap(ctx context.Context, instructions []solana.Instruction) error {
----------	logger := c.logger.Debug("Simulating swap transaction")
---------+	logger := c.logger.With(zap.String("method", "SimulateSwap"))
---------+	logger.Debug("Starting swap simulation")
--------- 
--------- 	recent, err := c.client.GetRecentBlockhash(ctx)
--------- 	if err != nil {
---------@@ -246,15 +246,16 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, instructions []solana.
--------- 		}
--------- 	}
--------- 
----------	if simulation.Value.Err != nil {
---------+	if simulation.Err != nil {
--------- 		return &SwapError{
--------- 			Stage:   "simulate_swap",
----------			Message: fmt.Sprintf("simulation returned error: %v", simulation.Value.Err),
---------+			Message: fmt.Sprintf("simulation returned error: %v", simulation.Err),
--------- 		}
+--------@@ -26,7 +27,46 @@ func NewPoolManager(client blockchain.Client, logger *zap.Logger) *PoolManager {
 -------- 	}
--------- 
--------- 	logger.Debug("Swap simulation successful",
----------		zap.Uint64("compute_units_used", simulation.Value.UnitsConsumed))
---------+		zap.Uint64("compute_units_used", simulation.UnitsConsumed),
---------+		zap.Strings("logs", simulation.Logs))
--------- 
--------- 	return nil
 -------- }
---------@@ -294,15 +295,112 @@ func (c *RaydiumClient) GetAmountOut(pool *RaydiumPool, state *PoolState, amount
 -------- 
--------- // createSwapInstruction создает инструкцию свапа
--------- func (c *RaydiumClient) createSwapInstruction(params SwapParams) (solana.Instruction, error) {
----------	// ... реализация создания инструкции свапа
----------	// Этот метод будет реализован в следующей части
----------	return nil, nil
---------+	// Проверяем входные параметры
---------+	if params.Pool == nil {
---------+		return nil, &SwapError{
---------+			Stage:   "create_swap_instruction",
---------+			Message: "pool is required",
---------+		}
+---------// InitializePool создает новый пул с заданными параметрами
+--------+// Добавляем метод для загрузки состояния lookup table в PoolManager
+--------+func (pm *PoolManager) LoadPoolLookupTable(
+--------+	ctx context.Context,
+--------+	pool *RaydiumPool,
+--------+) error {
+--------+	if pool.LookupTableID.IsZero() {
+--------+		return nil
 --------+	}
 --------+
---------+	// Создаем слайс аккаунтов для инструкции
---------+	accounts := make(solana.AccountMetaSlice, 0)
---------+
---------+	// Добавляем основные аккаунты
---------+	accounts = append(accounts,
---------+		// Token Program ID
---------+		solana.Meta(solana.TokenProgramID),
---------+		// AMM Program ID
---------+		solana.Meta(params.Pool.AmmProgramID),
---------+		// User wallet (signer)
---------+		solana.Meta(params.UserWallet).SIGNER(),
---------+		// Pool ID
---------+		solana.Meta(params.Pool.ID),
---------+		// Pool Authority
---------+		solana.Meta(params.Pool.Authority),
---------+		// Source token account
---------+		solana.Meta(params.SourceTokenAccount).WRITE(),
---------+		// Destination token account
---------+		solana.Meta(params.DestinationTokenAccount).WRITE(),
---------+		// Pool base vault
---------+		solana.Meta(params.Pool.BaseVault).WRITE(),
---------+		// Pool quote vault
---------+		solana.Meta(params.Pool.QuoteVault).WRITE(),
+--------+	logger := pm.logger.With(
+--------+		zap.String("lookup_table_id", pool.LookupTableID.String()),
 --------+	)
+--------+	logger.Debug("Loading lookup table")
 --------+
---------+	// Создаем данные инструкции
---------+	data := make([]byte, 9)
---------+	// Команда swap (предположим, что это 1)
---------+	data[0] = 1
---------+	// Записываем AmountIn (8 байт, little endian)
---------+	binary.LittleEndian.PutUint64(data[1:], params.AmountIn)
---------+
---------+	// Создаем инструкцию
---------+	instruction := solana.NewInstruction(
---------+		params.Pool.AmmProgramID,
---------+		accounts,
---------+		data,
+--------+	// Загружаем состояние lookup table
+--------+	rpcClient := pm.client.GetRpcClient()
+--------+	lookupTable, err := addresslookuptable.GetAddressLookupTable(
+--------+		ctx,
+--------+		rpcClient,
+--------+		pool.LookupTableID,
 --------+	)
---------+
---------+	return instruction, nil
--------- }
--------- 
--------- // decodePoolData декодирует данные аккаунта пула
--------- func (c *RaydiumClient) decodePoolData(data []byte, pool *RaydiumPool) error {
----------	// ... реализация декодирования данных пула
----------	// Этот метод будет реализован в следующей части
---------+	if len(data) < PoolDataSize {
---------+		return &SwapError{
---------+			Stage:   "decode_pool_data",
---------+			Message: fmt.Sprintf("invalid data length: got %d, want at least %d", len(data), PoolDataSize),
+--------+	if err != nil {
+--------+		return &PoolError{
+--------+			Stage:   "load_lookup_table",
+--------+			Message: "failed to load lookup table",
+--------+			Err:     err,
 --------+		}
 --------+	}
 --------+
---------+	// Декодируем данные пула используя binary.LittleEndian
---------+	// Предполагаем следующую структуру данных:
---------+	offset := 0
---------+
---------+	// Status (1 byte)
---------+	pool.Status = data[offset]
---------+	offset += 1
---------+
---------+	// Nonce (1 byte)
---------+	pool.Nonce = data[offset]
---------+	offset += 1
+--------+	// Сохраняем адреса
+--------+	pool.LookupTableAddresses = lookupTable.Addresses
 --------+
---------+	// AMM Program ID (32 bytes)
---------+	copy(pool.AmmProgramID[:], data[offset:offset+32])
---------+	offset += 32
---------+
---------+	// Authority (32 bytes)
---------+	copy(pool.Authority[:], data[offset:offset+32])
---------+	offset += 32
---------+
---------+	// Base Vault (32 bytes)
---------+	copy(pool.BaseVault[:], data[offset:offset+32])
---------+	offset += 32
---------+
---------+	// Quote Vault (32 bytes)
---------+	copy(pool.QuoteVault[:], data[offset:offset+32])
---------+	offset += 32
---------+
---------+	// Base Mint (32 bytes)
---------+	copy(pool.BaseMint[:], data[offset:offset+32])
---------+	offset += 32
---------+
---------+	// Quote Mint (32 bytes)
---------+	copy(pool.QuoteMint[:], data[offset:offset+32])
---------+	offset += 32
---------+
---------+	// Base Reserve (8 bytes)
---------+	pool.BaseReserve = binary.LittleEndian.Uint64(data[offset : offset+8])
---------+	offset += 8
---------+
---------+	// Quote Reserve (8 bytes)
---------+	pool.QuoteReserve = binary.LittleEndian.Uint64(data[offset : offset+8])
---------+	offset += 8
---------+
---------+	// Fee Rate (8 bytes)
---------+	pool.FeeRate = binary.LittleEndian.Uint64(data[offset : offset+8])
+--------+	logger.Debug("Lookup table loaded successfully",
+--------+		zap.Int("addresses_count", len(pool.LookupTableAddresses)),
+--------+	)
 --------+
--------- 	return nil
--------- }
--------- 
---------@@ -334,13 +432,14 @@ func (c *RaydiumClient) CreateVersionedSwapInstructions(
--------- 
--------- 	// Создаем базовое сообщение
--------- 	message := &solana.Message{
+--------+	return nil
+--------+}
 --------+
--------- 		AccountKeys: []solana.PublicKey{params.UserWallet}, // Начинаем с основного кошелька
--------- 		Header: solana.MessageHeader{
--------- 			NumRequiredSignatures:       1, // Минимум одна подпись от кошелька
--------- 			NumReadonlySignedAccounts:   0,
--------- 			NumReadonlyUnsignedAccounts: 0,
--------- 		},
----------		RecentBlockhash: recent.Value.Blockhash,
---------+		RecentBlockhash: recent,
--------- 		Instructions:    make([]solana.CompiledInstruction, 0),
--------- 	}
--------- 
---------@@ -361,8 +460,15 @@ func (c *RaydiumClient) CreateVersionedSwapInstructions(
--------- 	for _, instruction := range instructions {
--------- 		compiledIx := solana.CompiledInstruction{
--------- 			ProgramIDIndex: uint16(len(message.AccountKeys)), // Индекс программы
----------			Data:           instruction.Data(),
----------			Accounts:       make([]uint16, len(instruction.Accounts())),
---------+			Data: func() []byte {
---------+				data, err := instruction.Data()
---------+				if err != nil {
---------+					logger.Error("failed to get instruction data", zap.Error(err))
---------+					return nil
---------+				}
---------+				return data
---------+			}(),
---------+			Accounts: make([]uint16, len(instruction.Accounts())),
+--------+// Модифицируем существующий метод инициализации пула
+-------- func (pm *PoolManager) InitializePool(ctx context.Context, params *RaydiumPool) error {
+-------- 	logger := pm.logger.With(
+-------- 		zap.String("base_mint", params.BaseMint.String()),
+--------@@ -42,6 +82,11 @@ func (pm *PoolManager) InitializePool(ctx context.Context, params *RaydiumPool)
 -------- 		}
--------- 
--------- 		// Добавляем ProgramID в список аккаунтов, если его там еще нет
---------@@ -427,10 +533,13 @@ func (c *RaydiumClient) GetPoolLookupTable(
--------- 		return nil, fmt.Errorf("failed to derive lookup table address: %w", err)
 -------- 	}
 -------- 
----------	// Получаем данные таблицы
---------+	// Получаем RPC клиент через GetRpcClient
---------+	rpcClient := c.client.GetRpcClient()
+--------+	// Добавляем загрузку lookup table после валидации параметров
+--------+	if err := pm.LoadPoolLookupTable(ctx, params); err != nil {
+--------+		return err
+--------+	}
 --------+
---------+	// Получаем данные таблицы с помощью RPC клиента
--------- 	lookupTable, err := addresslookuptable.GetAddressLookupTable(
--------- 		ctx,
----------		c.client,
---------+		rpcClient,
--------- 		lookupTableAddr,
--------- 	)
--------- 	if err != nil {
---------@@ -450,7 +559,6 @@ func (c *RaydiumClient) GetPoolLookupTable(
--------- 		return nil, nil
--------- 	}
+-------- 	return nil
+-------- }
 -------- 
----------	// Проверяем наличие необходимых адресов
--------- 	requiredAddresses := []solana.PublicKey{
--------- 		pool.ID,
--------- 		pool.Authority,
---------@@ -461,7 +569,6 @@ func (c *RaydiumClient) GetPoolLookupTable(
--------- 		pool.MarketQuoteVault,
+--------@@ -216,6 +261,14 @@ func (pm *PoolManager) validatePoolParameters(pool *RaydiumPool) error {
+-------- 		return fmt.Errorf("invalid market parameters")
 -------- 	}
 -------- 
----------	// Проверяем, что все необходимые адреса есть в таблице
--------- 	for _, addr := range requiredAddresses {
--------- 		found := false
--------- 		for _, tableAddr := range lookupTable.Addresses {
---------diff --git a/internal/dex/raydium/instruction.go b/internal/dex/raydium/instruction.go
---------index 6b75182..ffb819e 100644
------------ a/internal/dex/raydium/instruction.go
---------+++ b/internal/dex/raydium/instruction.go
---------@@ -206,33 +206,160 @@ func (b *SwapInstructionBuilder) serializeInstructionData(params SwapParams) ([]
--------- 	return data, nil
--------- }
--------- 
---------+// Добавим новые параметры для инициализации пула
---------+type InitializePoolParams struct {
---------+	Nonce           uint8
---------+	InitialLPSupply uint64
---------+	UserAuthority   solana.PublicKey
---------+}
---------+
---------+// Добавим параметры для депозита
---------+type DepositParams struct {
---------+	MaxBaseAmount  uint64
---------+	MaxQuoteAmount uint64
---------+	UserAuthority  solana.PublicKey
---------+}
---------+
--------- // BuildInitializePoolInstruction создает инструкцию инициализации пула
--------- func (b *SwapInstructionBuilder) BuildInitializePoolInstruction(
--------- 	ctx context.Context,
----------	nonce uint8,
----------	initialLPSupply uint64,
---------+	params InitializePoolParams,
--------- ) (solana.Instruction, error) {
----------	// ... реализация создания инструкции инициализации пула
----------	return nil, nil
---------+	logger := b.logger.With(
---------+		zap.Uint8("nonce", params.Nonce),
---------+		zap.Uint64("initial_lp_supply", params.InitialLPSupply),
---------+		zap.String("user_authority", params.UserAuthority.String()),
---------+	)
---------+	logger.Debug("Building initialize pool instruction")
---------+
---------+	// Находим пользовательский LP токен аккаунт
---------+	userLPAccount, _, err := solana.FindAssociatedTokenAddress(
---------+		params.UserAuthority,
---------+		b.pool.LPMint,
---------+	)
---------+	if err != nil {
---------+		return nil, fmt.Errorf("failed to find user LP token account: %w", err)
---------+	}
---------+
---------+	// Сериализуем данные инструкции
---------+	data := make([]byte, 10) // 1 (тип) + 1 (nonce) + 8 (initialLPSupply)
---------+	data[0] = byte(InstructionTypeInitialize)
---------+	data[1] = params.Nonce
---------+	binary.LittleEndian.PutUint64(data[2:], params.InitialLPSupply)
---------+
---------+	// Создаем список необходимых аккаунтов
---------+	accountMetas := solana.AccountMetaSlice{
---------+		solana.NewAccountMeta(b.pool.ID, true, false),                // AMM ID
---------+		solana.NewAccountMeta(b.pool.Authority, true, false),         // AMM Authority
---------+		solana.NewAccountMeta(b.pool.BaseVault, true, false),         // Base Token Vault
---------+		solana.NewAccountMeta(b.pool.QuoteVault, true, false),        // Quote Token Vault
---------+		solana.NewAccountMeta(b.pool.LPMint, true, false),            // LP Token Mint
---------+		solana.NewAccountMeta(userLPAccount, true, false),            // User LP Token Account
---------+		solana.NewAccountMeta(params.UserAuthority, true, true),      // User Authority (signer)
---------+		solana.NewAccountMeta(solana.TokenProgramID, false, false),   // Token Program
---------+		solana.NewAccountMeta(solana.SysVarRentPubkey, false, false), // Rent Sysvar
+--------+	// Если указан lookup table ID, проверяем что он валидный
+--------+	if !pool.LookupTableID.IsZero() {
+--------+		// Проверка существования lookup table будет выполнена при загрузке
+--------+		logger := pm.logger.With(
+--------+			zap.String("lookup_table_id", pool.LookupTableID.String()),
+--------+		)
+--------+		logger.Debug("Pool has lookup table configuration")
 --------+	}
---------+
---------+	return solana.NewInstruction(
---------+		b.pool.AmmProgramID,
---------+		accountMetas,
---------+		data,
---------+	), nil
+-------- 	return nil
 -------- }
 -------- 
--------- // BuildDepositInstruction создает инструкцию депозита в пул
--------- func (b *SwapInstructionBuilder) BuildDepositInstruction(
--------- 	ctx context.Context,
----------	maxBaseAmount uint64,
----------	maxQuoteAmount uint64,
---------+	params DepositParams,
--------- ) (solana.Instruction, error) {
----------	// ... реализация создания инструкции депозита
----------	return nil, nil
---------+	logger := b.logger.With(
---------+		zap.Uint64("max_base_amount", params.MaxBaseAmount),
---------+		zap.Uint64("max_quote_amount", params.MaxQuoteAmount),
---------+		zap.String("user_authority", params.UserAuthority.String()),
---------+	)
---------+	logger.Debug("Building deposit instruction")
---------+
---------+	// Находим пользовательские токен аккаунты
---------+	userBaseAccount, _, err := solana.FindAssociatedTokenAddress(
---------+		params.UserAuthority,
---------+		b.pool.BaseMint,
---------+	)
---------+	if err != nil {
---------+		return nil, fmt.Errorf("failed to find user base token account: %w", err)
---------+	}
---------+
---------+	userQuoteAccount, _, err := solana.FindAssociatedTokenAddress(
---------+		params.UserAuthority,
---------+		b.pool.QuoteMint,
---------+	)
---------+	if err != nil {
---------+		return nil, fmt.Errorf("failed to find user quote token account: %w", err)
---------+	}
---------+
---------+	userLPAccount, _, err := solana.FindAssociatedTokenAddress(
---------+		params.UserAuthority,
---------+		b.pool.LPMint,
---------+	)
---------+	if err != nil {
---------+		return nil, fmt.Errorf("failed to find user LP token account: %w", err)
---------+	}
---------+
---------+	// Сериализуем данные инструкции
---------+	data := make([]byte, 17) // 1 (тип) + 8 (maxBaseAmount) + 8 (maxQuoteAmount)
---------+	data[0] = byte(InstructionTypeDeposit)
---------+	binary.LittleEndian.PutUint64(data[1:9], params.MaxBaseAmount)
---------+	binary.LittleEndian.PutUint64(data[9:17], params.MaxQuoteAmount)
---------+
---------+	// Создаем список необходимых аккаунтов
---------+	accountMetas := solana.AccountMetaSlice{
---------+		solana.NewAccountMeta(b.pool.ID, true, false),              // AMM ID
---------+		solana.NewAccountMeta(b.pool.Authority, false, false),      // AMM Authority
---------+		solana.NewAccountMeta(b.pool.BaseVault, true, false),       // Base Token Vault
---------+		solana.NewAccountMeta(b.pool.QuoteVault, true, false),      // Quote Token Vault
---------+		solana.NewAccountMeta(b.pool.LPMint, true, false),          // LP Token Mint
---------+		solana.NewAccountMeta(userBaseAccount, true, false),        // User Base Token Account
---------+		solana.NewAccountMeta(userQuoteAccount, true, false),       // User Quote Token Account
---------+		solana.NewAccountMeta(userLPAccount, true, false),          // User LP Token Account
---------+		solana.NewAccountMeta(params.UserAuthority, true, true),    // User Authority (signer)
---------+		solana.NewAccountMeta(solana.TokenProgramID, false, false), // Token Program
---------+	}
---------+
---------+	// Добавим проверку существования аккаунтов
---------+	if err := b.validateDepositAccounts(ctx, userBaseAccount, userQuoteAccount, userLPAccount); err != nil {
---------+		return nil, fmt.Errorf("invalid accounts: %w", err)
---------+	}
+--------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
+--------index a2965fa..6100e4c 100644
+----------- a/internal/dex/raydium/types.go
+--------+++ b/internal/dex/raydium/types.go
+--------@@ -78,7 +78,10 @@ type RaydiumPool struct {
+-------- 	MarketAsks       solana.PublicKey
+-------- 	MarketEventQueue solana.PublicKey
+-------- 	MarketVersion    uint8
+---------	LookupTableID    solana.PublicKey
 --------+
---------+	return solana.NewInstruction(
---------+		b.pool.AmmProgramID,
---------+		accountMetas,
---------+		data,
---------+	), nil
--------- }
+--------+	// Lookup Table конфигурация
+--------+	LookupTableID        solana.PublicKey
+--------+	LookupTableAddresses solana.PublicKeySlice // добавляем это поле
 -------- 
----------// BuildWithdrawInstruction создает инструкцию вывода из пула
----------func (b *SwapInstructionBuilder) BuildWithdrawInstruction(
---------+// validateDepositAccounts проверяет существование необходимых аккаунтов
---------+func (b *SwapInstructionBuilder) validateDepositAccounts(
--------- 	ctx context.Context,
----------	lpAmount uint64,
----------) (solana.Instruction, error) {
----------	// ... реализация создания инструкции вывода
----------	return nil, nil
---------+	userBaseAccount,
---------+	userQuoteAccount,
---------+	userLPAccount solana.PublicKey,
---------+) error {
---------+	for _, check := range []struct {
---------+		account solana.PublicKey
---------+		name    string
---------+	}{
---------+		{userBaseAccount, "user base token"},
---------+		{userQuoteAccount, "user quote token"},
---------+		{userLPAccount, "user LP token"},
---------+	} {
---------+		info, err := b.client.GetAccountInfo(ctx, check.account)
---------+		if err != nil {
---------+			return fmt.Errorf("failed to get %s account info: %w", check.name, err)
---------+		}
---------+		if info.Value == nil || !info.Value.Owner.Equals(solana.TokenProgramID) {
---------+			return fmt.Errorf("invalid %s account", check.name)
---------+		}
---------+	}
---------+	return nil
+-------- 	// Версионирование и инструкции
+-------- 	Version              uint8
+--------diff --git a/internal/dex/raydium/utils.go b/internal/dex/raydium/utils.go
+--------index 9739bad..104cc1d 100644
+----------- a/internal/dex/raydium/utils.go
+--------+++ b/internal/dex/raydium/utils.go
+--------@@ -311,12 +311,14 @@ func ConvertBigFloatToUint64(value *big.Float) (uint64, error) {
 -------- }
 -------- 
--------- // GetRequiredAccounts собирает все необходимые аккаунты для свапа
---------@@ -277,22 +404,166 @@ func (b *SwapInstructionBuilder) GetRequiredAccounts(
--------- 	return accounts, nil
+-------- // Утилиты для версионированных транзакций
+--------+// TODO: Implement the method logic
+-------- func CreateVersionedTransaction(instructions []solana.Instruction, lookupTables []solana.AddressLookupTable) (*solana.VersionedTransaction, error) {
+-------- 	// Создаем транзакцию
+-------- 	return nil, nil
 -------- }
 -------- 
---------+// Параметры для вывода из пула
---------+type WithdrawParams struct {
---------+	LPAmount      uint64
---------+	UserAuthority solana.PublicKey
---------+}
---------+
---------+// BuildWithdrawInstruction создает инструкцию вывода из пула
---------+func (b *SwapInstructionBuilder) BuildWithdrawInstruction(
---------+	ctx context.Context,
---------+	params WithdrawParams,
---------+) (solana.Instruction, error) {
---------+	logger := b.logger.With(
---------+		zap.Uint64("lp_amount", params.LPAmount),
---------+		zap.String("user_authority", params.UserAuthority.String()),
---------+	)
---------+	logger.Debug("Building withdraw instruction")
---------+
---------+	// Находим пользовательские токен аккаунты
---------+	userBaseAccount, _, err := solana.FindAssociatedTokenAddress(
---------+		params.UserAuthority,
---------+		b.pool.BaseMint,
---------+	)
---------+	if err != nil {
---------+		return nil, fmt.Errorf("failed to find user base token account: %w", err)
---------+	}
---------+
---------+	userQuoteAccount, _, err := solana.FindAssociatedTokenAddress(
---------+		params.UserAuthority,
---------+		b.pool.QuoteMint,
---------+	)
---------+	if err != nil {
---------+		return nil, fmt.Errorf("failed to find user quote token account: %w", err)
---------+	}
---------+
---------+	userLPAccount, _, err := solana.FindAssociatedTokenAddress(
---------+		params.UserAuthority,
---------+		b.pool.LPMint,
---------+	)
---------+	if err != nil {
---------+		return nil, fmt.Errorf("failed to find user LP token account: %w", err)
---------+	}
---------+
---------+	// Сериализуем данные инструкции
---------+	data := make([]byte, 9) // 1 (тип) + 8 (lpAmount)
---------+	data[0] = byte(InstructionTypeWithdraw)
---------+	binary.LittleEndian.PutUint64(data[1:], params.LPAmount)
---------+
---------+	// Создаем список необходимых аккаунтов
---------+	accountMetas := solana.AccountMetaSlice{
---------+		solana.NewAccountMeta(b.pool.ID, true, false),              // AMM ID
---------+		solana.NewAccountMeta(b.pool.Authority, false, false),      // AMM Authority
---------+		solana.NewAccountMeta(b.pool.BaseVault, true, false),       // Base Token Vault
---------+		solana.NewAccountMeta(b.pool.QuoteVault, true, false),      // Quote Token Vault
---------+		solana.NewAccountMeta(b.pool.LPMint, true, false),          // LP Token Mint
---------+		solana.NewAccountMeta(userBaseAccount, true, false),        // User Base Token Account
---------+		solana.NewAccountMeta(userQuoteAccount, true, false),       // User Quote Token Account
---------+		solana.NewAccountMeta(userLPAccount, true, false),          // User LP Token Account
---------+		solana.NewAccountMeta(params.UserAuthority, true, true),    // User Authority (signer)
---------+		solana.NewAccountMeta(solana.TokenProgramID, false, false), // Token Program
---------+	}
---------+
---------+	// Проверяем существование аккаунтов
---------+	if err := b.validateWithdrawAccounts(ctx, userBaseAccount, userQuoteAccount, userLPAccount); err != nil {
---------+		return nil, fmt.Errorf("invalid accounts: %w", err)
---------+	}
---------+
---------+	return solana.NewInstruction(
---------+		b.pool.AmmProgramID,
---------+		accountMetas,
---------+		data,
---------+	), nil
---------+}
---------+
---------+// validateWithdrawAccounts проверяет существование необходимых аккаунтов
---------+func (b *SwapInstructionBuilder) validateWithdrawAccounts(
---------+	ctx context.Context,
---------+	userBaseAccount,
---------+	userQuoteAccount,
---------+	userLPAccount solana.PublicKey,
---------+) error {
---------+	for _, check := range []struct {
---------+		account solana.PublicKey
---------+		name    string
---------+	}{
---------+		{userBaseAccount, "user base token"},
---------+		{userQuoteAccount, "user quote token"},
---------+		{userLPAccount, "user LP token"},
---------+	} {
---------+		info, err := b.client.GetAccountInfo(ctx, check.account)
---------+		if err != nil {
---------+			return fmt.Errorf("failed to get %s account info: %w", check.name, err)
---------+		}
---------+		if info.Value == nil || !info.Value.Owner.Equals(solana.TokenProgramID) {
---------+			return fmt.Errorf("invalid %s account", check.name)
---------+		}
---------+	}
---------+	return nil
---------+}
---------+
--------- // BuildVersionedSwapInstruction создает версионированную инструкцию свапа
--------- func (b *SwapInstructionBuilder) BuildVersionedSwapInstruction(
--------- 	ctx context.Context,
--------- 	params SwapParams,
--------- 	accounts SwapInstructionAccounts,
--------- ) (*solana.VersionedTransaction, error) {
----------	// ... реализация создания версионированной инструкции свапа
----------	return nil, nil
---------+	logger := b.logger.With(
---------+		zap.String("user", accounts.UserAuthority.String()),
---------+		zap.Uint64("amount_in", params.AmountIn),
---------+		zap.Uint64("min_amount_out", params.MinAmountOut),
---------+	)
---------+	logger.Debug("Building versioned swap instruction")
---------+
---------+	// Создаем базовую инструкцию свапа
---------+	instruction, err := b.BuildSwapInstruction(ctx, params, accounts)
---------+	if err != nil {
---------+		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
---------+	}
---------+
---------+	// Создаем message для транзакции
---------+	message := solana.NewMessage(
---------+		solana.MessageV0, // используем версию 0 для версионированных транзакций
---------+		[]solana.Instruction{instruction},
---------+		accounts.UserAuthority, // fee payer
---------+	)
---------+
---------+	// Если есть lookup table, добавляем её
---------+	if !b.pool.LookupTableID.IsZero() {
---------+		addressLookupTable := &solana.MessageAddressTableLookup{
---------+			AccountKey:      b.pool.LookupTableID,
---------+			WritableIndexes: []uint8{}, // заполнить необходимыми индексами
---------+			ReadonlyIndexes: []uint8{}, // заполнить необходимыми индексами
---------+		}
---------+		message.AddressTableLookups = append(message.AddressTableLookups, addressLookupTable)
---------+	}
---------+
---------+	// Создаем версионированную транзакцию
---------+	tx := &solana.VersionedTransaction{
---------+		Message:    message,
---------+		Signatures: make([]solana.Signature, message.Header.NumRequiredSignatures),
---------+	}
---------+
---------+	logger.Debug("Versioned swap transaction built successfully")
---------+
---------+	return tx, nil
--------- }
--------- 
----------// BuildDepositInstruction создает инструкцию депозита
----------func (b *SwapInstructionBuilder) BuildDepositInstruction(
----------	ctx context.Context,
----------	params DepositParams,
----------	accounts DepositInstructionAccounts,
----------) (solana.Instruction, error) {
----------	// ... реализация создания инструкции депозита
----------	return nil, nil
---------+// DepositInstructionAccounts аккаунты, необходимые для депозита
---------+type DepositInstructionAccounts struct {
---------+	// Пользовательские аккаунты
---------+	UserAuthority  solana.PublicKey // Аккаунт пользователя, который делает депозит
---------+	UserBaseToken  solana.PublicKey // Аккаунт base токенов пользователя
---------+	UserQuoteToken solana.PublicKey // Аккаунт quote токенов пользователя
---------+	UserLPToken    solana.PublicKey // Аккаунт LP токенов пользователя
---------+
---------+	// Аккаунты пула
---------+	AmmId           solana.PublicKey // ID пула
---------+	AmmAuthority    solana.PublicKey // Authority пула
---------+	AmmOpenOrders   solana.PublicKey // OpenOrders аккаунт пула
---------+	AmmTargetOrders solana.PublicKey // TargetOrders аккаунт пула
---------+	LPMint          solana.PublicKey // Минт LP токенов
---------+	PoolBaseVault   solana.PublicKey // Vault для base токенов пула
---------+	PoolQuoteVault  solana.PublicKey // Vault для quote токенов пула
--------- }
---------diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
---------index e6d2983..2851f20 100644
------------ a/internal/dex/raydium/pool.go
---------+++ b/internal/dex/raydium/pool.go
---------@@ -47,15 +47,17 @@ func (pm *PoolManager) InitializePool(ctx context.Context, params *RaydiumPool)
--------- 
--------- // PoolCalculator предоставляет методы для расчетов в пуле
--------- type PoolCalculator struct {
----------	pool  *RaydiumPool
----------	state *PoolState
---------+	pool   *RaydiumPool
---------+	state  *PoolState
---------+	logger *zap.Logger // Добавляем logger в структуру
--------- }
--------- 
--------- // NewPoolCalculator создает новый калькулятор для пула
----------func NewPoolCalculator(pool *RaydiumPool, state *PoolState) *PoolCalculator {
---------+func NewPoolCalculator(pool *RaydiumPool, state *PoolState, logger *zap.Logger) *PoolCalculator {
--------- 	return &PoolCalculator{
----------		pool:  pool,
----------		state: state,
---------+		pool:   pool,
---------+		state:  state,
---------+		logger: logger.Named("pool-calculator"), // Добавляем префикс для логгера
--------- 	}
--------- }
--------- 
---------@@ -83,26 +85,24 @@ func (pc *PoolCalculator) CalculateSwapAmount(
--------- 
--------- 	var amountOut *big.Float
--------- 	if side == SwapSideIn {
----------		// dx * y / (x + dx)
--------- 		numerator := new(big.Float).Mul(amountInAfterFee, quoteReserveF)
--------- 		denominator := new(big.Float).Add(baseReserveF, amountInAfterFee)
--------- 		amountOut = new(big.Float).Quo(numerator, denominator)
--------- 	} else {
----------		// dx * y / (x + dx)
--------- 		numerator := new(big.Float).Mul(amountInAfterFee, baseReserveF)
--------- 		denominator := new(big.Float).Add(quoteReserveF, amountInAfterFee)
--------- 		amountOut = new(big.Float).Quo(numerator, denominator)
--------- 	}
--------- 
----------	// Конвертируем результат обратно в uint64
----------	var amountOutU uint64
----------	amountOut.Uint64(&amountOutU)
---------+	// Исправляем конвертацию в uint64
---------+	amountOutU, _ := amountOut.Uint64()
--------- 
--------- 	// Учитываем слиппаж для минимального выхода
--------- 	slippageMultiplier := new(big.Float).SetFloat64(1 - float64(slippageBps)/10000)
--------- 	minAmountOut := new(big.Float).Mul(new(big.Float).SetUint64(amountOutU), slippageMultiplier)
----------	var minAmountOutU uint64
----------	minAmountOut.Uint64(&minAmountOutU)
---------+
---------+	// Исправляем конвертацию в uint64
---------+	minAmountOutU, _ := minAmountOut.Uint64()
--------- 
--------- 	return &SwapAmounts{
--------- 		AmountIn:     amountIn,
---------@@ -140,14 +140,15 @@ func (pc *PoolCalculator) GetOptimalSwapAmount(
--------- 	targetAmount uint64,
--------- 	slippageBps uint16,
--------- ) (*SwapAmounts, error) {
----------	logger := pm.logger.With(
---------+	// Исправляем pm на pc.pool, так как мы находимся в методе PoolCalculator
---------+	logger := pc.logger.With(
--------- 		zap.Uint64("available_amount", availableAmount),
--------- 		zap.Uint64("target_amount", targetAmount),
--------- 		zap.Uint16("slippage_bps", slippageBps),
--------- 	)
--------- 	logger.Debug("Calculating optimal swap amount")
--------- 
----------	// Используем бинарный поиск для нахождения оптимального количества
---------+	// Остальной код остается без изменений
--------- 	left := uint64(1)
--------- 	right := availableAmount
--------- 	var bestAmount *SwapAmounts
---------@@ -271,6 +272,17 @@ func (pc *PoolCalculator) GetMarketPrice() float64 {
--------- 	return (quoteF / quoteDecimalAdj) / (baseF / baseDecimalAdj)
--------- }
--------- 
---------+// Добавить в pool.go:
---------+type RaydiumV5Pool struct {
---------+	RaydiumPool
---------+	PnlOwner    solana.PublicKey
---------+	ModelDataId solana.PublicKey
---------+	RecentRoot  *big.Int
---------+	MaxOrders   uint64
---------+	OrderStates []*big.Int
---------+	TickSpacing uint16
---------+}
---------+
--------- // Методы для работы с v5 пулами
--------- func (pm *PoolManager) InitializeV5Pool(ctx context.Context, params *RaydiumPoolV5) error {
--------- 	// TODO: implement
---------diff --git a/internal/dex/raydium/state.go b/internal/dex/raydium/state.go
---------index 49dd70a..cff0664 100644
------------ a/internal/dex/raydium/state.go
---------+++ b/internal/dex/raydium/state.go
---------@@ -6,7 +6,6 @@ import (
--------- 	"fmt"
--------- 	"math"
--------- 
----------	"github.com/gagliardetto/binary"
--------- 	"github.com/gagliardetto/solana-go"
--------- 	"go.uber.org/zap"
--------- )
---------@@ -294,16 +293,101 @@ func (d *StateDecoder) CalculateVirtualPrice(layout *Layout) (float64, error) {
--------- 	return 2 * sqrtK / lpAdjusted, nil
--------- }
--------- 
----------// Декодер для v5 состояния
---------+// LayoutV5 расширяет базовую структуру Layout дополнительными полями для v5
---------+type LayoutV5 struct {
---------+	Layout                       // Встраиваем базовый Layout
---------+	PnlOwner    solana.PublicKey // Владелец PnL
---------+	ModelDataId solana.PublicKey // ID модели данных
---------+	PnlPool     solana.PublicKey // Пул PnL
---------+}
---------+
---------+// DecodeV5State декодирует бинарные данные в структуру состояния версии 5
--------- func (d *StateDecoder) DecodeV5State(data []byte) (*LayoutV5, error) {
----------	// ... реализация декодирования v5 состояния
----------	// Этот метод будет реализован в следующей части
----------	return nil, nil
---------+	logger := d.logger.With(zap.Int("data_length", len(data)))
---------+	logger.Debug("Starting v5 state decoding")
---------+
---------+	// Сначала декодируем базовую структуру
---------+	baseLayout, err := d.DecodeState(data)
---------+	if err != nil {
---------+		return nil, fmt.Errorf("failed to decode base layout: %w", err)
---------+	}
---------+
---------+	// Проверяем версию
---------+	if baseLayout.Version != uint8(StateV5) {
---------+		return nil, fmt.Errorf("invalid version for V5 decode: %d", baseLayout.Version)
---------+	}
---------+
---------+	// Создаем V5 структуру
---------+	layout := &LayoutV5{
---------+		Layout: *baseLayout,
---------+	}
---------+
---------+	// Вычисляем смещение для дополнительных полей V5
---------+	offset := d.GetStateSize(StateV4)
---------+
---------+	// Проверяем достаточно ли данных для V5 полей
---------+	if len(data) < int(d.GetStateSize(StateV5)) {
---------+		return nil, fmt.Errorf("insufficient data for V5 layout: got %d, need %d",
---------+			len(data), d.GetStateSize(StateV5))
---------+	}
---------+
---------+	// Читаем дополнительные поля V5
---------+	copy(layout.PnlOwner[:], data[offset:offset+32])
---------+	offset += 32
---------+
---------+	copy(layout.ModelDataId[:], data[offset:offset+32])
---------+	offset += 32
---------+
---------+	copy(layout.PnlPool[:], data[offset:offset+32])
---------+
---------+	logger.Debug("V5 state decoded successfully",
---------+		zap.Stringer("pnl_owner", layout.PnlOwner),
---------+		zap.Stringer("model_data_id", layout.ModelDataId),
---------+		zap.Stringer("pnl_pool", layout.PnlPool))
---------+
---------+	return layout, nil
--------- }
--------- 
----------// Методы миграции
---------+// MigrateState выполняет миграцию состояния между версиями
--------- func (d *StateDecoder) MigrateState(oldState *Layout, newVersion StateVersion) (*Layout, error) {
----------	// ... реализация миграции состояния
----------	// Этот метод будет реализован в следующей части
----------	return nil, nil
---------+	if oldState == nil {
---------+		return nil, fmt.Errorf("old state is nil")
---------+	}
---------+
---------+	// Проверяем корректность текущей версии
---------+	currentVersion := StateVersion(oldState.Version)
---------+	if currentVersion != StateV4 && currentVersion != StateV5 {
---------+		return nil, fmt.Errorf("unsupported current version: %d", currentVersion)
---------+	}
---------+
---------+	// Проверяем поддерживается ли миграция на новую версию
---------+	if newVersion != StateV4 && newVersion != StateV5 {
---------+		return nil, fmt.Errorf("unsupported target version: %d", newVersion)
---------+	}
---------+
---------+	// Если версии совпадают, возвращаем копию старого состояния
---------+	if currentVersion == newVersion {
---------+		newState := *oldState
---------+		return &newState, nil
---------+	}
---------+
---------+	// Миграция с V4 на V5
---------+	if currentVersion == StateV4 && newVersion == StateV5 {
---------+		// При миграции с V4 на V5 мы просто копируем базовые поля
---------+		// и инициализируем новые поля нулевыми значениями
---------+		newState := *oldState
---------+		newState.Version = uint8(StateV5)
---------+		return &newState, nil
---------+	}
---------+
---------+	// Миграция с V5 на V4
---------+	if currentVersion == StateV5 && newVersion == StateV4 {
---------+		// При миграции с V5 на V4 мы просто копируем базовые поля
---------+		newState := *oldState
---------+		newState.Version = uint8(StateV4)
---------+		return &newState, nil
---------+	}
---------+
---------+	return nil, fmt.Errorf("unsupported migration path: %d -> %d",
---------+		currentVersion, newVersion)
--------- }
---------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
---------index ef19a7a..a2965fa 100644
------------ a/internal/dex/raydium/types.go
---------+++ b/internal/dex/raydium/types.go
---------@@ -5,8 +5,10 @@ package raydium
--------- import (
--------- 	"context"
--------- 	"fmt"
---------+	"math/big"
--------- 
--------- 	"github.com/gagliardetto/solana-go"
---------+	"go.uber.org/zap"
--------- )
--------- 
--------- // Layout константы для правильного чтения данных из аккаунта пула
---------@@ -28,6 +30,20 @@ const (
--------- 	MinimumAmountOut      = 1
--------- )
--------- 
---------+const (
---------+	PoolDataSize = 217 // Минимальный размер данных пула
---------+
---------+	LayoutAmmProgramID = 2
---------+	LayoutAuthority    = 34
---------+	LayoutBaseVault    = 66
---------+	LayoutQuoteVault   = 98
---------+	LayoutBaseMint     = 130
---------+	LayoutQuoteMint    = 162
---------+	LayoutBaseReserve  = 194
---------+	LayoutQuoteReserve = 202
---------+	LayoutFeeRate      = 210
---------+)
---------+
--------- // RaydiumPool представляет собой конфигурацию пула ликвидности Raydium
--------- type RaydiumPool struct {
--------- 	// Программы
---------@@ -69,6 +85,34 @@ type RaydiumPool struct {
--------- 	SwapInstructionIndex uint8
--------- 	DefaultMinimumOutBps uint16 // базовых пунктов (1 bps = 0.01%)
--------- 	DefaultFeeBps        uint16 // комиссия пула в базовых пунктах
---------+
---------+	// Статус пула
---------+	Status uint8
---------+	Nonce  uint8
---------+
---------+	BaseReserve  uint64
---------+	QuoteReserve uint64
---------+	FeeRate      uint64
---------+}
---------+
---------+// Добавить в types.go:
---------+type LiquidityState struct {
---------+	Status      uint8
---------+	Nonce       uint8
---------+	MaxOrder    *big.Int         // Используется для ограничения размера ордера
---------+	DepthBPS    uint64           // Глубина пула в базисных пунктах
---------+	PnLOwner    solana.PublicKey // Владелец PnL
---------+	ModelDataId solana.PublicKey // ID модели данных
---------+	RecentRoot  *big.Int         // Последний корень для верификации
---------+	OrderBook   OrderBookState
---------+}
---------+
---------+type OrderBookState struct {
---------+	Bids       solana.PublicKey
---------+	Asks       solana.PublicKey
---------+	EventQueue solana.PublicKey
---------+	BaseVault  solana.PublicKey
---------+	QuoteVault solana.PublicKey
--------- }
--------- 
--------- // PoolState содержит динамическое состояние пула
---------@@ -99,6 +143,11 @@ type SwapParams struct {
--------- 	WritableIndexes     []uint8           // Индексы для writable аккаунтов в lookup table
--------- 	ReadonlyIndexes     []uint8           // Индексы для readonly аккаунтов в lookup table
--------- 	Pool                *RaydiumPool      // Информация о пуле
---------+	Logger              *zap.Logger       // Добавляем поле logger
---------+
---------+	// Аккаунты для свапа
---------+	SourceTokenAccount      solana.PublicKey
---------+	DestinationTokenAccount solana.PublicKey
--------- }
--------- 
--------- // Client представляет интерфейс для взаимодействия с Raydium DEX
---------diff --git a/internal/dex/raydium/utils.go b/internal/dex/raydium/utils.go
---------index b8f7378..9739bad 100644
------------ a/internal/dex/raydium/utils.go
---------+++ b/internal/dex/raydium/utils.go
---------@@ -2,6 +2,7 @@
--------- package raydium
--------- 
--------- import (
---------+	"bytes"
--------- 	"context"
--------- 	"encoding/binary"
--------- 	"fmt"
---------@@ -152,7 +153,6 @@ func FindAssociatedTokenAddress(
--------- 			owner, // payer
--------- 			ata,   // ata
--------- 			owner, // owner
----------			mint,  // mint
--------- 		).Build()
--------- 
--------- 		instructions = append(instructions, createATAInst)
---------@@ -271,7 +271,7 @@ func ValidateTokenAccount(
--------- 	}
--------- 
--------- 	var tokenAccount token.Account
----------	if err := binary.NewDecoder(info.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
---------+	if err := binary.Read(bytes.NewReader(info.Value.Data.GetBinary()), binary.LittleEndian, &tokenAccount); err != nil {
--------- 		return fmt.Errorf("failed to decode token account: %w", err)
--------- 	}
--------- 
---------diff --git a/newdif.txt b/newdif.txt
---------index 2431b7e..949f2f1 100644
------------ a/newdif.txt
---------+++ b/newdif.txt
---------@@ -1,4014 +0,0 @@
----------diff --git a/TODOata.md b/TODOata.md
----------deleted file mode 100644
----------index daa131d..0000000
------------- a/TODOata.md
----------+++ /dev/null
----------@@ -1,69 +0,0 @@
-----------
-----------## Оптимизация работы с ATA (Associated Token Accounts)
-----------
-----------### 1. Этап подготовки и архитектуры
-----------
------------ [ ] Создать отдельный сервис для управления ATA
------------ [ ] Спроектировать интерфейс сервиса
------------ [ ] Определить методы и основные операции
------------ [ ] Разработать схему кэширования
------------ [ ] Определить стратегии обработки ошибок
-----------
------------ [ ] Разработать систему предварительной инициализации
------------ [ ] Создать механизм проверки необходимых ATA
-----------      - [ ] Внедрить процесс предварительного создания ATA
------------ [ ] Добавить валидацию состояния ATA
-----------
-----------### 2. Оптимизация RPC взаимодействия
-----------
------------ [ ] Улучшить работу с RPC запросами
------------ [ ] Внедрить batch-запросы для множественных проверок
------------ [ ] Оптимизировать частоту запросов
------------ [ ] Настроить умные повторные попытки
-----------
------------ [ ] Создать систему кэширования
------------ [ ] Реализовать локальный кэш ATA состояний
-----------  - [ ] Настроить TTL для кэша
-----------  - [ ] Добавить механизм инвалидации кэша
-----------
-----------### 3. Мониторинг и логирование
-----------
------------ [ ] Внедрить расширенное логирование
-----------  - [ ] Добавить детальные логи для каждой операции с ATA
-----------  - [ ] Логировать времена выполнения операций
-----------  - [ ] Отслеживать ошибки и их причины
-----------
------------ [ ] Настроить метрики
-----------  - [ ] Время создания ATA
-----------  - [ ] Количество успешных/неуспешных операций
-----------  - [ ] Использование кэша
-----------  - [ ] Задержки RPC
-----------
------------ [ ] Создать систему алертов
-----------  - [ ] Настроить оповещения о критических ошибках
-----------  - [ ] Мониторить аномалии в работе
-----------  - [ ] Отслеживать деградацию производительности
-----------
-----------### 4. Обработка ошибок
-----------
------------ [ ] Улучшить систему обработки ошибок
-----------  - [ ] Создать специфические коды ошибок
-----------  - [ ] Внедрить механизм автоматического восстановления
-----------  - [ ] Добавить логику повторных попыток
-----------
------------ [ ] Разработать стратегии восстановления
-----------  - [ ] Определить сценарии восстановления
-----------  - [ ] Внедрить автоматическое исправление ошибок
-----------  - [ ] Добавить механизм откатов
-----------
-----------### 5. Производительность
-----------
------------ [ ] Оптимизировать работу с ATA
-----------  - [ ] Внедрить параллельную обработку запросов
-----------  - [ ] Оптимизировать использование памяти
-----------  - [ ] Улучшить время отклика
-----------
------------ [ ] Настроить пулы и очереди
-----------  - [ ] Создать пул предварительно инициализированных ATA
-----------  - [ ] Настроить очередь для операций создания
-----------  - [ ] Оптимизировать управление ресурсами
----------diff --git a/go.mod b/go.mod
----------index 6c586dc..6b29758 100644
------------- a/go.mod
----------+++ b/go.mod
----------@@ -10,7 +10,7 @@ require (
---------- 	github.com/google/uuid v1.6.0
---------- 	github.com/mr-tron/base58 v1.2.0
---------- 	github.com/prometheus/client_golang v1.20.5
-----------	github.com/sirupsen/logrus v1.9.3
----------+	github.com/shopspring/decimal v1.3.1
---------- 	github.com/spf13/viper v1.19.0
---------- 	go.uber.org/zap v1.27.0
---------- 	gopkg.in/natefinch/lumberjack.v2 v2.2.1
----------diff --git a/go.sum b/go.sum
----------index 6a9097a..21aa3cc 100644
------------- a/go.sum
----------+++ b/go.sum
----------@@ -141,8 +141,6 @@ github.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6g
---------- github.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=
---------- github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8=
---------- github.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=
-----------github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
-----------github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
---------- github.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=
---------- github.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=
---------- github.com/spf13/afero v1.11.0 h1:WJQKhtpdm3v2IzqG8VMqrr6Rf3UYpEF239Jy9wNepM8=
----------@@ -235,7 +233,6 @@ golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7w
---------- golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
---------- golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
---------- golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
-----------golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
---------- golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
---------- golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
---------- golang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=
----------diff --git a/internal/dex/raydium/config.go b/internal/dex/raydium/config.go
----------deleted file mode 100644
----------index fab480a..0000000
------------- a/internal/dex/raydium/config.go
----------+++ /dev/null
----------@@ -1,31 +0,0 @@
-----------// internal/dex/raydium/config.go
-----------package raydium
-----------
-----------// DefaultPoolConfig с обновленным типом для RaydiumSwapInstructionCode
-----------var DefaultPoolConfig = &Pool{
-----------	// Программы
-----------	AmmProgramID:   "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8", // ✅ Подтверждено
-----------	SerumProgramID: "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX",  // ✅ Подтверждено
-----------
-----------	// AMM конфигурация
-----------	AmmID:           "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", // ✅ Подтверждено
-----------	AmmAuthority:    "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1", // ✅ Обновлено (authority)
-----------	AmmOpenOrders:   "HmiHHzq4Fym9e1D4qzLS6LDDM3tNsCTBPDWHTLZ763jY", // ✅ Обновлено (openOrders)
-----------	AmmTargetOrders: "CZza3Ej4Mc58MnxWA385itCC9jCo3L1D7zc3LKy1bZMR", // ✅ Обновлено (targetOrders)
-----------
-----------	// Token Accounts
-----------	PoolCoinTokenAccount: "DQyrAcCrDXQ7NeoqGgDCZwBvWDcYmFCjSb9JtteuvPpz", // ✅ Обновлено (baseVault)
-----------	PoolPcTokenAccount:   "HLmqeL62xR1QoZ1HKKbXRrdN1p3phKpxRMb2VVopvBBz", // ✅ Обновлено (quoteVault)
-----------
-----------	// Serum Market
-----------	SerumMarket:           "8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6", // ✅ Подтверждено
-----------	SerumBids:             "5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh", // ✅ Подтверждено
-----------	SerumAsks:             "EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCLNBEDXDn1d5", // ✅ Обновлено
-----------	SerumEventQueue:       "8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa", // ✅ Подтверждено
-----------	SerumCoinVaultAccount: "CKxTHwM9fPMRRvZmFnFoqKNd9pQR21c5Aq9bh5h9oghX", // ✅ Обновлено (marketBaseVault)
-----------	SerumPcVaultAccount:   "6A5NHCj1yF6urc9wZNe6Bcjj4LVszQNj5DwAWG97yzMu", // ✅ Обновлено (marketQuoteVault)
-----------	SerumVaultSigner:      "CTz5UMLQm2SRWHzQnU62Pi4yJqbNGjgRBHqqp6oDHfF7", // ✅ Обновлено (marketAuthority)
-----------
-----------	// Дополнительные параметры
-----------	RaydiumSwapInstructionCode: 1, // ✅ Не изменилось
-----------}
----------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
----------deleted file mode 100644
----------index c684b6e..0000000
------------- a/internal/dex/raydium/raydium.go
----------+++ /dev/null
----------@@ -1,927 +0,0 @@
-----------// internal/dex/raydium/raydium.go
-----------
-----------package raydium
-----------
-----------import (
-----------	"context"
-----------	"encoding/binary"
-----------	"fmt"
-----------	"math"
-----------	"time"
-----------
-----------	bin "github.com/gagliardetto/binary"
-----------	"github.com/gagliardetto/solana-go"
-----------	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
-----------	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
-----------	"github.com/gagliardetto/solana-go/programs/token"
-----------
-----------	solanarpc "github.com/gagliardetto/solana-go/rpc"
-----------	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
-----------	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
-----------	"github.com/rovshanmuradov/solana-bot/internal/types"
-----------	"github.com/rovshanmuradov/solana-bot/internal/wallet"
-----------	"go.uber.org/zap"
-----------)
-----------
-----------const (
-----------	defaultTimeout  = 10 * time.Second
-----------	maxRetries      = 3
-----------	retryDelay      = 500 * time.Millisecond
-----------	ataCheckTimeout = 5 * time.Second
-----------	txSendTimeout   = 15 * time.Second
-----------)
-----------
-----------// Добавляем новые типы для работы с ценами
-----------type PriceValidator interface {
-----------	ValidatePrice(poolPrice float64) error
-----------	GetMaxDeviation() float64
-----------}
-----------
-----------// Обновляем структуру PoolState
-----------
-----------// Добавляем базовую реализацию валидатора цен
-----------type BasicPriceValidator struct {
-----------	basePrice    float64
-----------	maxDeviation float64
-----------	logger       *zap.Logger
-----------}
-----------
-----------func NewBasicPriceValidator(basePrice float64, maxDeviation float64, logger *zap.Logger) *BasicPriceValidator {
-----------	return &BasicPriceValidator{
-----------		basePrice:    basePrice,
-----------		maxDeviation: maxDeviation,
-----------		logger:       logger,
-----------	}
-----------}
-----------
-----------func (v *BasicPriceValidator) ValidatePrice(poolPrice float64) error {
-----------	if v.basePrice <= 0 {
-----------		// Если базовая цена не установлена, пропускаем валидацию
-----------		return nil
-----------	}
-----------
-----------	deviation := math.Abs(poolPrice-v.basePrice) / v.basePrice
-----------	if deviation > v.maxDeviation {
-----------		return fmt.Errorf("pool price deviation too high: %.2f%% (pool: %.2f, base: %.2f)",
-----------			deviation*100, poolPrice, v.basePrice)
-----------	}
-----------
-----------	return nil
-----------}
-----------
-----------func (v *BasicPriceValidator) GetMaxDeviation() float64 {
-----------	return v.maxDeviation
-----------}
-----------
-----------// NewDEX создает новый экземпляр DEX
-----------func NewDEX(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) *DEX {
-----------	if err := validateDEXParams(client, logger, poolInfo); err != nil {
-----------		logger.Error("Failed to create DEX", zap.Error(err))
-----------		return nil
-----------	}
-----------
-----------	priceValidator := NewBasicPriceValidator(
-----------		181.0, // Базовая цена SOL/USDC
-----------		0.5,   // 50% максимальное отклонение
-----------		logger,
-----------	)
-----------
-----------	dex := &DEX{
-----------		client:         client,
-----------		logger:         logger.Named("raydium-dex"),
-----------		poolInfo:       poolInfo,
-----------		tokenCache:     solbc.NewTokenMetadataCache(logger),
-----------		priceValidator: priceValidator,
-----------	}
-----------
-----------	// Инициализируем atomic.Value
-----------	dex.lastPoolState.Store((*PoolState)(nil))
-----------
-----------	return dex
-----------}
-----------
-----------func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wallet.Wallet) error {
-----------	opCtx, cancel := context.WithTimeout(ctx, defaultTimeout)
-----------	defer cancel()
-----------
-----------	r.slippage = task.SlippageConfig.Value
-----------
-----------	logger := r.logger.With(
-----------		zap.String("task", task.TaskName),
-----------		zap.String("wallet", userWallet.PublicKey.String()),
-----------		zap.String("slippage_type", string(task.SlippageConfig.Type)),
-----------		zap.Float64("slippage_value", task.SlippageConfig.Value),
-----------	)
-----------	logger.Info("Starting swap execution")
-----------
-----------	// Parse token addresses
-----------	sourceMint, targetMint, err := parseTokenAddresses(task.SourceToken, task.TargetToken)
-----------	if err != nil {
-----------		return fmt.Errorf("invalid token addresses: %w", err)
-----------	}
-----------
-----------	ataCtx, ataCancel := context.WithTimeout(opCtx, ataCheckTimeout)
-----------	defer ataCancel()
-----------
-----------	// Setup token accounts
-----------	sourceATA, targetATA, err := r.setupTokenAccounts(ataCtx, userWallet, sourceMint, targetMint, logger)
-----------	if err != nil {
-----------		return fmt.Errorf("failed to setup token accounts: %w", err)
-----------	}
-----------
-----------	// Prepare amount with decimals
-----------	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
-----------
-----------	logger.Debug("Prepared swap amount",
-----------		zap.Uint64("amount_in", amountIn),
-----------		zap.String("slippage_type", string(task.SlippageConfig.Type)),
-----------		zap.Float64("slippage_value", task.SlippageConfig.Value),
-----------	)
-----------
-----------	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
-----------	defer swapCancel()
-----------
-----------	// Prepare swap instructions
-----------	instructions, err := r.PrepareSwapInstructions(
-----------		swapCtx,
-----------		userWallet.PublicKey,
-----------		sourceATA,
-----------		targetATA,
-----------		amountIn,
-----------		task.PriorityFee,
-----------		logger,
-----------	)
-----------	if err != nil {
-----------		return fmt.Errorf("failed to prepare swap instructions: %w", err)
-----------	}
-----------
-----------	// Send transaction
-----------	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
-----------	if err != nil {
-----------		return fmt.Errorf("failed to send swap transaction: %w", err)
-----------	}
-----------
-----------	logger.Info("Swap transaction sent successfully",
-----------		zap.String("signature", signature.String()),
-----------		zap.Float64("priority_fee", task.PriorityFee))
-----------
-----------	return nil
-----------}
-----------
-----------func (r *DEX) setupTokenAccounts(
-----------	ctx context.Context,
-----------	wallet *wallet.Wallet,
-----------	sourceMint, targetMint solana.PublicKey,
-----------	logger *zap.Logger,
-----------) (solana.PublicKey, solana.PublicKey, error) {
-----------	sourceATA, _, err := solana.FindAssociatedTokenAddress(wallet.PublicKey, sourceMint)
-----------	if err != nil {
-----------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("failed to find source ATA: %w", err)
-----------	}
-----------
-----------	targetATA, _, err := solana.FindAssociatedTokenAddress(wallet.PublicKey, targetMint)
-----------	if err != nil {
-----------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("failed to find target ATA: %w", err)
-----------	}
-----------
-----------	// Проверяем и создаем ATA если необходимо
-----------	if err := r.ensureATA(ctx, wallet, sourceMint, sourceATA, "source", logger); err != nil {
-----------		return solana.PublicKey{}, solana.PublicKey{}, err
-----------	}
-----------
-----------	if err := r.ensureATA(ctx, wallet, targetMint, targetATA, "target", logger); err != nil {
-----------		return solana.PublicKey{}, solana.PublicKey{}, err
-----------	}
-----------
-----------	return sourceATA, targetATA, nil
-----------}
-----------
-----------func (r *DEX) ensureATA(
-----------	ctx context.Context,
-----------	wallet *wallet.Wallet,
-----------	mint, ata solana.PublicKey,
-----------	ataType string,
-----------	logger *zap.Logger,
-----------) error {
-----------	logger = logger.With(
-----------		zap.String("mint", mint.String()),
-----------		zap.String("ata", ata.String()),
-----------		zap.String("wallet", wallet.PublicKey.String()),
-----------	)
-----------
-----------	// Проверяем существование ATA с повторными попытками
-----------	exists, err := r.checkATAExists(ctx, ata, logger)
-----------	if err != nil {
-----------		return fmt.Errorf("failed to check %s ATA: %w", ataType, err)
-----------	}
-----------
-----------	if !exists {
-----------		logger.Debug("Creating new ATA")
-----------		// Используем правильное создание инструкции из solana-go
-----------		instruction, err := r.createATAInstruction(wallet, mint)
-----------		if err != nil {
-----------			return fmt.Errorf("failed to create %s ATA instruction: %w", ataType, err)
-----------		}
-----------
-----------		// Отправляем транзакцию и ждем подтверждения
-----------		signature, err := r.sendTransactionWithRetryAndConfirmation(ctx, wallet, []solana.Instruction{instruction}, logger)
-----------		if err != nil {
-----------			return fmt.Errorf("failed to create %s ATA: %w", ataType, err)
-----------		}
-----------
-----------		logger.Info("ATA created successfully",
-----------			zap.String("signature", signature.String()))
-----------
-----------		// Ждем появления аккаунта
-----------		if err := r.waitForATACreation(ctx, ata, logger); err != nil {
-----------			return fmt.Errorf("failed to confirm %s ATA creation: %w", ataType, err)
-----------		}
-----------	}
-----------
-----------	return nil
-----------}
-----------
-----------func (r *DEX) checkATAExists(
-----------	ctx context.Context,
-----------	ata solana.PublicKey,
-----------	logger *zap.Logger,
-----------) (bool, error) {
-----------	for attempt := 0; attempt < maxRetries; attempt++ {
-----------		account, err := r.client.GetAccountInfo(ctx, ata)
-----------		if err == nil && account.Value != nil {
-----------			// Проверяем, что владелец - TokenProgram
-----------			return account.Value.Owner == solana.TokenProgramID, nil
-----------		}
-----------
-----------		if attempt < maxRetries-1 {
-----------			select {
-----------			case <-ctx.Done():
-----------				return false, ctx.Err()
-----------			case <-time.After(retryDelay):
-----------				logger.Debug("Retrying ATA check", zap.Int("attempt", attempt+1))
-----------			}
-----------		}
-----------	}
-----------	return false, nil
-----------}
-----------
-----------func (r *DEX) createATAInstruction(
-----------	wallet *wallet.Wallet,
-----------	mint solana.PublicKey,
-----------) (solana.Instruction, error) {
-----------	// Используем билдер из solana-go
-----------	inst := associatedtokenaccount.NewCreateInstruction(
-----------		wallet.PublicKey, // payer
-----------		wallet.PublicKey, // wallet address
-----------		mint,             // token mint
-----------	)
-----------
-----------	// Проводим валидацию
-----------	if err := inst.Validate(); err != nil {
-----------		return nil, fmt.Errorf("invalid ATA instruction: %w", err)
-----------	}
-----------
-----------	return inst.Build(), nil
-----------}
-----------
-----------func (r *DEX) waitForATACreation(
-----------	ctx context.Context,
-----------	ata solana.PublicKey,
-----------	logger *zap.Logger,
-----------) error {
-----------	// Увеличиваем время ожидания до 2 минут
-----------	deadline := time.Now().Add(2 * time.Minute)
-----------	// Начальный интервал проверки
-----------	ticker := time.NewTicker(2 * time.Second)
-----------	defer ticker.Stop()
-----------
-----------	retryCount := 0
-----------	maxRetries := 60 // Максимальное количество попыток
-----------
-----------	for {
-----------		if time.Now().After(deadline) {
-----------			return fmt.Errorf("timeout waiting for ATA creation after 2 minutes")
-----------		}
-----------
-----------		if retryCount >= maxRetries {
-----------			return fmt.Errorf("exceeded maximum retry attempts (%d) waiting for ATA creation", maxRetries)
-----------		}
-----------
-----------		select {
-----------		case <-ctx.Done():
-----------			return ctx.Err()
-----------		case <-ticker.C:
-----------			account, err := r.client.GetAccountInfo(ctx, ata)
-----------			if err != nil {
-----------				logger.Debug("ATA verification attempt failed",
-----------					zap.Error(err),
-----------					zap.Int("retry", retryCount),
-----------					zap.Time("deadline", deadline))
-----------				retryCount++
-----------				continue
-----------			}
-----------
-----------			if account.Value != nil && account.Value.Owner == solana.TokenProgramID {
-----------				logger.Info("ATA creation confirmed",
-----------					zap.String("ata", ata.String()),
-----------					zap.Int("retries", retryCount))
-----------				return nil
-----------			}
-----------
-----------			logger.Debug("ATA not ready yet",
-----------				zap.String("ata", ata.String()),
-----------				zap.Int("retry", retryCount))
-----------			retryCount++
-----------		}
-----------	}
-----------}
-----------
-----------// PrepareSwapInstructions объединяет все инструкции для свапа
-----------func (r *DEX) PrepareSwapInstructions(
-----------	ctx context.Context,
-----------	wallet solana.PublicKey,
-----------	sourceATA solana.PublicKey,
-----------	targetATA solana.PublicKey,
-----------	amountIn uint64,
-----------	priorityFee float64,
-----------	logger *zap.Logger,
-----------) ([]solana.Instruction, error) {
-----------	var instructions []solana.Instruction
-----------
-----------	// Добавляем compute budget инструкции
-----------	computeBudgetInst := computebudget.NewSetComputeUnitPriceInstruction(
-----------		uint64(priorityFee * 1e6),
-----------	).Build()
-----------	instructions = append(instructions, computeBudgetInst)
-----------
-----------	// Создаем базовую инструкцию свапа
-----------	swapInst, err := r.PrepareSwapInstruction(
-----------		ctx,
-----------		wallet,
-----------		sourceATA,
-----------		targetATA,
-----------		amountIn,
-----------		logger,
-----------	)
-----------	if err != nil {
-----------		return nil, fmt.Errorf("failed to prepare swap instruction: %w", err)
-----------	}
-----------	instructions = append(instructions, swapInst)
-----------
-----------	return instructions, nil
-----------}
-----------
-----------// PrepareSwapInstruction подготавливает базовую инструкцию свапа
-----------func (r *DEX) PrepareSwapInstruction(
-----------	ctx context.Context,
-----------	wallet solana.PublicKey,
-----------	sourceATA solana.PublicKey,
-----------	targetATA solana.PublicKey,
-----------	amountIn uint64,
-----------	logger *zap.Logger,
-----------) (solana.Instruction, error) {
-----------	logger = logger.With(
-----------		zap.String("wallet", wallet.String()),
-----------		zap.String("source_ata", sourceATA.String()),
-----------		zap.String("target_ata", targetATA.String()),
-----------	)
-----------	logger.Debug("Preparing swap instruction")
-----------
-----------	// Получаем ожидаемый выход
-----------	sourceMint, err := r.getMintFromATA(ctx, sourceATA)
-----------	if err != nil {
-----------		return nil, fmt.Errorf("failed to get source mint: %w", err)
-----------	}
-----------
-----------	targetMint, err := r.getMintFromATA(ctx, targetATA)
-----------	if err != nil {
-----------		return nil, fmt.Errorf("failed to get target mint: %w", err)
-----------	}
-----------
-----------	expectedOut, err := r.getExpectedOutput(
-----------		ctx,
-----------		amountIn,
-----------		sourceMint,
-----------		targetMint,
-----------		r.poolInfo,
-----------		logger,
-----------	)
-----------	if err != nil {
-----------		return nil, fmt.Errorf("failed to get expected output: %w", err)
-----------	}
-----------
-----------	// Используем slippage из структуры DEX
-----------	minAmountOut := calculateMinimumOut(expectedOut, r.slippage)
-----------
-----------	return r.createSwapInstruction(
-----------		wallet,
-----------		sourceATA,
-----------		targetATA,
-----------		amountIn,
-----------		minAmountOut,
-----------		logger,
-----------		r.poolInfo,
-----------	)
-----------}
-----------
-----------// createSwapInstruction внутренний метод для создания инструкции свапа
-----------func (r *DEX) createSwapInstruction(
-----------	wallet solana.PublicKey,
-----------	sourceATA solana.PublicKey,
-----------	targetATA solana.PublicKey,
-----------	amountIn uint64,
-----------	minAmountOut uint64,
-----------	logger *zap.Logger,
-----------	poolInfo *Pool,
-----------) (solana.Instruction, error) {
-----------	// Существующая логика из CreateSwapInstruction
-----------	return r.CreateSwapInstruction(
-----------		wallet,
-----------		sourceATA,
-----------		targetATA,
-----------		amountIn,
-----------		minAmountOut,
-----------		logger,
-----------		poolInfo,
-----------	)
-----------}
-----------
-----------// Вспомогательный метод для получения mint address из ATA
-----------func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.PublicKey, error) {
-----------	account, err := r.client.GetAccountInfo(ctx, ata)
-----------	if err != nil {
-----------		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
-----------	}
-----------
-----------	if account.Value == nil || len(account.Value.Data.GetBinary()) < 64 {
-----------		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
-----------	}
-----------
-----------	var tokenAccount token.Account
-----------	if err := bin.NewBinDecoder(account.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
-----------		return solana.PublicKey{}, fmt.Errorf("failed to decode ATA data: %w", err)
-----------	}
-----------
-----------	return tokenAccount.Mint, nil
-----------}
-----------
-----------func (r *DEX) sendTransactionWithRetryAndConfirmation(
-----------	ctx context.Context,
-----------	wallet *wallet.Wallet,
-----------	instructions []solana.Instruction,
-----------	logger *zap.Logger,
-----------) (solana.Signature, error) {
-----------	const (
-----------		maxRetries          = 3
-----------		sendTimeout         = 15 * time.Second
-----------		confirmationTimeout = 60 * time.Second
-----------	)
-----------
-----------	var lastErr error
-----------	for attempt := 0; attempt < maxRetries; attempt++ {
-----------		select {
-----------		case <-ctx.Done():
-----------			return solana.Signature{}, ctx.Err()
-----------		default:
-----------			// Создаем контекст с таймаутом для отправки
-----------			sendCtx, cancel := context.WithTimeout(ctx, sendTimeout)
-----------			signature, err := r.sendTransaction(sendCtx, wallet, instructions)
-----------			cancel()
-----------
-----------			if err != nil {
-----------				lastErr = err
-----------				logger.Warn("Retrying transaction send",
-----------					zap.Int("attempt", attempt+1),
-----------					zap.Error(err))
-----------				time.Sleep(time.Second * time.Duration(attempt+1))
-----------				continue
-----------			}
-----------
-----------			// Создаем отдельный контекст для подтверждения
-----------			confirmCtx, cancel := context.WithTimeout(ctx, confirmationTimeout)
-----------			defer cancel()
-----------
-----------			// Ждем подтверждения с периодическими проверками
-----------			ticker := time.NewTicker(time.Second)
-----------			defer ticker.Stop()
-----------
-----------			for {
-----------				select {
-----------				case <-confirmCtx.Done():
-----------					return signature, fmt.Errorf("confirmation timeout exceeded: %v", confirmCtx.Err())
-----------				case <-ticker.C:
-----------					status, err := r.getTransactionStatus(ctx, signature)
-----------					if err != nil {
-----------						logger.Debug("Failed to get transaction status",
-----------							zap.Error(err),
-----------							zap.String("signature", signature.String()))
-----------						continue
-----------					}
-----------
-----------					// Проверяем ошибки в транзакции
-----------					if status.Error != "" {
-----------						return signature, fmt.Errorf("transaction failed: %s", status.Error)
-----------					}
-----------
-----------					// Проверяем подтверждение
-----------					if status.Confirmations >= 1 || status.Status == "finalized" {
-----------						logger.Debug("Transaction confirmed",
-----------							zap.String("signature", signature.String()),
-----------							zap.String("status", status.Status),
-----------							zap.Uint64("confirmations", status.Confirmations))
-----------						return signature, nil
-----------					}
-----------
-----------					logger.Debug("Waiting for confirmation",
-----------						zap.String("signature", signature.String()),
-----------						zap.String("status", status.Status),
-----------						zap.Uint64("confirmations", status.Confirmations))
-----------				}
-----------			}
-----------		}
-----------	}
-----------
-----------	return solana.Signature{}, fmt.Errorf("failed after %d attempts: %w", maxRetries, lastErr)
-----------}
-----------
-----------func (r *DEX) sendTransaction(
-----------	ctx context.Context,
-----------	wallet *wallet.Wallet,
-----------	instructions []solana.Instruction,
-----------) (solana.Signature, error) {
-----------	recent, err := r.client.GetRecentBlockhash(ctx)
-----------	if err != nil {
-----------		return solana.Signature{}, fmt.Errorf("failed to get recent blockhash: %w", err)
-----------	}
-----------
-----------	tx, err := solana.NewTransaction(
-----------		instructions,
-----------		recent,
-----------		solana.TransactionPayer(wallet.PublicKey),
-----------	)
-----------	if err != nil {
-----------		return solana.Signature{}, fmt.Errorf("failed to create transaction: %w", err)
-----------	}
-----------
-----------	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
-----------		if key.Equals(wallet.PublicKey) {
-----------			return &wallet.PrivateKey
-----------		}
-----------		return nil
-----------	})
-----------	if err != nil {
-----------		return solana.Signature{}, fmt.Errorf("failed to sign transaction: %w", err)
-----------	}
-----------
-----------	opts := blockchain.TransactionOptions{
-----------		SkipPreflight:       true,
-----------		PreflightCommitment: solanarpc.CommitmentProcessed,
-----------	}
-----------
-----------	signature, err := r.client.SendTransactionWithOpts(ctx, tx, opts)
-----------	if err != nil {
-----------		return solana.Signature{}, fmt.Errorf("failed to send transaction: %w", err)
-----------	}
-----------
-----------	return signature, nil
-----------}
-----------
-----------func validateDEXParams(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) error {
-----------	switch {
-----------	case client == nil:
-----------		return fmt.Errorf("client cannot be nil")
-----------	case logger == nil:
-----------		return fmt.Errorf("logger cannot be nil")
-----------	case poolInfo == nil:
-----------		return fmt.Errorf("pool info cannot be nil")
-----------	}
-----------	return nil
-----------}
-----------
-----------func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, solana.PublicKey, error) {
-----------	sourceMint, err := solana.PublicKeyFromBase58(sourceToken)
-----------	if err != nil {
-----------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("invalid source token: %w", err)
-----------	}
-----------
-----------	targetMint, err := solana.PublicKeyFromBase58(targetToken)
-----------	if err != nil {
-----------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("invalid target token: %w", err)
-----------	}
-----------
-----------	return sourceMint, targetMint, nil
-----------}
-----------
-----------// getExpectedOutput calculates the expected output for the swap
-----------func (r *DEX) getExpectedOutput(
-----------	ctx context.Context,
-----------	amountIn uint64,
-----------	sourceToken, targetToken solana.PublicKey,
-----------	poolInfo *Pool,
-----------	logger *zap.Logger,
-----------) (float64, error) {
-----------	// Get pool state
-----------	poolState, err := r.getPoolState(ctx, poolInfo)
-----------	if err != nil {
-----------		return 0, fmt.Errorf("failed to get pool state: %w", err)
-----------	}
-----------
-----------	// Get decimals for tokens
-----------	sourceMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, sourceToken)
-----------	if err != nil {
-----------		return 0, fmt.Errorf("failed to get source token metadata: %w", err)
-----------	}
-----------
-----------	targetMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, targetToken)
-----------	if err != nil {
-----------		return 0, fmt.Errorf("failed to get target token metadata: %w", err)
-----------	}
-----------
-----------	// Calculate expected output
-----------	expectedOut := r.calculateExpectedOutput(
-----------		amountIn,
-----------		int(sourceMetadata.Decimals),
-----------		int(targetMetadata.Decimals),
-----------		poolState,
-----------	)
-----------
-----------	// Validate calculated price against market price
-----------	marketPrice := 181.0 // Use current market price of SOL in USDC
-----------	err = validateSwapAmount(expectedOut, marketPrice, amountIn,
-----------		int(sourceMetadata.Decimals),
-----------		int(targetMetadata.Decimals))
-----------	if err != nil {
-----------		return 0, fmt.Errorf("swap amount validation failed: %w", err)
-----------	}
-----------
-----------	return expectedOut, nil
-----------}
-----------
-----------// getPoolState gets the current state of the pool
-----------// Скорректированные смещения для Raydium v4 пула
-----------const (
-----------	DISCRIMINATOR_SIZE = 8
-----------	STATUS_SIZE        = 1
-----------	NONCE_SIZE         = 1
-----------	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 bytes
-----------
-----------	// Новые смещения (в байтах)
-----------	baseVaultOffset    = BASE_SIZE + 96       // После discriminator + статуса + nonce + 3 pubkeys
-----------	quoteVaultOffset   = baseVaultOffset + 40 // После base vault + доп. данные
-----------	baseReserveOffset  = 178                  // Фиксированное смещение для базового резерва
-----------	quoteReserveOffset = 186                  // Фиксированное смещение для quote резерва
-----------)
-----------
-----------// Добавляем новые типы для работы с ценами
-----------type PriceSource interface {
-----------	GetCurrentPrice(ctx context.Context, base, quote solana.PublicKey) (float64, error)
-----------}
-----------
-----------type PoolPriceValidator struct {
-----------	priceSource  PriceSource
-----------	maxDeviation float64
-----------	logger       *zap.Logger
-----------}
-----------
-----------func NewPoolPriceValidator(priceSource PriceSource, logger *zap.Logger) *PoolPriceValidator {
-----------	return &PoolPriceValidator{
-----------		priceSource:  priceSource,
-----------		maxDeviation: 0.5, // 50% максимальное отклонение
-----------		logger:       logger,
-----------	}
-----------}
-----------
-----------// Добавляем метод для обновления валидатора цен
-----------func (r *DEX) SetPriceValidator(validator PriceValidator) {
-----------	r.priceValidator = validator
-----------}
-----------
-----------// internal/dex/raydium/raydium.go
-----------
-----------func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
-----------	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
-----------	if err != nil {
-----------		return nil, fmt.Errorf("failed to get pool account: %w", err)
-----------	}
-----------
-----------	if poolAccount == nil || poolAccount.Value == nil {
-----------		return nil, fmt.Errorf("pool account not found")
-----------	}
-----------
-----------	data := poolAccount.Value.Data.GetBinary()
-----------
-----------	r.logger.Debug("Full pool data",
-----------		zap.Binary("data", data),
-----------		zap.Int("length", len(data)))
-----------
-----------	if len(data) < quoteReserveOffset+8 {
-----------		return nil, fmt.Errorf("invalid pool data length: got %d, need at least %d",
-----------			len(data), quoteReserveOffset+8)
-----------	}
-----------
-----------	// Читаем резервы
-----------	baseReserve := binary.LittleEndian.Uint64(data[baseReserveOffset : baseReserveOffset+8])
-----------	quoteReserve := binary.LittleEndian.Uint64(data[quoteReserveOffset : quoteReserveOffset+8])
-----------
-----------	r.logger.Debug("Raw reserves",
-----------		zap.Uint64("base_reserve_raw", baseReserve),
-----------		zap.Uint64("quote_reserve_raw", quoteReserve))
-----------
-----------	// Проверяем резервы
-----------	if baseReserve == 0 || quoteReserve == 0 {
-----------		return nil, fmt.Errorf("invalid pool reserves: base=%d, quote=%d",
-----------			baseReserve, quoteReserve)
-----------	}
-----------
-----------	// Нормализуем значения с учетом decimals
-----------	solAmount := float64(baseReserve) / 1e9   // 9 decimals для SOL
-----------	usdcAmount := float64(quoteReserve) / 1e6 // 6 decimals для USDC
-----------
-----------	poolPrice := usdcAmount / solAmount
-----------	r.logger.Debug("Pool price calculated",
-----------		zap.Float64("pool_price", poolPrice),
-----------		zap.Float64("sol_amount", solAmount),
-----------		zap.Float64("usdc_amount", usdcAmount))
-----------
-----------	// Проверяем цену через валидатор
-----------	if r.priceValidator != nil {
-----------		if err := r.priceValidator.ValidatePrice(poolPrice); err != nil {
-----------			return nil, fmt.Errorf("pool price validation failed: %w", err)
-----------		}
-----------	}
-----------
-----------	state := &PoolState{
-----------		TokenAReserve: baseReserve,
-----------		TokenBReserve: quoteReserve,
-----------		SwapFee:       0.25,
-----------		CurrentPrice:  poolPrice,
-----------	}
-----------
-----------	// Сохраняем новое состояние
-----------	r.UpdatePoolState(state)
-----------
-----------	return state, nil
-----------}
-----------
-----------// Добавляем вспомогательные методы для работы с ценами
-----------// GetCurrentPoolPrice возвращает текущую цену пула
-----------func (r *DEX) GetCurrentPoolPrice() float64 {
-----------	if state := r.lastPoolState.Load().(*PoolState); state != nil {
-----------		return state.CurrentPrice
-----------	}
-----------	return 0
-----------}
-----------
-----------func (r *DEX) SetMaxPriceDeviation(deviation float64) {
-----------	if r.priceValidator != nil {
-----------		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
-----------			basicValidator.maxDeviation = deviation
-----------		}
-----------	}
-----------}
-----------
-----------func (r *DEX) UpdateBasePrice(price float64) {
-----------	if r.priceValidator != nil {
-----------		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
-----------			basicValidator.basePrice = price
-----------		}
-----------	}
-----------}
-----------
-----------// calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
-----------// calculateExpectedOutput computes the expected output based on the pool state
-----------func (r *DEX) calculateExpectedOutput(
-----------	amountIn uint64,
-----------	sourceDec,
-----------	targetDec int,
-----------	state *PoolState,
-----------) float64 {
-----------	logger := r.logger.With(
-----------		zap.Uint64("amount_in_raw", amountIn),
-----------		zap.Int("source_decimals", sourceDec),
-----------		zap.Int("target_decimals", targetDec),
-----------	)
-----------
-----------	// Normalize input amount
-----------	amountInF := float64(amountIn) / math.Pow10(sourceDec)
-----------	logger.Debug("Normalized input amount",
-----------		zap.Float64("amount_in_normalized", amountInF))
-----------
-----------	// Get normalized reserves
-----------	reserveIn := float64(state.TokenAReserve) / math.Pow10(sourceDec)
-----------	reserveOut := float64(state.TokenBReserve) / math.Pow10(targetDec)
-----------	logger.Debug("Normalized reserves",
-----------		zap.Float64("reserve_in_normalized", reserveIn),
-----------		zap.Float64("reserve_out_normalized", reserveOut))
-----------
-----------	// Calculate output using constant product formula
-----------	amountOut := (amountInF * reserveOut * (1 - state.SwapFee/100)) / (reserveIn + amountInF*(1-state.SwapFee/100))
-----------	logger.Debug("Calculated amount out",
-----------		zap.Float64("amount_out", amountOut))
-----------
-----------	// Convert back to lamports
-----------	finalOutput := amountOut * math.Pow10(targetDec)
-----------	logger.Debug("Final output in lamports",
-----------		zap.Float64("final_output_lamports", finalOutput))
-----------
-----------	return finalOutput
-----------}
-----------
-----------func validateSwapAmount(expectedOut float64, currentPrice float64, amountIn uint64, sourceDec, targetDec int) error {
-----------	// Normalize values
-----------	realAmountIn := float64(amountIn) / math.Pow10(sourceDec)
-----------	realExpectedOut := expectedOut / math.Pow10(targetDec)
-----------
-----------	// Calculate the swap price
-----------	calculatedPrice := realExpectedOut / realAmountIn
-----------
-----------	// Calculate price difference percentage
-----------	priceDiff := math.Abs(calculatedPrice-currentPrice) / currentPrice
-----------
-----------	// Allow up to 20% difference
-----------	if priceDiff > 0.2 {
-----------		return fmt.Errorf("calculated price differs too much from current price: %.2f vs %.2f",
-----------			calculatedPrice, currentPrice)
-----------	}
-----------
-----------	return nil
-----------}
-----------
-----------// GetAmountOutQuote получает котировку для свапа
-----------func (r *DEX) GetAmountOutQuote(
-----------	ctx context.Context,
-----------	amountIn uint64,
-----------	sourceToken, targetToken solana.PublicKey,
-----------) (float64, error) {
-----------	// Создаем временный пул для получения котировки
-----------	poolInfo := r.poolInfo
-----------	if poolInfo == nil {
-----------		return 0, fmt.Errorf("pool info not configured")
-----------	}
-----------
-----------	// Получаем ожидаемый выход
-----------	expectedOut, err := r.getExpectedOutput(ctx, amountIn, sourceToken, targetToken, poolInfo, r.logger)
-----------	if err != nil {
-----------		return 0, fmt.Errorf("failed to get expected output: %w", err)
-----------	}
-----------
-----------	return expectedOut, nil
-----------}
-----------
-----------// TransactionStatus представляет статус транзакции
-----------type TransactionStatus struct {
-----------	Signature     string    `json:"signature"`
-----------	Status        string    `json:"status"`
-----------	Confirmations uint64    `json:"confirmations"`
-----------	Slot          uint64    `json:"slot"`
-----------	Error         string    `json:"error,omitempty"`
-----------	Timestamp     time.Time `json:"timestamp"` // Время проверки статуса
-----------}
-----------
-----------// getTransactionStatus получает полный статус транзакции
-----------func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signature) (*TransactionStatus, error) {
-----------	result, err := r.client.GetSignatureStatuses(ctx, signature)
-----------	if err != nil {
-----------		return nil, fmt.Errorf("failed to get signature status: %w", err)
-----------	}
-----------
-----------	now := time.Now()
-----------	status := &TransactionStatus{
-----------		Signature: signature.String(),
-----------		Status:    "pending",
-----------		Timestamp: now,
-----------	}
-----------
-----------	if len(result.Value) == 0 || result.Value[0] == nil {
-----------		return status, nil
-----------	}
-----------
-----------	statusInfo := result.Value[0]
-----------	if statusInfo.Err != nil {
-----------		status.Error = fmt.Sprintf("%v", statusInfo.Err)
-----------		status.Status = "failed"
-----------		return status, nil
-----------	}
-----------
-----------	if statusInfo.Confirmations != nil {
-----------		status.Confirmations = *statusInfo.Confirmations
-----------	}
-----------
-----------	if statusInfo.Slot > 0 {
-----------		status.Slot = statusInfo.Slot
-----------	}
-----------
-----------	switch statusInfo.ConfirmationStatus {
-----------	case solanarpc.ConfirmationStatusFinalized:
-----------		status.Status = "finalized"
-----------	case solanarpc.ConfirmationStatusConfirmed:
-----------		status.Status = "confirmed"
-----------	}
-----------
-----------	return status, nil
-----------}
-----------
-----------// GetSignatureStatus получает детальный статус подписи
-----------func (r *DEX) GetSignatureStatus(ctx context.Context, signature solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
-----------	return r.client.GetSignatureStatuses(ctx, signature)
-----------}
----------diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
----------deleted file mode 100644
----------index 61d78a0..0000000
------------- a/internal/dex/raydium/transaction.go
----------+++ /dev/null
----------@@ -1,264 +0,0 @@
-----------// internal/dex/raydium/transaction.go
-----------
-----------package raydium
-----------
-----------import (
-----------	"context"
-----------	"encoding/binary"
-----------	"fmt"
-----------	"math"
-----------
-----------	"github.com/gagliardetto/solana-go"
-----------	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
-----------	"github.com/rovshanmuradov/solana-bot/internal/types"
-----------	"github.com/rovshanmuradov/solana-bot/internal/wallet"
-----------	"go.uber.org/zap"
-----------)
-----------
-----------// Serialize serializes the swap instruction data
-----------func (s *SwapInstructionData) Serialize() ([]byte, error) {
-----------	if err := s.Validate(); err != nil {
-----------		return nil, err
-----------	}
-----------
-----------	data := make([]byte, 17)
-----------
-----------	// Write instruction discriminator
-----------	data[0] = s.Instruction
-----------
-----------	// Write amount in
-----------	binary.LittleEndian.PutUint64(data[1:9], s.AmountIn)
-----------
-----------	// Write minimum out
-----------	binary.LittleEndian.PutUint64(data[9:17], s.MinAmountOut)
-----------
-----------	return data, nil
-----------}
-----------
-----------// Validate validates the swap instruction data
-----------func (s *SwapInstructionData) Validate() error {
-----------	if s.Instruction != 1 {
-----------		return fmt.Errorf("invalid instruction type: expected 1, got %d", s.Instruction)
-----------	}
-----------
-----------	if s.AmountIn == 0 {
-----------		return fmt.Errorf("amount_in cannot be zero")
-----------	}
-----------
-----------	// MinimumOut can be zero, but log a warning
-----------	if s.MinAmountOut == 0 {
-----------		// You may want to log a warning here
-----------	}
-----------
-----------	return nil
-----------}
-----------
-----------// CreateSwapInstruction creates a swap instruction for Raydium
-----------func (r *DEX) CreateSwapInstruction(
-----------	userWallet solana.PublicKey,
-----------	userSourceTokenAccount solana.PublicKey,
-----------	userDestinationTokenAccount solana.PublicKey,
-----------	amountIn uint64,
-----------	minAmountOut uint64,
-----------	logger *zap.Logger,
-----------	poolInfo *Pool,
-----------) (solana.Instruction, error) {
-----------	logger.Debug("Creating swap instruction",
-----------		zap.String("user_wallet", userWallet.String()),
-----------		zap.String("source_account", userSourceTokenAccount.String()),
-----------		zap.String("destination_account", userDestinationTokenAccount.String()),
-----------		zap.Uint64("amount_in", amountIn),
-----------		zap.Uint64("min_amount_out", minAmountOut))
-----------
-----------	if poolInfo == nil {
-----------		return nil, fmt.Errorf("pool info is nil")
-----------	}
-----------
-----------	// Validate and parse all necessary public keys
-----------	ammProgramID, err := validatePublicKey(poolInfo.AmmProgramID)
-----------	if err != nil {
-----------		logger.Error("Invalid AmmProgramID", zap.Error(err))
-----------		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
-----------	}
-----------
-----------	// Map of required accounts with their names
-----------	requiredAccounts := map[string]string{
-----------		"AmmID":                poolInfo.AmmID,
-----------		"AmmAuthority":         poolInfo.AmmAuthority,
-----------		"AmmOpenOrders":        poolInfo.AmmOpenOrders,
-----------		"AmmTargetOrders":      poolInfo.AmmTargetOrders,
-----------		"PoolCoinTokenAccount": poolInfo.PoolCoinTokenAccount,
-----------		"PoolPcTokenAccount":   poolInfo.PoolPcTokenAccount,
-----------		"SerumProgramID":       poolInfo.SerumProgramID,
-----------		"SerumMarket":          poolInfo.SerumMarket,
-----------		"SerumBids":            poolInfo.SerumBids,
-----------		"SerumAsks":            poolInfo.SerumAsks,
-----------		"SerumEventQueue":      poolInfo.SerumEventQueue,
-----------		"SerumCoinVault":       poolInfo.SerumCoinVaultAccount,
-----------		"SerumPcVault":         poolInfo.SerumPcVaultAccount,
-----------		"SerumVaultSigner":     poolInfo.SerumVaultSigner,
-----------	}
-----------
-----------	accounts := make(map[string]solana.PublicKey)
-----------	for name, address := range requiredAccounts {
-----------		pubKey, err := validatePublicKey(address)
-----------		if err != nil {
-----------			logger.Error(fmt.Sprintf("Invalid %s", name),
-----------				zap.String("address", address),
-----------				zap.Error(err))
-----------			return nil, fmt.Errorf("invalid %s: %w", name, err)
-----------		}
-----------		accounts[name] = pubKey
-----------	}
-----------
-----------	// Create the account meta slice in the correct order
-----------	metas := solana.AccountMetaSlice{
-----------		// User accounts
-----------		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
-----------		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
-----------		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
-----------		// Pool accounts
-----------		{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
-----------		{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
-----------		// Serum accounts
-----------		{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
-----------		{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
-----------		{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
-----------		// System accounts
-----------		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
-----------		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
-----------		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
-----------	}
-----------
-----------	// Create swap instruction data
-----------	instructionData := &SwapInstructionData{
-----------		Instruction:  poolInfo.RaydiumSwapInstructionCode,
-----------		AmountIn:     amountIn,
-----------		MinAmountOut: minAmountOut,
-----------	}
-----------
-----------	// Serialize instruction data
-----------	data, err := instructionData.Serialize()
-----------	if err != nil {
-----------		logger.Error("Failed to serialize instruction data",
-----------			zap.Error(err),
-----------			zap.Uint8("instruction", instructionData.Instruction),
-----------			zap.Uint64("amount_in", instructionData.AmountIn),
-----------			zap.Uint64("min_amount_out", instructionData.MinAmountOut))
-----------		return nil, fmt.Errorf("failed to serialize instruction data: %w", err)
-----------	}
-----------
-----------	// Create the instruction
-----------	instruction := solana.NewInstruction(ammProgramID, metas, data)
-----------
-----------	logger.Debug("Created swap instruction",
-----------		zap.Int("num_accounts", len(metas)),
-----------		zap.Int("data_len", len(data)))
-----------
-----------	return instruction, nil
-----------}
-----------
-----------// PrepareAndSendTransaction prepares and sends the swap transaction
-----------func (r *DEX) PrepareAndSendTransaction(
-----------	ctx context.Context,
-----------	task *types.Task,
-----------	userWallet *wallet.Wallet,
-----------	logger *zap.Logger,
-----------	swapInstruction solana.Instruction,
-----------) error {
-----------	recentBlockhash, err := r.client.GetRecentBlockhash(ctx)
-----------	if err != nil {
-----------		logger.Error("Failed to get recent blockhash", zap.Error(err))
-----------		return fmt.Errorf("failed to get recent blockhash: %w", err)
-----------	}
-----------
-----------	// Create compute budget instruction if needed
-----------	computeBudgetInst := computebudget.NewSetComputeUnitPriceInstruction(
-----------		uint64(task.PriorityFee * 1e6), // Convert SOL to micro-lamports
-----------	).Build()
-----------
-----------	// Combine all instructions
-----------	instructions := []solana.Instruction{
-----------		computeBudgetInst,
-----------		swapInstruction,
-----------	}
-----------
-----------	// Create the transaction
-----------	tx, err := solana.NewTransaction(
-----------		instructions,
-----------		recentBlockhash,
-----------		solana.TransactionPayer(userWallet.PublicKey),
-----------	)
-----------	if err != nil {
-----------		logger.Error("Failed to create transaction", zap.Error(err))
-----------		return fmt.Errorf("failed to create transaction: %w", err)
-----------	}
-----------
-----------	// Sign the transaction
-----------	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
-----------		if key.Equals(userWallet.PublicKey) {
-----------			return &userWallet.PrivateKey
-----------		}
-----------		return nil
-----------	})
-----------	if err != nil {
-----------		logger.Error("Failed to sign transaction", zap.Error(err))
-----------		return fmt.Errorf("failed to sign transaction: %w", err)
-----------	}
-----------
-----------	// Send the transaction
-----------	signature, err := r.client.SendTransaction(ctx, tx)
-----------	if err != nil {
-----------		logger.Error("Failed to send transaction", zap.Error(err))
-----------		return fmt.Errorf("failed to send transaction: %w", err)
-----------	}
-----------
-----------	logger.Info("Transaction sent successfully",
-----------		zap.String("signature", signature.String()),
-----------		zap.Float64("priority_fee_sol", task.PriorityFee))
-----------
-----------	return nil
-----------}
-----------
-----------// validatePublicKey checks if a public key string is valid
-----------func validatePublicKey(key string) (solana.PublicKey, error) {
-----------	if key == "" {
-----------		return solana.PublicKey{}, fmt.Errorf("empty public key")
-----------	}
-----------
-----------	pubKey, err := solana.PublicKeyFromBase58(key)
-----------	if err != nil {
-----------		return solana.PublicKey{}, fmt.Errorf("invalid public key %s: %w", key, err)
-----------	}
-----------
-----------	return pubKey, nil
-----------}
-----------
-----------// Helper function to calculate minimum output considering slippage
-----------func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
-----------	if expectedOut <= 0 {
-----------		return 1 // Minimum safe value
-----------	}
-----------
-----------	// Consider slippage
-----------	minOut := expectedOut * (1 - slippagePercent/100)
-----------
-----------	// Convert to uint64 and check for minimum value
-----------	result := uint64(math.Floor(minOut))
-----------	if result == 0 {
-----------		return 1
-----------	}
-----------
-----------	return result
-----------}
-----------
-----------// You may want to include other helper functions or adjust existing ones as needed
----------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
----------index 7db11c6..ef19a7a 100644
------------- a/internal/dex/raydium/types.go
----------+++ b/internal/dex/raydium/types.go
----------@@ -1,103 +1,152 @@
---------- // internal/dex/raydium/types.go
-----------
----------+// Package raydium реализует интеграцию с Raydium DEX на Solana
---------- package raydium
+-------- // Утилиты для работы с новыми комиссиями
+--------+// TODO: Implement the method logic
+-------- func CalculateV5Fees(amount uint64, feeParams V5FeeParams) uint64 {
+-------- 	return 0
+-------- }
+--------diff --git a/newdif.txt b/newdif.txt
+--------index 94ec35e..dd1019e 100644
+----------- a/newdif.txt
+--------+++ b/newdif.txt
+--------@@ -1,5048 +0,0 @@
+---------diff --git a/internal/blockchain/solbc/solana.go b/internal/blockchain/solbc/solana.go
+---------index b764d85..dec574a 100644
+------------ a/internal/blockchain/solbc/solana.go
+---------+++ b/internal/blockchain/solbc/solana.go
+---------@@ -1,10 +1,13 @@
+----------// internal/blockchain/solbc/solana.go:
+---------+// internal/blockchain/solbc/solana.go
+--------- package solbc
 --------- 
 --------- import (
-----------	"sync"
-----------	"sync/atomic"
----------+	"context"
----------+	"fmt"
+--------- 	"context"
+--------- 	"fmt"
+--------- 
+---------+	solanarpc "github.com/gagliardetto/solana-go/rpc"
+---------+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
 ---------+
----------+	"github.com/gagliardetto/solana-go"
----------+)
+--------- 	"github.com/gagliardetto/solana-go"
+--------- 	"go.uber.org/zap"
+--------- )
+---------@@ -54,3 +57,25 @@ func (s *Blockchain) GetRecentBlockhash(ctx context.Context) (solana.Hash, error
+--------- 	}
+--------- 	return hash, nil
+--------- }
+---------+
+---------+// SimulateTransaction simulates a transaction on the Solana blockchain
+---------+func (c *Client) SimulateTransaction(tx string) (string, error) {
+---------+	// Implement the method logic here
+---------+	return "", nil
+---------+}
+---------+
+---------+func (c *Client) GetRpcClient() *solanarpc.Client {
+---------+	if c.adapter == nil {
+---------+		c.adapter = NewRpcAdapter(c.rpc)
+---------+	}
+---------+	return c.adapter
+---------+}
+---------+
+---------+// RpcAdapter адаптирует наш RPCClient к интерфейсу solana-go/rpc.Client
+---------+type RpcAdapter struct {
+---------+	client *rpc.RPCClient
+---------+}
+---------+
+---------+func NewRpcAdapter(client *rpc.RPCClient) *solanarpc.Client {
+---------+	return solanarpc.New("") // Создаем пустой клиент
+---------+}
+---------diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
+---------index 42debad..b3e342d 100644
+------------ a/internal/blockchain/solbc/types.go
+---------+++ b/internal/blockchain/solbc/types.go
+---------@@ -7,6 +7,7 @@ import (
 --------- 
-----------	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
-----------	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
-----------	"go.uber.org/zap"
----------+// Layout константы для правильного чтения данных из аккаунта пула
----------+const (
----------+	// Базовые смещения
----------+	LayoutDiscriminator = 8
----------+	LayoutStatus        = 1
----------+	LayoutNonce         = 1
----------+	LayoutBaseSize      = LayoutDiscriminator + LayoutStatus + LayoutNonce // 10 байт
+--------- 	"go.uber.org/zap"
+--------- 
+---------+	solanarpc "github.com/gagliardetto/solana-go/rpc"
+--------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+--------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc/rpc"
+--------- )
+---------@@ -20,6 +21,7 @@ type TokenMetadataCache struct {
+--------- // Client представляет основной клиент Solana
+--------- type Client struct {
+--------- 	rpc     *rpc.RPCClient
+---------+	adapter *solanarpc.Client
+--------- 	logger  *zap.Logger
+--------- 	metrics *ClientMetrics
+--------- }
+---------diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
+---------index 03c15ac..45d076b 100644
+------------ a/internal/blockchain/types.go
+---------+++ b/internal/blockchain/types.go
+---------@@ -3,6 +3,7 @@ package blockchain
+--------- 
+--------- import (
+--------- 	"context"
+---------+	"encoding/base64"
+--------- 
+--------- 	"github.com/gagliardetto/solana-go"
+--------- 	"github.com/gagliardetto/solana-go/rpc"
+---------@@ -14,6 +15,30 @@ type TransactionOptions struct {
+--------- 	PreflightCommitment rpc.CommitmentType
+--------- }
+--------- 
+---------+// SimulationResult представляет результат симуляции транзакции
+---------+// Обновляем структуру SimulationResult
+---------+type SimulationResult struct {
+---------+	Err           interface{}
+---------+	Logs          []string
+---------+	UnitsConsumed uint64
+---------+	ReturnData    *Base64Data
+---------+}
+---------+
+---------+// Base64Data представляет данные в формате Base64
+---------+type Base64Data struct {
+---------+	Data string
+---------+}
 ---------+
----------+	// Смещения для резервов и других данных пула
----------+	LayoutBaseVaultOffset    = LayoutBaseSize + 32 + 32 + 32 // После discriminator, status, nonce и трех pubkeys
----------+	LayoutQuoteVaultOffset   = LayoutBaseVaultOffset + 32
----------+	LayoutBaseReserveOffset  = LayoutQuoteVaultOffset + 32 + 8
----------+	LayoutQuoteReserveOffset = LayoutBaseReserveOffset + 8
+---------+// EncodeBase64 кодирует данные в Base64
+---------+func (b *Base64Data) EncodeBase64(data []byte) {
+---------+	b.Data = base64.StdEncoding.EncodeToString(data)
+---------+}
+---------+
+---------+// DecodeBase64 декодирует данные из Base64
+---------+func (b *Base64Data) DecodeBase64() ([]byte, error) {
+---------+	return base64.StdEncoding.DecodeString(b.Data)
+---------+}
 ---------+
----------+	// Константы протокола
----------+	DefaultSwapFeePercent = 0.25
----------+	MinimumAmountOut      = 1
+--------- // Client определяет общий интерфейс для клиентов блокчейна
+--------- type Client interface {
+--------- 	GetRecentBlockhash(ctx context.Context) (solana.Hash, error)
+---------@@ -21,4 +46,6 @@ type Client interface {
+--------- 	GetAccountInfo(ctx context.Context, pubkey solana.PublicKey) (*rpc.GetAccountInfoResult, error)
+--------- 	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
+--------- 	SendTransactionWithOpts(ctx context.Context, tx *solana.Transaction, opts TransactionOptions) (solana.Signature, error)
+---------+	SimulateTransaction(ctx context.Context, tx *solana.Transaction) (*SimulationResult, error)
+---------+	GetRpcClient() *rpc.Client
+--------- }
+---------diff --git a/internal/dex/raydium/client.go b/internal/dex/raydium/client.go
+---------index e7de9a0..eafb611 100644
+------------ a/internal/dex/raydium/client.go
+---------+++ b/internal/dex/raydium/client.go
+---------@@ -12,9 +12,8 @@ import (
+--------- 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
+--------- 	"github.com/gagliardetto/solana-go/rpc"
+--------- 	"github.com/gagliardetto/solana-go/rpc/jsonrpc"
+----------	"go.uber.org/zap"
+----------
+--------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+---------+	"go.uber.org/zap"
 --------- )
 --------- 
-----------// RaydiumPoolInfo содержит информацию о пуле Raydium
-----------type Pool struct {
-----------	AmmProgramID               string
-----------	AmmID                      string
-----------	AmmAuthority               string
-----------	AmmOpenOrders              string
-----------	AmmTargetOrders            string
-----------	PoolCoinTokenAccount       string
-----------	PoolPcTokenAccount         string
-----------	SerumProgramID             string
-----------	SerumMarket                string
-----------	SerumBids                  string
-----------	SerumAsks                  string
-----------	SerumEventQueue            string
-----------	SerumCoinVaultAccount      string
-----------	SerumPcVaultAccount        string
-----------	SerumVaultSigner           string
-----------	RaydiumSwapInstructionCode uint8
----------+// RaydiumPool представляет собой конфигурацию пула ликвидности Raydium
----------+type RaydiumPool struct {
----------+	// Программы
----------+	AmmProgramID   solana.PublicKey
----------+	SerumProgramID solana.PublicKey
+--------- const (
+---------@@ -217,7 +216,8 @@ func (c *RaydiumClient) CreateSwapInstructions(ctx context.Context, params SwapP
+--------- 
+--------- // SimulateSwap симулирует выполнение свапа
+--------- func (c *RaydiumClient) SimulateSwap(ctx context.Context, instructions []solana.Instruction) error {
+----------	logger := c.logger.Debug("Simulating swap transaction")
+---------+	logger := c.logger.With(zap.String("method", "SimulateSwap"))
+---------+	logger.Debug("Starting swap simulation")
+--------- 
+--------- 	recent, err := c.client.GetRecentBlockhash(ctx)
+--------- 	if err != nil {
+---------@@ -246,15 +246,16 @@ func (c *RaydiumClient) SimulateSwap(ctx context.Context, instructions []solana.
+--------- 		}
+--------- 	}
+--------- 
+----------	if simulation.Value.Err != nil {
+---------+	if simulation.Err != nil {
+--------- 		return &SwapError{
+--------- 			Stage:   "simulate_swap",
+----------			Message: fmt.Sprintf("simulation returned error: %v", simulation.Value.Err),
+---------+			Message: fmt.Sprintf("simulation returned error: %v", simulation.Err),
+--------- 		}
+--------- 	}
+--------- 
+--------- 	logger.Debug("Swap simulation successful",
+----------		zap.Uint64("compute_units_used", simulation.Value.UnitsConsumed))
+---------+		zap.Uint64("compute_units_used", simulation.UnitsConsumed),
+---------+		zap.Strings("logs", simulation.Logs))
+--------- 
+--------- 	return nil
+--------- }
+---------@@ -294,15 +295,112 @@ func (c *RaydiumClient) GetAmountOut(pool *RaydiumPool, state *PoolState, amount
+--------- 
+--------- // createSwapInstruction создает инструкцию свапа
+--------- func (c *RaydiumClient) createSwapInstruction(params SwapParams) (solana.Instruction, error) {
+----------	// ... реализация создания инструкции свапа
+----------	// Этот метод будет реализован в следующей части
+----------	return nil, nil
+---------+	// Проверяем входные параметры
+---------+	if params.Pool == nil {
+---------+		return nil, &SwapError{
+---------+			Stage:   "create_swap_instruction",
+---------+			Message: "pool is required",
+---------+		}
+---------+	}
+---------+
+---------+	// Создаем слайс аккаунтов для инструкции
+---------+	accounts := make(solana.AccountMetaSlice, 0)
+---------+
+---------+	// Добавляем основные аккаунты
+---------+	accounts = append(accounts,
+---------+		// Token Program ID
+---------+		solana.Meta(solana.TokenProgramID),
+---------+		// AMM Program ID
+---------+		solana.Meta(params.Pool.AmmProgramID),
+---------+		// User wallet (signer)
+---------+		solana.Meta(params.UserWallet).SIGNER(),
+---------+		// Pool ID
+---------+		solana.Meta(params.Pool.ID),
+---------+		// Pool Authority
+---------+		solana.Meta(params.Pool.Authority),
+---------+		// Source token account
+---------+		solana.Meta(params.SourceTokenAccount).WRITE(),
+---------+		// Destination token account
+---------+		solana.Meta(params.DestinationTokenAccount).WRITE(),
+---------+		// Pool base vault
+---------+		solana.Meta(params.Pool.BaseVault).WRITE(),
+---------+		// Pool quote vault
+---------+		solana.Meta(params.Pool.QuoteVault).WRITE(),
+---------+	)
+---------+
+---------+	// Создаем данные инструкции
+---------+	data := make([]byte, 9)
+---------+	// Команда swap (предположим, что это 1)
+---------+	data[0] = 1
+---------+	// Записываем AmountIn (8 байт, little endian)
+---------+	binary.LittleEndian.PutUint64(data[1:], params.AmountIn)
+---------+
+---------+	// Создаем инструкцию
+---------+	instruction := solana.NewInstruction(
+---------+		params.Pool.AmmProgramID,
+---------+		accounts,
+---------+		data,
+---------+	)
+---------+
+---------+	return instruction, nil
+--------- }
+--------- 
+--------- // decodePoolData декодирует данные аккаунта пула
+--------- func (c *RaydiumClient) decodePoolData(data []byte, pool *RaydiumPool) error {
+----------	// ... реализация декодирования данных пула
+----------	// Этот метод будет реализован в следующей части
+---------+	if len(data) < PoolDataSize {
+---------+		return &SwapError{
+---------+			Stage:   "decode_pool_data",
+---------+			Message: fmt.Sprintf("invalid data length: got %d, want at least %d", len(data), PoolDataSize),
+---------+		}
+---------+	}
+---------+
+---------+	// Декодируем данные пула используя binary.LittleEndian
+---------+	// Предполагаем следующую структуру данных:
+---------+	offset := 0
+---------+
+---------+	// Status (1 byte)
+---------+	pool.Status = data[offset]
+---------+	offset += 1
 ---------+
----------+	// AMM конфигурация
----------+	ID            solana.PublicKey // ID пула
----------+	Authority     solana.PublicKey
----------+	OpenOrders    solana.PublicKey
----------+	TargetOrders  solana.PublicKey
----------+	BaseVault     solana.PublicKey
----------+	QuoteVault    solana.PublicKey
----------+	WithdrawQueue solana.PublicKey
----------+	LPVault       solana.PublicKey
+---------+	// Nonce (1 byte)
+---------+	pool.Nonce = data[offset]
+---------+	offset += 1
 ---------+
----------+	// Токены и минты
----------+	BaseMint      solana.PublicKey
----------+	QuoteMint     solana.PublicKey
----------+	LPMint        solana.PublicKey
----------+	BaseDecimals  uint8
----------+	QuoteDecimals uint8
----------+	LPDecimals    uint8
+---------+	// AMM Program ID (32 bytes)
+---------+	copy(pool.AmmProgramID[:], data[offset:offset+32])
+---------+	offset += 32
 ---------+
----------+	// Serum Market
----------+	MarketID         solana.PublicKey
----------+	MarketProgramID  solana.PublicKey
----------+	MarketAuthority  solana.PublicKey
----------+	MarketBaseVault  solana.PublicKey
----------+	MarketQuoteVault solana.PublicKey
----------+	MarketBids       solana.PublicKey
----------+	MarketAsks       solana.PublicKey
----------+	MarketEventQueue solana.PublicKey
----------+	MarketVersion    uint8
----------+	LookupTableID    solana.PublicKey
+---------+	// Authority (32 bytes)
+---------+	copy(pool.Authority[:], data[offset:offset+32])
+---------+	offset += 32
 ---------+
----------+	// Версионирование и инструкции
----------+	Version              uint8
----------+	SwapInstructionIndex uint8
----------+	DefaultMinimumOutBps uint16 // базовых пунктов (1 bps = 0.01%)
----------+	DefaultFeeBps        uint16 // комиссия пула в базовых пунктах
+---------+	// Base Vault (32 bytes)
+---------+	copy(pool.BaseVault[:], data[offset:offset+32])
+---------+	offset += 32
+---------+
+---------+	// Quote Vault (32 bytes)
+---------+	copy(pool.QuoteVault[:], data[offset:offset+32])
+---------+	offset += 32
+---------+
+---------+	// Base Mint (32 bytes)
+---------+	copy(pool.BaseMint[:], data[offset:offset+32])
+---------+	offset += 32
+---------+
+---------+	// Quote Mint (32 bytes)
+---------+	copy(pool.QuoteMint[:], data[offset:offset+32])
+---------+	offset += 32
+---------+
+---------+	// Base Reserve (8 bytes)
+---------+	pool.BaseReserve = binary.LittleEndian.Uint64(data[offset : offset+8])
+---------+	offset += 8
+---------+
+---------+	// Quote Reserve (8 bytes)
+---------+	pool.QuoteReserve = binary.LittleEndian.Uint64(data[offset : offset+8])
+---------+	offset += 8
+---------+
+---------+	// Fee Rate (8 bytes)
+---------+	pool.FeeRate = binary.LittleEndian.Uint64(data[offset : offset+8])
+---------+
+--------- 	return nil
 --------- }
+--------- 
+---------@@ -334,13 +432,14 @@ func (c *RaydiumClient) CreateVersionedSwapInstructions(
+--------- 
+--------- 	// Создаем базовое сообщение
+--------- 	message := &solana.Message{
+---------+
+--------- 		AccountKeys: []solana.PublicKey{params.UserWallet}, // Начинаем с основного кошелька
+--------- 		Header: solana.MessageHeader{
+--------- 			NumRequiredSignatures:       1, // Минимум одна подпись от кошелька
+--------- 			NumReadonlySignedAccounts:   0,
+--------- 			NumReadonlyUnsignedAccounts: 0,
+--------- 		},
+----------		RecentBlockhash: recent.Value.Blockhash,
+---------+		RecentBlockhash: recent,
+--------- 		Instructions:    make([]solana.CompiledInstruction, 0),
+--------- 	}
+--------- 
+---------@@ -361,8 +460,15 @@ func (c *RaydiumClient) CreateVersionedSwapInstructions(
+--------- 	for _, instruction := range instructions {
+--------- 		compiledIx := solana.CompiledInstruction{
+--------- 			ProgramIDIndex: uint16(len(message.AccountKeys)), // Индекс программы
+----------			Data:           instruction.Data(),
+----------			Accounts:       make([]uint16, len(instruction.Accounts())),
+---------+			Data: func() []byte {
+---------+				data, err := instruction.Data()
+---------+				if err != nil {
+---------+					logger.Error("failed to get instruction data", zap.Error(err))
+---------+					return nil
+---------+				}
+---------+				return data
+---------+			}(),
+---------+			Accounts: make([]uint16, len(instruction.Accounts())),
+--------- 		}
+--------- 
+--------- 		// Добавляем ProgramID в список аккаунтов, если его там еще нет
+---------@@ -427,10 +533,13 @@ func (c *RaydiumClient) GetPoolLookupTable(
+--------- 		return nil, fmt.Errorf("failed to derive lookup table address: %w", err)
+--------- 	}
+--------- 
+----------	// Получаем данные таблицы
+---------+	// Получаем RPC клиент через GetRpcClient
+---------+	rpcClient := c.client.GetRpcClient()
 ---------+
----------+// PoolState содержит динамическое состояние пула
---------- type PoolState struct {
-----------	TokenAReserve uint64
-----------	TokenBReserve uint64
-----------	SwapFee       float64 // в процентах
-----------	CurrentPrice  float64 // текущая цена пула
----------+	BaseReserve        uint64
----------+	QuoteReserve       uint64
----------+	SwapFeeNumerator   uint64
----------+	SwapFeeDenominator uint64
----------+	Status             uint8
+---------+	// Получаем данные таблицы с помощью RPC клиента
+--------- 	lookupTable, err := addresslookuptable.GetAddressLookupTable(
+--------- 		ctx,
+----------		c.client,
+---------+		rpcClient,
+--------- 		lookupTableAddr,
+--------- 	)
+--------- 	if err != nil {
+---------@@ -450,7 +559,6 @@ func (c *RaydiumClient) GetPoolLookupTable(
+--------- 		return nil, nil
+--------- 	}
+--------- 
+----------	// Проверяем наличие необходимых адресов
+--------- 	requiredAddresses := []solana.PublicKey{
+--------- 		pool.ID,
+--------- 		pool.Authority,
+---------@@ -461,7 +569,6 @@ func (c *RaydiumClient) GetPoolLookupTable(
+--------- 		pool.MarketQuoteVault,
+--------- 	}
+--------- 
+----------	// Проверяем, что все необходимые адреса есть в таблице
+--------- 	for _, addr := range requiredAddresses {
+--------- 		found := false
+--------- 		for _, tableAddr := range lookupTable.Addresses {
+---------diff --git a/internal/dex/raydium/instruction.go b/internal/dex/raydium/instruction.go
+---------index 6b75182..ffb819e 100644
+------------ a/internal/dex/raydium/instruction.go
+---------+++ b/internal/dex/raydium/instruction.go
+---------@@ -206,33 +206,160 @@ func (b *SwapInstructionBuilder) serializeInstructionData(params SwapParams) ([]
+--------- 	return data, nil
 --------- }
 --------- 
-----------// SwapInstructionData представляет данные инструкции свапа
-----------type SwapInstructionData struct {
-----------	Instruction  uint8  // Тип инструкции
-----------	AmountIn     uint64 // Входящая сумма
-----------	MinAmountOut uint64 // Минимальная исходящая сумма
-----------}
-----------type DEX struct {
-----------	client         blockchain.Client
-----------	logger         *zap.Logger
-----------	poolInfo       *Pool
-----------	slippage       float64
-----------	tokenCache     *solbc.TokenMetadataCache
-----------	priceValidator PriceValidator
-----------	lastPoolState  atomic.Value // Используем atomic.Value для потокобезопасного доступа
-----------	stateMutex     sync.RWMutex // Мьютекс для дополнительной синхронизации при необходимости
-----------}
----------+// SwapSide определяет направление свапа
----------+type SwapSide uint8
+---------+// Добавим новые параметры для инициализации пула
+---------+type InitializePoolParams struct {
+---------+	Nonce           uint8
+---------+	InitialLPSupply uint64
+---------+	UserAuthority   solana.PublicKey
+---------+}
+---------+
+---------+// Добавим параметры для депозита
+---------+type DepositParams struct {
+---------+	MaxBaseAmount  uint64
+---------+	MaxQuoteAmount uint64
+---------+	UserAuthority  solana.PublicKey
+---------+}
+---------+
+--------- // BuildInitializePoolInstruction создает инструкцию инициализации пула
+--------- func (b *SwapInstructionBuilder) BuildInitializePoolInstruction(
+--------- 	ctx context.Context,
+----------	nonce uint8,
+----------	initialLPSupply uint64,
+---------+	params InitializePoolParams,
+--------- ) (solana.Instruction, error) {
+----------	// ... реализация создания инструкции инициализации пула
+----------	return nil, nil
+---------+	logger := b.logger.With(
+---------+		zap.Uint8("nonce", params.Nonce),
+---------+		zap.Uint64("initial_lp_supply", params.InitialLPSupply),
+---------+		zap.String("user_authority", params.UserAuthority.String()),
+---------+	)
+---------+	logger.Debug("Building initialize pool instruction")
+---------+
+---------+	// Находим пользовательский LP токен аккаунт
+---------+	userLPAccount, _, err := solana.FindAssociatedTokenAddress(
+---------+		params.UserAuthority,
+---------+		b.pool.LPMint,
+---------+	)
+---------+	if err != nil {
+---------+		return nil, fmt.Errorf("failed to find user LP token account: %w", err)
+---------+	}
+---------+
+---------+	// Сериализуем данные инструкции
+---------+	data := make([]byte, 10) // 1 (тип) + 1 (nonce) + 8 (initialLPSupply)
+---------+	data[0] = byte(InstructionTypeInitialize)
+---------+	data[1] = params.Nonce
+---------+	binary.LittleEndian.PutUint64(data[2:], params.InitialLPSupply)
+---------+
+---------+	// Создаем список необходимых аккаунтов
+---------+	accountMetas := solana.AccountMetaSlice{
+---------+		solana.NewAccountMeta(b.pool.ID, true, false),                // AMM ID
+---------+		solana.NewAccountMeta(b.pool.Authority, true, false),         // AMM Authority
+---------+		solana.NewAccountMeta(b.pool.BaseVault, true, false),         // Base Token Vault
+---------+		solana.NewAccountMeta(b.pool.QuoteVault, true, false),        // Quote Token Vault
+---------+		solana.NewAccountMeta(b.pool.LPMint, true, false),            // LP Token Mint
+---------+		solana.NewAccountMeta(userLPAccount, true, false),            // User LP Token Account
+---------+		solana.NewAccountMeta(params.UserAuthority, true, true),      // User Authority (signer)
+---------+		solana.NewAccountMeta(solana.TokenProgramID, false, false),   // Token Program
+---------+		solana.NewAccountMeta(solana.SysVarRentPubkey, false, false), // Rent Sysvar
+---------+	}
+---------+
+---------+	return solana.NewInstruction(
+---------+		b.pool.AmmProgramID,
+---------+		accountMetas,
+---------+		data,
+---------+	), nil
+--------- }
 --------- 
-----------// setLastPoolState безопасно обновляет состояние пула
-----------func (r *DEX) setLastPoolState(state *PoolState) {
-----------	r.lastPoolState.Store(state)
-----------}
----------+const (
----------+	SwapSideIn SwapSide = iota
----------+	SwapSideOut
----------+)
+--------- // BuildDepositInstruction создает инструкцию депозита в пул
+--------- func (b *SwapInstructionBuilder) BuildDepositInstruction(
+--------- 	ctx context.Context,
+----------	maxBaseAmount uint64,
+----------	maxQuoteAmount uint64,
+---------+	params DepositParams,
+--------- ) (solana.Instruction, error) {
+----------	// ... реализация создания инструкции депозита
+----------	return nil, nil
+---------+	logger := b.logger.With(
+---------+		zap.Uint64("max_base_amount", params.MaxBaseAmount),
+---------+		zap.Uint64("max_quote_amount", params.MaxQuoteAmount),
+---------+		zap.String("user_authority", params.UserAuthority.String()),
+---------+	)
+---------+	logger.Debug("Building deposit instruction")
+---------+
+---------+	// Находим пользовательские токен аккаунты
+---------+	userBaseAccount, _, err := solana.FindAssociatedTokenAddress(
+---------+		params.UserAuthority,
+---------+		b.pool.BaseMint,
+---------+	)
+---------+	if err != nil {
+---------+		return nil, fmt.Errorf("failed to find user base token account: %w", err)
+---------+	}
+---------+
+---------+	userQuoteAccount, _, err := solana.FindAssociatedTokenAddress(
+---------+		params.UserAuthority,
+---------+		b.pool.QuoteMint,
+---------+	)
+---------+	if err != nil {
+---------+		return nil, fmt.Errorf("failed to find user quote token account: %w", err)
+---------+	}
+---------+
+---------+	userLPAccount, _, err := solana.FindAssociatedTokenAddress(
+---------+		params.UserAuthority,
+---------+		b.pool.LPMint,
+---------+	)
+---------+	if err != nil {
+---------+		return nil, fmt.Errorf("failed to find user LP token account: %w", err)
+---------+	}
+---------+
+---------+	// Сериализуем данные инструкции
+---------+	data := make([]byte, 17) // 1 (тип) + 8 (maxBaseAmount) + 8 (maxQuoteAmount)
+---------+	data[0] = byte(InstructionTypeDeposit)
+---------+	binary.LittleEndian.PutUint64(data[1:9], params.MaxBaseAmount)
+---------+	binary.LittleEndian.PutUint64(data[9:17], params.MaxQuoteAmount)
+---------+
+---------+	// Создаем список необходимых аккаунтов
+---------+	accountMetas := solana.AccountMetaSlice{
+---------+		solana.NewAccountMeta(b.pool.ID, true, false),              // AMM ID
+---------+		solana.NewAccountMeta(b.pool.Authority, false, false),      // AMM Authority
+---------+		solana.NewAccountMeta(b.pool.BaseVault, true, false),       // Base Token Vault
+---------+		solana.NewAccountMeta(b.pool.QuoteVault, true, false),      // Quote Token Vault
+---------+		solana.NewAccountMeta(b.pool.LPMint, true, false),          // LP Token Mint
+---------+		solana.NewAccountMeta(userBaseAccount, true, false),        // User Base Token Account
+---------+		solana.NewAccountMeta(userQuoteAccount, true, false),       // User Quote Token Account
+---------+		solana.NewAccountMeta(userLPAccount, true, false),          // User LP Token Account
+---------+		solana.NewAccountMeta(params.UserAuthority, true, true),    // User Authority (signer)
+---------+		solana.NewAccountMeta(solana.TokenProgramID, false, false), // Token Program
+---------+	}
+---------+
+---------+	// Добавим проверку существования аккаунтов
+---------+	if err := b.validateDepositAccounts(ctx, userBaseAccount, userQuoteAccount, userLPAccount); err != nil {
+---------+		return nil, fmt.Errorf("invalid accounts: %w", err)
+---------+	}
+---------+
+---------+	return solana.NewInstruction(
+---------+		b.pool.AmmProgramID,
+---------+		accountMetas,
+---------+		data,
+---------+	), nil
+--------- }
 --------- 
-----------// getLastPoolState безопасно получает состояние пула
-----------func (r *DEX) getLastPoolState() *PoolState {
-----------	return r.lastPoolState.Load().(*PoolState)
----------+// SwapParams содержит параметры для создания инструкций свапа
----------+type SwapParams struct {
----------+	UserWallet          solana.PublicKey
----------+	AmountIn            uint64
----------+	MinAmountOut        uint64
----------+	ComputeUnits        uint32
----------+	PriorityFeeLamports uint64
----------+	LookupTableAccount  *solana.PublicKey // Опционально: адрес lookup таблицы
----------+	WritableIndexes     []uint8           // Индексы для writable аккаунтов в lookup table
----------+	ReadonlyIndexes     []uint8           // Индексы для readonly аккаунтов в lookup table
----------+	Pool                *RaydiumPool      // Информация о пуле
+----------// BuildWithdrawInstruction создает инструкцию вывода из пула
+----------func (b *SwapInstructionBuilder) BuildWithdrawInstruction(
+---------+// validateDepositAccounts проверяет существование необходимых аккаунтов
+---------+func (b *SwapInstructionBuilder) validateDepositAccounts(
+--------- 	ctx context.Context,
+----------	lpAmount uint64,
+----------) (solana.Instruction, error) {
+----------	// ... реализация создания инструкции вывода
+----------	return nil, nil
+---------+	userBaseAccount,
+---------+	userQuoteAccount,
+---------+	userLPAccount solana.PublicKey,
+---------+) error {
+---------+	for _, check := range []struct {
+---------+		account solana.PublicKey
+---------+		name    string
+---------+	}{
+---------+		{userBaseAccount, "user base token"},
+---------+		{userQuoteAccount, "user quote token"},
+---------+		{userLPAccount, "user LP token"},
+---------+	} {
+---------+		info, err := b.client.GetAccountInfo(ctx, check.account)
+---------+		if err != nil {
+---------+			return fmt.Errorf("failed to get %s account info: %w", check.name, err)
+---------+		}
+---------+		if info.Value == nil || !info.Value.Owner.Equals(solana.TokenProgramID) {
+---------+			return fmt.Errorf("invalid %s account", check.name)
+---------+		}
+---------+	}
+---------+	return nil
 --------- }
 --------- 
-----------// UpdatePoolState обновляет состояние пула с дополнительной синхронизацией
-----------func (r *DEX) UpdatePoolState(state *PoolState) {
-----------	r.stateMutex.Lock()
-----------	defer r.stateMutex.Unlock()
----------+// Client представляет интерфейс для взаимодействия с Raydium DEX
----------+type Client interface {
----------+	// Основные методы пула
----------+	GetPool(ctx context.Context, poolID solana.PublicKey) (*RaydiumPool, error)
----------+	GetPoolState(ctx context.Context, pool *RaydiumPool) (*PoolState, error)
+--------- // GetRequiredAccounts собирает все необходимые аккаунты для свапа
+---------@@ -277,22 +404,166 @@ func (b *SwapInstructionBuilder) GetRequiredAccounts(
+--------- 	return accounts, nil
+--------- }
 --------- 
-----------	r.setLastPoolState(state)
----------+	// Методы для свапов
----------+	CreateSwapInstructions(ctx context.Context, params SwapParams) ([]solana.Instruction, error)
----------+	SimulateSwap(ctx context.Context, instructions []solana.Instruction) error
----------+	GetAmountOut(pool *RaydiumPool, state *PoolState, amountIn uint64) (uint64, error)
+---------+// Параметры для вывода из пула
+---------+type WithdrawParams struct {
+---------+	LPAmount      uint64
+---------+	UserAuthority solana.PublicKey
+---------+}
+---------+
+---------+// BuildWithdrawInstruction создает инструкцию вывода из пула
+---------+func (b *SwapInstructionBuilder) BuildWithdrawInstruction(
+---------+	ctx context.Context,
+---------+	params WithdrawParams,
+---------+) (solana.Instruction, error) {
+---------+	logger := b.logger.With(
+---------+		zap.Uint64("lp_amount", params.LPAmount),
+---------+		zap.String("user_authority", params.UserAuthority.String()),
+---------+	)
+---------+	logger.Debug("Building withdraw instruction")
+---------+
+---------+	// Находим пользовательские токен аккаунты
+---------+	userBaseAccount, _, err := solana.FindAssociatedTokenAddress(
+---------+		params.UserAuthority,
+---------+		b.pool.BaseMint,
+---------+	)
+---------+	if err != nil {
+---------+		return nil, fmt.Errorf("failed to find user base token account: %w", err)
+---------+	}
+---------+
+---------+	userQuoteAccount, _, err := solana.FindAssociatedTokenAddress(
+---------+		params.UserAuthority,
+---------+		b.pool.QuoteMint,
+---------+	)
+---------+	if err != nil {
+---------+		return nil, fmt.Errorf("failed to find user quote token account: %w", err)
+---------+	}
+---------+
+---------+	userLPAccount, _, err := solana.FindAssociatedTokenAddress(
+---------+		params.UserAuthority,
+---------+		b.pool.LPMint,
+---------+	)
+---------+	if err != nil {
+---------+		return nil, fmt.Errorf("failed to find user LP token account: %w", err)
+---------+	}
+---------+
+---------+	// Сериализуем данные инструкции
+---------+	data := make([]byte, 9) // 1 (тип) + 8 (lpAmount)
+---------+	data[0] = byte(InstructionTypeWithdraw)
+---------+	binary.LittleEndian.PutUint64(data[1:], params.LPAmount)
+---------+
+---------+	// Создаем список необходимых аккаунтов
+---------+	accountMetas := solana.AccountMetaSlice{
+---------+		solana.NewAccountMeta(b.pool.ID, true, false),              // AMM ID
+---------+		solana.NewAccountMeta(b.pool.Authority, false, false),      // AMM Authority
+---------+		solana.NewAccountMeta(b.pool.BaseVault, true, false),       // Base Token Vault
+---------+		solana.NewAccountMeta(b.pool.QuoteVault, true, false),      // Quote Token Vault
+---------+		solana.NewAccountMeta(b.pool.LPMint, true, false),          // LP Token Mint
+---------+		solana.NewAccountMeta(userBaseAccount, true, false),        // User Base Token Account
+---------+		solana.NewAccountMeta(userQuoteAccount, true, false),       // User Quote Token Account
+---------+		solana.NewAccountMeta(userLPAccount, true, false),          // User LP Token Account
+---------+		solana.NewAccountMeta(params.UserAuthority, true, true),    // User Authority (signer)
+---------+		solana.NewAccountMeta(solana.TokenProgramID, false, false), // Token Program
+---------+	}
+---------+
+---------+	// Проверяем существование аккаунтов
+---------+	if err := b.validateWithdrawAccounts(ctx, userBaseAccount, userQuoteAccount, userLPAccount); err != nil {
+---------+		return nil, fmt.Errorf("invalid accounts: %w", err)
+---------+	}
+---------+
+---------+	return solana.NewInstruction(
+---------+		b.pool.AmmProgramID,
+---------+		accountMetas,
+---------+		data,
+---------+	), nil
+---------+}
+---------+
+---------+// validateWithdrawAccounts проверяет существование необходимых аккаунтов
+---------+func (b *SwapInstructionBuilder) validateWithdrawAccounts(
+---------+	ctx context.Context,
+---------+	userBaseAccount,
+---------+	userQuoteAccount,
+---------+	userLPAccount solana.PublicKey,
+---------+) error {
+---------+	for _, check := range []struct {
+---------+		account solana.PublicKey
+---------+		name    string
+---------+	}{
+---------+		{userBaseAccount, "user base token"},
+---------+		{userQuoteAccount, "user quote token"},
+---------+		{userLPAccount, "user LP token"},
+---------+	} {
+---------+		info, err := b.client.GetAccountInfo(ctx, check.account)
+---------+		if err != nil {
+---------+			return fmt.Errorf("failed to get %s account info: %w", check.name, err)
+---------+		}
+---------+		if info.Value == nil || !info.Value.Owner.Equals(solana.TokenProgramID) {
+---------+			return fmt.Errorf("invalid %s account", check.name)
+---------+		}
+---------+	}
+---------+	return nil
 ---------+}
+---------+
+--------- // BuildVersionedSwapInstruction создает версионированную инструкцию свапа
+--------- func (b *SwapInstructionBuilder) BuildVersionedSwapInstruction(
+--------- 	ctx context.Context,
+--------- 	params SwapParams,
+--------- 	accounts SwapInstructionAccounts,
+--------- ) (*solana.VersionedTransaction, error) {
+----------	// ... реализация создания версионированной инструкции свапа
+----------	return nil, nil
+---------+	logger := b.logger.With(
+---------+		zap.String("user", accounts.UserAuthority.String()),
+---------+		zap.Uint64("amount_in", params.AmountIn),
+---------+		zap.Uint64("min_amount_out", params.MinAmountOut),
+---------+	)
+---------+	logger.Debug("Building versioned swap instruction")
+---------+
+---------+	// Создаем базовую инструкцию свапа
+---------+	instruction, err := b.BuildSwapInstruction(ctx, params, accounts)
+---------+	if err != nil {
+---------+		return nil, fmt.Errorf("failed to build swap instruction: %w", err)
+---------+	}
+---------+
+---------+	// Создаем message для транзакции
+---------+	message := solana.NewMessage(
+---------+		solana.MessageV0, // используем версию 0 для версионированных транзакций
+---------+		[]solana.Instruction{instruction},
+---------+		accounts.UserAuthority, // fee payer
+---------+	)
+---------+
+---------+	// Если есть lookup table, добавляем её
+---------+	if !b.pool.LookupTableID.IsZero() {
+---------+		addressLookupTable := &solana.MessageAddressTableLookup{
+---------+			AccountKey:      b.pool.LookupTableID,
+---------+			WritableIndexes: []uint8{}, // заполнить необходимыми индексами
+---------+			ReadonlyIndexes: []uint8{}, // заполнить необходимыми индексами
+---------+		}
+---------+		message.AddressTableLookups = append(message.AddressTableLookups, addressLookupTable)
+---------+	}
+---------+
+---------+	// Создаем версионированную транзакцию
+---------+	tx := &solana.VersionedTransaction{
+---------+		Message:    message,
+---------+		Signatures: make([]solana.Signature, message.Header.NumRequiredSignatures),
+---------+	}
+---------+
+---------+	logger.Debug("Versioned swap transaction built successfully")
+---------+
+---------+	return tx, nil
+--------- }
 --------- 
-----------	// Логируем обновление состояния
-----------	r.logger.Debug("Pool state updated",
-----------		zap.Float64("current_price", state.CurrentPrice),
-----------		zap.Uint64("token_a_reserve", state.TokenAReserve),
-----------		zap.Uint64("token_b_reserve", state.TokenBReserve))
----------+// ValidationError представляет ошибку валидации
----------+type ValidationError struct {
----------+	Field   string
----------+	Message string
+----------// BuildDepositInstruction создает инструкцию депозита
+----------func (b *SwapInstructionBuilder) BuildDepositInstruction(
+----------	ctx context.Context,
+----------	params DepositParams,
+----------	accounts DepositInstructionAccounts,
+----------) (solana.Instruction, error) {
+----------	// ... реализация создания инструкции депозита
+----------	return nil, nil
+---------+// DepositInstructionAccounts аккаунты, необходимые для депозита
+---------+type DepositInstructionAccounts struct {
+---------+	// Пользовательские аккаунты
+---------+	UserAuthority  solana.PublicKey // Аккаунт пользователя, который делает депозит
+---------+	UserBaseToken  solana.PublicKey // Аккаунт base токенов пользователя
+---------+	UserQuoteToken solana.PublicKey // Аккаунт quote токенов пользователя
+---------+	UserLPToken    solana.PublicKey // Аккаунт LP токенов пользователя
+---------+
+---------+	// Аккаунты пула
+---------+	AmmId           solana.PublicKey // ID пула
+---------+	AmmAuthority    solana.PublicKey // Authority пула
+---------+	AmmOpenOrders   solana.PublicKey // OpenOrders аккаунт пула
+---------+	AmmTargetOrders solana.PublicKey // TargetOrders аккаунт пула
+---------+	LPMint          solana.PublicKey // Минт LP токенов
+---------+	PoolBaseVault   solana.PublicKey // Vault для base токенов пула
+---------+	PoolQuoteVault  solana.PublicKey // Vault для quote токенов пула
 --------- }
+---------diff --git a/internal/dex/raydium/pool.go b/internal/dex/raydium/pool.go
+---------index e6d2983..2851f20 100644
+------------ a/internal/dex/raydium/pool.go
+---------+++ b/internal/dex/raydium/pool.go
+---------@@ -47,15 +47,17 @@ func (pm *PoolManager) InitializePool(ctx context.Context, params *RaydiumPool)
 --------- 
-----------// GetPoolStateSnapshot получает снапшот текущего состояния пула
-----------func (r *DEX) GetPoolStateSnapshot() *PoolState {
-----------	r.stateMutex.RLock()
-----------	defer r.stateMutex.RUnlock()
----------+func (e *ValidationError) Error() string {
----------+	return fmt.Sprintf("validation error for %s: %s", e.Field, e.Message)
----------+}
+--------- // PoolCalculator предоставляет методы для расчетов в пуле
+--------- type PoolCalculator struct {
+----------	pool  *RaydiumPool
+----------	state *PoolState
+---------+	pool   *RaydiumPool
+---------+	state  *PoolState
+---------+	logger *zap.Logger // Добавляем logger в структуру
+--------- }
 --------- 
-----------	state := r.getLastPoolState()
-----------	if state == nil {
-----------		return nil
-----------	}
----------+// SwapError представляет ошибку при выполнении свапа
----------+type SwapError struct {
----------+	Stage   string
----------+	Message string
----------+	Err     error
----------+}
+--------- // NewPoolCalculator создает новый калькулятор для пула
+----------func NewPoolCalculator(pool *RaydiumPool, state *PoolState) *PoolCalculator {
+---------+func NewPoolCalculator(pool *RaydiumPool, state *PoolState, logger *zap.Logger) *PoolCalculator {
+--------- 	return &PoolCalculator{
+----------		pool:  pool,
+----------		state: state,
+---------+		pool:   pool,
+---------+		state:  state,
+---------+		logger: logger.Named("pool-calculator"), // Добавляем префикс для логгера
+--------- 	}
+--------- }
+--------- 
+---------@@ -83,26 +85,24 @@ func (pc *PoolCalculator) CalculateSwapAmount(
 --------- 
-----------	// Возвращаем копию состояния
-----------	return &PoolState{
-----------		TokenAReserve: state.TokenAReserve,
-----------		TokenBReserve: state.TokenBReserve,
-----------		SwapFee:       state.SwapFee,
-----------		CurrentPrice:  state.CurrentPrice,
----------+func (e *SwapError) Error() string {
----------+	if e.Err != nil {
----------+		return fmt.Sprintf("swap error at %s: %s: %v", e.Stage, e.Message, e.Err)
+--------- 	var amountOut *big.Float
+--------- 	if side == SwapSideIn {
+----------		// dx * y / (x + dx)
+--------- 		numerator := new(big.Float).Mul(amountInAfterFee, quoteReserveF)
+--------- 		denominator := new(big.Float).Add(baseReserveF, amountInAfterFee)
+--------- 		amountOut = new(big.Float).Quo(numerator, denominator)
+--------- 	} else {
+----------		// dx * y / (x + dx)
+--------- 		numerator := new(big.Float).Mul(amountInAfterFee, baseReserveF)
+--------- 		denominator := new(big.Float).Add(quoteReserveF, amountInAfterFee)
+--------- 		amountOut = new(big.Float).Quo(numerator, denominator)
 --------- 	}
----------+	return fmt.Sprintf("swap error at %s: %s", e.Stage, e.Message)
+--------- 
+----------	// Конвертируем результат обратно в uint64
+----------	var amountOutU uint64
+----------	amountOut.Uint64(&amountOutU)
+---------+	// Исправляем конвертацию в uint64
+---------+	amountOutU, _ := amountOut.Uint64()
+--------- 
+--------- 	// Учитываем слиппаж для минимального выхода
+--------- 	slippageMultiplier := new(big.Float).SetFloat64(1 - float64(slippageBps)/10000)
+--------- 	minAmountOut := new(big.Float).Mul(new(big.Float).SetUint64(amountOutU), slippageMultiplier)
+----------	var minAmountOutU uint64
+----------	minAmountOut.Uint64(&minAmountOutU)
+---------+
+---------+	// Исправляем конвертацию в uint64
+---------+	minAmountOutU, _ := minAmountOut.Uint64()
+--------- 
+--------- 	return &SwapAmounts{
+--------- 		AmountIn:     amountIn,
+---------@@ -140,14 +140,15 @@ func (pc *PoolCalculator) GetOptimalSwapAmount(
+--------- 	targetAmount uint64,
+--------- 	slippageBps uint16,
+--------- ) (*SwapAmounts, error) {
+----------	logger := pm.logger.With(
+---------+	// Исправляем pm на pc.pool, так как мы находимся в методе PoolCalculator
+---------+	logger := pc.logger.With(
+--------- 		zap.Uint64("available_amount", availableAmount),
+--------- 		zap.Uint64("target_amount", targetAmount),
+--------- 		zap.Uint16("slippage_bps", slippageBps),
+--------- 	)
+--------- 	logger.Debug("Calculating optimal swap amount")
+--------- 
+----------	// Используем бинарный поиск для нахождения оптимального количества
+---------+	// Остальной код остается без изменений
+--------- 	left := uint64(1)
+--------- 	right := availableAmount
+--------- 	var bestAmount *SwapAmounts
+---------@@ -271,6 +272,17 @@ func (pc *PoolCalculator) GetMarketPrice() float64 {
+--------- 	return (quoteF / quoteDecimalAdj) / (baseF / baseDecimalAdj)
+--------- }
+--------- 
+---------+// Добавить в pool.go:
+---------+type RaydiumV5Pool struct {
+---------+	RaydiumPool
+---------+	PnlOwner    solana.PublicKey
+---------+	ModelDataId solana.PublicKey
+---------+	RecentRoot  *big.Int
+---------+	MaxOrders   uint64
+---------+	OrderStates []*big.Int
+---------+	TickSpacing uint16
 ---------+}
 ---------+
----------+func (e *SwapError) Unwrap() error {
----------+	return e.Err
+--------- // Методы для работы с v5 пулами
+--------- func (pm *PoolManager) InitializeV5Pool(ctx context.Context, params *RaydiumPoolV5) error {
+--------- 	// TODO: implement
+---------diff --git a/internal/dex/raydium/state.go b/internal/dex/raydium/state.go
+---------index 49dd70a..cff0664 100644
+------------ a/internal/dex/raydium/state.go
+---------+++ b/internal/dex/raydium/state.go
+---------@@ -6,7 +6,6 @@ import (
+--------- 	"fmt"
+--------- 	"math"
+--------- 
+----------	"github.com/gagliardetto/binary"
+--------- 	"github.com/gagliardetto/solana-go"
+--------- 	"go.uber.org/zap"
+--------- )
+---------@@ -294,16 +293,101 @@ func (d *StateDecoder) CalculateVirtualPrice(layout *Layout) (float64, error) {
+--------- 	return 2 * sqrtK / lpAdjusted, nil
+--------- }
+--------- 
+----------// Декодер для v5 состояния
+---------+// LayoutV5 расширяет базовую структуру Layout дополнительными полями для v5
+---------+type LayoutV5 struct {
+---------+	Layout                       // Встраиваем базовый Layout
+---------+	PnlOwner    solana.PublicKey // Владелец PnL
+---------+	ModelDataId solana.PublicKey // ID модели данных
+---------+	PnlPool     solana.PublicKey // Пул PnL
 ---------+}
 ---------+
----------+// Типы для v5 пулов
----------+type RaydiumPoolV5 struct {
----------+	// Новые поля v5
+---------+// DecodeV5State декодирует бинарные данные в структуру состояния версии 5
+--------- func (d *StateDecoder) DecodeV5State(data []byte) (*LayoutV5, error) {
+----------	// ... реализация декодирования v5 состояния
+----------	// Этот метод будет реализован в следующей части
+----------	return nil, nil
+---------+	logger := d.logger.With(zap.Int("data_length", len(data)))
+---------+	logger.Debug("Starting v5 state decoding")
+---------+
+---------+	// Сначала декодируем базовую структуру
+---------+	baseLayout, err := d.DecodeState(data)
+---------+	if err != nil {
+---------+		return nil, fmt.Errorf("failed to decode base layout: %w", err)
+---------+	}
+---------+
+---------+	// Проверяем версию
+---------+	if baseLayout.Version != uint8(StateV5) {
+---------+		return nil, fmt.Errorf("invalid version for V5 decode: %d", baseLayout.Version)
+---------+	}
+---------+
+---------+	// Создаем V5 структуру
+---------+	layout := &LayoutV5{
+---------+		Layout: *baseLayout,
+---------+	}
+---------+
+---------+	// Вычисляем смещение для дополнительных полей V5
+---------+	offset := d.GetStateSize(StateV4)
+---------+
+---------+	// Проверяем достаточно ли данных для V5 полей
+---------+	if len(data) < int(d.GetStateSize(StateV5)) {
+---------+		return nil, fmt.Errorf("insufficient data for V5 layout: got %d, need %d",
+---------+			len(data), d.GetStateSize(StateV5))
+---------+	}
+---------+
+---------+	// Читаем дополнительные поля V5
+---------+	copy(layout.PnlOwner[:], data[offset:offset+32])
+---------+	offset += 32
+---------+
+---------+	copy(layout.ModelDataId[:], data[offset:offset+32])
+---------+	offset += 32
+---------+
+---------+	copy(layout.PnlPool[:], data[offset:offset+32])
+---------+
+---------+	logger.Debug("V5 state decoded successfully",
+---------+		zap.Stringer("pnl_owner", layout.PnlOwner),
+---------+		zap.Stringer("model_data_id", layout.ModelDataId),
+---------+		zap.Stringer("pnl_pool", layout.PnlPool))
+---------+
+---------+	return layout, nil
 --------- }
 --------- 
-----------// Name возвращает имя DEX
-----------func (r *DEX) Name() string {
-----------	return "Raydium"
----------+// Типы для маркет-мейкинга
----------+type MarketMakingParams struct {
----------+	// Параметры для MM
+----------// Методы миграции
+---------+// MigrateState выполняет миграцию состояния между версиями
+--------- func (d *StateDecoder) MigrateState(oldState *Layout, newVersion StateVersion) (*Layout, error) {
+----------	// ... реализация миграции состояния
+----------	// Этот метод будет реализован в следующей части
+----------	return nil, nil
+---------+	if oldState == nil {
+---------+		return nil, fmt.Errorf("old state is nil")
+---------+	}
+---------+
+---------+	// Проверяем корректность текущей версии
+---------+	currentVersion := StateVersion(oldState.Version)
+---------+	if currentVersion != StateV4 && currentVersion != StateV5 {
+---------+		return nil, fmt.Errorf("unsupported current version: %d", currentVersion)
+---------+	}
+---------+
+---------+	// Проверяем поддерживается ли миграция на новую версию
+---------+	if newVersion != StateV4 && newVersion != StateV5 {
+---------+		return nil, fmt.Errorf("unsupported target version: %d", newVersion)
+---------+	}
+---------+
+---------+	// Если версии совпадают, возвращаем копию старого состояния
+---------+	if currentVersion == newVersion {
+---------+		newState := *oldState
+---------+		return &newState, nil
+---------+	}
+---------+
+---------+	// Миграция с V4 на V5
+---------+	if currentVersion == StateV4 && newVersion == StateV5 {
+---------+		// При миграции с V4 на V5 мы просто копируем базовые поля
+---------+		// и инициализируем новые поля нулевыми значениями
+---------+		newState := *oldState
+---------+		newState.Version = uint8(StateV5)
+---------+		return &newState, nil
+---------+	}
+---------+
+---------+	// Миграция с V5 на V4
+---------+	if currentVersion == StateV5 && newVersion == StateV4 {
+---------+		// При миграции с V5 на V4 мы просто копируем базовые поля
+---------+		newState := *oldState
+---------+		newState.Version = uint8(StateV4)
+---------+		return &newState, nil
+---------+	}
+---------+
+---------+	return nil, fmt.Errorf("unsupported migration path: %d -> %d",
+---------+		currentVersion, newVersion)
 --------- }
----------diff --git a/internal/dex/raydium/validation.go b/internal/dex/raydium/validation.go
----------deleted file mode 100644
----------index 9267897..0000000
------------- a/internal/dex/raydium/validation.go
----------+++ /dev/null
----------@@ -1,105 +0,0 @@
-----------// internal/dex/raydium/validation.go
-----------package raydium
-----------
-----------import (
-----------	"fmt"
-----------
-----------	"github.com/gagliardetto/solana-go"
-----------	"github.com/rovshanmuradov/solana-bot/internal/types"
-----------)
-----------
-----------// ValidateTask проверяет корректность параметров задачи
-----------func ValidateTask(task *types.Task) error {
-----------	if task == nil {
-----------		return fmt.Errorf("task cannot be nil")
-----------	}
-----------
-----------	if task.TaskName == "" {
-----------		return fmt.Errorf("task name cannot be empty")
-----------	}
-----------
-----------	if task.SourceToken == "" {
-----------		return fmt.Errorf("source token cannot be empty")
-----------	}
-----------
-----------	if task.TargetToken == "" {
-----------		return fmt.Errorf("target token cannot be empty")
-----------	}
-----------
-----------	// Проверяем корректность адресов токенов
-----------	if _, err := solana.PublicKeyFromBase58(task.SourceToken); err != nil {
-----------		return fmt.Errorf("invalid source token address: %w", err)
-----------	}
-----------
-----------	if _, err := solana.PublicKeyFromBase58(task.TargetToken); err != nil {
-----------		return fmt.Errorf("invalid target token address: %w", err)
-----------	}
-----------
-----------	if task.AmountIn <= 0 {
-----------		return fmt.Errorf("amount in must be greater than 0")
-----------	}
-----------
-----------	// Удаляем проверку MinAmountOut, так как теперь оно может быть нулевым или пустым
-----------	// if task.MinAmountOut <= 0 {
-----------	//     return fmt.Errorf("min amount out must be greater than 0")
-----------	// }
-----------
-----------	// Проверяем конфигурацию проскальзывания, если она используется
-----------	if task.SlippageConfig.Type != types.SlippageNone {
-----------		if task.SlippageConfig.Type == types.SlippagePercent &&
-----------			(task.SlippageConfig.Value <= 0 || task.SlippageConfig.Value > 100) {
-----------			return fmt.Errorf("slippage percentage must be between 0 and 100")
-----------		}
-----------		if task.SlippageConfig.Type == types.SlippageFixed && task.SlippageConfig.Value < 0 {
-----------			return fmt.Errorf("fixed slippage value cannot be negative")
-----------		}
-----------	}
-----------
-----------	if task.SourceTokenDecimals <= 0 {
-----------		return fmt.Errorf("source token decimals must be greater than 0")
-----------	}
-----------
-----------	if task.TargetTokenDecimals <= 0 {
-----------		return fmt.Errorf("target token decimals must be greater than 0")
-----------	}
-----------
-----------	return nil
-----------}
-----------
-----------// ValidatePool проверяет корректность конфигурации пула
-----------func ValidatePool(pool *Pool) error {
-----------	if pool == nil {
-----------		return fmt.Errorf("pool config cannot be nil")
-----------	}
-----------
-----------	// Проверяем все обязательные адреса
-----------	addresses := map[string]string{
-----------		"AmmProgramID":          pool.AmmProgramID,
-----------		"AmmID":                 pool.AmmID,
-----------		"AmmAuthority":          pool.AmmAuthority,
-----------		"AmmOpenOrders":         pool.AmmOpenOrders,
-----------		"AmmTargetOrders":       pool.AmmTargetOrders,
-----------		"PoolCoinTokenAccount":  pool.PoolCoinTokenAccount,
-----------		"PoolPcTokenAccount":    pool.PoolPcTokenAccount,
-----------		"SerumProgramID":        pool.SerumProgramID,
-----------		"SerumMarket":           pool.SerumMarket,
-----------		"SerumBids":             pool.SerumBids,
-----------		"SerumAsks":             pool.SerumAsks,
-----------		"SerumEventQueue":       pool.SerumEventQueue,
-----------		"SerumCoinVaultAccount": pool.SerumCoinVaultAccount,
-----------		"SerumPcVaultAccount":   pool.SerumPcVaultAccount,
-----------		"SerumVaultSigner":      pool.SerumVaultSigner,
-----------	}
-----------
-----------	for name, addr := range addresses {
-----------		if addr == "" {
-----------			return fmt.Errorf("%s cannot be empty", name)
-----------		}
-----------
-----------		if _, err := solana.PublicKeyFromBase58(addr); err != nil {
-----------			return fmt.Errorf("invalid %s address: %w", name, err)
-----------		}
-----------	}
-----------
-----------	return nil
-----------}
+---------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
+---------index ef19a7a..a2965fa 100644
+------------ a/internal/dex/raydium/types.go
+---------+++ b/internal/dex/raydium/types.go
+---------@@ -5,8 +5,10 @@ package raydium
+--------- import (
+--------- 	"context"
+--------- 	"fmt"
+---------+	"math/big"
+--------- 
+--------- 	"github.com/gagliardetto/solana-go"
+---------+	"go.uber.org/zap"
+--------- )
+--------- 
+--------- // Layout константы для правильного чтения данных из аккаунта пула
+---------@@ -28,6 +30,20 @@ const (
+--------- 	MinimumAmountOut      = 1
+--------- )
+--------- 
+---------+const (
+---------+	PoolDataSize = 217 // Минимальный размер данных пула
+---------+
+---------+	LayoutAmmProgramID = 2
+---------+	LayoutAuthority    = 34
+---------+	LayoutBaseVault    = 66
+---------+	LayoutQuoteVault   = 98
+---------+	LayoutBaseMint     = 130
+---------+	LayoutQuoteMint    = 162
+---------+	LayoutBaseReserve  = 194
+---------+	LayoutQuoteReserve = 202
+---------+	LayoutFeeRate      = 210
+---------+)
+---------+
+--------- // RaydiumPool представляет собой конфигурацию пула ликвидности Raydium
+--------- type RaydiumPool struct {
+--------- 	// Программы
+---------@@ -69,6 +85,34 @@ type RaydiumPool struct {
+--------- 	SwapInstructionIndex uint8
+--------- 	DefaultMinimumOutBps uint16 // базовых пунктов (1 bps = 0.01%)
+--------- 	DefaultFeeBps        uint16 // комиссия пула в базовых пунктах
+---------+
+---------+	// Статус пула
+---------+	Status uint8
+---------+	Nonce  uint8
+---------+
+---------+	BaseReserve  uint64
+---------+	QuoteReserve uint64
+---------+	FeeRate      uint64
+---------+}
+---------+
+---------+// Добавить в types.go:
+---------+type LiquidityState struct {
+---------+	Status      uint8
+---------+	Nonce       uint8
+---------+	MaxOrder    *big.Int         // Используется для ограничения размера ордера
+---------+	DepthBPS    uint64           // Глубина пула в базисных пунктах
+---------+	PnLOwner    solana.PublicKey // Владелец PnL
+---------+	ModelDataId solana.PublicKey // ID модели данных
+---------+	RecentRoot  *big.Int         // Последний корень для верификации
+---------+	OrderBook   OrderBookState
+---------+}
+---------+
+---------+type OrderBookState struct {
+---------+	Bids       solana.PublicKey
+---------+	Asks       solana.PublicKey
+---------+	EventQueue solana.PublicKey
+---------+	BaseVault  solana.PublicKey
+---------+	QuoteVault solana.PublicKey
+--------- }
+--------- 
+--------- // PoolState содержит динамическое состояние пула
+---------@@ -99,6 +143,11 @@ type SwapParams struct {
+--------- 	WritableIndexes     []uint8           // Индексы для writable аккаунтов в lookup table
+--------- 	ReadonlyIndexes     []uint8           // Индексы для readonly аккаунтов в lookup table
+--------- 	Pool                *RaydiumPool      // Информация о пуле
+---------+	Logger              *zap.Logger       // Добавляем поле logger
+---------+
+---------+	// Аккаунты для свапа
+---------+	SourceTokenAccount      solana.PublicKey
+---------+	DestinationTokenAccount solana.PublicKey
+--------- }
+--------- 
+--------- // Client представляет интерфейс для взаимодействия с Raydium DEX
+---------diff --git a/internal/dex/raydium/utils.go b/internal/dex/raydium/utils.go
+---------index b8f7378..9739bad 100644
+------------ a/internal/dex/raydium/utils.go
+---------+++ b/internal/dex/raydium/utils.go
+---------@@ -2,6 +2,7 @@
+--------- package raydium
+--------- 
+--------- import (
+---------+	"bytes"
+--------- 	"context"
+--------- 	"encoding/binary"
+--------- 	"fmt"
+---------@@ -152,7 +153,6 @@ func FindAssociatedTokenAddress(
+--------- 			owner, // payer
+--------- 			ata,   // ata
+--------- 			owner, // owner
+----------			mint,  // mint
+--------- 		).Build()
+--------- 
+--------- 		instructions = append(instructions, createATAInst)
+---------@@ -271,7 +271,7 @@ func ValidateTokenAccount(
+--------- 	}
+--------- 
+--------- 	var tokenAccount token.Account
+----------	if err := binary.NewDecoder(info.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
+---------+	if err := binary.Read(bytes.NewReader(info.Value.Data.GetBinary()), binary.LittleEndian, &tokenAccount); err != nil {
+--------- 		return fmt.Errorf("failed to decode token account: %w", err)
+--------- 	}
+--------- 
 ---------diff --git a/newdif.txt b/newdif.txt
----------index 406c273..a8395ed 100644
+---------index 2431b7e..949f2f1 100644
 ------------ a/newdif.txt
 ---------+++ b/newdif.txt
----------@@ -1,2314 +0,0 @@
+---------@@ -1,4014 +0,0 @@
+----------diff --git a/TODOata.md b/TODOata.md
+----------deleted file mode 100644
+----------index daa131d..0000000
+------------- a/TODOata.md
+----------+++ /dev/null
+----------@@ -1,69 +0,0 @@
+-----------
+-----------## Оптимизация работы с ATA (Associated Token Accounts)
+-----------
+-----------### 1. Этап подготовки и архитектуры
+-----------
+------------ [ ] Создать отдельный сервис для управления ATA
+------------ [ ] Спроектировать интерфейс сервиса
+------------ [ ] Определить методы и основные операции
+------------ [ ] Разработать схему кэширования
+------------ [ ] Определить стратегии обработки ошибок
+-----------
+------------ [ ] Разработать систему предварительной инициализации
+------------ [ ] Создать механизм проверки необходимых ATA
+-----------      - [ ] Внедрить процесс предварительного создания ATA
+------------ [ ] Добавить валидацию состояния ATA
+-----------
+-----------### 2. Оптимизация RPC взаимодействия
+-----------
+------------ [ ] Улучшить работу с RPC запросами
+------------ [ ] Внедрить batch-запросы для множественных проверок
+------------ [ ] Оптимизировать частоту запросов
+------------ [ ] Настроить умные повторные попытки
+-----------
+------------ [ ] Создать систему кэширования
+------------ [ ] Реализовать локальный кэш ATA состояний
+-----------  - [ ] Настроить TTL для кэша
+-----------  - [ ] Добавить механизм инвалидации кэша
+-----------
+-----------### 3. Мониторинг и логирование
+-----------
+------------ [ ] Внедрить расширенное логирование
+-----------  - [ ] Добавить детальные логи для каждой операции с ATA
+-----------  - [ ] Логировать времена выполнения операций
+-----------  - [ ] Отслеживать ошибки и их причины
+-----------
+------------ [ ] Настроить метрики
+-----------  - [ ] Время создания ATA
+-----------  - [ ] Количество успешных/неуспешных операций
+-----------  - [ ] Использование кэша
+-----------  - [ ] Задержки RPC
+-----------
+------------ [ ] Создать систему алертов
+-----------  - [ ] Настроить оповещения о критических ошибках
+-----------  - [ ] Мониторить аномалии в работе
+-----------  - [ ] Отслеживать деградацию производительности
+-----------
+-----------### 4. Обработка ошибок
+-----------
+------------ [ ] Улучшить систему обработки ошибок
+-----------  - [ ] Создать специфические коды ошибок
+-----------  - [ ] Внедрить механизм автоматического восстановления
+-----------  - [ ] Добавить логику повторных попыток
+-----------
+------------ [ ] Разработать стратегии восстановления
+-----------  - [ ] Определить сценарии восстановления
+-----------  - [ ] Внедрить автоматическое исправление ошибок
+-----------  - [ ] Добавить механизм откатов
+-----------
+-----------### 5. Производительность
+-----------
+------------ [ ] Оптимизировать работу с ATA
+-----------  - [ ] Внедрить параллельную обработку запросов
+-----------  - [ ] Оптимизировать использование памяти
+-----------  - [ ] Улучшить время отклика
+-----------
+------------ [ ] Настроить пулы и очереди
+-----------  - [ ] Создать пул предварительно инициализированных ATA
+-----------  - [ ] Настроить очередь для операций создания
+-----------  - [ ] Оптимизировать управление ресурсами
+----------diff --git a/go.mod b/go.mod
+----------index 6c586dc..6b29758 100644
+------------- a/go.mod
+----------+++ b/go.mod
+----------@@ -10,7 +10,7 @@ require (
+---------- 	github.com/google/uuid v1.6.0
+---------- 	github.com/mr-tron/base58 v1.2.0
+---------- 	github.com/prometheus/client_golang v1.20.5
+-----------	github.com/sirupsen/logrus v1.9.3
+----------+	github.com/shopspring/decimal v1.3.1
+---------- 	github.com/spf13/viper v1.19.0
+---------- 	go.uber.org/zap v1.27.0
+---------- 	gopkg.in/natefinch/lumberjack.v2 v2.2.1
+----------diff --git a/go.sum b/go.sum
+----------index 6a9097a..21aa3cc 100644
+------------- a/go.sum
+----------+++ b/go.sum
+----------@@ -141,8 +141,6 @@ github.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6g
+---------- github.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=
+---------- github.com/shopspring/decimal v1.3.1 h1:2Usl1nmF/WZucqkFZhnfFYxxxu8LG21F6nPQBE5gKV8=
+---------- github.com/shopspring/decimal v1.3.1/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=
+-----------github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
+-----------github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
+---------- github.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=
+---------- github.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=
+---------- github.com/spf13/afero v1.11.0 h1:WJQKhtpdm3v2IzqG8VMqrr6Rf3UYpEF239Jy9wNepM8=
+----------@@ -235,7 +233,6 @@ golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7w
+---------- golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+---------- golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+---------- golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+-----------golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+---------- golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+---------- golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+---------- golang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=
 ----------diff --git a/internal/dex/raydium/config.go b/internal/dex/raydium/config.go
-----------index cb0c21b..fab480a 100644
+----------deleted file mode 100644
+----------index fab480a..0000000
 ------------- a/internal/dex/raydium/config.go
-----------+++ b/internal/dex/raydium/config.go
-----------@@ -3,27 +3,29 @@ package raydium
----------- 
----------- // DefaultPoolConfig с обновленным типом для RaydiumSwapInstructionCode
----------- var DefaultPoolConfig = &Pool{
------------	// Актуальный программный ID Raydium
------------	AmmProgramID: "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",
-----------+	// Программы
-----------+	AmmProgramID:   "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8", // ✅ Подтверждено
-----------+	SerumProgramID: "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX",  // ✅ Подтверждено
----------- 
------------	// Актуальная конфигурация для SOL-USDC пула
------------	AmmID:                "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
------------	AmmAuthority:         "3uaZBfHPfmpAHW7dsimC1SnyR61X4bJqQZKWmRSCXJxv",
------------	AmmOpenOrders:        "4NfmERReGt1QCKey8cH5q4LsBYJoUcsuGg11J8GQFwH8",
------------	AmmTargetOrders:      "38RJcGjtgd4SKRfY2dcM8Z9LzXQR6cyZeGxvjrRsVGZD",
------------	PoolCoinTokenAccount: "8spXrXn2EWtNiAHvWZY3EE2f8E1TRDHzFTYyXtNuVFKs",
------------	PoolPcTokenAccount:   "DuYuU5Y6TEZoMhzwPsYYRFzB5xqF999kXGHUDmBZwJge",
-----------+	// AMM конфигурация
-----------+	AmmID:           "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", // ✅ Подтверждено
-----------+	AmmAuthority:    "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1", // ✅ Обновлено (authority)
-----------+	AmmOpenOrders:   "HmiHHzq4Fym9e1D4qzLS6LDDM3tNsCTBPDWHTLZ763jY", // ✅ Обновлено (openOrders)
-----------+	AmmTargetOrders: "CZza3Ej4Mc58MnxWA385itCC9jCo3L1D7zc3LKy1bZMR", // ✅ Обновлено (targetOrders)
----------- 
------------	// OpenBook (бывший Serum) маркет
------------	SerumProgramID:        "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX",
------------	SerumMarket:           "8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6",
------------	SerumBids:             "5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh",
------------	SerumAsks:             "EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCHV5T73Sw8TL",
------------	SerumEventQueue:       "8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa",
------------	SerumCoinVaultAccount: "CKxTHwM9fPksGqGd5AHjyGWGbzGkDYjP6ABNYRLvJ1Vz",
------------	SerumPcVaultAccount:   "PCxN9aXvxtwMYrXk8BgESw3NNkGLwpPM8c6DwByrjgN",
------------	SerumVaultSigner:      "GXWEpRURaQZ9E62Q23EreTUfBy4hfemXgWFUWcg7YFgv",
-----------+	// Token Accounts
-----------+	PoolCoinTokenAccount: "DQyrAcCrDXQ7NeoqGgDCZwBvWDcYmFCjSb9JtteuvPpz", // ✅ Обновлено (baseVault)
-----------+	PoolPcTokenAccount:   "HLmqeL62xR1QoZ1HKKbXRrdN1p3phKpxRMb2VVopvBBz", // ✅ Обновлено (quoteVault)
----------- 
------------	// Правильный код инструкции для свапа (теперь uint8)
------------	RaydiumSwapInstructionCode: 1,
-----------+	// Serum Market
-----------+	SerumMarket:           "8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6", // ✅ Подтверждено
-----------+	SerumBids:             "5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh", // ✅ Подтверждено
-----------+	SerumAsks:             "EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCLNBEDXDn1d5", // ✅ Обновлено
-----------+	SerumEventQueue:       "8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa", // ✅ Подтверждено
-----------+	SerumCoinVaultAccount: "CKxTHwM9fPMRRvZmFnFoqKNd9pQR21c5Aq9bh5h9oghX", // ✅ Обновлено (marketBaseVault)
-----------+	SerumPcVaultAccount:   "6A5NHCj1yF6urc9wZNe6Bcjj4LVszQNj5DwAWG97yzMu", // ✅ Обновлено (marketQuoteVault)
-----------+	SerumVaultSigner:      "CTz5UMLQm2SRWHzQnU62Pi4yJqbNGjgRBHqqp6oDHfF7", // ✅ Обновлено (marketAuthority)
-----------+
-----------+	// Дополнительные параметры
-----------+	RaydiumSwapInstructionCode: 1, // ✅ Не изменилось
----------- }
+----------+++ /dev/null
+----------@@ -1,31 +0,0 @@
+-----------// internal/dex/raydium/config.go
+-----------package raydium
+-----------
+-----------// DefaultPoolConfig с обновленным типом для RaydiumSwapInstructionCode
+-----------var DefaultPoolConfig = &Pool{
+-----------	// Программы
+-----------	AmmProgramID:   "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8", // ✅ Подтверждено
+-----------	SerumProgramID: "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX",  // ✅ Подтверждено
+-----------
+-----------	// AMM конфигурация
+-----------	AmmID:           "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", // ✅ Подтверждено
+-----------	AmmAuthority:    "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1", // ✅ Обновлено (authority)
+-----------	AmmOpenOrders:   "HmiHHzq4Fym9e1D4qzLS6LDDM3tNsCTBPDWHTLZ763jY", // ✅ Обновлено (openOrders)
+-----------	AmmTargetOrders: "CZza3Ej4Mc58MnxWA385itCC9jCo3L1D7zc3LKy1bZMR", // ✅ Обновлено (targetOrders)
+-----------
+-----------	// Token Accounts
+-----------	PoolCoinTokenAccount: "DQyrAcCrDXQ7NeoqGgDCZwBvWDcYmFCjSb9JtteuvPpz", // ✅ Обновлено (baseVault)
+-----------	PoolPcTokenAccount:   "HLmqeL62xR1QoZ1HKKbXRrdN1p3phKpxRMb2VVopvBBz", // ✅ Обновлено (quoteVault)
+-----------
+-----------	// Serum Market
+-----------	SerumMarket:           "8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6", // ✅ Подтверждено
+-----------	SerumBids:             "5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh", // ✅ Подтверждено
+-----------	SerumAsks:             "EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCLNBEDXDn1d5", // ✅ Обновлено
+-----------	SerumEventQueue:       "8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa", // ✅ Подтверждено
+-----------	SerumCoinVaultAccount: "CKxTHwM9fPMRRvZmFnFoqKNd9pQR21c5Aq9bh5h9oghX", // ✅ Обновлено (marketBaseVault)
+-----------	SerumPcVaultAccount:   "6A5NHCj1yF6urc9wZNe6Bcjj4LVszQNj5DwAWG97yzMu", // ✅ Обновлено (marketQuoteVault)
+-----------	SerumVaultSigner:      "CTz5UMLQm2SRWHzQnU62Pi4yJqbNGjgRBHqqp6oDHfF7", // ✅ Обновлено (marketAuthority)
+-----------
+-----------	// Дополнительные параметры
+-----------	RaydiumSwapInstructionCode: 1, // ✅ Не изменилось
+-----------}
 ----------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
-----------index 48baf94..c684b6e 100644
+----------deleted file mode 100644
+----------index c684b6e..0000000
 ------------- a/internal/dex/raydium/raydium.go
-----------+++ b/internal/dex/raydium/raydium.go
-----------@@ -17,6 +17,7 @@ import (
----------- 
----------- 	solanarpc "github.com/gagliardetto/solana-go/rpc"
----------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
-----------+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
----------- 	"github.com/rovshanmuradov/solana-bot/internal/types"
----------- 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
----------- 	"go.uber.org/zap"
-----------@@ -30,17 +31,73 @@ const (
----------- 	txSendTimeout   = 15 * time.Second
----------- )
----------- 
-----------+// Добавляем новые типы для работы с ценами
-----------+type PriceValidator interface {
-----------+	ValidatePrice(poolPrice float64) error
-----------+	GetMaxDeviation() float64
-----------+}
-----------+
-----------+// Обновляем структуру PoolState
-----------+
-----------+// Добавляем базовую реализацию валидатора цен
-----------+type BasicPriceValidator struct {
-----------+	basePrice    float64
-----------+	maxDeviation float64
-----------+	logger       *zap.Logger
-----------+}
-----------+
-----------+func NewBasicPriceValidator(basePrice float64, maxDeviation float64, logger *zap.Logger) *BasicPriceValidator {
-----------+	return &BasicPriceValidator{
-----------+		basePrice:    basePrice,
-----------+		maxDeviation: maxDeviation,
-----------+		logger:       logger,
-----------+	}
-----------+}
-----------+
-----------+func (v *BasicPriceValidator) ValidatePrice(poolPrice float64) error {
-----------+	if v.basePrice <= 0 {
-----------+		// Если базовая цена не установлена, пропускаем валидацию
-----------+		return nil
-----------+	}
-----------+
-----------+	deviation := math.Abs(poolPrice-v.basePrice) / v.basePrice
-----------+	if deviation > v.maxDeviation {
-----------+		return fmt.Errorf("pool price deviation too high: %.2f%% (pool: %.2f, base: %.2f)",
-----------+			deviation*100, poolPrice, v.basePrice)
-----------+	}
-----------+
-----------+	return nil
-----------+}
-----------+
-----------+func (v *BasicPriceValidator) GetMaxDeviation() float64 {
-----------+	return v.maxDeviation
-----------+}
-----------+
-----------+// NewDEX создает новый экземпляр DEX
----------- func NewDEX(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) *DEX {
----------- 	if err := validateDEXParams(client, logger, poolInfo); err != nil {
----------- 		logger.Error("Failed to create DEX", zap.Error(err))
----------- 		return nil
----------- 	}
----------- 
------------	return &DEX{
------------		client:   client,
------------		logger:   logger.Named("raydium-dex"),
------------		poolInfo: poolInfo,
-----------+	priceValidator := NewBasicPriceValidator(
-----------+		181.0, // Базовая цена SOL/USDC
-----------+		0.5,   // 50% максимальное отклонение
-----------+		logger,
-----------+	)
-----------+
-----------+	dex := &DEX{
-----------+		client:         client,
-----------+		logger:         logger.Named("raydium-dex"),
-----------+		poolInfo:       poolInfo,
-----------+		tokenCache:     solbc.NewTokenMetadataCache(logger),
-----------+		priceValidator: priceValidator,
----------- 	}
-----------+
-----------+	// Инициализируем atomic.Value
-----------+	dex.lastPoolState.Store((*PoolState)(nil))
-----------+
-----------+	return dex
----------- }
----------- 
----------- func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wallet.Wallet) error {
-----------@@ -57,7 +114,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
----------- 	)
----------- 	logger.Info("Starting swap execution")
----------- 
------------	// Проверяем и получаем токен-аккаунты с таймаутом
-----------+	// Parse token addresses
----------- 	sourceMint, targetMint, err := parseTokenAddresses(task.SourceToken, task.TargetToken)
----------- 	if err != nil {
----------- 		return fmt.Errorf("invalid token addresses: %w", err)
-----------@@ -66,12 +123,13 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
----------- 	ataCtx, ataCancel := context.WithTimeout(opCtx, ataCheckTimeout)
----------- 	defer ataCancel()
----------- 
-----------+	// Setup token accounts
----------- 	sourceATA, targetATA, err := r.setupTokenAccounts(ataCtx, userWallet, sourceMint, targetMint, logger)
----------- 	if err != nil {
----------- 		return fmt.Errorf("failed to setup token accounts: %w", err)
----------- 	}
----------- 
------------	// Подготавливаем amount с учетом decimals
-----------+	// Prepare amount with decimals
----------- 	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
----------- 
----------- 	logger.Debug("Prepared swap amount",
-----------@@ -80,11 +138,10 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
----------- 		zap.Float64("slippage_value", task.SlippageConfig.Value),
----------- 	)
----------- 
------------	// Создаем инструкции с таймаутом
----------- 	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
----------- 	defer swapCancel()
----------- 
------------	// Подготавливаем все необходимые инструкции
-----------+	// Prepare swap instructions
----------- 	instructions, err := r.PrepareSwapInstructions(
----------- 		swapCtx,
----------- 		userWallet.PublicKey,
-----------@@ -98,7 +155,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
----------- 		return fmt.Errorf("failed to prepare swap instructions: %w", err)
----------- 	}
----------- 
------------	// Отправляем транзакцию
-----------+	// Send transaction
----------- 	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
----------- 	if err != nil {
----------- 		return fmt.Errorf("failed to send swap transaction: %w", err)
-----------@@ -555,7 +612,7 @@ func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, sol
----------- 	return sourceMint, targetMint, nil
----------- }
----------- 
------------// getExpectedOutput вычисляет ожидаемый выход для свапа
-----------+// getExpectedOutput calculates the expected output for the swap
----------- func (r *DEX) getExpectedOutput(
----------- 	ctx context.Context,
----------- 	amountIn uint64,
-----------@@ -563,52 +620,84 @@ func (r *DEX) getExpectedOutput(
----------- 	poolInfo *Pool,
----------- 	logger *zap.Logger,
----------- ) (float64, error) {
------------	// Создаем контекст с тайм-аутом
------------	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
+----------+++ /dev/null
+----------@@ -1,927 +0,0 @@
+-----------// internal/dex/raydium/raydium.go
+-----------
+-----------package raydium
+-----------
+-----------import (
+-----------	"context"
+-----------	"encoding/binary"
+-----------	"fmt"
+-----------	"math"
+-----------	"time"
+-----------
+-----------	bin "github.com/gagliardetto/binary"
+-----------	"github.com/gagliardetto/solana-go"
+-----------	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
+-----------	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
+-----------	"github.com/gagliardetto/solana-go/programs/token"
+-----------
+-----------	solanarpc "github.com/gagliardetto/solana-go/rpc"
+-----------	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+-----------	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
+-----------	"github.com/rovshanmuradov/solana-bot/internal/types"
+-----------	"github.com/rovshanmuradov/solana-bot/internal/wallet"
+-----------	"go.uber.org/zap"
+-----------)
+-----------
+-----------const (
+-----------	defaultTimeout  = 10 * time.Second
+-----------	maxRetries      = 3
+-----------	retryDelay      = 500 * time.Millisecond
+-----------	ataCheckTimeout = 5 * time.Second
+-----------	txSendTimeout   = 15 * time.Second
+-----------)
+-----------
+-----------// Добавляем новые типы для работы с ценами
+-----------type PriceValidator interface {
+-----------	ValidatePrice(poolPrice float64) error
+-----------	GetMaxDeviation() float64
+-----------}
+-----------
+-----------// Обновляем структуру PoolState
+-----------
+-----------// Добавляем базовую реализацию валидатора цен
+-----------type BasicPriceValidator struct {
+-----------	basePrice    float64
+-----------	maxDeviation float64
+-----------	logger       *zap.Logger
+-----------}
+-----------
+-----------func NewBasicPriceValidator(basePrice float64, maxDeviation float64, logger *zap.Logger) *BasicPriceValidator {
+-----------	return &BasicPriceValidator{
+-----------		basePrice:    basePrice,
+-----------		maxDeviation: maxDeviation,
+-----------		logger:       logger,
+-----------	}
+-----------}
+-----------
+-----------func (v *BasicPriceValidator) ValidatePrice(poolPrice float64) error {
+-----------	if v.basePrice <= 0 {
+-----------		// Если базовая цена не установлена, пропускаем валидацию
+-----------		return nil
+-----------	}
+-----------
+-----------	deviation := math.Abs(poolPrice-v.basePrice) / v.basePrice
+-----------	if deviation > v.maxDeviation {
+-----------		return fmt.Errorf("pool price deviation too high: %.2f%% (pool: %.2f, base: %.2f)",
+-----------			deviation*100, poolPrice, v.basePrice)
+-----------	}
+-----------
+-----------	return nil
+-----------}
+-----------
+-----------func (v *BasicPriceValidator) GetMaxDeviation() float64 {
+-----------	return v.maxDeviation
+-----------}
+-----------
+-----------// NewDEX создает новый экземпляр DEX
+-----------func NewDEX(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) *DEX {
+-----------	if err := validateDEXParams(client, logger, poolInfo); err != nil {
+-----------		logger.Error("Failed to create DEX", zap.Error(err))
+-----------		return nil
+-----------	}
+-----------
+-----------	priceValidator := NewBasicPriceValidator(
+-----------		181.0, // Базовая цена SOL/USDC
+-----------		0.5,   // 50% максимальное отклонение
+-----------		logger,
+-----------	)
+-----------
+-----------	dex := &DEX{
+-----------		client:         client,
+-----------		logger:         logger.Named("raydium-dex"),
+-----------		poolInfo:       poolInfo,
+-----------		tokenCache:     solbc.NewTokenMetadataCache(logger),
+-----------		priceValidator: priceValidator,
+-----------	}
+-----------
+-----------	// Инициализируем atomic.Value
+-----------	dex.lastPoolState.Store((*PoolState)(nil))
+-----------
+-----------	return dex
+-----------}
+-----------
+-----------func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wallet.Wallet) error {
+-----------	opCtx, cancel := context.WithTimeout(ctx, defaultTimeout)
 -----------	defer cancel()
 -----------
------------	logger = logger.With(
------------		zap.String("source_token", sourceToken.String()),
------------		zap.String("target_token", targetToken.String()),
+-----------	r.slippage = task.SlippageConfig.Value
+-----------
+-----------	logger := r.logger.With(
+-----------		zap.String("task", task.TaskName),
+-----------		zap.String("wallet", userWallet.PublicKey.String()),
+-----------		zap.String("slippage_type", string(task.SlippageConfig.Type)),
+-----------		zap.Float64("slippage_value", task.SlippageConfig.Value),
+-----------	)
+-----------	logger.Info("Starting swap execution")
+-----------
+-----------	// Parse token addresses
+-----------	sourceMint, targetMint, err := parseTokenAddresses(task.SourceToken, task.TargetToken)
+-----------	if err != nil {
+-----------		return fmt.Errorf("invalid token addresses: %w", err)
+-----------	}
+-----------
+-----------	ataCtx, ataCancel := context.WithTimeout(opCtx, ataCheckTimeout)
+-----------	defer ataCancel()
+-----------
+-----------	// Setup token accounts
+-----------	sourceATA, targetATA, err := r.setupTokenAccounts(ataCtx, userWallet, sourceMint, targetMint, logger)
+-----------	if err != nil {
+-----------		return fmt.Errorf("failed to setup token accounts: %w", err)
+-----------	}
+-----------
+-----------	// Prepare amount with decimals
+-----------	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
+-----------
+-----------	logger.Debug("Prepared swap amount",
+-----------		zap.Uint64("amount_in", amountIn),
+-----------		zap.String("slippage_type", string(task.SlippageConfig.Type)),
+-----------		zap.Float64("slippage_value", task.SlippageConfig.Value),
+-----------	)
+-----------
+-----------	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
+-----------	defer swapCancel()
+-----------
+-----------	// Prepare swap instructions
+-----------	instructions, err := r.PrepareSwapInstructions(
+-----------		swapCtx,
+-----------		userWallet.PublicKey,
+-----------		sourceATA,
+-----------		targetATA,
+-----------		amountIn,
+-----------		task.PriorityFee,
+-----------		logger,
+-----------	)
+-----------	if err != nil {
+-----------		return fmt.Errorf("failed to prepare swap instructions: %w", err)
+-----------	}
+-----------
+-----------	// Send transaction
+-----------	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
+-----------	if err != nil {
+-----------		return fmt.Errorf("failed to send swap transaction: %w", err)
+-----------	}
+-----------
+-----------	logger.Info("Swap transaction sent successfully",
+-----------		zap.String("signature", signature.String()),
+-----------		zap.Float64("priority_fee", task.PriorityFee))
+-----------
+-----------	return nil
+-----------}
+-----------
+-----------func (r *DEX) setupTokenAccounts(
+-----------	ctx context.Context,
+-----------	wallet *wallet.Wallet,
+-----------	sourceMint, targetMint solana.PublicKey,
+-----------	logger *zap.Logger,
+-----------) (solana.PublicKey, solana.PublicKey, error) {
+-----------	sourceATA, _, err := solana.FindAssociatedTokenAddress(wallet.PublicKey, sourceMint)
+-----------	if err != nil {
+-----------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("failed to find source ATA: %w", err)
+-----------	}
+-----------
+-----------	targetATA, _, err := solana.FindAssociatedTokenAddress(wallet.PublicKey, targetMint)
+-----------	if err != nil {
+-----------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("failed to find target ATA: %w", err)
+-----------	}
+-----------
+-----------	// Проверяем и создаем ATA если необходимо
+-----------	if err := r.ensureATA(ctx, wallet, sourceMint, sourceATA, "source", logger); err != nil {
+-----------		return solana.PublicKey{}, solana.PublicKey{}, err
+-----------	}
+-----------
+-----------	if err := r.ensureATA(ctx, wallet, targetMint, targetATA, "target", logger); err != nil {
+-----------		return solana.PublicKey{}, solana.PublicKey{}, err
+-----------	}
+-----------
+-----------	return sourceATA, targetATA, nil
+-----------}
+-----------
+-----------func (r *DEX) ensureATA(
+-----------	ctx context.Context,
+-----------	wallet *wallet.Wallet,
+-----------	mint, ata solana.PublicKey,
+-----------	ataType string,
+-----------	logger *zap.Logger,
+-----------) error {
+-----------	logger = logger.With(
+-----------		zap.String("mint", mint.String()),
+-----------		zap.String("ata", ata.String()),
+-----------		zap.String("wallet", wallet.PublicKey.String()),
+-----------	)
+-----------
+-----------	// Проверяем существование ATA с повторными попытками
+-----------	exists, err := r.checkATAExists(ctx, ata, logger)
+-----------	if err != nil {
+-----------		return fmt.Errorf("failed to check %s ATA: %w", ataType, err)
+-----------	}
+-----------
+-----------	if !exists {
+-----------		logger.Debug("Creating new ATA")
+-----------		// Используем правильное создание инструкции из solana-go
+-----------		instruction, err := r.createATAInstruction(wallet, mint)
+-----------		if err != nil {
+-----------			return fmt.Errorf("failed to create %s ATA instruction: %w", ataType, err)
+-----------		}
+-----------
+-----------		// Отправляем транзакцию и ждем подтверждения
+-----------		signature, err := r.sendTransactionWithRetryAndConfirmation(ctx, wallet, []solana.Instruction{instruction}, logger)
+-----------		if err != nil {
+-----------			return fmt.Errorf("failed to create %s ATA: %w", ataType, err)
+-----------		}
+-----------
+-----------		logger.Info("ATA created successfully",
+-----------			zap.String("signature", signature.String()))
+-----------
+-----------		// Ждем появления аккаунта
+-----------		if err := r.waitForATACreation(ctx, ata, logger); err != nil {
+-----------			return fmt.Errorf("failed to confirm %s ATA creation: %w", ataType, err)
+-----------		}
+-----------	}
+-----------
+-----------	return nil
+-----------}
+-----------
+-----------func (r *DEX) checkATAExists(
+-----------	ctx context.Context,
+-----------	ata solana.PublicKey,
+-----------	logger *zap.Logger,
+-----------) (bool, error) {
+-----------	for attempt := 0; attempt < maxRetries; attempt++ {
+-----------		account, err := r.client.GetAccountInfo(ctx, ata)
+-----------		if err == nil && account.Value != nil {
+-----------			// Проверяем, что владелец - TokenProgram
+-----------			return account.Value.Owner == solana.TokenProgramID, nil
+-----------		}
+-----------
+-----------		if attempt < maxRetries-1 {
+-----------			select {
+-----------			case <-ctx.Done():
+-----------				return false, ctx.Err()
+-----------			case <-time.After(retryDelay):
+-----------				logger.Debug("Retrying ATA check", zap.Int("attempt", attempt+1))
+-----------			}
+-----------		}
+-----------	}
+-----------	return false, nil
+-----------}
+-----------
+-----------func (r *DEX) createATAInstruction(
+-----------	wallet *wallet.Wallet,
+-----------	mint solana.PublicKey,
+-----------) (solana.Instruction, error) {
+-----------	// Используем билдер из solana-go
+-----------	inst := associatedtokenaccount.NewCreateInstruction(
+-----------		wallet.PublicKey, // payer
+-----------		wallet.PublicKey, // wallet address
+-----------		mint,             // token mint
+-----------	)
+-----------
+-----------	// Проводим валидацию
+-----------	if err := inst.Validate(); err != nil {
+-----------		return nil, fmt.Errorf("invalid ATA instruction: %w", err)
+-----------	}
+-----------
+-----------	return inst.Build(), nil
+-----------}
+-----------
+-----------func (r *DEX) waitForATACreation(
+-----------	ctx context.Context,
+-----------	ata solana.PublicKey,
+-----------	logger *zap.Logger,
+-----------) error {
+-----------	// Увеличиваем время ожидания до 2 минут
+-----------	deadline := time.Now().Add(2 * time.Minute)
+-----------	// Начальный интервал проверки
+-----------	ticker := time.NewTicker(2 * time.Second)
+-----------	defer ticker.Stop()
+-----------
+-----------	retryCount := 0
+-----------	maxRetries := 60 // Максимальное количество попыток
+-----------
+-----------	for {
+-----------		if time.Now().After(deadline) {
+-----------			return fmt.Errorf("timeout waiting for ATA creation after 2 minutes")
+-----------		}
+-----------
+-----------		if retryCount >= maxRetries {
+-----------			return fmt.Errorf("exceeded maximum retry attempts (%d) waiting for ATA creation", maxRetries)
+-----------		}
+-----------
+-----------		select {
+-----------		case <-ctx.Done():
+-----------			return ctx.Err()
+-----------		case <-ticker.C:
+-----------			account, err := r.client.GetAccountInfo(ctx, ata)
+-----------			if err != nil {
+-----------				logger.Debug("ATA verification attempt failed",
+-----------					zap.Error(err),
+-----------					zap.Int("retry", retryCount),
+-----------					zap.Time("deadline", deadline))
+-----------				retryCount++
+-----------				continue
+-----------			}
+-----------
+-----------			if account.Value != nil && account.Value.Owner == solana.TokenProgramID {
+-----------				logger.Info("ATA creation confirmed",
+-----------					zap.String("ata", ata.String()),
+-----------					zap.Int("retries", retryCount))
+-----------				return nil
+-----------			}
+-----------
+-----------			logger.Debug("ATA not ready yet",
+-----------				zap.String("ata", ata.String()),
+-----------				zap.Int("retry", retryCount))
+-----------			retryCount++
+-----------		}
+-----------	}
+-----------}
+-----------
+-----------// PrepareSwapInstructions объединяет все инструкции для свапа
+-----------func (r *DEX) PrepareSwapInstructions(
+-----------	ctx context.Context,
+-----------	wallet solana.PublicKey,
+-----------	sourceATA solana.PublicKey,
+-----------	targetATA solana.PublicKey,
+-----------	amountIn uint64,
+-----------	priorityFee float64,
+-----------	logger *zap.Logger,
+-----------) ([]solana.Instruction, error) {
+-----------	var instructions []solana.Instruction
+-----------
+-----------	// Добавляем compute budget инструкции
+-----------	computeBudgetInst := computebudget.NewSetComputeUnitPriceInstruction(
+-----------		uint64(priorityFee * 1e6),
+-----------	).Build()
+-----------	instructions = append(instructions, computeBudgetInst)
+-----------
+-----------	// Создаем базовую инструкцию свапа
+-----------	swapInst, err := r.PrepareSwapInstruction(
+-----------		ctx,
+-----------		wallet,
+-----------		sourceATA,
+-----------		targetATA,
+-----------		amountIn,
+-----------		logger,
+-----------	)
+-----------	if err != nil {
+-----------		return nil, fmt.Errorf("failed to prepare swap instruction: %w", err)
+-----------	}
+-----------	instructions = append(instructions, swapInst)
+-----------
+-----------	return instructions, nil
+-----------}
+-----------
+-----------// PrepareSwapInstruction подготавливает базовую инструкцию свапа
+-----------func (r *DEX) PrepareSwapInstruction(
+-----------	ctx context.Context,
+-----------	wallet solana.PublicKey,
+-----------	sourceATA solana.PublicKey,
+-----------	targetATA solana.PublicKey,
+-----------	amountIn uint64,
+-----------	logger *zap.Logger,
+-----------) (solana.Instruction, error) {
+-----------	logger = logger.With(
+-----------		zap.String("wallet", wallet.String()),
+-----------		zap.String("source_ata", sourceATA.String()),
+-----------		zap.String("target_ata", targetATA.String()),
+-----------	)
+-----------	logger.Debug("Preparing swap instruction")
+-----------
+-----------	// Получаем ожидаемый выход
+-----------	sourceMint, err := r.getMintFromATA(ctx, sourceATA)
+-----------	if err != nil {
+-----------		return nil, fmt.Errorf("failed to get source mint: %w", err)
+-----------	}
+-----------
+-----------	targetMint, err := r.getMintFromATA(ctx, targetATA)
+-----------	if err != nil {
+-----------		return nil, fmt.Errorf("failed to get target mint: %w", err)
+-----------	}
+-----------
+-----------	expectedOut, err := r.getExpectedOutput(
+-----------		ctx,
+-----------		amountIn,
+-----------		sourceMint,
+-----------		targetMint,
+-----------		r.poolInfo,
+-----------		logger,
+-----------	)
+-----------	if err != nil {
+-----------		return nil, fmt.Errorf("failed to get expected output: %w", err)
+-----------	}
+-----------
+-----------	// Используем slippage из структуры DEX
+-----------	minAmountOut := calculateMinimumOut(expectedOut, r.slippage)
+-----------
+-----------	return r.createSwapInstruction(
+-----------		wallet,
+-----------		sourceATA,
+-----------		targetATA,
+-----------		amountIn,
+-----------		minAmountOut,
+-----------		logger,
+-----------		r.poolInfo,
+-----------	)
+-----------}
+-----------
+-----------// createSwapInstruction внутренний метод для создания инструкции свапа
+-----------func (r *DEX) createSwapInstruction(
+-----------	wallet solana.PublicKey,
+-----------	sourceATA solana.PublicKey,
+-----------	targetATA solana.PublicKey,
+-----------	amountIn uint64,
+-----------	minAmountOut uint64,
+-----------	logger *zap.Logger,
+-----------	poolInfo *Pool,
+-----------) (solana.Instruction, error) {
+-----------	// Существующая логика из CreateSwapInstruction
+-----------	return r.CreateSwapInstruction(
+-----------		wallet,
+-----------		sourceATA,
+-----------		targetATA,
+-----------		amountIn,
+-----------		minAmountOut,
+-----------		logger,
+-----------		poolInfo,
+-----------	)
+-----------}
+-----------
+-----------// Вспомогательный метод для получения mint address из ATA
+-----------func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.PublicKey, error) {
+-----------	account, err := r.client.GetAccountInfo(ctx, ata)
+-----------	if err != nil {
+-----------		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
+-----------	}
+-----------
+-----------	if account.Value == nil || len(account.Value.Data.GetBinary()) < 64 {
+-----------		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
+-----------	}
+-----------
+-----------	var tokenAccount token.Account
+-----------	if err := bin.NewBinDecoder(account.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
+-----------		return solana.PublicKey{}, fmt.Errorf("failed to decode ATA data: %w", err)
+-----------	}
+-----------
+-----------	return tokenAccount.Mint, nil
+-----------}
+-----------
+-----------func (r *DEX) sendTransactionWithRetryAndConfirmation(
+-----------	ctx context.Context,
+-----------	wallet *wallet.Wallet,
+-----------	instructions []solana.Instruction,
+-----------	logger *zap.Logger,
+-----------) (solana.Signature, error) {
+-----------	const (
+-----------		maxRetries          = 3
+-----------		sendTimeout         = 15 * time.Second
+-----------		confirmationTimeout = 60 * time.Second
+-----------	)
+-----------
+-----------	var lastErr error
+-----------	for attempt := 0; attempt < maxRetries; attempt++ {
+-----------		select {
+-----------		case <-ctx.Done():
+-----------			return solana.Signature{}, ctx.Err()
+-----------		default:
+-----------			// Создаем контекст с таймаутом для отправки
+-----------			sendCtx, cancel := context.WithTimeout(ctx, sendTimeout)
+-----------			signature, err := r.sendTransaction(sendCtx, wallet, instructions)
+-----------			cancel()
+-----------
+-----------			if err != nil {
+-----------				lastErr = err
+-----------				logger.Warn("Retrying transaction send",
+-----------					zap.Int("attempt", attempt+1),
+-----------					zap.Error(err))
+-----------				time.Sleep(time.Second * time.Duration(attempt+1))
+-----------				continue
+-----------			}
+-----------
+-----------			// Создаем отдельный контекст для подтверждения
+-----------			confirmCtx, cancel := context.WithTimeout(ctx, confirmationTimeout)
+-----------			defer cancel()
+-----------
+-----------			// Ждем подтверждения с периодическими проверками
+-----------			ticker := time.NewTicker(time.Second)
+-----------			defer ticker.Stop()
+-----------
+-----------			for {
+-----------				select {
+-----------				case <-confirmCtx.Done():
+-----------					return signature, fmt.Errorf("confirmation timeout exceeded: %v", confirmCtx.Err())
+-----------				case <-ticker.C:
+-----------					status, err := r.getTransactionStatus(ctx, signature)
+-----------					if err != nil {
+-----------						logger.Debug("Failed to get transaction status",
+-----------							zap.Error(err),
+-----------							zap.String("signature", signature.String()))
+-----------						continue
+-----------					}
+-----------
+-----------					// Проверяем ошибки в транзакции
+-----------					if status.Error != "" {
+-----------						return signature, fmt.Errorf("transaction failed: %s", status.Error)
+-----------					}
+-----------
+-----------					// Проверяем подтверждение
+-----------					if status.Confirmations >= 1 || status.Status == "finalized" {
+-----------						logger.Debug("Transaction confirmed",
+-----------							zap.String("signature", signature.String()),
+-----------							zap.String("status", status.Status),
+-----------							zap.Uint64("confirmations", status.Confirmations))
+-----------						return signature, nil
+-----------					}
+-----------
+-----------					logger.Debug("Waiting for confirmation",
+-----------						zap.String("signature", signature.String()),
+-----------						zap.String("status", status.Status),
+-----------						zap.Uint64("confirmations", status.Confirmations))
+-----------				}
+-----------			}
+-----------		}
+-----------	}
+-----------
+-----------	return solana.Signature{}, fmt.Errorf("failed after %d attempts: %w", maxRetries, lastErr)
+-----------}
+-----------
+-----------func (r *DEX) sendTransaction(
+-----------	ctx context.Context,
+-----------	wallet *wallet.Wallet,
+-----------	instructions []solana.Instruction,
+-----------) (solana.Signature, error) {
+-----------	recent, err := r.client.GetRecentBlockhash(ctx)
+-----------	if err != nil {
+-----------		return solana.Signature{}, fmt.Errorf("failed to get recent blockhash: %w", err)
+-----------	}
+-----------
+-----------	tx, err := solana.NewTransaction(
+-----------		instructions,
+-----------		recent,
+-----------		solana.TransactionPayer(wallet.PublicKey),
+-----------	)
+-----------	if err != nil {
+-----------		return solana.Signature{}, fmt.Errorf("failed to create transaction: %w", err)
+-----------	}
+-----------
+-----------	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+-----------		if key.Equals(wallet.PublicKey) {
+-----------			return &wallet.PrivateKey
+-----------		}
+-----------		return nil
+-----------	})
+-----------	if err != nil {
+-----------		return solana.Signature{}, fmt.Errorf("failed to sign transaction: %w", err)
+-----------	}
+-----------
+-----------	opts := blockchain.TransactionOptions{
+-----------		SkipPreflight:       true,
+-----------		PreflightCommitment: solanarpc.CommitmentProcessed,
+-----------	}
+-----------
+-----------	signature, err := r.client.SendTransactionWithOpts(ctx, tx, opts)
+-----------	if err != nil {
+-----------		return solana.Signature{}, fmt.Errorf("failed to send transaction: %w", err)
+-----------	}
+-----------
+-----------	return signature, nil
+-----------}
+-----------
+-----------func validateDEXParams(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) error {
+-----------	switch {
+-----------	case client == nil:
+-----------		return fmt.Errorf("client cannot be nil")
+-----------	case logger == nil:
+-----------		return fmt.Errorf("logger cannot be nil")
+-----------	case poolInfo == nil:
+-----------		return fmt.Errorf("pool info cannot be nil")
+-----------	}
+-----------	return nil
+-----------}
+-----------
+-----------func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, solana.PublicKey, error) {
+-----------	sourceMint, err := solana.PublicKeyFromBase58(sourceToken)
+-----------	if err != nil {
+-----------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("invalid source token: %w", err)
+-----------	}
+-----------
+-----------	targetMint, err := solana.PublicKeyFromBase58(targetToken)
+-----------	if err != nil {
+-----------		return solana.PublicKey{}, solana.PublicKey{}, fmt.Errorf("invalid target token: %w", err)
+-----------	}
+-----------
+-----------	return sourceMint, targetMint, nil
+-----------}
+-----------
+-----------// getExpectedOutput calculates the expected output for the swap
+-----------func (r *DEX) getExpectedOutput(
+-----------	ctx context.Context,
+-----------	amountIn uint64,
+-----------	sourceToken, targetToken solana.PublicKey,
+-----------	poolInfo *Pool,
+-----------	logger *zap.Logger,
+-----------) (float64, error) {
+-----------	// Get pool state
+-----------	poolState, err := r.getPoolState(ctx, poolInfo)
+-----------	if err != nil {
+-----------		return 0, fmt.Errorf("failed to get pool state: %w", err)
+-----------	}
+-----------
+-----------	// Get decimals for tokens
+-----------	sourceMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, sourceToken)
+-----------	if err != nil {
+-----------		return 0, fmt.Errorf("failed to get source token metadata: %w", err)
+-----------	}
+-----------
+-----------	targetMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, targetToken)
+-----------	if err != nil {
+-----------		return 0, fmt.Errorf("failed to get target token metadata: %w", err)
+-----------	}
+-----------
+-----------	// Calculate expected output
+-----------	expectedOut := r.calculateExpectedOutput(
+-----------		amountIn,
+-----------		int(sourceMetadata.Decimals),
+-----------		int(targetMetadata.Decimals),
+-----------		poolState,
+-----------	)
+-----------
+-----------	// Validate calculated price against market price
+-----------	marketPrice := 181.0 // Use current market price of SOL in USDC
+-----------	err = validateSwapAmount(expectedOut, marketPrice, amountIn,
+-----------		int(sourceMetadata.Decimals),
+-----------		int(targetMetadata.Decimals))
+-----------	if err != nil {
+-----------		return 0, fmt.Errorf("swap amount validation failed: %w", err)
+-----------	}
+-----------
+-----------	return expectedOut, nil
+-----------}
+-----------
+-----------// getPoolState gets the current state of the pool
+-----------// Скорректированные смещения для Raydium v4 пула
+-----------const (
+-----------	DISCRIMINATOR_SIZE = 8
+-----------	STATUS_SIZE        = 1
+-----------	NONCE_SIZE         = 1
+-----------	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 bytes
+-----------
+-----------	// Новые смещения (в байтах)
+-----------	baseVaultOffset    = BASE_SIZE + 96       // После discriminator + статуса + nonce + 3 pubkeys
+-----------	quoteVaultOffset   = baseVaultOffset + 40 // После base vault + доп. данные
+-----------	baseReserveOffset  = 178                  // Фиксированное смещение для базового резерва
+-----------	quoteReserveOffset = 186                  // Фиксированное смещение для quote резерва
+-----------)
+-----------
+-----------// Добавляем новые типы для работы с ценами
+-----------type PriceSource interface {
+-----------	GetCurrentPrice(ctx context.Context, base, quote solana.PublicKey) (float64, error)
+-----------}
+-----------
+-----------type PoolPriceValidator struct {
+-----------	priceSource  PriceSource
+-----------	maxDeviation float64
+-----------	logger       *zap.Logger
+-----------}
+-----------
+-----------func NewPoolPriceValidator(priceSource PriceSource, logger *zap.Logger) *PoolPriceValidator {
+-----------	return &PoolPriceValidator{
+-----------		priceSource:  priceSource,
+-----------		maxDeviation: 0.5, // 50% максимальное отклонение
+-----------		logger:       logger,
+-----------	}
+-----------}
+-----------
+-----------// Добавляем метод для обновления валидатора цен
+-----------func (r *DEX) SetPriceValidator(validator PriceValidator) {
+-----------	r.priceValidator = validator
+-----------}
+-----------
+-----------// internal/dex/raydium/raydium.go
+-----------
+-----------func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
+-----------	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
+-----------	if err != nil {
+-----------		return nil, fmt.Errorf("failed to get pool account: %w", err)
+-----------	}
+-----------
+-----------	if poolAccount == nil || poolAccount.Value == nil {
+-----------		return nil, fmt.Errorf("pool account not found")
+-----------	}
+-----------
+-----------	data := poolAccount.Value.Data.GetBinary()
+-----------
+-----------	r.logger.Debug("Full pool data",
+-----------		zap.Binary("data", data),
+-----------		zap.Int("length", len(data)))
+-----------
+-----------	if len(data) < quoteReserveOffset+8 {
+-----------		return nil, fmt.Errorf("invalid pool data length: got %d, need at least %d",
+-----------			len(data), quoteReserveOffset+8)
+-----------	}
+-----------
+-----------	// Читаем резервы
+-----------	baseReserve := binary.LittleEndian.Uint64(data[baseReserveOffset : baseReserveOffset+8])
+-----------	quoteReserve := binary.LittleEndian.Uint64(data[quoteReserveOffset : quoteReserveOffset+8])
+-----------
+-----------	r.logger.Debug("Raw reserves",
+-----------		zap.Uint64("base_reserve_raw", baseReserve),
+-----------		zap.Uint64("quote_reserve_raw", quoteReserve))
+-----------
+-----------	// Проверяем резервы
+-----------	if baseReserve == 0 || quoteReserve == 0 {
+-----------		return nil, fmt.Errorf("invalid pool reserves: base=%d, quote=%d",
+-----------			baseReserve, quoteReserve)
+-----------	}
+-----------
+-----------	// Нормализуем значения с учетом decimals
+-----------	solAmount := float64(baseReserve) / 1e9   // 9 decimals для SOL
+-----------	usdcAmount := float64(quoteReserve) / 1e6 // 6 decimals для USDC
+-----------
+-----------	poolPrice := usdcAmount / solAmount
+-----------	r.logger.Debug("Pool price calculated",
+-----------		zap.Float64("pool_price", poolPrice),
+-----------		zap.Float64("sol_amount", solAmount),
+-----------		zap.Float64("usdc_amount", usdcAmount))
+-----------
+-----------	// Проверяем цену через валидатор
+-----------	if r.priceValidator != nil {
+-----------		if err := r.priceValidator.ValidatePrice(poolPrice); err != nil {
+-----------			return nil, fmt.Errorf("pool price validation failed: %w", err)
+-----------		}
+-----------	}
+-----------
+-----------	state := &PoolState{
+-----------		TokenAReserve: baseReserve,
+-----------		TokenBReserve: quoteReserve,
+-----------		SwapFee:       0.25,
+-----------		CurrentPrice:  poolPrice,
+-----------	}
+-----------
+-----------	// Сохраняем новое состояние
+-----------	r.UpdatePoolState(state)
+-----------
+-----------	return state, nil
+-----------}
+-----------
+-----------// Добавляем вспомогательные методы для работы с ценами
+-----------// GetCurrentPoolPrice возвращает текущую цену пула
+-----------func (r *DEX) GetCurrentPoolPrice() float64 {
+-----------	if state := r.lastPoolState.Load().(*PoolState); state != nil {
+-----------		return state.CurrentPrice
+-----------	}
+-----------	return 0
+-----------}
+-----------
+-----------func (r *DEX) SetMaxPriceDeviation(deviation float64) {
+-----------	if r.priceValidator != nil {
+-----------		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
+-----------			basicValidator.maxDeviation = deviation
+-----------		}
+-----------	}
+-----------}
+-----------
+-----------func (r *DEX) UpdateBasePrice(price float64) {
+-----------	if r.priceValidator != nil {
+-----------		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
+-----------			basicValidator.basePrice = price
+-----------		}
+-----------	}
+-----------}
+-----------
+-----------// calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
+-----------// calculateExpectedOutput computes the expected output based on the pool state
+-----------func (r *DEX) calculateExpectedOutput(
+-----------	amountIn uint64,
+-----------	sourceDec,
+-----------	targetDec int,
+-----------	state *PoolState,
+-----------) float64 {
+-----------	logger := r.logger.With(
+-----------		zap.Uint64("amount_in_raw", amountIn),
+-----------		zap.Int("source_decimals", sourceDec),
+-----------		zap.Int("target_decimals", targetDec),
+-----------	)
+-----------
+-----------	// Normalize input amount
+-----------	amountInF := float64(amountIn) / math.Pow10(sourceDec)
+-----------	logger.Debug("Normalized input amount",
+-----------		zap.Float64("amount_in_normalized", amountInF))
+-----------
+-----------	// Get normalized reserves
+-----------	reserveIn := float64(state.TokenAReserve) / math.Pow10(sourceDec)
+-----------	reserveOut := float64(state.TokenBReserve) / math.Pow10(targetDec)
+-----------	logger.Debug("Normalized reserves",
+-----------		zap.Float64("reserve_in_normalized", reserveIn),
+-----------		zap.Float64("reserve_out_normalized", reserveOut))
+-----------
+-----------	// Calculate output using constant product formula
+-----------	amountOut := (amountInF * reserveOut * (1 - state.SwapFee/100)) / (reserveIn + amountInF*(1-state.SwapFee/100))
+-----------	logger.Debug("Calculated amount out",
+-----------		zap.Float64("amount_out", amountOut))
+-----------
+-----------	// Convert back to lamports
+-----------	finalOutput := amountOut * math.Pow10(targetDec)
+-----------	logger.Debug("Final output in lamports",
+-----------		zap.Float64("final_output_lamports", finalOutput))
+-----------
+-----------	return finalOutput
+-----------}
+-----------
+-----------func validateSwapAmount(expectedOut float64, currentPrice float64, amountIn uint64, sourceDec, targetDec int) error {
+-----------	// Normalize values
+-----------	realAmountIn := float64(amountIn) / math.Pow10(sourceDec)
+-----------	realExpectedOut := expectedOut / math.Pow10(targetDec)
+-----------
+-----------	// Calculate the swap price
+-----------	calculatedPrice := realExpectedOut / realAmountIn
+-----------
+-----------	// Calculate price difference percentage
+-----------	priceDiff := math.Abs(calculatedPrice-currentPrice) / currentPrice
+-----------
+-----------	// Allow up to 20% difference
+-----------	if priceDiff > 0.2 {
+-----------		return fmt.Errorf("calculated price differs too much from current price: %.2f vs %.2f",
+-----------			calculatedPrice, currentPrice)
+-----------	}
+-----------
+-----------	return nil
+-----------}
+-----------
+-----------// GetAmountOutQuote получает котировку для свапа
+-----------func (r *DEX) GetAmountOutQuote(
+-----------	ctx context.Context,
+-----------	amountIn uint64,
+-----------	sourceToken, targetToken solana.PublicKey,
+-----------) (float64, error) {
+-----------	// Создаем временный пул для получения котировки
+-----------	poolInfo := r.poolInfo
+-----------	if poolInfo == nil {
+-----------		return 0, fmt.Errorf("pool info not configured")
+-----------	}
+-----------
+-----------	// Получаем ожидаемый выход
+-----------	expectedOut, err := r.getExpectedOutput(ctx, amountIn, sourceToken, targetToken, poolInfo, r.logger)
+-----------	if err != nil {
+-----------		return 0, fmt.Errorf("failed to get expected output: %w", err)
+-----------	}
+-----------
+-----------	return expectedOut, nil
+-----------}
+-----------
+-----------// TransactionStatus представляет статус транзакции
+-----------type TransactionStatus struct {
+-----------	Signature     string    `json:"signature"`
+-----------	Status        string    `json:"status"`
+-----------	Confirmations uint64    `json:"confirmations"`
+-----------	Slot          uint64    `json:"slot"`
+-----------	Error         string    `json:"error,omitempty"`
+-----------	Timestamp     time.Time `json:"timestamp"` // Время проверки статуса
+-----------}
+-----------
+-----------// getTransactionStatus получает полный статус транзакции
+-----------func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signature) (*TransactionStatus, error) {
+-----------	result, err := r.client.GetSignatureStatuses(ctx, signature)
+-----------	if err != nil {
+-----------		return nil, fmt.Errorf("failed to get signature status: %w", err)
+-----------	}
+-----------
+-----------	now := time.Now()
+-----------	status := &TransactionStatus{
+-----------		Signature: signature.String(),
+-----------		Status:    "pending",
+-----------		Timestamp: now,
+-----------	}
+-----------
+-----------	if len(result.Value) == 0 || result.Value[0] == nil {
+-----------		return status, nil
+-----------	}
+-----------
+-----------	statusInfo := result.Value[0]
+-----------	if statusInfo.Err != nil {
+-----------		status.Error = fmt.Sprintf("%v", statusInfo.Err)
+-----------		status.Status = "failed"
+-----------		return status, nil
+-----------	}
+-----------
+-----------	if statusInfo.Confirmations != nil {
+-----------		status.Confirmations = *statusInfo.Confirmations
+-----------	}
+-----------
+-----------	if statusInfo.Slot > 0 {
+-----------		status.Slot = statusInfo.Slot
+-----------	}
+-----------
+-----------	switch statusInfo.ConfirmationStatus {
+-----------	case solanarpc.ConfirmationStatusFinalized:
+-----------		status.Status = "finalized"
+-----------	case solanarpc.ConfirmationStatusConfirmed:
+-----------		status.Status = "confirmed"
+-----------	}
+-----------
+-----------	return status, nil
+-----------}
+-----------
+-----------// GetSignatureStatus получает детальный статус подписи
+-----------func (r *DEX) GetSignatureStatus(ctx context.Context, signature solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
+-----------	return r.client.GetSignatureStatuses(ctx, signature)
+-----------}
+----------diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
+----------deleted file mode 100644
+----------index 61d78a0..0000000
+------------- a/internal/dex/raydium/transaction.go
+----------+++ /dev/null
+----------@@ -1,264 +0,0 @@
+-----------// internal/dex/raydium/transaction.go
+-----------
+-----------package raydium
+-----------
+-----------import (
+-----------	"context"
+-----------	"encoding/binary"
+-----------	"fmt"
+-----------	"math"
+-----------
+-----------	"github.com/gagliardetto/solana-go"
+-----------	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
+-----------	"github.com/rovshanmuradov/solana-bot/internal/types"
+-----------	"github.com/rovshanmuradov/solana-bot/internal/wallet"
+-----------	"go.uber.org/zap"
+-----------)
+-----------
+-----------// Serialize serializes the swap instruction data
+-----------func (s *SwapInstructionData) Serialize() ([]byte, error) {
+-----------	if err := s.Validate(); err != nil {
+-----------		return nil, err
+-----------	}
+-----------
+-----------	data := make([]byte, 17)
+-----------
+-----------	// Write instruction discriminator
+-----------	data[0] = s.Instruction
+-----------
+-----------	// Write amount in
+-----------	binary.LittleEndian.PutUint64(data[1:9], s.AmountIn)
+-----------
+-----------	// Write minimum out
+-----------	binary.LittleEndian.PutUint64(data[9:17], s.MinAmountOut)
+-----------
+-----------	return data, nil
+-----------}
+-----------
+-----------// Validate validates the swap instruction data
+-----------func (s *SwapInstructionData) Validate() error {
+-----------	if s.Instruction != 1 {
+-----------		return fmt.Errorf("invalid instruction type: expected 1, got %d", s.Instruction)
+-----------	}
+-----------
+-----------	if s.AmountIn == 0 {
+-----------		return fmt.Errorf("amount_in cannot be zero")
+-----------	}
+-----------
+-----------	// MinimumOut can be zero, but log a warning
+-----------	if s.MinAmountOut == 0 {
+-----------		// You may want to log a warning here
+-----------	}
+-----------
+-----------	return nil
+-----------}
+-----------
+-----------// CreateSwapInstruction creates a swap instruction for Raydium
+-----------func (r *DEX) CreateSwapInstruction(
+-----------	userWallet solana.PublicKey,
+-----------	userSourceTokenAccount solana.PublicKey,
+-----------	userDestinationTokenAccount solana.PublicKey,
+-----------	amountIn uint64,
+-----------	minAmountOut uint64,
+-----------	logger *zap.Logger,
+-----------	poolInfo *Pool,
+-----------) (solana.Instruction, error) {
+-----------	logger.Debug("Creating swap instruction",
+-----------		zap.String("user_wallet", userWallet.String()),
+-----------		zap.String("source_account", userSourceTokenAccount.String()),
+-----------		zap.String("destination_account", userDestinationTokenAccount.String()),
 -----------		zap.Uint64("amount_in", amountIn),
+-----------		zap.Uint64("min_amount_out", minAmountOut))
+-----------
+-----------	if poolInfo == nil {
+-----------		return nil, fmt.Errorf("pool info is nil")
+-----------	}
+-----------
+-----------	// Validate and parse all necessary public keys
+-----------	ammProgramID, err := validatePublicKey(poolInfo.AmmProgramID)
+-----------	if err != nil {
+-----------		logger.Error("Invalid AmmProgramID", zap.Error(err))
+-----------		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
+-----------	}
+-----------
+-----------	// Map of required accounts with their names
+-----------	requiredAccounts := map[string]string{
+-----------		"AmmID":                poolInfo.AmmID,
+-----------		"AmmAuthority":         poolInfo.AmmAuthority,
+-----------		"AmmOpenOrders":        poolInfo.AmmOpenOrders,
+-----------		"AmmTargetOrders":      poolInfo.AmmTargetOrders,
+-----------		"PoolCoinTokenAccount": poolInfo.PoolCoinTokenAccount,
+-----------		"PoolPcTokenAccount":   poolInfo.PoolPcTokenAccount,
+-----------		"SerumProgramID":       poolInfo.SerumProgramID,
+-----------		"SerumMarket":          poolInfo.SerumMarket,
+-----------		"SerumBids":            poolInfo.SerumBids,
+-----------		"SerumAsks":            poolInfo.SerumAsks,
+-----------		"SerumEventQueue":      poolInfo.SerumEventQueue,
+-----------		"SerumCoinVault":       poolInfo.SerumCoinVaultAccount,
+-----------		"SerumPcVault":         poolInfo.SerumPcVaultAccount,
+-----------		"SerumVaultSigner":     poolInfo.SerumVaultSigner,
+-----------	}
+-----------
+-----------	accounts := make(map[string]solana.PublicKey)
+-----------	for name, address := range requiredAccounts {
+-----------		pubKey, err := validatePublicKey(address)
+-----------		if err != nil {
+-----------			logger.Error(fmt.Sprintf("Invalid %s", name),
+-----------				zap.String("address", address),
+-----------				zap.Error(err))
+-----------			return nil, fmt.Errorf("invalid %s: %w", name, err)
+-----------		}
+-----------		accounts[name] = pubKey
+-----------	}
+-----------
+-----------	// Create the account meta slice in the correct order
+-----------	metas := solana.AccountMetaSlice{
+-----------		// User accounts
+-----------		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
+-----------		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
+-----------		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
+-----------		// Pool accounts
+-----------		{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
+-----------		{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
+-----------		// Serum accounts
+-----------		{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
+-----------		{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
+-----------		{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
+-----------		// System accounts
+-----------		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
+-----------		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
+-----------		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
+-----------	}
+-----------
+-----------	// Create swap instruction data
+-----------	instructionData := &SwapInstructionData{
+-----------		Instruction:  poolInfo.RaydiumSwapInstructionCode,
+-----------		AmountIn:     amountIn,
+-----------		MinAmountOut: minAmountOut,
+-----------	}
+-----------
+-----------	// Serialize instruction data
+-----------	data, err := instructionData.Serialize()
+-----------	if err != nil {
+-----------		logger.Error("Failed to serialize instruction data",
+-----------			zap.Error(err),
+-----------			zap.Uint8("instruction", instructionData.Instruction),
+-----------			zap.Uint64("amount_in", instructionData.AmountIn),
+-----------			zap.Uint64("min_amount_out", instructionData.MinAmountOut))
+-----------		return nil, fmt.Errorf("failed to serialize instruction data: %w", err)
+-----------	}
+-----------
+-----------	// Create the instruction
+-----------	instruction := solana.NewInstruction(ammProgramID, metas, data)
+-----------
+-----------	logger.Debug("Created swap instruction",
+-----------		zap.Int("num_accounts", len(metas)),
+-----------		zap.Int("data_len", len(data)))
+-----------
+-----------	return instruction, nil
+-----------}
+-----------
+-----------// PrepareAndSendTransaction prepares and sends the swap transaction
+-----------func (r *DEX) PrepareAndSendTransaction(
+-----------	ctx context.Context,
+-----------	task *types.Task,
+-----------	userWallet *wallet.Wallet,
+-----------	logger *zap.Logger,
+-----------	swapInstruction solana.Instruction,
+-----------) error {
+-----------	recentBlockhash, err := r.client.GetRecentBlockhash(ctx)
+-----------	if err != nil {
+-----------		logger.Error("Failed to get recent blockhash", zap.Error(err))
+-----------		return fmt.Errorf("failed to get recent blockhash: %w", err)
+-----------	}
+-----------
+-----------	// Create compute budget instruction if needed
+-----------	computeBudgetInst := computebudget.NewSetComputeUnitPriceInstruction(
+-----------		uint64(task.PriorityFee * 1e6), // Convert SOL to micro-lamports
+-----------	).Build()
+-----------
+-----------	// Combine all instructions
+-----------	instructions := []solana.Instruction{
+-----------		computeBudgetInst,
+-----------		swapInstruction,
+-----------	}
+-----------
+-----------	// Create the transaction
+-----------	tx, err := solana.NewTransaction(
+-----------		instructions,
+-----------		recentBlockhash,
+-----------		solana.TransactionPayer(userWallet.PublicKey),
 -----------	)
+-----------	if err != nil {
+-----------		logger.Error("Failed to create transaction", zap.Error(err))
+-----------		return fmt.Errorf("failed to create transaction: %w", err)
+-----------	}
 -----------
------------	// Получаем состояние пула
-----------+	// Get pool state
----------- 	poolState, err := r.getPoolState(ctx, poolInfo)
----------- 	if err != nil {
----------- 		return 0, fmt.Errorf("failed to get pool state: %w", err)
----------- 	}
----------- 
------------	logger.Debug("Pool state retrieved",
------------		zap.Uint64("token_a_reserve", poolState.TokenAReserve),
------------		zap.Uint64("token_b_reserve", poolState.TokenBReserve),
------------		zap.Float64("swap_fee", poolState.SwapFee))
-----------+	// Get decimals for tokens
-----------+	sourceMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, sourceToken)
-----------+	if err != nil {
-----------+		return 0, fmt.Errorf("failed to get source token metadata: %w", err)
-----------+	}
----------- 
------------	// Вычисляем ожидаемый выход с учетом всех факторов
------------	expectedOut := r.calculateExpectedOutput(amountIn, poolState)
-----------+	targetMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, targetToken)
-----------+	if err != nil {
-----------+		return 0, fmt.Errorf("failed to get target token metadata: %w", err)
-----------+	}
----------- 
------------	logger.Debug("Expected output calculated",
------------		zap.Float64("expected_out", expectedOut))
-----------+	// Calculate expected output
-----------+	expectedOut := r.calculateExpectedOutput(
-----------+		amountIn,
-----------+		int(sourceMetadata.Decimals),
-----------+		int(targetMetadata.Decimals),
-----------+		poolState,
-----------+	)
-----------+
-----------+	// Validate calculated price against market price
-----------+	marketPrice := 181.0 // Use current market price of SOL in USDC
-----------+	err = validateSwapAmount(expectedOut, marketPrice, amountIn,
-----------+		int(sourceMetadata.Decimals),
-----------+		int(targetMetadata.Decimals))
-----------+	if err != nil {
-----------+		return 0, fmt.Errorf("swap amount validation failed: %w", err)
-----------+	}
----------- 
----------- 	return expectedOut, nil
----------- }
----------- 
------------// Определяем смещения для чтения данных пула Raydium
-----------+// getPoolState gets the current state of the pool
-----------+// Скорректированные смещения для Raydium v4 пула
----------- const (
------------	// Смещения в байтах для различных полей в структуре пула
----------- 	DISCRIMINATOR_SIZE = 8
----------- 	STATUS_SIZE        = 1
----------- 	NONCE_SIZE         = 1
------------	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 байт
-----------+	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 bytes
----------- 
------------	// Смещения для резервов
------------	baseVaultOffset    = BASE_SIZE + 32 + 32 + 32 // После discriminator, status, nonce и трех pubkeys
------------	quoteVaultOffset   = baseVaultOffset + 32
------------	baseReserveOffset  = quoteVaultOffset + 32 + 8 // +8 для uint64
------------	quoteReserveOffset = baseReserveOffset + 8
-----------+	// Новые смещения (в байтах)
-----------+	baseVaultOffset    = BASE_SIZE + 96       // После discriminator + статуса + nonce + 3 pubkeys
-----------+	quoteVaultOffset   = baseVaultOffset + 40 // После base vault + доп. данные
-----------+	baseReserveOffset  = 178                  // Фиксированное смещение для базового резерва
-----------+	quoteReserveOffset = 186                  // Фиксированное смещение для quote резерва
----------- )
+-----------	// Sign the transaction
+-----------	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+-----------		if key.Equals(userWallet.PublicKey) {
+-----------			return &userWallet.PrivateKey
+-----------		}
+-----------		return nil
+-----------	})
+-----------	if err != nil {
+-----------		logger.Error("Failed to sign transaction", zap.Error(err))
+-----------		return fmt.Errorf("failed to sign transaction: %w", err)
+-----------	}
+-----------
+-----------	// Send the transaction
+-----------	signature, err := r.client.SendTransaction(ctx, tx)
+-----------	if err != nil {
+-----------		logger.Error("Failed to send transaction", zap.Error(err))
+-----------		return fmt.Errorf("failed to send transaction: %w", err)
+-----------	}
+-----------
+-----------	logger.Info("Transaction sent successfully",
+-----------		zap.String("signature", signature.String()),
+-----------		zap.Float64("priority_fee_sol", task.PriorityFee))
+-----------
+-----------	return nil
+-----------}
+-----------
+-----------// validatePublicKey checks if a public key string is valid
+-----------func validatePublicKey(key string) (solana.PublicKey, error) {
+-----------	if key == "" {
+-----------		return solana.PublicKey{}, fmt.Errorf("empty public key")
+-----------	}
+-----------
+-----------	pubKey, err := solana.PublicKeyFromBase58(key)
+-----------	if err != nil {
+-----------		return solana.PublicKey{}, fmt.Errorf("invalid public key %s: %w", key, err)
+-----------	}
+-----------
+-----------	return pubKey, nil
+-----------}
+-----------
+-----------// Helper function to calculate minimum output considering slippage
+-----------func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
+-----------	if expectedOut <= 0 {
+-----------		return 1 // Minimum safe value
+-----------	}
+-----------
+-----------	// Consider slippage
+-----------	minOut := expectedOut * (1 - slippagePercent/100)
+-----------
+-----------	// Convert to uint64 and check for minimum value
+-----------	result := uint64(math.Floor(minOut))
+-----------	if result == 0 {
+-----------		return 1
+-----------	}
+-----------
+-----------	return result
+-----------}
+-----------
+-----------// You may want to include other helper functions or adjust existing ones as needed
+----------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
+----------index 7db11c6..ef19a7a 100644
+------------- a/internal/dex/raydium/types.go
+----------+++ b/internal/dex/raydium/types.go
+----------@@ -1,103 +1,152 @@
+---------- // internal/dex/raydium/types.go
+-----------
+----------+// Package raydium реализует интеграцию с Raydium DEX на Solana
+---------- package raydium
 ---------- 
------------// getPoolState получает текущее состояние пула
-----------+// Добавляем новые типы для работы с ценами
-----------+type PriceSource interface {
-----------+	GetCurrentPrice(ctx context.Context, base, quote solana.PublicKey) (float64, error)
-----------+}
-----------+
-----------+type PoolPriceValidator struct {
-----------+	priceSource  PriceSource
-----------+	maxDeviation float64
-----------+	logger       *zap.Logger
-----------+}
-----------+
-----------+func NewPoolPriceValidator(priceSource PriceSource, logger *zap.Logger) *PoolPriceValidator {
-----------+	return &PoolPriceValidator{
-----------+		priceSource:  priceSource,
-----------+		maxDeviation: 0.5, // 50% максимальное отклонение
-----------+		logger:       logger,
-----------+	}
-----------+}
-----------+
-----------+// Добавляем метод для обновления валидатора цен
-----------+func (r *DEX) SetPriceValidator(validator PriceValidator) {
-----------+	r.priceValidator = validator
-----------+}
-----------+
-----------+// internal/dex/raydium/raydium.go
+---------- import (
+-----------	"sync"
+-----------	"sync/atomic"
+----------+	"context"
+----------+	"fmt"
 ----------+
----------- func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
----------- 	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
----------- 	if err != nil {
-----------@@ -621,7 +710,6 @@ func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, err
----------- 
----------- 	data := poolAccount.Value.Data.GetBinary()
----------- 
------------	// Debug полных данных
----------- 	r.logger.Debug("Full pool data",
----------- 		zap.Binary("data", data),
----------- 		zap.Int("length", len(data)))
-----------@@ -635,41 +723,128 @@ func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, err
----------- 	baseReserve := binary.LittleEndian.Uint64(data[baseReserveOffset : baseReserveOffset+8])
----------- 	quoteReserve := binary.LittleEndian.Uint64(data[quoteReserveOffset : quoteReserveOffset+8])
----------- 
------------	r.logger.Debug("Pool reserves offsets",
------------		zap.Int("base_offset", baseReserveOffset),
------------		zap.Int("quote_offset", quoteReserveOffset))
-----------+	r.logger.Debug("Raw reserves",
-----------+		zap.Uint64("base_reserve_raw", baseReserve),
-----------+		zap.Uint64("quote_reserve_raw", quoteReserve))
+----------+	"github.com/gagliardetto/solana-go"
+----------+)
 ---------- 
------------	r.logger.Debug("Pool reserves raw bytes",
------------		zap.Binary("base_bytes", data[baseReserveOffset:baseReserveOffset+8]),
------------		zap.Binary("quote_bytes", data[quoteReserveOffset:quoteReserveOffset+8]))
-----------+	// Проверяем резервы
-----------+	if baseReserve == 0 || quoteReserve == 0 {
-----------+		return nil, fmt.Errorf("invalid pool reserves: base=%d, quote=%d",
-----------+			baseReserve, quoteReserve)
-----------+	}
+-----------	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+-----------	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
+-----------	"go.uber.org/zap"
+----------+// Layout константы для правильного чтения данных из аккаунта пула
+----------+const (
+----------+	// Базовые смещения
+----------+	LayoutDiscriminator = 8
+----------+	LayoutStatus        = 1
+----------+	LayoutNonce         = 1
+----------+	LayoutBaseSize      = LayoutDiscriminator + LayoutStatus + LayoutNonce // 10 байт
 ----------+
-----------+	// Нормализуем значения с учетом decimals
-----------+	solAmount := float64(baseReserve) / 1e9   // 9 decimals для SOL
-----------+	usdcAmount := float64(quoteReserve) / 1e6 // 6 decimals для USDC
+----------+	// Смещения для резервов и других данных пула
+----------+	LayoutBaseVaultOffset    = LayoutBaseSize + 32 + 32 + 32 // После discriminator, status, nonce и трех pubkeys
+----------+	LayoutQuoteVaultOffset   = LayoutBaseVaultOffset + 32
+----------+	LayoutBaseReserveOffset  = LayoutQuoteVaultOffset + 32 + 8
+----------+	LayoutQuoteReserveOffset = LayoutBaseReserveOffset + 8
 ----------+
-----------+	poolPrice := usdcAmount / solAmount
-----------+	r.logger.Debug("Pool price calculated",
-----------+		zap.Float64("pool_price", poolPrice),
-----------+		zap.Float64("sol_amount", solAmount),
-----------+		zap.Float64("usdc_amount", usdcAmount))
-----------+
-----------+	// Проверяем цену через валидатор
-----------+	if r.priceValidator != nil {
-----------+		if err := r.priceValidator.ValidatePrice(poolPrice); err != nil {
-----------+			return nil, fmt.Errorf("pool price validation failed: %w", err)
-----------+		}
-----------+	}
+----------+	// Константы протокола
+----------+	DefaultSwapFeePercent = 0.25
+----------+	MinimumAmountOut      = 1
+---------- )
 ---------- 
------------	return &PoolState{
-----------+	state := &PoolState{
----------- 		TokenAReserve: baseReserve,
----------- 		TokenBReserve: quoteReserve,
----------- 		SwapFee:       0.25,
------------	}, nil
-----------+		CurrentPrice:  poolPrice,
-----------+	}
-----------+
-----------+	// Сохраняем новое состояние
-----------+	r.UpdatePoolState(state)
+-----------// RaydiumPoolInfo содержит информацию о пуле Raydium
+-----------type Pool struct {
+-----------	AmmProgramID               string
+-----------	AmmID                      string
+-----------	AmmAuthority               string
+-----------	AmmOpenOrders              string
+-----------	AmmTargetOrders            string
+-----------	PoolCoinTokenAccount       string
+-----------	PoolPcTokenAccount         string
+-----------	SerumProgramID             string
+-----------	SerumMarket                string
+-----------	SerumBids                  string
+-----------	SerumAsks                  string
+-----------	SerumEventQueue            string
+-----------	SerumCoinVaultAccount      string
+-----------	SerumPcVaultAccount        string
+-----------	SerumVaultSigner           string
+-----------	RaydiumSwapInstructionCode uint8
+----------+// RaydiumPool представляет собой конфигурацию пула ликвидности Raydium
+----------+type RaydiumPool struct {
+----------+	// Программы
+----------+	AmmProgramID   solana.PublicKey
+----------+	SerumProgramID solana.PublicKey
 ----------+
-----------+	return state, nil
-----------+}
+----------+	// AMM конфигурация
+----------+	ID            solana.PublicKey // ID пула
+----------+	Authority     solana.PublicKey
+----------+	OpenOrders    solana.PublicKey
+----------+	TargetOrders  solana.PublicKey
+----------+	BaseVault     solana.PublicKey
+----------+	QuoteVault    solana.PublicKey
+----------+	WithdrawQueue solana.PublicKey
+----------+	LPVault       solana.PublicKey
 ----------+
-----------+// Добавляем вспомогательные методы для работы с ценами
-----------+// GetCurrentPoolPrice возвращает текущую цену пула
-----------+func (r *DEX) GetCurrentPoolPrice() float64 {
-----------+	if state := r.lastPoolState.Load().(*PoolState); state != nil {
-----------+		return state.CurrentPrice
-----------+	}
-----------+	return 0
-----------+}
+----------+	// Токены и минты
+----------+	BaseMint      solana.PublicKey
+----------+	QuoteMint     solana.PublicKey
+----------+	LPMint        solana.PublicKey
+----------+	BaseDecimals  uint8
+----------+	QuoteDecimals uint8
+----------+	LPDecimals    uint8
 ----------+
-----------+func (r *DEX) SetMaxPriceDeviation(deviation float64) {
-----------+	if r.priceValidator != nil {
-----------+		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
-----------+			basicValidator.maxDeviation = deviation
-----------+		}
-----------+	}
-----------+}
+----------+	// Serum Market
+----------+	MarketID         solana.PublicKey
+----------+	MarketProgramID  solana.PublicKey
+----------+	MarketAuthority  solana.PublicKey
+----------+	MarketBaseVault  solana.PublicKey
+----------+	MarketQuoteVault solana.PublicKey
+----------+	MarketBids       solana.PublicKey
+----------+	MarketAsks       solana.PublicKey
+----------+	MarketEventQueue solana.PublicKey
+----------+	MarketVersion    uint8
+----------+	LookupTableID    solana.PublicKey
 ----------+
-----------+func (r *DEX) UpdateBasePrice(price float64) {
-----------+	if r.priceValidator != nil {
-----------+		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
-----------+			basicValidator.basePrice = price
-----------+		}
-----------+	}
+----------+	// Версионирование и инструкции
+----------+	Version              uint8
+----------+	SwapInstructionIndex uint8
+----------+	DefaultMinimumOutBps uint16 // базовых пунктов (1 bps = 0.01%)
+----------+	DefaultFeeBps        uint16 // комиссия пула в базовых пунктах
 ---------- }
----------- 
----------- // calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
------------func (r *DEX) calculateExpectedOutput(amountIn uint64, state *PoolState) float64 {
------------	// Конвертируем все в float64 для точных вычислений
------------	amountInF := float64(amountIn)
------------	reserveInF := float64(state.TokenAReserve)
------------	reserveOutF := float64(state.TokenBReserve)
-----------+// calculateExpectedOutput computes the expected output based on the pool state
-----------+func (r *DEX) calculateExpectedOutput(
-----------+	amountIn uint64,
-----------+	sourceDec,
-----------+	targetDec int,
-----------+	state *PoolState,
-----------+) float64 {
-----------+	logger := r.logger.With(
-----------+		zap.Uint64("amount_in_raw", amountIn),
-----------+		zap.Int("source_decimals", sourceDec),
-----------+		zap.Int("target_decimals", targetDec),
-----------+	)
-----------+
-----------+	// Normalize input amount
-----------+	amountInF := float64(amountIn) / math.Pow10(sourceDec)
-----------+	logger.Debug("Normalized input amount",
-----------+		zap.Float64("amount_in_normalized", amountInF))
 ----------+
-----------+	// Get normalized reserves
-----------+	reserveIn := float64(state.TokenAReserve) / math.Pow10(sourceDec)
-----------+	reserveOut := float64(state.TokenBReserve) / math.Pow10(targetDec)
-----------+	logger.Debug("Normalized reserves",
-----------+		zap.Float64("reserve_in_normalized", reserveIn),
-----------+		zap.Float64("reserve_out_normalized", reserveOut))
-----------+
-----------+	// Calculate output using constant product formula
-----------+	amountOut := (amountInF * reserveOut * (1 - state.SwapFee/100)) / (reserveIn + amountInF*(1-state.SwapFee/100))
-----------+	logger.Debug("Calculated amount out",
-----------+		zap.Float64("amount_out", amountOut))
-----------+
-----------+	// Convert back to lamports
-----------+	finalOutput := amountOut * math.Pow10(targetDec)
-----------+	logger.Debug("Final output in lamports",
-----------+		zap.Float64("final_output_lamports", finalOutput))
-----------+
-----------+	return finalOutput
-----------+}
----------- 
------------	// Учитываем комиссию (0.25%)
------------	amountInWithFee := amountInF * (1 - state.SwapFee/100)
-----------+func validateSwapAmount(expectedOut float64, currentPrice float64, amountIn uint64, sourceDec, targetDec int) error {
-----------+	// Normalize values
-----------+	realAmountIn := float64(amountIn) / math.Pow10(sourceDec)
-----------+	realExpectedOut := expectedOut / math.Pow10(targetDec)
----------- 
------------	// Используем формулу Raydium: dy = y * dx / (x + dx)
------------	// где dx - входная сумма с учетом комиссии
------------	// x, y - резервы токенов
------------	numerator := reserveOutF * amountInWithFee
------------	denominator := reserveInF + amountInWithFee
-----------+	// Calculate the swap price
-----------+	calculatedPrice := realExpectedOut / realAmountIn
+----------+// PoolState содержит динамическое состояние пула
+---------- type PoolState struct {
+-----------	TokenAReserve uint64
+-----------	TokenBReserve uint64
+-----------	SwapFee       float64 // в процентах
+-----------	CurrentPrice  float64 // текущая цена пула
+----------+	BaseReserve        uint64
+----------+	QuoteReserve       uint64
+----------+	SwapFeeNumerator   uint64
+----------+	SwapFeeDenominator uint64
+----------+	Status             uint8
+---------- }
 ---------- 
------------	expectedOut := numerator / denominator
-----------+	// Calculate price difference percentage
-----------+	priceDiff := math.Abs(calculatedPrice-currentPrice) / currentPrice
+-----------// SwapInstructionData представляет данные инструкции свапа
+-----------type SwapInstructionData struct {
+-----------	Instruction  uint8  // Тип инструкции
+-----------	AmountIn     uint64 // Входящая сумма
+-----------	MinAmountOut uint64 // Минимальная исходящая сумма
+-----------}
+-----------type DEX struct {
+-----------	client         blockchain.Client
+-----------	logger         *zap.Logger
+-----------	poolInfo       *Pool
+-----------	slippage       float64
+-----------	tokenCache     *solbc.TokenMetadataCache
+-----------	priceValidator PriceValidator
+-----------	lastPoolState  atomic.Value // Используем atomic.Value для потокобезопасного доступа
+-----------	stateMutex     sync.RWMutex // Мьютекс для дополнительной синхронизации при необходимости
+-----------}
+----------+// SwapSide определяет направление свапа
+----------+type SwapSide uint8
 ---------- 
------------	// Применяем дополнительный запас надежности 0.5%
------------	return expectedOut * 0.995
-----------+	// Allow up to 20% difference
-----------+	if priceDiff > 0.2 {
-----------+		return fmt.Errorf("calculated price differs too much from current price: %.2f vs %.2f",
-----------+			calculatedPrice, currentPrice)
-----------+	}
-----------+
-----------+	return nil
----------- }
+-----------// setLastPoolState безопасно обновляет состояние пула
+-----------func (r *DEX) setLastPoolState(state *PoolState) {
+-----------	r.lastPoolState.Store(state)
+-----------}
+----------+const (
+----------+	SwapSideIn SwapSide = iota
+----------+	SwapSideOut
+----------+)
 ---------- 
----------- // GetAmountOutQuote получает котировку для свапа
-----------@@ -750,5 +925,3 @@ func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signatu
----------- func (r *DEX) GetSignatureStatus(ctx context.Context, signature solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
----------- 	return r.client.GetSignatureStatuses(ctx, signature)
+-----------// getLastPoolState безопасно получает состояние пула
+-----------func (r *DEX) getLastPoolState() *PoolState {
+-----------	return r.lastPoolState.Load().(*PoolState)
+----------+// SwapParams содержит параметры для создания инструкций свапа
+----------+type SwapParams struct {
+----------+	UserWallet          solana.PublicKey
+----------+	AmountIn            uint64
+----------+	MinAmountOut        uint64
+----------+	ComputeUnits        uint32
+----------+	PriorityFeeLamports uint64
+----------+	LookupTableAccount  *solana.PublicKey // Опционально: адрес lookup таблицы
+----------+	WritableIndexes     []uint8           // Индексы для writable аккаунтов в lookup table
+----------+	ReadonlyIndexes     []uint8           // Индексы для readonly аккаунтов в lookup table
+----------+	Pool                *RaydiumPool      // Информация о пуле
 ---------- }
------------
------------// Удалены неиспользуемые функции getConfirmations и waitForTransactionConfirmation
-----------diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
-----------index 2063598..61d78a0 100644
-------------- a/internal/dex/raydium/transaction.go
-----------+++ b/internal/dex/raydium/transaction.go
-----------@@ -1,3 +1,5 @@
-----------+// internal/dex/raydium/transaction.go
-----------+
----------- package raydium
 ---------- 
----------- import (
-----------@@ -5,16 +7,15 @@ import (
----------- 	"encoding/binary"
----------- 	"fmt"
----------- 	"math"
------------	"testing"
+-----------// UpdatePoolState обновляет состояние пула с дополнительной синхронизацией
+-----------func (r *DEX) UpdatePoolState(state *PoolState) {
+-----------	r.stateMutex.Lock()
+-----------	defer r.stateMutex.Unlock()
+----------+// Client представляет интерфейс для взаимодействия с Raydium DEX
+----------+type Client interface {
+----------+	// Основные методы пула
+----------+	GetPool(ctx context.Context, poolID solana.PublicKey) (*RaydiumPool, error)
+----------+	GetPoolState(ctx context.Context, pool *RaydiumPool) (*PoolState, error)
 ---------- 
----------- 	"github.com/gagliardetto/solana-go"
-----------+	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
----------- 	"github.com/rovshanmuradov/solana-bot/internal/types"
----------- 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
------------	"github.com/sirupsen/logrus"
----------- 	"go.uber.org/zap"
----------- )
+-----------	r.setLastPoolState(state)
+----------+	// Методы для свапов
+----------+	CreateSwapInstructions(ctx context.Context, params SwapParams) ([]solana.Instruction, error)
+----------+	SimulateSwap(ctx context.Context, instructions []solana.Instruction) error
+----------+	GetAmountOut(pool *RaydiumPool, state *PoolState, amountIn uint64) (uint64, error)
+----------+}
 ---------- 
------------// Serialize сериализует данные инструкции свапа
-----------+// Serialize serializes the swap instruction data
----------- func (s *SwapInstructionData) Serialize() ([]byte, error) {
----------- 	if err := s.Validate(); err != nil {
----------- 		return nil, err
-----------@@ -34,6 +35,7 @@ func (s *SwapInstructionData) Serialize() ([]byte, error) {
----------- 	return data, nil
+-----------	// Логируем обновление состояния
+-----------	r.logger.Debug("Pool state updated",
+-----------		zap.Float64("current_price", state.CurrentPrice),
+-----------		zap.Uint64("token_a_reserve", state.TokenAReserve),
+-----------		zap.Uint64("token_b_reserve", state.TokenBReserve))
+----------+// ValidationError представляет ошибку валидации
+----------+type ValidationError struct {
+----------+	Field   string
+----------+	Message string
 ---------- }
 ---------- 
-----------+// Validate validates the swap instruction data
----------- func (s *SwapInstructionData) Validate() error {
----------- 	if s.Instruction != 1 {
----------- 		return fmt.Errorf("invalid instruction type: expected 1, got %d", s.Instruction)
-----------@@ -43,99 +45,15 @@ func (s *SwapInstructionData) Validate() error {
----------- 		return fmt.Errorf("amount_in cannot be zero")
----------- 	}
+-----------// GetPoolStateSnapshot получает снапшот текущего состояния пула
+-----------func (r *DEX) GetPoolStateSnapshot() *PoolState {
+-----------	r.stateMutex.RLock()
+-----------	defer r.stateMutex.RUnlock()
+----------+func (e *ValidationError) Error() string {
+----------+	return fmt.Sprintf("validation error for %s: %s", e.Field, e.Message)
+----------+}
 ---------- 
------------	// MinimumOut может быть 0, но логируем это как предупреждение
-----------+	// MinimumOut can be zero, but log a warning
----------- 	if s.MinAmountOut == 0 {
------------		logrus.Warn("minimum_out is set to zero, this may result in high slippage")
-----------+		// You may want to log a warning here
----------- 	}
+-----------	state := r.getLastPoolState()
+-----------	if state == nil {
+-----------		return nil
+-----------	}
+----------+// SwapError представляет ошибку при выполнении свапа
+----------+type SwapError struct {
+----------+	Stage   string
+----------+	Message string
+----------+	Err     error
+----------+}
 ---------- 
----------- 	return nil
+-----------	// Возвращаем копию состояния
+-----------	return &PoolState{
+-----------		TokenAReserve: state.TokenAReserve,
+-----------		TokenBReserve: state.TokenBReserve,
+-----------		SwapFee:       state.SwapFee,
+-----------		CurrentPrice:  state.CurrentPrice,
+----------+func (e *SwapError) Error() string {
+----------+	if e.Err != nil {
+----------+		return fmt.Sprintf("swap error at %s: %s: %v", e.Stage, e.Message, e.Err)
+---------- 	}
+----------+	return fmt.Sprintf("swap error at %s: %s", e.Stage, e.Message)
+----------+}
+----------+
+----------+func (e *SwapError) Unwrap() error {
+----------+	return e.Err
+----------+}
+----------+
+----------+// Типы для v5 пулов
+----------+type RaydiumPoolV5 struct {
+----------+	// Новые поля v5
 ---------- }
 ---------- 
------------// Обновляем вычисление минимального выхода
------------func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
------------	if expectedOut <= 0 {
------------		return 1 // Минимальное безопасное значение
------------	}
+-----------// Name возвращает имя DEX
+-----------func (r *DEX) Name() string {
+-----------	return "Raydium"
+----------+// Типы для маркет-мейкинга
+----------+type MarketMakingParams struct {
+----------+	// Параметры для MM
+---------- }
+----------diff --git a/internal/dex/raydium/validation.go b/internal/dex/raydium/validation.go
+----------deleted file mode 100644
+----------index 9267897..0000000
+------------- a/internal/dex/raydium/validation.go
+----------+++ /dev/null
+----------@@ -1,105 +0,0 @@
+-----------// internal/dex/raydium/validation.go
+-----------package raydium
 -----------
------------	// Учитываем слиппаж
------------	minOut := expectedOut * (1 - slippagePercent/100)
+-----------import (
+-----------	"fmt"
 -----------
------------	// Конвертируем в uint64 и проверяем на минимальное значение
------------	result := uint64(math.Floor(minOut))
------------	if result == 0 {
------------		return 1
------------	}
+-----------	"github.com/gagliardetto/solana-go"
+-----------	"github.com/rovshanmuradov/solana-bot/internal/types"
+-----------)
 -----------
------------	return result
------------}
+-----------// ValidateTask проверяет корректность параметров задачи
+-----------func ValidateTask(task *types.Task) error {
+-----------	if task == nil {
+-----------		return fmt.Errorf("task cannot be nil")
+-----------	}
 -----------
------------// TestSwapInstructionDataSerialization тест для проверки сериализации
------------func TestSwapInstructionDataSerialization(t *testing.T) {
------------	inst := &SwapInstructionData{
------------		Instruction:  1,
------------		AmountIn:     20000000,
------------		MinAmountOut: 6,
+-----------	if task.TaskName == "" {
+-----------		return fmt.Errorf("task name cannot be empty")
 -----------	}
 -----------
------------	data, err := inst.Serialize()
------------	if err != nil {
------------		t.Fatalf("Failed to serialize: %v", err)
+-----------	if task.SourceToken == "" {
+-----------		return fmt.Errorf("source token cannot be empty")
 -----------	}
 -----------
------------	// Проверяем instruction code
------------	if data[0] != 1 {
------------		t.Errorf("Expected instruction 1, got %d", data[0])
+-----------	if task.TargetToken == "" {
+-----------		return fmt.Errorf("target token cannot be empty")
 -----------	}
 -----------
------------	// Проверяем amountIn
------------	gotAmountIn := binary.LittleEndian.Uint64(data[1:9])
------------	if gotAmountIn != 20000000 {
------------		t.Errorf("Expected amountIn 20000000, got %d", gotAmountIn)
+-----------	// Проверяем корректность адресов токенов
+-----------	if _, err := solana.PublicKeyFromBase58(task.SourceToken); err != nil {
+-----------		return fmt.Errorf("invalid source token address: %w", err)
 -----------	}
 -----------
------------	// Проверяем minAmountOut
------------	gotMinAmountOut := binary.LittleEndian.Uint64(data[9:17])
------------	if gotMinAmountOut != 6 {
------------		t.Errorf("Expected minAmountOut 6, got %d", gotMinAmountOut)
+-----------	if _, err := solana.PublicKeyFromBase58(task.TargetToken); err != nil {
+-----------		return fmt.Errorf("invalid target token address: %w", err)
 -----------	}
------------}
 -----------
------------// Debug выводит шестнадцатеричное представление данных
------------func (s *SwapInstructionData) Debug(logger *zap.Logger) {
------------	data, err := s.Serialize()
------------	if err != nil {
------------		logger.Error("Failed to serialize for debug", zap.Error(err))
------------		return
+-----------	if task.AmountIn <= 0 {
+-----------		return fmt.Errorf("amount in must be greater than 0")
 -----------	}
 -----------
------------	// Проверяем данные
------------	amountIn := binary.LittleEndian.Uint64(data[1:9])
------------	minAmountOut := binary.LittleEndian.Uint64(data[9:17])
------------
------------	logger.Debug("Instruction data debug",
------------		zap.Uint8("instruction", data[0]),
------------		zap.Uint64("amount_in_original", s.AmountIn),
------------		zap.Uint64("amount_in_serialized", amountIn),
------------		zap.Uint64("min_amount_out_original", s.MinAmountOut),
------------		zap.Uint64("min_amount_out_serialized", minAmountOut),
------------		zap.Binary("raw_data", data))
------------}
+-----------	// Удаляем проверку MinAmountOut, так как теперь оно может быть нулевым или пустым
+-----------	// if task.MinAmountOut <= 0 {
+-----------	//     return fmt.Errorf("min amount out must be greater than 0")
+-----------	// }
 -----------
------------// validatePublicKey проверяет корректность публичного ключа
------------func validatePublicKey(key string) (solana.PublicKey, error) {
------------	if key == "" {
------------		return solana.PublicKey{}, fmt.Errorf("empty public key")
+-----------	// Проверяем конфигурацию проскальзывания, если она используется
+-----------	if task.SlippageConfig.Type != types.SlippageNone {
+-----------		if task.SlippageConfig.Type == types.SlippagePercent &&
+-----------			(task.SlippageConfig.Value <= 0 || task.SlippageConfig.Value > 100) {
+-----------			return fmt.Errorf("slippage percentage must be between 0 and 100")
+-----------		}
+-----------		if task.SlippageConfig.Type == types.SlippageFixed && task.SlippageConfig.Value < 0 {
+-----------			return fmt.Errorf("fixed slippage value cannot be negative")
+-----------		}
 -----------	}
 -----------
------------	pubKey, err := solana.PublicKeyFromBase58(key)
------------	if err != nil {
------------		return solana.PublicKey{}, fmt.Errorf("invalid public key %s: %w", key, err)
+-----------	if task.SourceTokenDecimals <= 0 {
+-----------		return fmt.Errorf("source token decimals must be greater than 0")
 -----------	}
 -----------
------------	return pubKey, nil
------------}
------------
------------// CreateSwapInstruction создает инструкцию свапа для Raydium
-----------+// CreateSwapInstruction creates a swap instruction for Raydium
----------- func (r *DEX) CreateSwapInstruction(
----------- 	userWallet solana.PublicKey,
----------- 	userSourceTokenAccount solana.PublicKey,
-----------@@ -156,14 +74,14 @@ func (r *DEX) CreateSwapInstruction(
----------- 		return nil, fmt.Errorf("pool info is nil")
----------- 	}
----------- 
------------	// Проверяем и конвертируем все необходимые публичные ключи
-----------+	// Validate and parse all necessary public keys
----------- 	ammProgramID, err := validatePublicKey(poolInfo.AmmProgramID)
----------- 	if err != nil {
----------- 		logger.Error("Invalid AmmProgramID", zap.Error(err))
----------- 		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
----------- 	}
----------- 
------------	// Проверяем и создаем все необходимые аккаунты
-----------+	// Map of required accounts with their names
----------- 	requiredAccounts := map[string]string{
----------- 		"AmmID":                poolInfo.AmmID,
----------- 		"AmmAuthority":         poolInfo.AmmAuthority,
-----------@@ -193,56 +111,42 @@ func (r *DEX) CreateSwapInstruction(
----------- 		accounts[name] = pubKey
----------- 	}
----------- 
------------	// Создаем слайс аккаунтов в правильном порядке для Raydium
------------	metas := make(solana.AccountMetaSlice, 0, 20)
------------
------------	// Токен аккаунты пользователя
------------	metas = append(metas,
------------		&solana.AccountMeta{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
------------	)
------------
------------	// Аккаунты AMM
------------	metas = append(metas,
------------		&solana.AccountMeta{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
------------		&solana.AccountMeta{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
------------	)
------------
------------	// Аккаунты Serum
------------	metas = append(metas,
------------		&solana.AccountMeta{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
------------		&solana.AccountMeta{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
------------		&solana.AccountMeta{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
------------	)
------------
------------	// Системные аккаунты
------------	metas = append(metas,
------------		&solana.AccountMeta{PublicKey: userWallet, IsSigner: true, IsWritable: false},
------------		&solana.AccountMeta{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
------------		&solana.AccountMeta{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
------------		&solana.AccountMeta{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
------------	)
-----------+	// Create the account meta slice in the correct order
-----------+	metas := solana.AccountMetaSlice{
-----------+		// User accounts
-----------+		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
-----------+		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
-----------+		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
-----------+		// Pool accounts
-----------+		{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
-----------+		{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
-----------+		// Serum accounts
-----------+		{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
-----------+		{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
-----------+		{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
-----------+		// System accounts
-----------+		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
-----------+		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
-----------+		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
-----------+	}
----------- 
------------	// Создание данных инструкции
-----------+	// Create swap instruction data
----------- 	instructionData := &SwapInstructionData{
----------- 		Instruction:  poolInfo.RaydiumSwapInstructionCode,
----------- 		AmountIn:     amountIn,
----------- 		MinAmountOut: minAmountOut,
----------- 	}
----------- 
------------	// Добавляем отладочный вывод
------------	instructionData.Debug(logger)
------------
------------	// Сериализация
-----------+	// Serialize instruction data
----------- 	data, err := instructionData.Serialize()
----------- 	if err != nil {
----------- 		logger.Error("Failed to serialize instruction data",
-----------@@ -253,39 +157,17 @@ func (r *DEX) CreateSwapInstruction(
----------- 		return nil, fmt.Errorf("failed to serialize instruction data: %w", err)
----------- 	}
----------- 
------------	// Проверка сериализованных данных
------------	if len(data) != 17 {
------------		logger.Error("Invalid serialized data length",
------------			zap.Int("got_length", len(data)),
------------			zap.Int("expected_length", 17))
------------		return nil, fmt.Errorf("invalid serialized data length")
+-----------	if task.TargetTokenDecimals <= 0 {
+-----------		return fmt.Errorf("target token decimals must be greater than 0")
 -----------	}
 -----------
------------	// Проверяем значения после сериализации
------------	amountInCheck := binary.LittleEndian.Uint64(data[1:9])
------------	minAmountOutCheck := binary.LittleEndian.Uint64(data[9:17])
+-----------	return nil
+-----------}
 -----------
------------	logger.Debug("Serialized data check",
------------		zap.Uint64("amount_in_check", amountInCheck),
------------		zap.Uint64("min_amount_out_check", minAmountOutCheck))
+-----------// ValidatePool проверяет корректность конфигурации пула
+-----------func ValidatePool(pool *Pool) error {
+-----------	if pool == nil {
+-----------		return fmt.Errorf("pool config cannot be nil")
+-----------	}
 -----------
------------	if amountInCheck != amountIn {
------------		logger.Error("AmountIn mismatch after serialization",
------------			zap.Uint64("original", amountIn),
------------			zap.Uint64("serialized", amountInCheck))
------------		return nil, fmt.Errorf("amountIn mismatch after serialization")
+-----------	// Проверяем все обязательные адреса
+-----------	addresses := map[string]string{
+-----------		"AmmProgramID":          pool.AmmProgramID,
+-----------		"AmmID":                 pool.AmmID,
+-----------		"AmmAuthority":          pool.AmmAuthority,
+-----------		"AmmOpenOrders":         pool.AmmOpenOrders,
+-----------		"AmmTargetOrders":       pool.AmmTargetOrders,
+-----------		"PoolCoinTokenAccount":  pool.PoolCoinTokenAccount,
+-----------		"PoolPcTokenAccount":    pool.PoolPcTokenAccount,
+-----------		"SerumProgramID":        pool.SerumProgramID,
+-----------		"SerumMarket":           pool.SerumMarket,
+-----------		"SerumBids":             pool.SerumBids,
+-----------		"SerumAsks":             pool.SerumAsks,
+-----------		"SerumEventQueue":       pool.SerumEventQueue,
+-----------		"SerumCoinVaultAccount": pool.SerumCoinVaultAccount,
+-----------		"SerumPcVaultAccount":   pool.SerumPcVaultAccount,
+-----------		"SerumVaultSigner":      pool.SerumVaultSigner,
 -----------	}
 -----------
-----------+	// Create the instruction
----------- 	instruction := solana.NewInstruction(ammProgramID, metas, data)
----------- 
------------	logger.Debug("Created instruction",
-----------+	logger.Debug("Created swap instruction",
----------- 		zap.Int("num_accounts", len(metas)),
----------- 		zap.Int("data_len", len(data)))
----------- 
----------- 	return instruction, nil
----------- }
----------- 
------------// PrepareAndSendTransaction готовит и отправляет транзакцию свапа
-----------+// PrepareAndSendTransaction prepares and sends the swap transaction
----------- func (r *DEX) PrepareAndSendTransaction(
----------- 	ctx context.Context,
----------- 	task *types.Task,
-----------@@ -299,23 +181,18 @@ func (r *DEX) PrepareAndSendTransaction(
----------- 		return fmt.Errorf("failed to get recent blockhash: %w", err)
----------- 	}
----------- 
------------	// Создаем compute budget инструкции с использованием нового PriorityManager
------------	priorityManager := types.NewPriorityManager(logger)
------------	budgetInstructions, err := priorityManager.CreateCustomPriorityInstructions(
------------		uint64(task.PriorityFee*1e6), // Конвертируем SOL в микро-ламports
------------		1_000_000,                    // Используем sniping units
------------	)
------------	if err != nil {
------------		logger.Error("Failed to create compute budget instructions", zap.Error(err))
------------		return fmt.Errorf("failed to create compute budget instructions: %w", err)
+-----------	for name, addr := range addresses {
+-----------		if addr == "" {
+-----------			return fmt.Errorf("%s cannot be empty", name)
+-----------		}
+-----------
+-----------		if _, err := solana.PublicKeyFromBase58(addr); err != nil {
+-----------			return fmt.Errorf("invalid %s address: %w", name, err)
+-----------		}
 -----------	}
-----------+	// Create compute budget instruction if needed
-----------+	computeBudgetInst := computebudget.NewSetComputeUnitPriceInstruction(
-----------+		uint64(task.PriorityFee * 1e6), // Convert SOL to micro-lamports
-----------+	).Build()
----------- 
------------	// Combine all instructions properly
------------	instructions := make([]solana.Instruction, 0, len(budgetInstructions)+1)
------------	instructions = append(instructions, budgetInstructions...)
------------	instructions = append(instructions, swapInstruction)
-----------+	// Combine all instructions
-----------+	instructions := []solana.Instruction{
-----------+		computeBudgetInst,
-----------+		swapInstruction,
-----------+	}
----------- 
------------	// Создаем транзакцию
-----------+	// Create the transaction
----------- 	tx, err := solana.NewTransaction(
----------- 		instructions,
----------- 		recentBlockhash,
-----------@@ -326,7 +203,7 @@ func (r *DEX) PrepareAndSendTransaction(
----------- 		return fmt.Errorf("failed to create transaction: %w", err)
----------- 	}
----------- 
------------	// Подписываем транзакцию
-----------+	// Sign the transaction
----------- 	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
----------- 		if key.Equals(userWallet.PublicKey) {
----------- 			return &userWallet.PrivateKey
-----------@@ -338,7 +215,7 @@ func (r *DEX) PrepareAndSendTransaction(
----------- 		return fmt.Errorf("failed to sign transaction: %w", err)
----------- 	}
----------- 
------------	// Отправляем транзакцию
-----------+	// Send the transaction
----------- 	signature, err := r.client.SendTransaction(ctx, tx)
----------- 	if err != nil {
----------- 		logger.Error("Failed to send transaction", zap.Error(err))
-----------@@ -347,8 +224,41 @@ func (r *DEX) PrepareAndSendTransaction(
----------- 
----------- 	logger.Info("Transaction sent successfully",
----------- 		zap.String("signature", signature.String()),
------------		zap.Float64("priority_fee_sol", task.PriorityFee),
------------		zap.Uint64("compute_units", 1_000_000))
-----------+		zap.Float64("priority_fee_sol", task.PriorityFee))
----------- 
----------- 	return nil
----------- }
-----------+
-----------+// validatePublicKey checks if a public key string is valid
-----------+func validatePublicKey(key string) (solana.PublicKey, error) {
-----------+	if key == "" {
-----------+		return solana.PublicKey{}, fmt.Errorf("empty public key")
-----------+	}
-----------+
-----------+	pubKey, err := solana.PublicKeyFromBase58(key)
-----------+	if err != nil {
-----------+		return solana.PublicKey{}, fmt.Errorf("invalid public key %s: %w", key, err)
-----------+	}
-----------+
-----------+	return pubKey, nil
-----------+}
-----------+
-----------+// Helper function to calculate minimum output considering slippage
-----------+func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
-----------+	if expectedOut <= 0 {
-----------+		return 1 // Minimum safe value
-----------+	}
-----------+
-----------+	// Consider slippage
-----------+	minOut := expectedOut * (1 - slippagePercent/100)
-----------+
-----------+	// Convert to uint64 and check for minimum value
-----------+	result := uint64(math.Floor(minOut))
-----------+	if result == 0 {
-----------+		return 1
-----------+	}
-----------+
-----------+	return result
-----------+}
-----------+
-----------+// You may want to include other helper functions or adjust existing ones as needed
-----------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
-----------index 001489f..7db11c6 100644
-------------- a/internal/dex/raydium/types.go
-----------+++ b/internal/dex/raydium/types.go
-----------@@ -1,8 +1,13 @@
----------- // internal/dex/raydium/types.go
-----------+
----------- package raydium
----------- 
----------- import (
-----------+	"sync"
-----------+	"sync/atomic"
-----------+
----------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
-----------+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
----------- 	"go.uber.org/zap"
----------- )
----------- 
-----------@@ -25,6 +30,12 @@ type Pool struct {
----------- 	SerumVaultSigner           string
----------- 	RaydiumSwapInstructionCode uint8
----------- }
-----------+type PoolState struct {
-----------+	TokenAReserve uint64
-----------+	TokenBReserve uint64
-----------+	SwapFee       float64 // в процентах
-----------+	CurrentPrice  float64 // текущая цена пула
-----------+}
----------- 
----------- // SwapInstructionData представляет данные инструкции свапа
----------- type SwapInstructionData struct {
-----------@@ -33,32 +44,60 @@ type SwapInstructionData struct {
----------- 	MinAmountOut uint64 // Минимальная исходящая сумма
----------- }
----------- type DEX struct {
------------	client   blockchain.Client // изменяем тип на интерфейс.
------------	logger   *zap.Logger
------------	poolInfo *Pool
------------	slippage float64 // Добавляем поле для slippage
-----------+	client         blockchain.Client
-----------+	logger         *zap.Logger
-----------+	poolInfo       *Pool
-----------+	slippage       float64
-----------+	tokenCache     *solbc.TokenMetadataCache
-----------+	priceValidator PriceValidator
-----------+	lastPoolState  atomic.Value // Используем atomic.Value для потокобезопасного доступа
-----------+	stateMutex     sync.RWMutex // Мьютекс для дополнительной синхронизации при необходимости
----------- }
----------- 
------------func (r *Pool) GetProgramID() string {
------------	return r.AmmProgramID
-----------+// setLastPoolState безопасно обновляет состояние пула
-----------+func (r *DEX) setLastPoolState(state *PoolState) {
-----------+	r.lastPoolState.Store(state)
----------- }
----------- 
------------func (r *Pool) GetPoolID() string {
------------	return r.AmmID
-----------+// getLastPoolState безопасно получает состояние пула
-----------+func (r *DEX) getLastPoolState() *PoolState {
-----------+	return r.lastPoolState.Load().(*PoolState)
----------- }
----------- 
------------func (r *Pool) GetTokenAccounts() (string, string) {
------------	return r.PoolCoinTokenAccount, r.PoolPcTokenAccount
-----------+// UpdatePoolState обновляет состояние пула с дополнительной синхронизацией
-----------+func (r *DEX) UpdatePoolState(state *PoolState) {
-----------+	r.stateMutex.Lock()
-----------+	defer r.stateMutex.Unlock()
-----------+
-----------+	r.setLastPoolState(state)
-----------+
-----------+	// Логируем обновление состояния
-----------+	r.logger.Debug("Pool state updated",
-----------+		zap.Float64("current_price", state.CurrentPrice),
-----------+		zap.Uint64("token_a_reserve", state.TokenAReserve),
-----------+		zap.Uint64("token_b_reserve", state.TokenBReserve))
-----------+}
-----------+
-----------+// GetPoolStateSnapshot получает снапшот текущего состояния пула
-----------+func (r *DEX) GetPoolStateSnapshot() *PoolState {
-----------+	r.stateMutex.RLock()
-----------+	defer r.stateMutex.RUnlock()
-----------+
-----------+	state := r.getLastPoolState()
-----------+	if state == nil {
-----------+		return nil
-----------+	}
-----------+
-----------+	// Возвращаем копию состояния
-----------+	return &PoolState{
-----------+		TokenAReserve: state.TokenAReserve,
-----------+		TokenBReserve: state.TokenBReserve,
-----------+		SwapFee:       state.SwapFee,
-----------+		CurrentPrice:  state.CurrentPrice,
-----------+	}
----------- }
----------- 
----------- // Name возвращает имя DEX
----------- func (r *DEX) Name() string {
----------- 	return "Raydium"
----------- }
 -----------
------------// PoolState содержит состояние пула ликвидности
------------type PoolState struct {
------------	TokenAReserve uint64
------------	TokenBReserve uint64
------------	SwapFee       float64 // в процентах
+-----------	return nil
 -----------}
 ----------diff --git a/newdif.txt b/newdif.txt
-----------index cc2c079..c7ae03d 100644
+----------index 406c273..a8395ed 100644
 ------------- a/newdif.txt
 ----------+++ b/newdif.txt
-----------@@ -1,1340 +0,0 @@
------------diff --git a/TODO.md b/TODO.md
------------index 5b1d499..34aab1e 100644
--------------- a/TODO.md
------------+++ b/TODO.md
------------@@ -264,3 +264,8 @@
------------     - [ ] Например, прогнозирование цен, анализ рынка и т.д.
------------ - [ ] Рассмотреть возможность масштабирования
------------     - [ ] Настроить приложение для работы в распределенной среде.
------------+
------------+
------------+TODO: Оптимизация работы с ATA (Associated Token Accounts)
------------+1. Этап подготовки и архитектуры
------------+
------------diff --git a/configs/tasks.csv b/configs/tasks.csv
------------index 33e5da0..bbc2c6d 100644
--------------- a/configs/tasks.csv
------------+++ b/configs/tasks.csv
------------@@ -1,2 +1,2 @@
------------ TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,MinAmountOut,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
-------------buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
------------\ No newline at end of file
------------+buyTokens,Raydium,1,wallet1,100,0.0001,58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
------------\ No newline at end of file
------------diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
------------index 75b6e0d..bcfeacc 100644
--------------- a/internal/blockchain/solbc/client.go
------------+++ b/internal/blockchain/solbc/client.go
------------@@ -64,3 +64,6 @@ func (c *Client) Close() error {
------------ 	c.rpc.Close()
------------ 	return nil
------------ }
------------+func (c *Client) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
------------+	return c.rpc.GetSignatureStatuses(ctx, signatures...)
------------+}
------------diff --git a/internal/blockchain/solbc/rpc/rpc.go b/internal/blockchain/solbc/rpc/rpc.go
------------index ee4c137..ac6f2c4 100644
--------------- a/internal/blockchain/solbc/rpc/rpc.go
------------+++ b/internal/blockchain/solbc/rpc/rpc.go
------------@@ -144,5 +144,16 @@ func (c *RPCClient) SendTransaction(ctx context.Context, tx *solana.Transaction)
------------ 	return signature, err
------------ }
+----------@@ -1,2314 +0,0 @@
+-----------diff --git a/internal/dex/raydium/config.go b/internal/dex/raydium/config.go
+-----------index cb0c21b..fab480a 100644
+-------------- a/internal/dex/raydium/config.go
+-----------+++ b/internal/dex/raydium/config.go
+-----------@@ -3,27 +3,29 @@ package raydium
 ----------- 
------------+// Добавляем новый метод в RPCClient
------------+func (c *RPCClient) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
------------+	var result *solanarpc.GetSignatureStatusesResult
------------+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
------------+		var err error
------------+		result, err = client.GetSignatureStatuses(ctx, false, signatures...)
------------+		return err
------------+	})
------------+	return result, err
------------+}
------------+
------------ // Close закрывает клиент
------------ func (c *RPCClient) Close() {}
------------diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
------------index cc61a29..42debad 100644
--------------- a/internal/blockchain/solbc/types.go
------------+++ b/internal/blockchain/solbc/types.go
------------@@ -19,7 +19,7 @@ type TokenMetadataCache struct {
+----------- // DefaultPoolConfig с обновленным типом для RaydiumSwapInstructionCode
+----------- var DefaultPoolConfig = &Pool{
+------------	// Актуальный программный ID Raydium
+------------	AmmProgramID: "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",
+-----------+	// Программы
+-----------+	AmmProgramID:   "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8", // ✅ Подтверждено
+-----------+	SerumProgramID: "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX",  // ✅ Подтверждено
 ----------- 
------------ // Client представляет основной клиент Solana
------------ type Client struct {
-------------	rpc     *rpc.RPCClient // Меняем тип с enhancedRPC на RPCClient
------------+	rpc     *rpc.RPCClient
------------ 	logger  *zap.Logger
------------ 	metrics *ClientMetrics
------------ }
------------diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
------------index 2690c82..202b59a 100644
--------------- a/internal/blockchain/types.go
------------+++ b/internal/blockchain/types.go
------------@@ -13,4 +13,5 @@ type Client interface {
------------ 	GetRecentBlockhash(ctx context.Context) (solana.Hash, error)
------------ 	SendTransaction(ctx context.Context, tx *solana.Transaction) (solana.Signature, error)
------------ 	GetAccountInfo(ctx context.Context, pubkey solana.PublicKey) (*rpc.GetAccountInfoResult, error)
------------+	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
------------ }
------------diff --git a/internal/dex/dex.go b/internal/dex/dex.go
------------index 5aebaa7..9b9fb16 100644
--------------- a/internal/dex/dex.go
------------+++ b/internal/dex/dex.go
------------@@ -1,62 +1,79 @@
-------------// internal/dex/dex.go
------------ package dex
+------------	// Актуальная конфигурация для SOL-USDC пула
+------------	AmmID:                "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
+------------	AmmAuthority:         "3uaZBfHPfmpAHW7dsimC1SnyR61X4bJqQZKWmRSCXJxv",
+------------	AmmOpenOrders:        "4NfmERReGt1QCKey8cH5q4LsBYJoUcsuGg11J8GQFwH8",
+------------	AmmTargetOrders:      "38RJcGjtgd4SKRfY2dcM8Z9LzXQR6cyZeGxvjrRsVGZD",
+------------	PoolCoinTokenAccount: "8spXrXn2EWtNiAHvWZY3EE2f8E1TRDHzFTYyXtNuVFKs",
+------------	PoolPcTokenAccount:   "DuYuU5Y6TEZoMhzwPsYYRFzB5xqF999kXGHUDmBZwJge",
+-----------+	// AMM конфигурация
+-----------+	AmmID:           "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", // ✅ Подтверждено
+-----------+	AmmAuthority:    "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1", // ✅ Обновлено (authority)
+-----------+	AmmOpenOrders:   "HmiHHzq4Fym9e1D4qzLS6LDDM3tNsCTBPDWHTLZ763jY", // ✅ Обновлено (openOrders)
+-----------+	AmmTargetOrders: "CZza3Ej4Mc58MnxWA385itCC9jCo3L1D7zc3LKy1bZMR", // ✅ Обновлено (targetOrders)
 ----------- 
------------ import (
-------------	"errors"
------------ 	"fmt"
------------ 	"strings"
+------------	// OpenBook (бывший Serum) маркет
+------------	SerumProgramID:        "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX",
+------------	SerumMarket:           "8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6",
+------------	SerumBids:             "5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh",
+------------	SerumAsks:             "EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCHV5T73Sw8TL",
+------------	SerumEventQueue:       "8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa",
+------------	SerumCoinVaultAccount: "CKxTHwM9fPksGqGd5AHjyGWGbzGkDYjP6ABNYRLvJ1Vz",
+------------	SerumPcVaultAccount:   "PCxN9aXvxtwMYrXk8BgESw3NNkGLwpPM8c6DwByrjgN",
+------------	SerumVaultSigner:      "GXWEpRURaQZ9E62Q23EreTUfBy4hfemXgWFUWcg7YFgv",
+-----------+	// Token Accounts
+-----------+	PoolCoinTokenAccount: "DQyrAcCrDXQ7NeoqGgDCZwBvWDcYmFCjSb9JtteuvPpz", // ✅ Обновлено (baseVault)
+-----------+	PoolPcTokenAccount:   "HLmqeL62xR1QoZ1HKKbXRrdN1p3phKpxRMb2VVopvBBz", // ✅ Обновлено (quoteVault)
+----------- 
+------------	// Правильный код инструкции для свапа (теперь uint8)
+------------	RaydiumSwapInstructionCode: 1,
+-----------+	// Serum Market
+-----------+	SerumMarket:           "8BnEgHoWFysVcuFFX7QztDmzuH8r5ZFvyP3sYwn1XTh6", // ✅ Подтверждено
+-----------+	SerumBids:             "5jWUncPNBMZJ3sTHKmMLszypVkoRK6bfEQMQUHweeQnh", // ✅ Подтверждено
+-----------+	SerumAsks:             "EaXdHx7x3mdGA38j5RSmKYSXMzAFzzUXCLNBEDXDn1d5", // ✅ Обновлено
+-----------+	SerumEventQueue:       "8CvwxZ9Db6XbLD46NZwwmVDZZRDy7eydFcAGkXKh9axa", // ✅ Подтверждено
+-----------+	SerumCoinVaultAccount: "CKxTHwM9fPMRRvZmFnFoqKNd9pQR21c5Aq9bh5h9oghX", // ✅ Обновлено (marketBaseVault)
+-----------+	SerumPcVaultAccount:   "6A5NHCj1yF6urc9wZNe6Bcjj4LVszQNj5DwAWG97yzMu", // ✅ Обновлено (marketQuoteVault)
+-----------+	SerumVaultSigner:      "CTz5UMLQm2SRWHzQnU62Pi4yJqbNGjgRBHqqp6oDHfF7", // ✅ Обновлено (marketAuthority)
+-----------+
+-----------+	// Дополнительные параметры
+-----------+	RaydiumSwapInstructionCode: 1, // ✅ Не изменилось
+----------- }
+-----------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
+-----------index 48baf94..c684b6e 100644
+-------------- a/internal/dex/raydium/raydium.go
+-----------+++ b/internal/dex/raydium/raydium.go
+-----------@@ -17,6 +17,7 @@ import (
 ----------- 
+----------- 	solanarpc "github.com/gagliardetto/solana-go/rpc"
 ----------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
------------+	"github.com/rovshanmuradov/solana-bot/internal/dex/pumpfun"
------------ 	"github.com/rovshanmuradov/solana-bot/internal/dex/raydium"
+-----------+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
 ----------- 	"github.com/rovshanmuradov/solana-bot/internal/types"
+----------- 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
 ----------- 	"go.uber.org/zap"
+-----------@@ -30,17 +31,73 @@ const (
+----------- 	txSendTimeout   = 15 * time.Second
 ----------- )
 ----------- 
------------+// GetDEXByName возвращает имплементацию DEX по имени
------------ func GetDEXByName(name string, client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
-------------	logger = logger.With(zap.String("dex_name", name))
-------------	logger.Info("Getting DEX by name")
-------------	fmt.Printf("\n=== Getting DEX by name: %s ===\n", name)
------------+	if client == nil {
------------+		return nil, fmt.Errorf("client cannot be nil")
+-----------+// Добавляем новые типы для работы с ценами
+-----------+type PriceValidator interface {
+-----------+	ValidatePrice(poolPrice float64) error
+-----------+	GetMaxDeviation() float64
+-----------+}
+-----------+
+-----------+// Обновляем структуру PoolState
+-----------+
+-----------+// Добавляем базовую реализацию валидатора цен
+-----------+type BasicPriceValidator struct {
+-----------+	basePrice    float64
+-----------+	maxDeviation float64
+-----------+	logger       *zap.Logger
+-----------+}
+-----------+
+-----------+func NewBasicPriceValidator(basePrice float64, maxDeviation float64, logger *zap.Logger) *BasicPriceValidator {
+-----------+	return &BasicPriceValidator{
+-----------+		basePrice:    basePrice,
+-----------+		maxDeviation: maxDeviation,
+-----------+		logger:       logger,
 -----------+	}
------------ 
------------ 	if logger == nil {
-------------		fmt.Println("Logger is nil")
-------------		return nil, errors.New("logger is nil")
------------+		return nil, fmt.Errorf("logger cannot be nil")
------------ 	}
------------ 
-------------	name = strings.TrimSpace(name)
------------+	name = strings.TrimSpace(strings.ToLower(name))
------------ 	if name == "" {
-------------		fmt.Println("DEX name is empty")
-------------		return nil, errors.New("DEX name cannot be empty")
------------+		return nil, fmt.Errorf("DEX name cannot be empty")
------------ 	}
------------ 
-------------	fmt.Printf("Client nil? %v\n", client == nil)
------------+	logger = logger.With(zap.String("dex_name", name))
------------+	logger.Info("Initializing DEX instance")
------------ 
-------------	if client == nil {
-------------		fmt.Println("Solana client is nil")
-------------		return nil, errors.New("solana client cannot be nil")
------------+	switch name {
------------+	case "raydium":
------------+		return initializeRaydiumDEX(client, logger)
------------+	case "pump.fun":
------------+		return initializePumpFunDEX(client, logger)
------------+	default:
------------+		logger.Error("Unsupported DEX requested", zap.String("name", name))
------------+		return nil, fmt.Errorf("unsupported DEX: %s", name)
------------ 	}
 -----------+}
------------ 
-------------	switch strings.ToLower(name) {
-------------	case strings.ToLower("Raydium"):
-------------		fmt.Println("Creating Raydium DEX instance")
------------+// initializeRaydiumDEX инициализирует Raydium DEX
------------+func initializeRaydiumDEX(client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
------------+	logger.Debug("Initializing Raydium DEX")
------------ 
-------------		if raydium.DefaultPoolConfig == nil {
-------------			fmt.Println("Default pool config is nil")
-------------			return nil, errors.New("default pool config is nil")
-------------		}
------------+	if raydium.DefaultPoolConfig == nil {
------------+		logger.Error("Default pool configuration is missing")
------------+		return nil, fmt.Errorf("raydium default pool config is nil")
+-----------+
+-----------+func (v *BasicPriceValidator) ValidatePrice(poolPrice float64) error {
+-----------+	if v.basePrice <= 0 {
+-----------+		// Если базовая цена не установлена, пропускаем валидацию
+-----------+		return nil
 -----------+	}
------------ 
-------------		fmt.Printf("Pool config: %+v\n", raydium.DefaultPoolConfig)
------------+	logger.Debug("Creating Raydium DEX instance",
------------+		zap.String("pool_id", raydium.DefaultPoolConfig.AmmID),
------------+		zap.String("program_id", raydium.DefaultPoolConfig.AmmProgramID))
------------ 
-------------		dex := raydium.NewDEX(client, logger, raydium.DefaultPoolConfig)
-------------		if dex == nil {
-------------			fmt.Println("Failed to create Raydium DEX instance")
-------------			return nil, errors.New("failed to create Raydium DEX instance")
-------------		}
------------+	dex := raydium.NewDEX(client, logger, raydium.DefaultPoolConfig)
------------+	if dex == nil {
------------+		logger.Error("Failed to create Raydium DEX instance")
------------+		return nil, fmt.Errorf("failed to create Raydium DEX instance")
+-----------+
+-----------+	deviation := math.Abs(poolPrice-v.basePrice) / v.basePrice
+-----------+	if deviation > v.maxDeviation {
+-----------+		return fmt.Errorf("pool price deviation too high: %.2f%% (pool: %.2f, base: %.2f)",
+-----------+			deviation*100, poolPrice, v.basePrice)
 -----------+	}
------------ 
-------------		fmt.Printf("DEX created: %+v\n", dex)
-------------		return dex, nil
------------+	logger.Info("Raydium DEX initialized successfully")
------------+	return dex, nil
+-----------+
+-----------+	return nil
 -----------+}
+-----------+
+-----------+func (v *BasicPriceValidator) GetMaxDeviation() float64 {
+-----------+	return v.maxDeviation
+-----------+}
+-----------+
+-----------+// NewDEX создает новый экземпляр DEX
+----------- func NewDEX(client blockchain.Client, logger *zap.Logger, poolInfo *Pool) *DEX {
+----------- 	if err := validateDEXParams(client, logger, poolInfo); err != nil {
+----------- 		logger.Error("Failed to create DEX", zap.Error(err))
+----------- 		return nil
+----------- 	}
 ----------- 
-------------	default:
-------------		fmt.Printf("Unsupported DEX: %s\n", name)
-------------		return nil, fmt.Errorf("unsupported DEX: %s", name)
------------+// initializePumpFunDEX инициализирует Pump.fun DEX
------------+func initializePumpFunDEX(_ blockchain.Client, logger *zap.Logger) (types.DEX, error) {
------------+	logger.Debug("Initializing Pump.fun DEX")
+------------	return &DEX{
+------------		client:   client,
+------------		logger:   logger.Named("raydium-dex"),
+------------		poolInfo: poolInfo,
+-----------+	priceValidator := NewBasicPriceValidator(
+-----------+		181.0, // Базовая цена SOL/USDC
+-----------+		0.5,   // 50% максимальное отклонение
+-----------+		logger,
+-----------+	)
 -----------+
------------+	// Создаем новый экземпляр Pump.fun DEX
------------+	dex := pumpfun.NewDEX()
------------+	if dex == nil {
------------+		logger.Error("Failed to create Pump.fun DEX instance")
------------+		return nil, fmt.Errorf("failed to create Pump.fun DEX instance")
+-----------+	dex := &DEX{
+-----------+		client:         client,
+-----------+		logger:         logger.Named("raydium-dex"),
+-----------+		poolInfo:       poolInfo,
+-----------+		tokenCache:     solbc.NewTokenMetadataCache(logger),
+-----------+		priceValidator: priceValidator,
 ----------- 	}
 -----------+
------------+	logger.Info("Pump.fun DEX initialized successfully")
------------+	return dex, nil
+-----------+	// Инициализируем atomic.Value
+-----------+	dex.lastPoolState.Store((*PoolState)(nil))
+-----------+
+-----------+	return dex
 ----------- }
------------diff --git a/internal/dex/pumpfun/pumpfun.go b/internal/dex/pumpfun/pumpfun.go
------------index 83e62de..a1450ec 100644
--------------- a/internal/dex/pumpfun/pumpfun.go
------------+++ b/internal/dex/pumpfun/pumpfun.go
------------@@ -1,4 +1,3 @@
-------------// internal/dex/pumpfun/pumpfun.go
------------ package pumpfun
 ----------- 
------------ import (
------------@@ -30,7 +29,6 @@ func (p *DEX) PrepareSwapInstruction(
------------ 	_ solana.PublicKey,
------------ 	_ solana.PublicKey,
------------ 	_ uint64,
-------------	_ uint64,
------------ 	_ *zap.Logger,
------------ ) (solana.Instruction, error) {
------------ 	return nil, fmt.Errorf("pump.fun DEX implementation not ready")
------------diff --git a/internal/dex/raydium/config.go b/internal/dex/raydium/config.go
------------index acf9464..cb0c21b 100644
--------------- a/internal/dex/raydium/config.go
------------+++ b/internal/dex/raydium/config.go
------------@@ -7,7 +7,7 @@ var DefaultPoolConfig = &Pool{
------------ 	AmmProgramID: "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",
+----------- func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wallet.Wallet) error {
+-----------@@ -57,7 +114,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+----------- 	)
+----------- 	logger.Info("Starting swap execution")
 ----------- 
------------ 	// Актуальная конфигурация для SOL-USDC пула
-------------	AmmID:                "EVzLJhqMtfPHFp5piYSeXqx5cY6hLbrE8oRR5Zrm1YaT",
------------+	AmmID:                "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
------------ 	AmmAuthority:         "3uaZBfHPfmpAHW7dsimC1SnyR61X4bJqQZKWmRSCXJxv",
------------ 	AmmOpenOrders:        "4NfmERReGt1QCKey8cH5q4LsBYJoUcsuGg11J8GQFwH8",
------------ 	AmmTargetOrders:      "38RJcGjtgd4SKRfY2dcM8Z9LzXQR6cyZeGxvjrRsVGZD",
------------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
------------index bcd26a9..8e2c6c3 100644
--------------- a/internal/dex/raydium/raydium.go
------------+++ b/internal/dex/raydium/raydium.go
------------@@ -9,9 +9,12 @@ import (
------------ 	"math"
------------ 	"time"
+------------	// Проверяем и получаем токен-аккаунты с таймаутом
+-----------+	// Parse token addresses
+----------- 	sourceMint, targetMint, err := parseTokenAddresses(task.SourceToken, task.TargetToken)
+----------- 	if err != nil {
+----------- 		return fmt.Errorf("invalid token addresses: %w", err)
+-----------@@ -66,12 +123,13 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+----------- 	ataCtx, ataCancel := context.WithTimeout(opCtx, ataCheckTimeout)
+----------- 	defer ataCancel()
 ----------- 
------------+	bin "github.com/gagliardetto/binary"
------------ 	"github.com/gagliardetto/solana-go"
------------ 	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
------------ 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
------------+	"github.com/gagliardetto/solana-go/programs/token"
------------+	solanarpc "github.com/gagliardetto/solana-go/rpc"
------------ 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
------------ 	"github.com/rovshanmuradov/solana-bot/internal/types"
------------ 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
------------@@ -93,7 +96,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+-----------+	// Setup token accounts
+----------- 	sourceATA, targetATA, err := r.setupTokenAccounts(ataCtx, userWallet, sourceMint, targetMint, logger)
+----------- 	if err != nil {
+----------- 		return fmt.Errorf("failed to setup token accounts: %w", err)
+----------- 	}
+----------- 
+------------	// Подготавливаем amount с учетом decimals
+-----------+	// Prepare amount with decimals
+----------- 	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
+----------- 
+----------- 	logger.Debug("Prepared swap amount",
+-----------@@ -80,11 +138,10 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+----------- 		zap.Float64("slippage_value", task.SlippageConfig.Value),
+----------- 	)
+----------- 
+------------	// Создаем инструкции с таймаутом
+----------- 	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
+----------- 	defer swapCancel()
+----------- 
+------------	// Подготавливаем все необходимые инструкции
+-----------+	// Prepare swap instructions
+----------- 	instructions, err := r.PrepareSwapInstructions(
+----------- 		swapCtx,
+----------- 		userWallet.PublicKey,
+-----------@@ -98,7 +155,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+----------- 		return fmt.Errorf("failed to prepare swap instructions: %w", err)
 ----------- 	}
 ----------- 
------------ 	// Отправляем транзакцию
-------------	signature, err := r.sendTransactionWithRetry(swapCtx, userWallet, instructions, logger)
------------+	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
+------------	// Отправляем транзакцию
+-----------+	// Send transaction
+----------- 	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
 ----------- 	if err != nil {
 ----------- 		return fmt.Errorf("failed to send swap transaction: %w", err)
------------ 	}
------------@@ -140,91 +143,139 @@ func (r *DEX) ensureATA(
------------ 	ataType string,
+-----------@@ -555,7 +612,7 @@ func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, sol
+----------- 	return sourceMint, targetMint, nil
+----------- }
+----------- 
+------------// getExpectedOutput вычисляет ожидаемый выход для свапа
+-----------+// getExpectedOutput calculates the expected output for the swap
+----------- func (r *DEX) getExpectedOutput(
+----------- 	ctx context.Context,
+----------- 	amountIn uint64,
+-----------@@ -563,52 +620,84 @@ func (r *DEX) getExpectedOutput(
+----------- 	poolInfo *Pool,
 ----------- 	logger *zap.Logger,
------------ ) error {
-------------	account, err := r.client.GetAccountInfo(ctx, ata)
------------+	logger = logger.With(
------------+		zap.String("mint", mint.String()),
------------+		zap.String("ata", ata.String()),
------------+		zap.String("wallet", wallet.PublicKey.String()),
------------+	)
------------+
------------+	// Проверяем существование ATA с повторными попытками
------------+	exists, err := r.checkATAExists(ctx, ata, logger)
+----------- ) (float64, error) {
+------------	// Создаем контекст с тайм-аутом
+------------	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
+------------	defer cancel()
+------------
+------------	logger = logger.With(
+------------		zap.String("source_token", sourceToken.String()),
+------------		zap.String("target_token", targetToken.String()),
+------------		zap.Uint64("amount_in", amountIn),
+------------	)
+------------
+------------	// Получаем состояние пула
+-----------+	// Get pool state
+----------- 	poolState, err := r.getPoolState(ctx, poolInfo)
 ----------- 	if err != nil {
------------ 		return fmt.Errorf("failed to check %s ATA: %w", ataType, err)
+----------- 		return 0, fmt.Errorf("failed to get pool state: %w", err)
 ----------- 	}
 ----------- 
-------------	if account.Value == nil {
-------------		logger.Debug("Creating ATA", zap.String("type", ataType), zap.String("address", ata.String()))
-------------
-------------		instruction := associatedtokenaccount.NewCreateInstruction(
-------------			wallet.PublicKey,
-------------			wallet.PublicKey,
-------------			mint,
-------------		).Build()
------------+	if !exists {
------------+		logger.Debug("Creating new ATA")
------------+		// Используем правильное создание инструкции из solana-go
------------+		instruction, err := r.createATAInstruction(wallet, mint)
------------+		if err != nil {
------------+			return fmt.Errorf("failed to create %s ATA instruction: %w", ataType, err)
------------+		}
+------------	logger.Debug("Pool state retrieved",
+------------		zap.Uint64("token_a_reserve", poolState.TokenAReserve),
+------------		zap.Uint64("token_b_reserve", poolState.TokenBReserve),
+------------		zap.Float64("swap_fee", poolState.SwapFee))
+-----------+	// Get decimals for tokens
+-----------+	sourceMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, sourceToken)
+-----------+	if err != nil {
+-----------+		return 0, fmt.Errorf("failed to get source token metadata: %w", err)
+-----------+	}
 ----------- 
-------------		if err := r.sendATATransaction(ctx, wallet, instruction); err != nil {
------------+		// Отправляем транзакцию и ждем подтверждения
------------+		signature, err := r.sendTransactionWithRetryAndConfirmation(ctx, wallet, []solana.Instruction{instruction}, logger)
------------+		if err != nil {
------------ 			return fmt.Errorf("failed to create %s ATA: %w", ataType, err)
------------ 		}
+------------	// Вычисляем ожидаемый выход с учетом всех факторов
+------------	expectedOut := r.calculateExpectedOutput(amountIn, poolState)
+-----------+	targetMetadata, err := r.tokenCache.GetTokenMetadata(ctx, r.client, targetToken)
+-----------+	if err != nil {
+-----------+		return 0, fmt.Errorf("failed to get target token metadata: %w", err)
+-----------+	}
 ----------- 
-------------		logger.Debug("ATA created successfully", zap.String("type", ataType))
------------+		logger.Info("ATA created successfully",
------------+			zap.String("signature", signature.String()))
+------------	logger.Debug("Expected output calculated",
+------------		zap.Float64("expected_out", expectedOut))
+-----------+	// Calculate expected output
+-----------+	expectedOut := r.calculateExpectedOutput(
+-----------+		amountIn,
+-----------+		int(sourceMetadata.Decimals),
+-----------+		int(targetMetadata.Decimals),
+-----------+		poolState,
+-----------+	)
 -----------+
------------+		// Ждем появления аккаунта
------------+		if err := r.waitForATACreation(ctx, ata, logger); err != nil {
------------+			return fmt.Errorf("failed to confirm %s ATA creation: %w", ataType, err)
------------+		}
------------ 	}
+-----------+	// Validate calculated price against market price
+-----------+	marketPrice := 181.0 // Use current market price of SOL in USDC
+-----------+	err = validateSwapAmount(expectedOut, marketPrice, amountIn,
+-----------+		int(sourceMetadata.Decimals),
+-----------+		int(targetMetadata.Decimals))
+-----------+	if err != nil {
+-----------+		return 0, fmt.Errorf("swap amount validation failed: %w", err)
+-----------+	}
 ----------- 
------------ 	return nil
+----------- 	return expectedOut, nil
 ----------- }
 ----------- 
-------------// Добавляем метод sendATATransaction
-------------func (r *DEX) sendATATransaction(ctx context.Context, wallet *wallet.Wallet, instruction solana.Instruction) error {
-------------	logger := r.logger.With(
-------------		zap.String("wallet", wallet.PublicKey.String()),
-------------		zap.String("operation", "create_ata"),
------------+func (r *DEX) checkATAExists(
------------+	ctx context.Context,
------------+	ata solana.PublicKey,
------------+	logger *zap.Logger,
------------+) (bool, error) {
------------+	for attempt := 0; attempt < maxRetries; attempt++ {
------------+		account, err := r.client.GetAccountInfo(ctx, ata)
------------+		if err == nil && account.Value != nil {
------------+			// Проверяем, что владелец - TokenProgram
------------+			return account.Value.Owner == solana.TokenProgramID, nil
------------+		}
+------------// Определяем смещения для чтения данных пула Raydium
+-----------+// getPoolState gets the current state of the pool
+-----------+// Скорректированные смещения для Raydium v4 пула
+----------- const (
+------------	// Смещения в байтах для различных полей в структуре пула
+----------- 	DISCRIMINATOR_SIZE = 8
+----------- 	STATUS_SIZE        = 1
+----------- 	NONCE_SIZE         = 1
+------------	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 байт
+-----------+	BASE_SIZE          = DISCRIMINATOR_SIZE + STATUS_SIZE + NONCE_SIZE // 10 bytes
+----------- 
+------------	// Смещения для резервов
+------------	baseVaultOffset    = BASE_SIZE + 32 + 32 + 32 // После discriminator, status, nonce и трех pubkeys
+------------	quoteVaultOffset   = baseVaultOffset + 32
+------------	baseReserveOffset  = quoteVaultOffset + 32 + 8 // +8 для uint64
+------------	quoteReserveOffset = baseReserveOffset + 8
+-----------+	// Новые смещения (в байтах)
+-----------+	baseVaultOffset    = BASE_SIZE + 96       // После discriminator + статуса + nonce + 3 pubkeys
+-----------+	quoteVaultOffset   = baseVaultOffset + 40 // После base vault + доп. данные
+-----------+	baseReserveOffset  = 178                  // Фиксированное смещение для базового резерва
+-----------+	quoteReserveOffset = 186                  // Фиксированное смещение для quote резерва
+----------- )
+----------- 
+------------// getPoolState получает текущее состояние пула
+-----------+// Добавляем новые типы для работы с ценами
+-----------+type PriceSource interface {
+-----------+	GetCurrentPrice(ctx context.Context, base, quote solana.PublicKey) (float64, error)
+-----------+}
 -----------+
------------+		if attempt < maxRetries-1 {
------------+			select {
------------+			case <-ctx.Done():
------------+				return false, ctx.Err()
------------+			case <-time.After(retryDelay):
------------+				logger.Debug("Retrying ATA check", zap.Int("attempt", attempt+1))
------------+			}
------------+		}
------------+	}
------------+	return false, nil
+-----------+type PoolPriceValidator struct {
+-----------+	priceSource  PriceSource
+-----------+	maxDeviation float64
+-----------+	logger       *zap.Logger
 -----------+}
 -----------+
------------+func (r *DEX) createATAInstruction(
------------+	wallet *wallet.Wallet,
------------+	mint solana.PublicKey,
------------+) (solana.Instruction, error) {
------------+	// Используем билдер из solana-go
------------+	inst := associatedtokenaccount.NewCreateInstruction(
------------+		wallet.PublicKey, // payer
------------+		wallet.PublicKey, // wallet address
------------+		mint,             // token mint
------------ 	)
------------ 
-------------	var lastErr error
-------------	for attempt := 0; attempt < maxRetries; attempt++ {
------------+	// Проводим валидацию
------------+	if err := inst.Validate(); err != nil {
------------+		return nil, fmt.Errorf("invalid ATA instruction: %w", err)
+-----------+func NewPoolPriceValidator(priceSource PriceSource, logger *zap.Logger) *PoolPriceValidator {
+-----------+	return &PoolPriceValidator{
+-----------+		priceSource:  priceSource,
+-----------+		maxDeviation: 0.5, // 50% максимальное отклонение
+-----------+		logger:       logger,
 -----------+	}
------------+
------------+	return inst.Build(), nil
 -----------+}
 -----------+
------------+func (r *DEX) waitForATACreation(
------------+	ctx context.Context,
------------+	ata solana.PublicKey,
------------+	logger *zap.Logger,
------------+) error {
------------+	// Увеличиваем время ожидания до 2 минут
------------+	deadline := time.Now().Add(2 * time.Minute)
------------+	// Начальный интервал проверки
------------+	ticker := time.NewTicker(2 * time.Second)
------------+	defer ticker.Stop()
------------+
------------+	retryCount := 0
------------+	maxRetries := 60 // Максимальное количество попыток
------------+
------------+	for {
------------+		if time.Now().After(deadline) {
------------+			return fmt.Errorf("timeout waiting for ATA creation after 2 minutes")
------------+		}
+-----------+// Добавляем метод для обновления валидатора цен
+-----------+func (r *DEX) SetPriceValidator(validator PriceValidator) {
+-----------+	r.priceValidator = validator
+-----------+}
 -----------+
------------+		if retryCount >= maxRetries {
------------+			return fmt.Errorf("exceeded maximum retry attempts (%d) waiting for ATA creation", maxRetries)
------------+		}
+-----------+// internal/dex/raydium/raydium.go
 -----------+
------------ 		select {
------------ 		case <-ctx.Done():
------------ 			return ctx.Err()
-------------		default:
-------------			recent, err := r.client.GetRecentBlockhash(ctx)
------------+		case <-ticker.C:
------------+			account, err := r.client.GetAccountInfo(ctx, ata)
------------ 			if err != nil {
-------------				lastErr = fmt.Errorf("failed to get recent blockhash: %w", err)
------------+				logger.Debug("ATA verification attempt failed",
------------+					zap.Error(err),
------------+					zap.Int("retry", retryCount),
------------+					zap.Time("deadline", deadline))
------------+				retryCount++
------------ 				continue
------------ 			}
------------ 
-------------			tx, err := solana.NewTransaction(
-------------				[]solana.Instruction{instruction},
-------------				recent,
-------------				solana.TransactionPayer(wallet.PublicKey),
-------------			)
-------------			if err != nil {
-------------				lastErr = fmt.Errorf("failed to create ATA transaction: %w", err)
-------------				continue
-------------			}
-------------
-------------			_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
-------------				if key.Equals(wallet.PublicKey) {
-------------					return &wallet.PrivateKey
-------------				}
------------+			if account.Value != nil && account.Value.Owner == solana.TokenProgramID {
------------+				logger.Info("ATA creation confirmed",
------------+					zap.String("ata", ata.String()),
------------+					zap.Int("retries", retryCount))
------------ 				return nil
-------------			})
-------------			if err != nil {
-------------				lastErr = fmt.Errorf("failed to sign ATA transaction: %w", err)
-------------				continue
------------ 			}
------------ 
-------------			sig, err := r.client.SendTransaction(ctx, tx)
-------------			if err != nil {
-------------				lastErr = err
-------------				logger.Warn("Failed to send ATA transaction, retrying",
-------------					zap.Int("attempt", attempt+1),
-------------					zap.Error(err))
-------------				time.Sleep(retryDelay)
-------------				continue
-------------			}
-------------
-------------			logger.Debug("ATA transaction sent successfully",
-------------				zap.String("signature", sig.String()))
-------------			return nil
------------+			logger.Debug("ATA not ready yet",
------------+				zap.String("ata", ata.String()),
------------+				zap.Int("retry", retryCount))
------------+			retryCount++
------------ 		}
------------ 	}
-------------
-------------	return fmt.Errorf("failed to send ATA transaction after %d attempts: %w", maxRetries, lastErr)
------------ }
------------ 
-------------// internal/dex/raydium/raydium.go
-------------
------------ // PrepareSwapInstructions объединяет все инструкции для свапа
------------ func (r *DEX) PrepareSwapInstructions(
------------ 	ctx context.Context,
------------@@ -343,24 +394,19 @@ func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.
------------ 		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
------------ 	}
+----------- func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
+----------- 	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
+----------- 	if err != nil {
+-----------@@ -621,7 +710,6 @@ func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, err
 ----------- 
-------------	if account.Value == nil || len(account.Value.Data.GetBinary()) < 32 {
------------+	if account.Value == nil || len(account.Value.Data.GetBinary()) < 64 {
------------ 		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
------------ 	}
+----------- 	data := poolAccount.Value.Data.GetBinary()
 ----------- 
-------------	data := account.Value.Data.GetBinary()[:32]
-------------	if len(data) != 32 {
-------------		return solana.PublicKey{}, fmt.Errorf("invalid public key length: expected 32 bytes, got %d", len(data))
------------+	var tokenAccount token.Account
------------+	if err := bin.NewBinDecoder(account.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
------------+		return solana.PublicKey{}, fmt.Errorf("failed to decode ATA data: %w", err)
------------ 	}
+------------	// Debug полных данных
+----------- 	r.logger.Debug("Full pool data",
+----------- 		zap.Binary("data", data),
+----------- 		zap.Int("length", len(data)))
+-----------@@ -635,41 +723,128 @@ func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, err
+----------- 	baseReserve := binary.LittleEndian.Uint64(data[baseReserveOffset : baseReserveOffset+8])
+----------- 	quoteReserve := binary.LittleEndian.Uint64(data[quoteReserveOffset : quoteReserveOffset+8])
 ----------- 
-------------	pubkey := solana.PublicKeyFromBytes(data)
-------------	if pubkey.IsZero() {
-------------		return solana.PublicKey{}, fmt.Errorf("invalid zero public key")
-------------	}
-------------
-------------	return pubkey, nil
------------+	return tokenAccount.Mint, nil
------------ }
+------------	r.logger.Debug("Pool reserves offsets",
+------------		zap.Int("base_offset", baseReserveOffset),
+------------		zap.Int("quote_offset", quoteReserveOffset))
+-----------+	r.logger.Debug("Raw reserves",
+-----------+		zap.Uint64("base_reserve_raw", baseReserve),
+-----------+		zap.Uint64("quote_reserve_raw", quoteReserve))
 ----------- 
-------------func (r *DEX) sendTransactionWithRetry(
------------+func (r *DEX) sendTransactionWithRetryAndConfirmation(
------------ 	ctx context.Context,
------------ 	wallet *wallet.Wallet,
------------ 	instructions []solana.Instruction,
------------@@ -373,14 +419,44 @@ func (r *DEX) sendTransactionWithRetry(
------------ 			return solana.Signature{}, ctx.Err()
------------ 		default:
------------ 			signature, err := r.sendTransaction(ctx, wallet, instructions)
-------------			if err == nil {
-------------				return signature, nil
------------+			if err != nil {
------------+				lastErr = err
------------+				logger.Warn("Retrying transaction send",
------------+					zap.Int("attempt", attempt+1),
------------+					zap.Error(err))
------------+				time.Sleep(retryDelay)
------------+				continue
------------+			}
------------+
------------+			// Ждем подтверждения транзакции
------------+			logger.Debug("Waiting for transaction confirmation",
------------+				zap.String("signature", signature.String()))
------------+
------------+			// Ждем подтверждения с таймаутом
------------+			confirmCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
------------+			defer cancel()
------------+
------------+			for {
------------+				select {
------------+				case <-confirmCtx.Done():
------------+					return signature, fmt.Errorf("timeout waiting for transaction confirmation")
------------+				case <-time.After(time.Second):
------------+					// Проверяем статус транзакции
------------+					status, err := r.getTransactionStatus(ctx, signature)
------------+					if err != nil {
------------+						logger.Debug("Failed to get transaction status", zap.Error(err))
------------+						continue
------------+					}
+------------	r.logger.Debug("Pool reserves raw bytes",
+------------		zap.Binary("base_bytes", data[baseReserveOffset:baseReserveOffset+8]),
+------------		zap.Binary("quote_bytes", data[quoteReserveOffset:quoteReserveOffset+8]))
+-----------+	// Проверяем резервы
+-----------+	if baseReserve == 0 || quoteReserve == 0 {
+-----------+		return nil, fmt.Errorf("invalid pool reserves: base=%d, quote=%d",
+-----------+			baseReserve, quoteReserve)
+-----------+	}
 -----------+
------------+					// Проверяем подтверждение
------------+					if status.Confirmations >= 1 || status.Status == "finalized" {
------------+						logger.Debug("Transaction confirmed",
------------+							zap.String("status", status.Status),
------------+							zap.Uint64("confirmations", status.Confirmations))
------------+						return signature, nil
------------+					}
------------+				}
------------ 			}
-------------			lastErr = err
-------------			logger.Warn("Retrying transaction send",
-------------				zap.Int("attempt", attempt+1),
-------------				zap.Error(err))
-------------			time.Sleep(retryDelay)
------------ 		}
------------ 	}
------------ 	return solana.Signature{}, fmt.Errorf("failed after %d attempts: %w", maxRetries, lastErr)
------------@@ -452,7 +528,7 @@ func (r *DEX) getExpectedOutput(
------------ 	poolInfo *Pool,
------------ 	logger *zap.Logger,
------------ ) (float64, error) {
-------------	// Создаем контекст с таймаутом
------------+	// Создаем контекст с тайм-аутом
------------ 	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
------------ 	defer cancel()
------------ 
------------@@ -557,3 +633,50 @@ func (r *DEX) GetAmountOutQuote(
+-----------+	// Нормализуем значения с учетом decimals
+-----------+	solAmount := float64(baseReserve) / 1e9   // 9 decimals для SOL
+-----------+	usdcAmount := float64(quoteReserve) / 1e6 // 6 decimals для USDC
+-----------+
+-----------+	poolPrice := usdcAmount / solAmount
+-----------+	r.logger.Debug("Pool price calculated",
+-----------+		zap.Float64("pool_price", poolPrice),
+-----------+		zap.Float64("sol_amount", solAmount),
+-----------+		zap.Float64("usdc_amount", usdcAmount))
+-----------+
+-----------+	// Проверяем цену через валидатор
+-----------+	if r.priceValidator != nil {
+-----------+		if err := r.priceValidator.ValidatePrice(poolPrice); err != nil {
+-----------+			return nil, fmt.Errorf("pool price validation failed: %w", err)
+-----------+		}
+-----------+	}
 ----------- 
------------ 	return expectedOut, nil
------------ }
+------------	return &PoolState{
+-----------+	state := &PoolState{
+----------- 		TokenAReserve: baseReserve,
+----------- 		TokenBReserve: quoteReserve,
+----------- 		SwapFee:       0.25,
+------------	}, nil
+-----------+		CurrentPrice:  poolPrice,
+-----------+	}
+-----------+
+-----------+	// Сохраняем новое состояние
+-----------+	r.UpdatePoolState(state)
 -----------+
------------+// TransactionStatus представляет статус транзакции
------------+type TransactionStatus struct {
------------+	Status        string
------------+	Confirmations uint64
------------+	Error         interface{}
------------+	Slot          uint64
+-----------+	return state, nil
 -----------+}
 -----------+
------------+// getConfirmations получает количество подтверждений из результата статуса
------------+func getConfirmations(status *solanarpc.SignatureStatusesResult) uint64 {
------------+	if status == nil {
------------+		return 0
+-----------+// Добавляем вспомогательные методы для работы с ценами
+-----------+// GetCurrentPoolPrice возвращает текущую цену пула
+-----------+func (r *DEX) GetCurrentPoolPrice() float64 {
+-----------+	if state := r.lastPoolState.Load().(*PoolState); state != nil {
+-----------+		return state.CurrentPrice
 -----------+	}
+-----------+	return 0
+-----------+}
 -----------+
------------+	if status.Confirmations == nil {
------------+		if status.ConfirmationStatus == solanarpc.ConfirmationStatusFinalized {
------------+			return math.MaxUint64 // Максимальное значение для финализированных транзакций
+-----------+func (r *DEX) SetMaxPriceDeviation(deviation float64) {
+-----------+	if r.priceValidator != nil {
+-----------+		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
+-----------+			basicValidator.maxDeviation = deviation
 -----------+		}
------------+		return 0
 -----------+	}
------------+	return *status.Confirmations
 -----------+}
 -----------+
------------+// getTransactionStatus получает полный статус транзакции
------------+func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signature) (*TransactionStatus, error) {
------------+	result, err := r.client.GetSignatureStatuses(ctx, signature)
------------+	if err != nil {
------------+		return nil, fmt.Errorf("failed to get signature status: %w", err)
+-----------+func (r *DEX) UpdateBasePrice(price float64) {
+-----------+	if r.priceValidator != nil {
+-----------+		if basicValidator, ok := r.priceValidator.(*BasicPriceValidator); ok {
+-----------+			basicValidator.basePrice = price
+-----------+		}
 -----------+	}
+----------- }
+----------- 
+----------- // calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
+------------func (r *DEX) calculateExpectedOutput(amountIn uint64, state *PoolState) float64 {
+------------	// Конвертируем все в float64 для точных вычислений
+------------	amountInF := float64(amountIn)
+------------	reserveInF := float64(state.TokenAReserve)
+------------	reserveOutF := float64(state.TokenBReserve)
+-----------+// calculateExpectedOutput computes the expected output based on the pool state
+-----------+func (r *DEX) calculateExpectedOutput(
+-----------+	amountIn uint64,
+-----------+	sourceDec,
+-----------+	targetDec int,
+-----------+	state *PoolState,
+-----------+) float64 {
+-----------+	logger := r.logger.With(
+-----------+		zap.Uint64("amount_in_raw", amountIn),
+-----------+		zap.Int("source_decimals", sourceDec),
+-----------+		zap.Int("target_decimals", targetDec),
+-----------+	)
 -----------+
------------+	if result == nil || len(result.Value) == 0 || result.Value[0] == nil {
------------+		return &TransactionStatus{
------------+			Status: "pending",
------------+		}, nil
------------+	}
+-----------+	// Normalize input amount
+-----------+	amountInF := float64(amountIn) / math.Pow10(sourceDec)
+-----------+	logger.Debug("Normalized input amount",
+-----------+		zap.Float64("amount_in_normalized", amountInF))
+-----------+
+-----------+	// Get normalized reserves
+-----------+	reserveIn := float64(state.TokenAReserve) / math.Pow10(sourceDec)
+-----------+	reserveOut := float64(state.TokenBReserve) / math.Pow10(targetDec)
+-----------+	logger.Debug("Normalized reserves",
+-----------+		zap.Float64("reserve_in_normalized", reserveIn),
+-----------+		zap.Float64("reserve_out_normalized", reserveOut))
 -----------+
------------+	status := result.Value[0]
------------+	confirmations := getConfirmations(status)
+-----------+	// Calculate output using constant product formula
+-----------+	amountOut := (amountInF * reserveOut * (1 - state.SwapFee/100)) / (reserveIn + amountInF*(1-state.SwapFee/100))
+-----------+	logger.Debug("Calculated amount out",
+-----------+		zap.Float64("amount_out", amountOut))
 -----------+
------------+	return &TransactionStatus{
------------+		Status:        string(status.ConfirmationStatus),
------------+		Confirmations: confirmations,
------------+		Error:         status.Err,
------------+		Slot:          status.Slot,
------------+	}, nil
+-----------+	// Convert back to lamports
+-----------+	finalOutput := amountOut * math.Pow10(targetDec)
+-----------+	logger.Debug("Final output in lamports",
+-----------+		zap.Float64("final_output_lamports", finalOutput))
+-----------+
+-----------+	return finalOutput
 -----------+}
+----------- 
+------------	// Учитываем комиссию (0.25%)
+------------	amountInWithFee := amountInF * (1 - state.SwapFee/100)
+-----------+func validateSwapAmount(expectedOut float64, currentPrice float64, amountIn uint64, sourceDec, targetDec int) error {
+-----------+	// Normalize values
+-----------+	realAmountIn := float64(amountIn) / math.Pow10(sourceDec)
+-----------+	realExpectedOut := expectedOut / math.Pow10(targetDec)
+----------- 
+------------	// Используем формулу Raydium: dy = y * dx / (x + dx)
+------------	// где dx - входная сумма с учетом комиссии
+------------	// x, y - резервы токенов
+------------	numerator := reserveOutF * amountInWithFee
+------------	denominator := reserveInF + amountInWithFee
+-----------+	// Calculate the swap price
+-----------+	calculatedPrice := realExpectedOut / realAmountIn
+----------- 
+------------	expectedOut := numerator / denominator
+-----------+	// Calculate price difference percentage
+-----------+	priceDiff := math.Abs(calculatedPrice-currentPrice) / currentPrice
+----------- 
+------------	// Применяем дополнительный запас надежности 0.5%
+------------	return expectedOut * 0.995
+-----------+	// Allow up to 20% difference
+-----------+	if priceDiff > 0.2 {
+-----------+		return fmt.Errorf("calculated price differs too much from current price: %.2f vs %.2f",
+-----------+			calculatedPrice, currentPrice)
+-----------+	}
+-----------+
+-----------+	return nil
+----------- }
+----------- 
+----------- // GetAmountOutQuote получает котировку для свапа
+-----------@@ -750,5 +925,3 @@ func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signatu
+----------- func (r *DEX) GetSignatureStatus(ctx context.Context, signature solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
+----------- 	return r.client.GetSignatureStatuses(ctx, signature)
+----------- }
+------------
+------------// Удалены неиспользуемые функции getConfirmations и waitForTransactionConfirmation
 -----------diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
------------index 85d91eb..cf37967 100644
+-----------index 2063598..61d78a0 100644
 -------------- a/internal/dex/raydium/transaction.go
 -----------+++ b/internal/dex/raydium/transaction.go
------------@@ -1,10 +1,10 @@
+-----------@@ -1,3 +1,5 @@
+-----------+// internal/dex/raydium/transaction.go
+-----------+
 ----------- package raydium
 ----------- 
 ----------- import (
-------------	"bytes"
------------ 	"context"
+-----------@@ -5,16 +7,15 @@ import (
 ----------- 	"encoding/binary"
 ----------- 	"fmt"
------------+	"testing"
+----------- 	"math"
+------------	"testing"
 ----------- 
 ----------- 	"github.com/gagliardetto/solana-go"
+-----------+	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
 ----------- 	"github.com/rovshanmuradov/solana-bot/internal/types"
------------@@ -13,23 +13,71 @@ import (
+----------- 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
+------------	"github.com/sirupsen/logrus"
+----------- 	"go.uber.org/zap"
 ----------- )
 ----------- 
------------ // Serialize сериализует данные инструкции свапа
-------------// Метод Serialize нужно обновить для корректной работы с uint8
+------------// Serialize сериализует данные инструкции свапа
+-----------+// Serialize serializes the swap instruction data
 ----------- func (s *SwapInstructionData) Serialize() ([]byte, error) {
-------------	buf := new(bytes.Buffer)
------------+	data := make([]byte, 17)
+----------- 	if err := s.Validate(); err != nil {
+----------- 		return nil, err
+-----------@@ -34,6 +35,7 @@ func (s *SwapInstructionData) Serialize() ([]byte, error) {
+----------- 	return data, nil
+----------- }
 ----------- 
-------------	// Записываем Instruction как uint8
-------------	if err := buf.WriteByte(s.Instruction); err != nil {
-------------		return nil, fmt.Errorf("failed to serialize instruction: %w", err)
------------+	// Instruction (1 byte)
------------+	data[0] = s.Instruction
------------+
------------+	// AmountIn (8 bytes)
------------+	binary.LittleEndian.PutUint64(data[1:9], s.AmountIn)
------------+
------------+	// MinAmountOut (8 bytes)
------------+	binary.LittleEndian.PutUint64(data[9:17], s.MinAmountOut)
------------+
------------+	return data, nil
------------+}
------------+
------------+// TestSwapInstructionDataSerialization тест для проверки сериализации
------------+func TestSwapInstructionDataSerialization(t *testing.T) {
------------+	inst := &SwapInstructionData{
------------+		Instruction:  1,
------------+		AmountIn:     20000000,
------------+		MinAmountOut: 6,
+-----------+// Validate validates the swap instruction data
+----------- func (s *SwapInstructionData) Validate() error {
+----------- 	if s.Instruction != 1 {
+----------- 		return fmt.Errorf("invalid instruction type: expected 1, got %d", s.Instruction)
+-----------@@ -43,99 +45,15 @@ func (s *SwapInstructionData) Validate() error {
+----------- 		return fmt.Errorf("amount_in cannot be zero")
 ----------- 	}
 ----------- 
-------------	// Записываем AmountIn и MinAmountOut как uint64
-------------	for _, v := range []uint64{s.AmountIn, s.MinAmountOut} {
-------------		if err := binary.Write(buf, binary.LittleEndian, v); err != nil {
-------------			return nil, fmt.Errorf("failed to serialize value: %w", err)
-------------		}
------------+	data, err := inst.Serialize()
------------+	if err != nil {
------------+		t.Fatalf("Failed to serialize: %v", err)
+------------	// MinimumOut может быть 0, но логируем это как предупреждение
+-----------+	// MinimumOut can be zero, but log a warning
+----------- 	if s.MinAmountOut == 0 {
+------------		logrus.Warn("minimum_out is set to zero, this may result in high slippage")
+-----------+		// You may want to log a warning here
 ----------- 	}
 ----------- 
-------------	return buf.Bytes(), nil
------------+	// Проверяем instruction code
------------+	if data[0] != 1 {
------------+		t.Errorf("Expected instruction 1, got %d", data[0])
------------+	}
------------+
------------+	// Проверяем amountIn
------------+	gotAmountIn := binary.LittleEndian.Uint64(data[1:9])
------------+	if gotAmountIn != 20000000 {
------------+		t.Errorf("Expected amountIn 20000000, got %d", gotAmountIn)
------------+	}
------------+
------------+	// Проверяем minAmountOut
------------+	gotMinAmountOut := binary.LittleEndian.Uint64(data[9:17])
------------+	if gotMinAmountOut != 6 {
------------+		t.Errorf("Expected minAmountOut 6, got %d", gotMinAmountOut)
------------+	}
------------+}
------------+
------------+// Debug выводит шестнадцатеричное представление данных
------------+func (s *SwapInstructionData) Debug(logger *zap.Logger) {
------------+	data, err := s.Serialize()
------------+	if err != nil {
------------+		logger.Error("Failed to serialize for debug", zap.Error(err))
------------+		return
------------+	}
------------+
------------+	// Проверяем данные
------------+	amountIn := binary.LittleEndian.Uint64(data[1:9])
------------+	minAmountOut := binary.LittleEndian.Uint64(data[9:17])
------------+
------------+	logger.Debug("Instruction data debug",
------------+		zap.Uint8("instruction", data[0]),
------------+		zap.Uint64("amount_in_original", s.AmountIn),
------------+		zap.Uint64("amount_in_serialized", amountIn),
------------+		zap.Uint64("min_amount_out_original", s.MinAmountOut),
------------+		zap.Uint64("min_amount_out_serialized", minAmountOut),
------------+		zap.Binary("raw_data", data))
+----------- 	return nil
 ----------- }
 ----------- 
------------ // validatePublicKey проверяет корректность публичного ключа
------------@@ -74,91 +122,125 @@ func (r *DEX) CreateSwapInstruction(
------------ 		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
------------ 	}
------------ 
-------------	ammID, err := validatePublicKey(poolInfo.AmmID)
+------------// Обновляем вычисление минимального выхода
+------------func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
+------------	if expectedOut <= 0 {
+------------		return 1 // Минимальное безопасное значение
+------------	}
+------------
+------------	// Учитываем слиппаж
+------------	minOut := expectedOut * (1 - slippagePercent/100)
+------------
+------------	// Конвертируем в uint64 и проверяем на минимальное значение
+------------	result := uint64(math.Floor(minOut))
+------------	if result == 0 {
+------------		return 1
+------------	}
+------------
+------------	return result
+------------}
+------------
+------------// TestSwapInstructionDataSerialization тест для проверки сериализации
+------------func TestSwapInstructionDataSerialization(t *testing.T) {
+------------	inst := &SwapInstructionData{
+------------		Instruction:  1,
+------------		AmountIn:     20000000,
+------------		MinAmountOut: 6,
+------------	}
+------------
+------------	data, err := inst.Serialize()
 ------------	if err != nil {
-------------		logger.Error("Invalid AmmID", zap.Error(err))
-------------		return nil, fmt.Errorf("invalid AmmID: %w", err)
+------------		t.Fatalf("Failed to serialize: %v", err)
 ------------	}
 ------------
-------------	// Создаем массив для всех аккаунтов, которые нужно проверить
-------------	accountChecks := []struct {
-------------		name    string
-------------		address string
-------------	}{
-------------		{"AmmAuthority", poolInfo.AmmAuthority},
-------------		{"AmmOpenOrders", poolInfo.AmmOpenOrders},
-------------		{"AmmTargetOrders", poolInfo.AmmTargetOrders},
-------------		{"PoolCoinTokenAccount", poolInfo.PoolCoinTokenAccount},
-------------		{"PoolPcTokenAccount", poolInfo.PoolPcTokenAccount},
-------------		{"SerumProgramID", poolInfo.SerumProgramID},
-------------		{"SerumMarket", poolInfo.SerumMarket},
-------------		{"SerumBids", poolInfo.SerumBids},
-------------		{"SerumAsks", poolInfo.SerumAsks},
-------------		{"SerumEventQueue", poolInfo.SerumEventQueue},
-------------		{"SerumCoinVaultAccount", poolInfo.SerumCoinVaultAccount},
-------------		{"SerumPcVaultAccount", poolInfo.SerumPcVaultAccount},
-------------		{"SerumVaultSigner", poolInfo.SerumVaultSigner},
+------------	// Проверяем instruction code
+------------	if data[0] != 1 {
+------------		t.Errorf("Expected instruction 1, got %d", data[0])
 ------------	}
 ------------
-------------	// Создаем слайс для аккаунтов с предварительно выделенной памятью
-------------	accounts := make([]*solana.AccountMeta, 0, len(accountChecks)+7) // +7 для базовых аккаунтов
+------------	// Проверяем amountIn
+------------	gotAmountIn := binary.LittleEndian.Uint64(data[1:9])
+------------	if gotAmountIn != 20000000 {
+------------		t.Errorf("Expected amountIn 20000000, got %d", gotAmountIn)
+------------	}
 ------------
-------------	// Добавляем базовые аккаунты
-------------	accounts = append(accounts, []*solana.AccountMeta{
-------------		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
-------------		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
-------------		{PublicKey: ammID, IsSigner: false, IsWritable: true},
-------------	}...)
+------------	// Проверяем minAmountOut
+------------	gotMinAmountOut := binary.LittleEndian.Uint64(data[9:17])
+------------	if gotMinAmountOut != 6 {
+------------		t.Errorf("Expected minAmountOut 6, got %d", gotMinAmountOut)
+------------	}
+------------}
 ------------
-------------	// Проверяем и добавляем остальные аккаунты
-------------	for _, check := range accountChecks {
-------------		pubKey, err := validatePublicKey(check.address)
------------+	// Проверяем и создаем все необходимые аккаунты
------------+	requiredAccounts := map[string]string{
------------+		"AmmID":                poolInfo.AmmID,
------------+		"AmmAuthority":         poolInfo.AmmAuthority,
------------+		"AmmOpenOrders":        poolInfo.AmmOpenOrders,
------------+		"AmmTargetOrders":      poolInfo.AmmTargetOrders,
------------+		"PoolCoinTokenAccount": poolInfo.PoolCoinTokenAccount,
------------+		"PoolPcTokenAccount":   poolInfo.PoolPcTokenAccount,
------------+		"SerumProgramID":       poolInfo.SerumProgramID,
------------+		"SerumMarket":          poolInfo.SerumMarket,
------------+		"SerumBids":            poolInfo.SerumBids,
------------+		"SerumAsks":            poolInfo.SerumAsks,
------------+		"SerumEventQueue":      poolInfo.SerumEventQueue,
------------+		"SerumCoinVault":       poolInfo.SerumCoinVaultAccount,
------------+		"SerumPcVault":         poolInfo.SerumPcVaultAccount,
------------+		"SerumVaultSigner":     poolInfo.SerumVaultSigner,
------------+	}
------------+
------------+	accounts := make(map[string]solana.PublicKey)
------------+	for name, address := range requiredAccounts {
------------+		pubKey, err := validatePublicKey(address)
------------ 		if err != nil {
-------------			logger.Error(fmt.Sprintf("Invalid %s", check.name),
-------------				zap.String("address", check.address),
------------+			logger.Error(fmt.Sprintf("Invalid %s", name),
------------+				zap.String("address", address),
------------ 				zap.Error(err))
-------------			return nil, fmt.Errorf("invalid %s: %w", check.name, err)
------------+			return nil, fmt.Errorf("invalid %s: %w", name, err)
------------ 		}
------------+		accounts[name] = pubKey
------------+	}
+------------// Debug выводит шестнадцатеричное представление данных
+------------func (s *SwapInstructionData) Debug(logger *zap.Logger) {
+------------	data, err := s.Serialize()
+------------	if err != nil {
+------------		logger.Error("Failed to serialize for debug", zap.Error(err))
+------------		return
+------------	}
+------------
+------------	// Проверяем данные
+------------	amountIn := binary.LittleEndian.Uint64(data[1:9])
+------------	minAmountOut := binary.LittleEndian.Uint64(data[9:17])
+------------
+------------	logger.Debug("Instruction data debug",
+------------		zap.Uint8("instruction", data[0]),
+------------		zap.Uint64("amount_in_original", s.AmountIn),
+------------		zap.Uint64("amount_in_serialized", amountIn),
+------------		zap.Uint64("min_amount_out_original", s.MinAmountOut),
+------------		zap.Uint64("min_amount_out_serialized", minAmountOut),
+------------		zap.Binary("raw_data", data))
+------------}
+------------
+------------// validatePublicKey проверяет корректность публичного ключа
+------------func validatePublicKey(key string) (solana.PublicKey, error) {
+------------	if key == "" {
+------------		return solana.PublicKey{}, fmt.Errorf("empty public key")
+------------	}
+------------
+------------	pubKey, err := solana.PublicKeyFromBase58(key)
+------------	if err != nil {
+------------		return solana.PublicKey{}, fmt.Errorf("invalid public key %s: %w", key, err)
+------------	}
+------------
+------------	return pubKey, nil
+------------}
+------------
+------------// CreateSwapInstruction создает инструкцию свапа для Raydium
+-----------+// CreateSwapInstruction creates a swap instruction for Raydium
+----------- func (r *DEX) CreateSwapInstruction(
+----------- 	userWallet solana.PublicKey,
+----------- 	userSourceTokenAccount solana.PublicKey,
+-----------@@ -156,14 +74,14 @@ func (r *DEX) CreateSwapInstruction(
+----------- 		return nil, fmt.Errorf("pool info is nil")
+----------- 	}
 ----------- 
-------------		isWritable := false
-------------		switch check.name {
-------------		case "AmmOpenOrders", "AmmTargetOrders", "PoolCoinTokenAccount",
-------------			"PoolPcTokenAccount", "SerumMarket", "SerumBids", "SerumAsks",
-------------			"SerumEventQueue", "SerumCoinVaultAccount", "SerumPcVaultAccount":
-------------			isWritable = true
-------------		}
------------+	// Создаем слайс аккаунтов в правильном порядке для Raydium
------------+	metas := make(solana.AccountMetaSlice, 0, 20)
+------------	// Проверяем и конвертируем все необходимые публичные ключи
+-----------+	// Validate and parse all necessary public keys
+----------- 	ammProgramID, err := validatePublicKey(poolInfo.AmmProgramID)
+----------- 	if err != nil {
+----------- 		logger.Error("Invalid AmmProgramID", zap.Error(err))
+----------- 		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
+----------- 	}
 ----------- 
-------------		accounts = append(accounts, &solana.AccountMeta{
-------------			PublicKey:  pubKey,
-------------			IsSigner:   false,
-------------			IsWritable: isWritable,
-------------		})
-------------	}
------------+	// Токен аккаунты пользователя
------------+	metas = append(metas,
------------+		&solana.AccountMeta{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
------------+	)
------------+
------------+	// Аккаунты AMM
------------+	metas = append(metas,
------------+		&solana.AccountMeta{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
------------+		&solana.AccountMeta{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
------------+	)
------------+
------------+	// Аккаунты Serum
------------+	metas = append(metas,
------------+		&solana.AccountMeta{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
------------+		&solana.AccountMeta{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
------------+		&solana.AccountMeta{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
------------+	)
+------------	// Проверяем и создаем все необходимые аккаунты
+-----------+	// Map of required accounts with their names
+----------- 	requiredAccounts := map[string]string{
+----------- 		"AmmID":                poolInfo.AmmID,
+----------- 		"AmmAuthority":         poolInfo.AmmAuthority,
+-----------@@ -193,56 +111,42 @@ func (r *DEX) CreateSwapInstruction(
+----------- 		accounts[name] = pubKey
+----------- 	}
 ----------- 
-------------	// Добавляем системные аккаунты
-------------	accounts = append(accounts, []*solana.AccountMeta{
-------------		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
-------------		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
-------------		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
-------------		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
-------------	}...)
------------+	// Системные аккаунты
------------+	metas = append(metas,
------------+		&solana.AccountMeta{PublicKey: userWallet, IsSigner: true, IsWritable: false},
------------+		&solana.AccountMeta{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
------------+		&solana.AccountMeta{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
------------+		&solana.AccountMeta{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
------------+	)
+------------	// Создаем слайс аккаунтов в правильном порядке для Raydium
+------------	metas := make(solana.AccountMetaSlice, 0, 20)
+------------
+------------	// Токен аккаунты пользователя
+------------	metas = append(metas,
+------------		&solana.AccountMeta{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
+------------	)
+------------
+------------	// Аккаунты AMM
+------------	metas = append(metas,
+------------		&solana.AccountMeta{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
+------------		&solana.AccountMeta{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
+------------	)
+------------
+------------	// Аккаунты Serum
+------------	metas = append(metas,
+------------		&solana.AccountMeta{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
+------------		&solana.AccountMeta{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
+------------		&solana.AccountMeta{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
+------------	)
+------------
+------------	// Системные аккаунты
+------------	metas = append(metas,
+------------		&solana.AccountMeta{PublicKey: userWallet, IsSigner: true, IsWritable: false},
+------------		&solana.AccountMeta{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
+------------		&solana.AccountMeta{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
+------------		&solana.AccountMeta{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
+------------	)
+-----------+	// Create the account meta slice in the correct order
+-----------+	metas := solana.AccountMetaSlice{
+-----------+		// User accounts
+-----------+		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
+-----------+		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
+-----------+		// Pool accounts
+-----------+		{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
+-----------+		{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
+-----------+		// Serum accounts
+-----------+		{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
+-----------+		{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
+-----------+		{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
+-----------+		// System accounts
+-----------+		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
+-----------+		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
+-----------+		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
+-----------+	}
 ----------- 
------------ 	// Создание данных инструкции
-------------	instructionData := SwapInstructionData{
------------+	instructionData := &SwapInstructionData{
+------------	// Создание данных инструкции
+-----------+	// Create swap instruction data
+----------- 	instructionData := &SwapInstructionData{
 ----------- 		Instruction:  poolInfo.RaydiumSwapInstructionCode,
 ----------- 		AmountIn:     amountIn,
 ----------- 		MinAmountOut: minAmountOut,
 ----------- 	}
 ----------- 
------------+	// Добавляем отладочный вывод
------------+	instructionData.Debug(logger)
------------+
------------+	// Сериализация
+------------	// Добавляем отладочный вывод
+------------	instructionData.Debug(logger)
+------------
+------------	// Сериализация
+-----------+	// Serialize instruction data
 ----------- 	data, err := instructionData.Serialize()
 ----------- 	if err != nil {
-------------		logger.Error("Failed to serialize instruction data", zap.Error(err))
------------+		logger.Error("Failed to serialize instruction data",
------------+			zap.Error(err),
------------+			zap.Uint8("instruction", instructionData.Instruction),
------------+			zap.Uint64("amount_in", instructionData.AmountIn),
------------+			zap.Uint64("min_amount_out", instructionData.MinAmountOut))
+----------- 		logger.Error("Failed to serialize instruction data",
+-----------@@ -253,39 +157,17 @@ func (r *DEX) CreateSwapInstruction(
 ----------- 		return nil, fmt.Errorf("failed to serialize instruction data: %w", err)
 ----------- 	}
 ----------- 
-------------	instruction := solana.NewInstruction(ammProgramID, accounts, data)
------------+	// Проверка сериализованных данных
------------+	if len(data) != 17 {
------------+		logger.Error("Invalid serialized data length",
------------+			zap.Int("got_length", len(data)),
------------+			zap.Int("expected_length", 17))
------------+		return nil, fmt.Errorf("invalid serialized data length")
+------------	// Проверка сериализованных данных
+------------	if len(data) != 17 {
+------------		logger.Error("Invalid serialized data length",
+------------			zap.Int("got_length", len(data)),
+------------			zap.Int("expected_length", 17))
+------------		return nil, fmt.Errorf("invalid serialized data length")
+------------	}
+------------
+------------	// Проверяем значения после сериализации
+------------	amountInCheck := binary.LittleEndian.Uint64(data[1:9])
+------------	minAmountOutCheck := binary.LittleEndian.Uint64(data[9:17])
+------------
+------------	logger.Debug("Serialized data check",
+------------		zap.Uint64("amount_in_check", amountInCheck),
+------------		zap.Uint64("min_amount_out_check", minAmountOutCheck))
+------------
+------------	if amountInCheck != amountIn {
+------------		logger.Error("AmountIn mismatch after serialization",
+------------			zap.Uint64("original", amountIn),
+------------			zap.Uint64("serialized", amountInCheck))
+------------		return nil, fmt.Errorf("amountIn mismatch after serialization")
+------------	}
+------------
+-----------+	// Create the instruction
+----------- 	instruction := solana.NewInstruction(ammProgramID, metas, data)
+----------- 
+------------	logger.Debug("Created instruction",
+-----------+	logger.Debug("Created swap instruction",
+----------- 		zap.Int("num_accounts", len(metas)),
+----------- 		zap.Int("data_len", len(data)))
+----------- 
+----------- 	return instruction, nil
+----------- }
+----------- 
+------------// PrepareAndSendTransaction готовит и отправляет транзакцию свапа
+-----------+// PrepareAndSendTransaction prepares and sends the swap transaction
+----------- func (r *DEX) PrepareAndSendTransaction(
+----------- 	ctx context.Context,
+----------- 	task *types.Task,
+-----------@@ -299,23 +181,18 @@ func (r *DEX) PrepareAndSendTransaction(
+----------- 		return fmt.Errorf("failed to get recent blockhash: %w", err)
+----------- 	}
+----------- 
+------------	// Создаем compute budget инструкции с использованием нового PriorityManager
+------------	priorityManager := types.NewPriorityManager(logger)
+------------	budgetInstructions, err := priorityManager.CreateCustomPriorityInstructions(
+------------		uint64(task.PriorityFee*1e6), // Конвертируем SOL в микро-ламports
+------------		1_000_000,                    // Используем sniping units
+------------	)
+------------	if err != nil {
+------------		logger.Error("Failed to create compute budget instructions", zap.Error(err))
+------------		return fmt.Errorf("failed to create compute budget instructions: %w", err)
+------------	}
+-----------+	// Create compute budget instruction if needed
+-----------+	computeBudgetInst := computebudget.NewSetComputeUnitPriceInstruction(
+-----------+		uint64(task.PriorityFee * 1e6), // Convert SOL to micro-lamports
+-----------+	).Build()
+----------- 
+------------	// Combine all instructions properly
+------------	instructions := make([]solana.Instruction, 0, len(budgetInstructions)+1)
+------------	instructions = append(instructions, budgetInstructions...)
+------------	instructions = append(instructions, swapInstruction)
+-----------+	// Combine all instructions
+-----------+	instructions := []solana.Instruction{
+-----------+		computeBudgetInst,
+-----------+		swapInstruction,
+-----------+	}
+----------- 
+------------	// Создаем транзакцию
+-----------+	// Create the transaction
+----------- 	tx, err := solana.NewTransaction(
+----------- 		instructions,
+----------- 		recentBlockhash,
+-----------@@ -326,7 +203,7 @@ func (r *DEX) PrepareAndSendTransaction(
+----------- 		return fmt.Errorf("failed to create transaction: %w", err)
+----------- 	}
+----------- 
+------------	// Подписываем транзакцию
+-----------+	// Sign the transaction
+----------- 	_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+----------- 		if key.Equals(userWallet.PublicKey) {
+----------- 			return &userWallet.PrivateKey
+-----------@@ -338,7 +215,7 @@ func (r *DEX) PrepareAndSendTransaction(
+----------- 		return fmt.Errorf("failed to sign transaction: %w", err)
+----------- 	}
+----------- 
+------------	// Отправляем транзакцию
+-----------+	// Send the transaction
+----------- 	signature, err := r.client.SendTransaction(ctx, tx)
+----------- 	if err != nil {
+----------- 		logger.Error("Failed to send transaction", zap.Error(err))
+-----------@@ -347,8 +224,41 @@ func (r *DEX) PrepareAndSendTransaction(
+----------- 
+----------- 	logger.Info("Transaction sent successfully",
+----------- 		zap.String("signature", signature.String()),
+------------		zap.Float64("priority_fee_sol", task.PriorityFee),
+------------		zap.Uint64("compute_units", 1_000_000))
+-----------+		zap.Float64("priority_fee_sol", task.PriorityFee))
+----------- 
+----------- 	return nil
+----------- }
+-----------+
+-----------+// validatePublicKey checks if a public key string is valid
+-----------+func validatePublicKey(key string) (solana.PublicKey, error) {
+-----------+	if key == "" {
+-----------+		return solana.PublicKey{}, fmt.Errorf("empty public key")
+-----------+	}
+-----------+
+-----------+	pubKey, err := solana.PublicKeyFromBase58(key)
+-----------+	if err != nil {
+-----------+		return solana.PublicKey{}, fmt.Errorf("invalid public key %s: %w", key, err)
 -----------+	}
 -----------+
------------+	// Проверяем значения после сериализации
------------+	amountInCheck := binary.LittleEndian.Uint64(data[1:9])
------------+	minAmountOutCheck := binary.LittleEndian.Uint64(data[9:17])
+-----------+	return pubKey, nil
+-----------+}
+-----------+
+-----------+// Helper function to calculate minimum output considering slippage
+-----------+func calculateMinimumOut(expectedOut float64, slippagePercent float64) uint64 {
+-----------+	if expectedOut <= 0 {
+-----------+		return 1 // Minimum safe value
+-----------+	}
 -----------+
------------+	logger.Debug("Serialized data check",
------------+		zap.Uint64("amount_in_check", amountInCheck),
------------+		zap.Uint64("min_amount_out_check", minAmountOutCheck))
+-----------+	// Consider slippage
+-----------+	minOut := expectedOut * (1 - slippagePercent/100)
 -----------+
------------+	if amountInCheck != amountIn {
------------+		logger.Error("AmountIn mismatch after serialization",
------------+			zap.Uint64("original", amountIn),
------------+			zap.Uint64("serialized", amountInCheck))
------------+		return nil, fmt.Errorf("amountIn mismatch after serialization")
+-----------+	// Convert to uint64 and check for minimum value
+-----------+	result := uint64(math.Floor(minOut))
+-----------+	if result == 0 {
+-----------+		return 1
 -----------+	}
 -----------+
------------+	instruction := solana.NewInstruction(ammProgramID, metas, data)
+-----------+	return result
+-----------+}
 -----------+
------------+	logger.Debug("Created instruction",
------------+		zap.Int("num_accounts", len(metas)),
------------+		zap.Int("data_len", len(data)))
------------ 
-------------	logger.Debug("Swap instruction created successfully")
------------ 	return instruction, nil
------------ }
------------ 
+-----------+// You may want to include other helper functions or adjust existing ones as needed
 -----------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
------------index cd3089e..4cc1b1e 100644
+-----------index 001489f..7db11c6 100644
 -------------- a/internal/dex/raydium/types.go
 -----------+++ b/internal/dex/raydium/types.go
------------@@ -27,11 +27,10 @@ type Pool struct {
+-----------@@ -1,8 +1,13 @@
+----------- // internal/dex/raydium/types.go
+-----------+
+----------- package raydium
+----------- 
+----------- import (
+-----------+	"sync"
+-----------+	"sync/atomic"
+-----------+
+----------- 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+-----------+	"github.com/rovshanmuradov/solana-bot/internal/blockchain/solbc"
+----------- 	"go.uber.org/zap"
+----------- )
+----------- 
+-----------@@ -25,6 +30,12 @@ type Pool struct {
+----------- 	SerumVaultSigner           string
+----------- 	RaydiumSwapInstructionCode uint8
 ----------- }
+-----------+type PoolState struct {
+-----------+	TokenAReserve uint64
+-----------+	TokenBReserve uint64
+-----------+	SwapFee       float64 // в процентах
+-----------+	CurrentPrice  float64 // текущая цена пула
+-----------+}
 ----------- 
 ----------- // SwapInstructionData представляет данные инструкции свапа
-------------// Обновляем также структуру инструкции
 ----------- type SwapInstructionData struct {
-------------	Instruction  uint8 // Изменено на uint8
-------------	AmountIn     uint64
-------------	MinAmountOut uint64
------------+	Instruction  uint8  // Тип инструкции
------------+	AmountIn     uint64 // Входящая сумма
------------+	MinAmountOut uint64 // Минимальная исходящая сумма
+-----------@@ -33,32 +44,60 @@ type SwapInstructionData struct {
+----------- 	MinAmountOut uint64 // Минимальная исходящая сумма
 ----------- }
 ----------- type DEX struct {
------------ 	client   blockchain.Client // изменяем тип на интерфейс.
+------------	client   blockchain.Client // изменяем тип на интерфейс.
+------------	logger   *zap.Logger
+------------	poolInfo *Pool
+------------	slippage float64 // Добавляем поле для slippage
+-----------+	client         blockchain.Client
+-----------+	logger         *zap.Logger
+-----------+	poolInfo       *Pool
+-----------+	slippage       float64
+-----------+	tokenCache     *solbc.TokenMetadataCache
+-----------+	priceValidator PriceValidator
+-----------+	lastPoolState  atomic.Value // Используем atomic.Value для потокобезопасного доступа
+-----------+	stateMutex     sync.RWMutex // Мьютекс для дополнительной синхронизации при необходимости
+----------- }
+----------- 
+------------func (r *Pool) GetProgramID() string {
+------------	return r.AmmProgramID
+-----------+// setLastPoolState безопасно обновляет состояние пула
+-----------+func (r *DEX) setLastPoolState(state *PoolState) {
+-----------+	r.lastPoolState.Store(state)
+----------- }
+----------- 
+------------func (r *Pool) GetPoolID() string {
+------------	return r.AmmID
+-----------+// getLastPoolState безопасно получает состояние пула
+-----------+func (r *DEX) getLastPoolState() *PoolState {
+-----------+	return r.lastPoolState.Load().(*PoolState)
+----------- }
+----------- 
+------------func (r *Pool) GetTokenAccounts() (string, string) {
+------------	return r.PoolCoinTokenAccount, r.PoolPcTokenAccount
+-----------+// UpdatePoolState обновляет состояние пула с дополнительной синхронизацией
+-----------+func (r *DEX) UpdatePoolState(state *PoolState) {
+-----------+	r.stateMutex.Lock()
+-----------+	defer r.stateMutex.Unlock()
+-----------+
+-----------+	r.setLastPoolState(state)
+-----------+
+-----------+	// Логируем обновление состояния
+-----------+	r.logger.Debug("Pool state updated",
+-----------+		zap.Float64("current_price", state.CurrentPrice),
+-----------+		zap.Uint64("token_a_reserve", state.TokenAReserve),
+-----------+		zap.Uint64("token_b_reserve", state.TokenBReserve))
+-----------+}
+-----------+
+-----------+// GetPoolStateSnapshot получает снапшот текущего состояния пула
+-----------+func (r *DEX) GetPoolStateSnapshot() *PoolState {
+-----------+	r.stateMutex.RLock()
+-----------+	defer r.stateMutex.RUnlock()
+-----------+
+-----------+	state := r.getLastPoolState()
+-----------+	if state == nil {
+-----------+		return nil
+-----------+	}
+-----------+
+-----------+	// Возвращаем копию состояния
+-----------+	return &PoolState{
+-----------+		TokenAReserve: state.TokenAReserve,
+-----------+		TokenBReserve: state.TokenBReserve,
+-----------+		SwapFee:       state.SwapFee,
+-----------+		CurrentPrice:  state.CurrentPrice,
+-----------+	}
+----------- }
+----------- 
+----------- // Name возвращает имя DEX
+----------- func (r *DEX) Name() string {
+----------- 	return "Raydium"
+----------- }
+------------
+------------// PoolState содержит состояние пула ликвидности
+------------type PoolState struct {
+------------	TokenAReserve uint64
+------------	TokenBReserve uint64
+------------	SwapFee       float64 // в процентах
+------------}
 -----------diff --git a/newdif.txt b/newdif.txt
------------index 073754f..a086373 100644
+-----------index cc2c079..c7ae03d 100644
 -------------- a/newdif.txt
 -----------+++ b/newdif.txt
------------@@ -1,436 +0,0 @@
+-----------@@ -1,1340 +0,0 @@
+------------diff --git a/TODO.md b/TODO.md
+------------index 5b1d499..34aab1e 100644
+--------------- a/TODO.md
+------------+++ b/TODO.md
+------------@@ -264,3 +264,8 @@
+------------     - [ ] Например, прогнозирование цен, анализ рынка и т.д.
+------------ - [ ] Рассмотреть возможность масштабирования
+------------     - [ ] Настроить приложение для работы в распределенной среде.
+------------+
+------------+
+------------+TODO: Оптимизация работы с ATA (Associated Token Accounts)
+------------+1. Этап подготовки и архитектуры
+------------+
 ------------diff --git a/configs/tasks.csv b/configs/tasks.csv
-------------index e44faa8..33e5da0 100644
+------------index 33e5da0..bbc2c6d 100644
 --------------- a/configs/tasks.csv
 ------------+++ b/configs/tasks.csv
 ------------@@ -1,2 +1,2 @@
 ------------ TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,MinAmountOut,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
--------------buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,,,,,100,
+-------------buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
 ------------\ No newline at end of file
-------------+buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
+------------+buyTokens,Raydium,1,wallet1,100,0.0001,58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
 ------------\ No newline at end of file
-------------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
-------------index 1703360..bcd26a9 100644
---------------- a/internal/dex/raydium/raydium.go
-------------+++ b/internal/dex/raydium/raydium.go
-------------@@ -4,6 +4,7 @@ package raydium
+------------diff --git a/internal/blockchain/solbc/client.go b/internal/blockchain/solbc/client.go
+------------index 75b6e0d..bcfeacc 100644
+--------------- a/internal/blockchain/solbc/client.go
+------------+++ b/internal/blockchain/solbc/client.go
+------------@@ -64,3 +64,6 @@ func (c *Client) Close() error {
+------------ 	c.rpc.Close()
+------------ 	return nil
+------------ }
+------------+func (c *Client) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
+------------+	return c.rpc.GetSignatureStatuses(ctx, signatures...)
+------------+}
+------------diff --git a/internal/blockchain/solbc/rpc/rpc.go b/internal/blockchain/solbc/rpc/rpc.go
+------------index ee4c137..ac6f2c4 100644
+--------------- a/internal/blockchain/solbc/rpc/rpc.go
+------------+++ b/internal/blockchain/solbc/rpc/rpc.go
+------------@@ -144,5 +144,16 @@ func (c *RPCClient) SendTransaction(ctx context.Context, tx *solana.Transaction)
+------------ 	return signature, err
+------------ }
+------------ 
+------------+// Добавляем новый метод в RPCClient
+------------+func (c *RPCClient) GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*solanarpc.GetSignatureStatusesResult, error) {
+------------+	var result *solanarpc.GetSignatureStatusesResult
+------------+	err := c.ExecuteWithRetry(ctx, func(client *solanarpc.Client) error {
+------------+		var err error
+------------+		result, err = client.GetSignatureStatuses(ctx, false, signatures...)
+------------+		return err
+------------+	})
+------------+	return result, err
+------------+}
+------------+
+------------ // Close закрывает клиент
+------------ func (c *RPCClient) Close() {}
+------------diff --git a/internal/blockchain/solbc/types.go b/internal/blockchain/solbc/types.go
+------------index cc61a29..42debad 100644
+--------------- a/internal/blockchain/solbc/types.go
+------------+++ b/internal/blockchain/solbc/types.go
+------------@@ -19,7 +19,7 @@ type TokenMetadataCache struct {
+------------ 
+------------ // Client представляет основной клиент Solana
+------------ type Client struct {
+-------------	rpc     *rpc.RPCClient // Меняем тип с enhancedRPC на RPCClient
+------------+	rpc     *rpc.RPCClient
+------------ 	logger  *zap.Logger
+------------ 	metrics *ClientMetrics
+------------ }
+------------diff --git a/internal/blockchain/types.go b/internal/blockchain/types.go
+------------index 2690c82..202b59a 100644
+--------------- a/internal/blockchain/types.go
+------------+++ b/internal/blockchain/types.go
+------------@@ -13,4 +13,5 @@ type Client interface {
+------------ 	GetRecentBlockhash(ctx context.Context) (solana.Hash, error)
+------------ 	SendTransaction(ctx context.Context, tx *solana.Transaction) (solana.Signature, error)
+------------ 	GetAccountInfo(ctx context.Context, pubkey solana.PublicKey) (*rpc.GetAccountInfoResult, error)
+------------+	GetSignatureStatuses(ctx context.Context, signatures ...solana.Signature) (*rpc.GetSignatureStatusesResult, error)
+------------ }
+------------diff --git a/internal/dex/dex.go b/internal/dex/dex.go
+------------index 5aebaa7..9b9fb16 100644
+--------------- a/internal/dex/dex.go
+------------+++ b/internal/dex/dex.go
+------------@@ -1,62 +1,79 @@
+-------------// internal/dex/dex.go
+------------ package dex
 ------------ 
 ------------ import (
------------- 	"context"
-------------+	"encoding/binary"
+-------------	"errors"
 ------------ 	"fmt"
------------- 	"math"
------------- 	"time"
-------------@@ -45,6 +46,8 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
------------- 	logger := r.logger.With(
------------- 		zap.String("task", task.TaskName),
------------- 		zap.String("wallet", userWallet.PublicKey.String()),
-------------+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
-------------+		zap.Float64("slippage_value", task.SlippageConfig.Value),
------------- 	)
------------- 	logger.Info("Starting swap execution")
+------------ 	"strings"
+------------ 
+------------ 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+------------+	"github.com/rovshanmuradov/solana-bot/internal/dex/pumpfun"
+------------ 	"github.com/rovshanmuradov/solana-bot/internal/dex/raydium"
+------------ 	"github.com/rovshanmuradov/solana-bot/internal/types"
+------------ 	"go.uber.org/zap"
+------------ )
 ------------ 
-------------@@ -64,11 +67,12 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+------------+// GetDEXByName возвращает имплементацию DEX по имени
+------------ func GetDEXByName(name string, client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
+-------------	logger = logger.With(zap.String("dex_name", name))
+-------------	logger.Info("Getting DEX by name")
+-------------	fmt.Printf("\n=== Getting DEX by name: %s ===\n", name)
+------------+	if client == nil {
+------------+		return nil, fmt.Errorf("client cannot be nil")
+------------+	}
 ------------ 
------------- 	// Подготавливаем amount с учетом decimals
------------- 	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
--------------	minAmountOut := uint64(task.MinAmountOut * math.Pow10(task.TargetTokenDecimals))
+------------ 	if logger == nil {
+-------------		fmt.Println("Logger is nil")
+-------------		return nil, errors.New("logger is nil")
+------------+		return nil, fmt.Errorf("logger cannot be nil")
+------------ 	}
 ------------ 
--------------	logger.Debug("Prepared swap amounts",
-------------+	logger.Debug("Prepared swap amount",
------------- 		zap.Uint64("amount_in", amountIn),
--------------		zap.Uint64("min_amount_out", minAmountOut))
-------------+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
-------------+		zap.Float64("slippage_value", task.SlippageConfig.Value),
-------------+	)
+-------------	name = strings.TrimSpace(name)
+------------+	name = strings.TrimSpace(strings.ToLower(name))
+------------ 	if name == "" {
+-------------		fmt.Println("DEX name is empty")
+-------------		return nil, errors.New("DEX name cannot be empty")
+------------+		return nil, fmt.Errorf("DEX name cannot be empty")
+------------ 	}
 ------------ 
------------- 	// Создаем инструкции с таймаутом
------------- 	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
-------------@@ -81,7 +85,6 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
------------- 		sourceATA,
------------- 		targetATA,
------------- 		amountIn,
--------------		minAmountOut,
------------- 		task.PriorityFee,
------------- 		logger,
------------- 	)
-------------@@ -220,7 +223,8 @@ func (r *DEX) sendATATransaction(ctx context.Context, wallet *wallet.Wallet, ins
------------- 	return fmt.Errorf("failed to send ATA transaction after %d attempts: %w", maxRetries, lastErr)
------------- }
+-------------	fmt.Printf("Client nil? %v\n", client == nil)
+------------+	logger = logger.With(zap.String("dex_name", name))
+------------+	logger.Info("Initializing DEX instance")
+------------ 
+-------------	if client == nil {
+-------------		fmt.Println("Solana client is nil")
+-------------		return nil, errors.New("solana client cannot be nil")
+------------+	switch name {
+------------+	case "raydium":
+------------+		return initializeRaydiumDEX(client, logger)
+------------+	case "pump.fun":
+------------+		return initializePumpFunDEX(client, logger)
+------------+	default:
+------------+		logger.Error("Unsupported DEX requested", zap.String("name", name))
+------------+		return nil, fmt.Errorf("unsupported DEX: %s", name)
+------------ 	}
+------------+}
+------------ 
+-------------	switch strings.ToLower(name) {
+-------------	case strings.ToLower("Raydium"):
+-------------		fmt.Println("Creating Raydium DEX instance")
+------------+// initializeRaydiumDEX инициализирует Raydium DEX
+------------+func initializeRaydiumDEX(client blockchain.Client, logger *zap.Logger) (types.DEX, error) {
+------------+	logger.Debug("Initializing Raydium DEX")
+------------ 
+-------------		if raydium.DefaultPoolConfig == nil {
+-------------			fmt.Println("Default pool config is nil")
+-------------			return nil, errors.New("default pool config is nil")
+-------------		}
+------------+	if raydium.DefaultPoolConfig == nil {
+------------+		logger.Error("Default pool configuration is missing")
+------------+		return nil, fmt.Errorf("raydium default pool config is nil")
+------------+	}
+------------ 
+-------------		fmt.Printf("Pool config: %+v\n", raydium.DefaultPoolConfig)
+------------+	logger.Debug("Creating Raydium DEX instance",
+------------+		zap.String("pool_id", raydium.DefaultPoolConfig.AmmID),
+------------+		zap.String("program_id", raydium.DefaultPoolConfig.AmmProgramID))
+------------ 
+-------------		dex := raydium.NewDEX(client, logger, raydium.DefaultPoolConfig)
+-------------		if dex == nil {
+-------------			fmt.Println("Failed to create Raydium DEX instance")
+-------------			return nil, errors.New("failed to create Raydium DEX instance")
+-------------		}
+------------+	dex := raydium.NewDEX(client, logger, raydium.DefaultPoolConfig)
+------------+	if dex == nil {
+------------+		logger.Error("Failed to create Raydium DEX instance")
+------------+		return nil, fmt.Errorf("failed to create Raydium DEX instance")
+------------+	}
+------------ 
+-------------		fmt.Printf("DEX created: %+v\n", dex)
+-------------		return dex, nil
+------------+	logger.Info("Raydium DEX initialized successfully")
+------------+	return dex, nil
+------------+}
 ------------ 
--------------// Добавляем метод PrepareSwapInstruction для соответствия интерфейсу types.DEX
-------------+// internal/dex/raydium/raydium.go
+-------------	default:
+-------------		fmt.Printf("Unsupported DEX: %s\n", name)
+-------------		return nil, fmt.Errorf("unsupported DEX: %s", name)
+------------+// initializePumpFunDEX инициализирует Pump.fun DEX
+------------+func initializePumpFunDEX(_ blockchain.Client, logger *zap.Logger) (types.DEX, error) {
+------------+	logger.Debug("Initializing Pump.fun DEX")
 ------------+
------------- // PrepareSwapInstructions объединяет все инструкции для свапа
------------- func (r *DEX) PrepareSwapInstructions(
------------- 	ctx context.Context,
-------------@@ -228,7 +232,6 @@ func (r *DEX) PrepareSwapInstructions(
------------- 	sourceATA solana.PublicKey,
------------- 	targetATA solana.PublicKey,
------------- 	amountIn uint64,
--------------	minAmountOut uint64,
------------- 	priorityFee float64,
------------- 	logger *zap.Logger,
------------- ) ([]solana.Instruction, error) {
-------------@@ -247,7 +250,6 @@ func (r *DEX) PrepareSwapInstructions(
------------- 		sourceATA,
------------- 		targetATA,
------------- 		amountIn,
--------------		minAmountOut,
------------- 		logger,
------------- 	)
+------------+	// Создаем новый экземпляр Pump.fun DEX
+------------+	dex := pumpfun.NewDEX()
+------------+	if dex == nil {
+------------+		logger.Error("Failed to create Pump.fun DEX instance")
+------------+		return nil, fmt.Errorf("failed to create Pump.fun DEX instance")
+------------ 	}
+------------+
+------------+	logger.Info("Pump.fun DEX initialized successfully")
+------------+	return dex, nil
+------------ }
+------------diff --git a/internal/dex/pumpfun/pumpfun.go b/internal/dex/pumpfun/pumpfun.go
+------------index 83e62de..a1450ec 100644
+--------------- a/internal/dex/pumpfun/pumpfun.go
+------------+++ b/internal/dex/pumpfun/pumpfun.go
+------------@@ -1,4 +1,3 @@
+-------------// internal/dex/pumpfun/pumpfun.go
+------------ package pumpfun
+------------ 
+------------ import (
+------------@@ -30,7 +29,6 @@ func (p *DEX) PrepareSwapInstruction(
+------------ 	_ solana.PublicKey,
+------------ 	_ solana.PublicKey,
+------------ 	_ uint64,
+-------------	_ uint64,
+------------ 	_ *zap.Logger,
+------------ ) (solana.Instruction, error) {
+------------ 	return nil, fmt.Errorf("pump.fun DEX implementation not ready")
+------------diff --git a/internal/dex/raydium/config.go b/internal/dex/raydium/config.go
+------------index acf9464..cb0c21b 100644
+--------------- a/internal/dex/raydium/config.go
+------------+++ b/internal/dex/raydium/config.go
+------------@@ -7,7 +7,7 @@ var DefaultPoolConfig = &Pool{
+------------ 	AmmProgramID: "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",
+------------ 
+------------ 	// Актуальная конфигурация для SOL-USDC пула
+-------------	AmmID:                "EVzLJhqMtfPHFp5piYSeXqx5cY6hLbrE8oRR5Zrm1YaT",
+------------+	AmmID:                "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
+------------ 	AmmAuthority:         "3uaZBfHPfmpAHW7dsimC1SnyR61X4bJqQZKWmRSCXJxv",
+------------ 	AmmOpenOrders:        "4NfmERReGt1QCKey8cH5q4LsBYJoUcsuGg11J8GQFwH8",
+------------ 	AmmTargetOrders:      "38RJcGjtgd4SKRfY2dcM8Z9LzXQR6cyZeGxvjrRsVGZD",
+------------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
+------------index bcd26a9..8e2c6c3 100644
+--------------- a/internal/dex/raydium/raydium.go
+------------+++ b/internal/dex/raydium/raydium.go
+------------@@ -9,9 +9,12 @@ import (
+------------ 	"math"
+------------ 	"time"
+------------ 
+------------+	bin "github.com/gagliardetto/binary"
+------------ 	"github.com/gagliardetto/solana-go"
+------------ 	associatedtokenaccount "github.com/gagliardetto/solana-go/programs/associated-token-account"
+------------ 	computebudget "github.com/gagliardetto/solana-go/programs/compute-budget"
+------------+	"github.com/gagliardetto/solana-go/programs/token"
+------------+	solanarpc "github.com/gagliardetto/solana-go/rpc"
+------------ 	"github.com/rovshanmuradov/solana-bot/internal/blockchain"
+------------ 	"github.com/rovshanmuradov/solana-bot/internal/types"
+------------ 	"github.com/rovshanmuradov/solana-bot/internal/wallet"
+------------@@ -93,7 +96,7 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+------------ 	}
+------------ 
+------------ 	// Отправляем транзакцию
+-------------	signature, err := r.sendTransactionWithRetry(swapCtx, userWallet, instructions, logger)
+------------+	signature, err := r.sendTransactionWithRetryAndConfirmation(swapCtx, userWallet, instructions, logger)
 ------------ 	if err != nil {
-------------@@ -265,7 +267,6 @@ func (r *DEX) PrepareSwapInstruction(
------------- 	sourceATA solana.PublicKey,
------------- 	targetATA solana.PublicKey,
------------- 	amountIn uint64,
--------------	minAmountOut uint64,
+------------ 		return fmt.Errorf("failed to send swap transaction: %w", err)
+------------ 	}
+------------@@ -140,91 +143,139 @@ func (r *DEX) ensureATA(
+------------ 	ataType string,
 ------------ 	logger *zap.Logger,
------------- ) (solana.Instruction, error) {
------------- 	logger = logger.With(
-------------@@ -275,8 +276,34 @@ func (r *DEX) PrepareSwapInstruction(
------------- 	)
------------- 	logger.Debug("Preparing swap instruction")
+------------ ) error {
+-------------	account, err := r.client.GetAccountInfo(ctx, ata)
+------------+	logger = logger.With(
+------------+		zap.String("mint", mint.String()),
+------------+		zap.String("ata", ata.String()),
+------------+		zap.String("wallet", wallet.PublicKey.String()),
+------------+	)
+------------+
+------------+	// Проверяем существование ATA с повторными попытками
+------------+	exists, err := r.checkATAExists(ctx, ata, logger)
+------------ 	if err != nil {
+------------ 		return fmt.Errorf("failed to check %s ATA: %w", ataType, err)
+------------ 	}
 ------------ 
--------------	// Создаем инструкцию свапа
--------------	instruction, err := r.CreateSwapInstruction(
-------------+	// Получаем ожидаемый выход
-------------+	sourceMint, err := r.getMintFromATA(ctx, sourceATA)
-------------+	if err != nil {
-------------+		return nil, fmt.Errorf("failed to get source mint: %w", err)
-------------+	}
+-------------	if account.Value == nil {
+-------------		logger.Debug("Creating ATA", zap.String("type", ataType), zap.String("address", ata.String()))
+-------------
+-------------		instruction := associatedtokenaccount.NewCreateInstruction(
+-------------			wallet.PublicKey,
+-------------			wallet.PublicKey,
+-------------			mint,
+-------------		).Build()
+------------+	if !exists {
+------------+		logger.Debug("Creating new ATA")
+------------+		// Используем правильное создание инструкции из solana-go
+------------+		instruction, err := r.createATAInstruction(wallet, mint)
+------------+		if err != nil {
+------------+			return fmt.Errorf("failed to create %s ATA instruction: %w", ataType, err)
+------------+		}
+------------ 
+-------------		if err := r.sendATATransaction(ctx, wallet, instruction); err != nil {
+------------+		// Отправляем транзакцию и ждем подтверждения
+------------+		signature, err := r.sendTransactionWithRetryAndConfirmation(ctx, wallet, []solana.Instruction{instruction}, logger)
+------------+		if err != nil {
+------------ 			return fmt.Errorf("failed to create %s ATA: %w", ataType, err)
+------------ 		}
+------------ 
+-------------		logger.Debug("ATA created successfully", zap.String("type", ataType))
+------------+		logger.Info("ATA created successfully",
+------------+			zap.String("signature", signature.String()))
 ------------+
-------------+	targetMint, err := r.getMintFromATA(ctx, targetATA)
-------------+	if err != nil {
-------------+		return nil, fmt.Errorf("failed to get target mint: %w", err)
-------------+	}
+------------+		// Ждем появления аккаунта
+------------+		if err := r.waitForATACreation(ctx, ata, logger); err != nil {
+------------+			return fmt.Errorf("failed to confirm %s ATA creation: %w", ataType, err)
+------------+		}
+------------ 	}
+------------ 
+------------ 	return nil
+------------ }
+------------ 
+-------------// Добавляем метод sendATATransaction
+-------------func (r *DEX) sendATATransaction(ctx context.Context, wallet *wallet.Wallet, instruction solana.Instruction) error {
+-------------	logger := r.logger.With(
+-------------		zap.String("wallet", wallet.PublicKey.String()),
+-------------		zap.String("operation", "create_ata"),
+------------+func (r *DEX) checkATAExists(
+------------+	ctx context.Context,
+------------+	ata solana.PublicKey,
+------------+	logger *zap.Logger,
+------------+) (bool, error) {
+------------+	for attempt := 0; attempt < maxRetries; attempt++ {
+------------+		account, err := r.client.GetAccountInfo(ctx, ata)
+------------+		if err == nil && account.Value != nil {
+------------+			// Проверяем, что владелец - TokenProgram
+------------+			return account.Value.Owner == solana.TokenProgramID, nil
+------------+		}
 ------------+
-------------+	expectedOut, err := r.getExpectedOutput(
-------------+		ctx,
-------------+		amountIn,
-------------+		sourceMint,
-------------+		targetMint,
-------------+		r.poolInfo,
-------------+		logger,
-------------+	)
-------------+	if err != nil {
-------------+		return nil, fmt.Errorf("failed to get expected output: %w", err)
+------------+		if attempt < maxRetries-1 {
+------------+			select {
+------------+			case <-ctx.Done():
+------------+				return false, ctx.Err()
+------------+			case <-time.After(retryDelay):
+------------+				logger.Debug("Retrying ATA check", zap.Int("attempt", attempt+1))
+------------+			}
+------------+		}
 ------------+	}
+------------+	return false, nil
+------------+}
 ------------+
-------------+	// Используем безопасное значение minAmountOut по умолчанию (99% от ожидаемого выхода)
-------------+	minAmountOut := uint64(float64(expectedOut) * 0.99)
-------------+
-------------+	// Создаем инструкцию свапа с помощью внутреннего метода createSwapInstruction
-------------+	return r.createSwapInstruction(
------------- 		wallet,
------------- 		sourceATA,
------------- 		targetATA,
-------------@@ -285,12 +312,52 @@ func (r *DEX) PrepareSwapInstruction(
------------- 		logger,
------------- 		r.poolInfo,
+------------+func (r *DEX) createATAInstruction(
+------------+	wallet *wallet.Wallet,
+------------+	mint solana.PublicKey,
+------------+) (solana.Instruction, error) {
+------------+	// Используем билдер из solana-go
+------------+	inst := associatedtokenaccount.NewCreateInstruction(
+------------+		wallet.PublicKey, // payer
+------------+		wallet.PublicKey, // wallet address
+------------+		mint,             // token mint
 ------------ 	)
+------------ 
+-------------	var lastErr error
+-------------	for attempt := 0; attempt < maxRetries; attempt++ {
+------------+	// Проводим валидацию
+------------+	if err := inst.Validate(); err != nil {
+------------+		return nil, fmt.Errorf("invalid ATA instruction: %w", err)
+------------+	}
+------------+
+------------+	return inst.Build(), nil
 ------------+}
 ------------+
-------------+// createSwapInstruction внутренний метод для создания инструкции свапа
-------------+func (r *DEX) createSwapInstruction(
-------------+	wallet solana.PublicKey,
-------------+	sourceATA solana.PublicKey,
-------------+	targetATA solana.PublicKey,
-------------+	amountIn uint64,
-------------+	minAmountOut uint64,
+------------+func (r *DEX) waitForATACreation(
+------------+	ctx context.Context,
+------------+	ata solana.PublicKey,
 ------------+	logger *zap.Logger,
-------------+	poolInfo *Pool,
-------------+) (solana.Instruction, error) {
-------------+	// Существующая логика из CreateSwapInstruction
-------------+	return r.CreateSwapInstruction(
-------------+		wallet,
-------------+		sourceATA,
-------------+		targetATA,
-------------+		amountIn,
-------------+		minAmountOut,
-------------+		logger,
-------------+		poolInfo,
-------------+	)
-------------+}
+------------+) error {
+------------+	// Увеличиваем время ожидания до 2 минут
+------------+	deadline := time.Now().Add(2 * time.Minute)
+------------+	// Начальный интервал проверки
+------------+	ticker := time.NewTicker(2 * time.Second)
+------------+	defer ticker.Stop()
 ------------+
-------------+// Вспомогательный метод для получения mint address из ATA
-------------+func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.PublicKey, error) {
-------------+	account, err := r.client.GetAccountInfo(ctx, ata)
------------- 	if err != nil {
--------------		return nil, fmt.Errorf("failed to create swap instruction: %w", err)
-------------+		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
------------- 	}
------------- 
--------------	logger.Debug("Swap instruction prepared successfully")
--------------	return instruction, nil
-------------+	if account.Value == nil || len(account.Value.Data.GetBinary()) < 32 {
-------------+		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
-------------+	}
+------------+	retryCount := 0
+------------+	maxRetries := 60 // Максимальное количество попыток
 ------------+
-------------+	data := account.Value.Data.GetBinary()[:32]
-------------+	if len(data) != 32 {
-------------+		return solana.PublicKey{}, fmt.Errorf("invalid public key length: expected 32 bytes, got %d", len(data))
-------------+	}
+------------+	for {
+------------+		if time.Now().After(deadline) {
+------------+			return fmt.Errorf("timeout waiting for ATA creation after 2 minutes")
+------------+		}
 ------------+
-------------+	pubkey := solana.PublicKeyFromBytes(data)
-------------+	if pubkey.IsZero() {
-------------+		return solana.PublicKey{}, fmt.Errorf("invalid zero public key")
-------------+	}
+------------+		if retryCount >= maxRetries {
+------------+			return fmt.Errorf("exceeded maximum retry attempts (%d) waiting for ATA creation", maxRetries)
+------------+		}
 ------------+
-------------+	return pubkey, nil
+------------ 		select {
+------------ 		case <-ctx.Done():
+------------ 			return ctx.Err()
+-------------		default:
+-------------			recent, err := r.client.GetRecentBlockhash(ctx)
+------------+		case <-ticker.C:
+------------+			account, err := r.client.GetAccountInfo(ctx, ata)
+------------ 			if err != nil {
+-------------				lastErr = fmt.Errorf("failed to get recent blockhash: %w", err)
+------------+				logger.Debug("ATA verification attempt failed",
+------------+					zap.Error(err),
+------------+					zap.Int("retry", retryCount),
+------------+					zap.Time("deadline", deadline))
+------------+				retryCount++
+------------ 				continue
+------------ 			}
+------------ 
+-------------			tx, err := solana.NewTransaction(
+-------------				[]solana.Instruction{instruction},
+-------------				recent,
+-------------				solana.TransactionPayer(wallet.PublicKey),
+-------------			)
+-------------			if err != nil {
+-------------				lastErr = fmt.Errorf("failed to create ATA transaction: %w", err)
+-------------				continue
+-------------			}
+-------------
+-------------			_, err = tx.Sign(func(key solana.PublicKey) *solana.PrivateKey {
+-------------				if key.Equals(wallet.PublicKey) {
+-------------					return &wallet.PrivateKey
+-------------				}
+------------+			if account.Value != nil && account.Value.Owner == solana.TokenProgramID {
+------------+				logger.Info("ATA creation confirmed",
+------------+					zap.String("ata", ata.String()),
+------------+					zap.Int("retries", retryCount))
+------------ 				return nil
+-------------			})
+-------------			if err != nil {
+-------------				lastErr = fmt.Errorf("failed to sign ATA transaction: %w", err)
+-------------				continue
+------------ 			}
+------------ 
+-------------			sig, err := r.client.SendTransaction(ctx, tx)
+-------------			if err != nil {
+-------------				lastErr = err
+-------------				logger.Warn("Failed to send ATA transaction, retrying",
+-------------					zap.Int("attempt", attempt+1),
+-------------					zap.Error(err))
+-------------				time.Sleep(retryDelay)
+-------------				continue
+-------------			}
+-------------
+-------------			logger.Debug("ATA transaction sent successfully",
+-------------				zap.String("signature", sig.String()))
+-------------			return nil
+------------+			logger.Debug("ATA not ready yet",
+------------+				zap.String("ata", ata.String()),
+------------+				zap.Int("retry", retryCount))
+------------+			retryCount++
+------------ 		}
+------------ 	}
+-------------
+-------------	return fmt.Errorf("failed to send ATA transaction after %d attempts: %w", maxRetries, lastErr)
 ------------ }
 ------------ 
------------- func (r *DEX) sendTransactionWithRetry(
-------------@@ -376,3 +443,117 @@ func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, sol
+-------------// internal/dex/raydium/raydium.go
+-------------
+------------ // PrepareSwapInstructions объединяет все инструкции для свапа
+------------ func (r *DEX) PrepareSwapInstructions(
+------------ 	ctx context.Context,
+------------@@ -343,24 +394,19 @@ func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.
+------------ 		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
+------------ 	}
+------------ 
+-------------	if account.Value == nil || len(account.Value.Data.GetBinary()) < 32 {
+------------+	if account.Value == nil || len(account.Value.Data.GetBinary()) < 64 {
+------------ 		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
+------------ 	}
+------------ 
+-------------	data := account.Value.Data.GetBinary()[:32]
+-------------	if len(data) != 32 {
+-------------		return solana.PublicKey{}, fmt.Errorf("invalid public key length: expected 32 bytes, got %d", len(data))
+------------+	var tokenAccount token.Account
+------------+	if err := bin.NewBinDecoder(account.Value.Data.GetBinary()).Decode(&tokenAccount); err != nil {
+------------+		return solana.PublicKey{}, fmt.Errorf("failed to decode ATA data: %w", err)
+------------ 	}
 ------------ 
------------- 	return sourceMint, targetMint, nil
+-------------	pubkey := solana.PublicKeyFromBytes(data)
+-------------	if pubkey.IsZero() {
+-------------		return solana.PublicKey{}, fmt.Errorf("invalid zero public key")
+-------------	}
+-------------
+-------------	return pubkey, nil
+------------+	return tokenAccount.Mint, nil
 ------------ }
+------------ 
+-------------func (r *DEX) sendTransactionWithRetry(
+------------+func (r *DEX) sendTransactionWithRetryAndConfirmation(
+------------ 	ctx context.Context,
+------------ 	wallet *wallet.Wallet,
+------------ 	instructions []solana.Instruction,
+------------@@ -373,14 +419,44 @@ func (r *DEX) sendTransactionWithRetry(
+------------ 			return solana.Signature{}, ctx.Err()
+------------ 		default:
+------------ 			signature, err := r.sendTransaction(ctx, wallet, instructions)
+-------------			if err == nil {
+-------------				return signature, nil
+------------+			if err != nil {
+------------+				lastErr = err
+------------+				logger.Warn("Retrying transaction send",
+------------+					zap.Int("attempt", attempt+1),
+------------+					zap.Error(err))
+------------+				time.Sleep(retryDelay)
+------------+				continue
+------------+			}
 ------------+
-------------+// getExpectedOutput вычисляет ожидаемый выход для свапа
-------------+func (r *DEX) getExpectedOutput(
-------------+	ctx context.Context,
-------------+	amountIn uint64,
-------------+	sourceToken, targetToken solana.PublicKey,
-------------+	poolInfo *Pool,
-------------+	logger *zap.Logger,
-------------+) (float64, error) {
-------------+	// Создаем контекст с таймаутом
-------------+	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
-------------+	defer cancel()
-------------+
-------------+	logger = logger.With(
-------------+		zap.String("source_token", sourceToken.String()),
-------------+		zap.String("target_token", targetToken.String()),
-------------+		zap.Uint64("amount_in", amountIn),
-------------+	)
-------------+
-------------+	// Получаем состояние пула
-------------+	poolState, err := r.getPoolState(ctx, poolInfo)
-------------+	if err != nil {
-------------+		return 0, fmt.Errorf("failed to get pool state: %w", err)
-------------+	}
+------------+			// Ждем подтверждения транзакции
+------------+			logger.Debug("Waiting for transaction confirmation",
+------------+				zap.String("signature", signature.String()))
 ------------+
-------------+	logger.Debug("Pool state retrieved",
-------------+		zap.Uint64("token_a_reserve", poolState.TokenAReserve),
-------------+		zap.Uint64("token_b_reserve", poolState.TokenBReserve),
-------------+		zap.Float64("swap_fee", poolState.SwapFee))
+------------+			// Ждем подтверждения с таймаутом
+------------+			confirmCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
+------------+			defer cancel()
 ------------+
-------------+	// Вычисляем ожидаемый выход с учетом всех факторов
-------------+	expectedOut := r.calculateExpectedOutput(amountIn, poolState)
+------------+			for {
+------------+				select {
+------------+				case <-confirmCtx.Done():
+------------+					return signature, fmt.Errorf("timeout waiting for transaction confirmation")
+------------+				case <-time.After(time.Second):
+------------+					// Проверяем статус транзакции
+------------+					status, err := r.getTransactionStatus(ctx, signature)
+------------+					if err != nil {
+------------+						logger.Debug("Failed to get transaction status", zap.Error(err))
+------------+						continue
+------------+					}
 ------------+
-------------+	logger.Debug("Expected output calculated",
-------------+		zap.Float64("expected_out", expectedOut))
+------------+					// Проверяем подтверждение
+------------+					if status.Confirmations >= 1 || status.Status == "finalized" {
+------------+						logger.Debug("Transaction confirmed",
+------------+							zap.String("status", status.Status),
+------------+							zap.Uint64("confirmations", status.Confirmations))
+------------+						return signature, nil
+------------+					}
+------------+				}
+------------ 			}
+-------------			lastErr = err
+-------------			logger.Warn("Retrying transaction send",
+-------------				zap.Int("attempt", attempt+1),
+-------------				zap.Error(err))
+-------------			time.Sleep(retryDelay)
+------------ 		}
+------------ 	}
+------------ 	return solana.Signature{}, fmt.Errorf("failed after %d attempts: %w", maxRetries, lastErr)
+------------@@ -452,7 +528,7 @@ func (r *DEX) getExpectedOutput(
+------------ 	poolInfo *Pool,
+------------ 	logger *zap.Logger,
+------------ ) (float64, error) {
+-------------	// Создаем контекст с таймаутом
+------------+	// Создаем контекст с тайм-аутом
+------------ 	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
+------------ 	defer cancel()
+------------ 
+------------@@ -557,3 +633,50 @@ func (r *DEX) GetAmountOutQuote(
+------------ 
+------------ 	return expectedOut, nil
+------------ }
 ------------+
-------------+	return expectedOut, nil
+------------+// TransactionStatus представляет статус транзакции
+------------+type TransactionStatus struct {
+------------+	Status        string
+------------+	Confirmations uint64
+------------+	Error         interface{}
+------------+	Slot          uint64
 ------------+}
 ------------+
-------------+// getPoolState получает текущее состояние пула
-------------+func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
-------------+	// Получаем аккаунт пула
-------------+	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
-------------+	if err != nil {
-------------+		return nil, fmt.Errorf("failed to get pool account: %w", err)
+------------+// getConfirmations получает количество подтверждений из результата статуса
+------------+func getConfirmations(status *solanarpc.SignatureStatusesResult) uint64 {
+------------+	if status == nil {
+------------+		return 0
 ------------+	}
 ------------+
-------------+	if poolAccount == nil || poolAccount.Value == nil {
-------------+		return nil, fmt.Errorf("pool account not found")
+------------+	if status.Confirmations == nil {
+------------+		if status.ConfirmationStatus == solanarpc.ConfirmationStatusFinalized {
+------------+			return math.MaxUint64 // Максимальное значение для финализированных транзакций
+------------+		}
+------------+		return 0
 ------------+	}
+------------+	return *status.Confirmations
+------------+}
 ------------+
-------------+	// Парсим данные аккаунта
-------------+	data := poolAccount.Value.Data.GetBinary()
-------------+	if len(data) < 8+32*2 { // Минимальный размер для резервов
-------------+		return nil, fmt.Errorf("invalid pool account data size")
+------------+// getTransactionStatus получает полный статус транзакции
+------------+func (r *DEX) getTransactionStatus(ctx context.Context, signature solana.Signature) (*TransactionStatus, error) {
+------------+	result, err := r.client.GetSignatureStatuses(ctx, signature)
+------------+	if err != nil {
+------------+		return nil, fmt.Errorf("failed to get signature status: %w", err)
 ------------+	}
 ------------+
-------------+	// Извлекаем резервы из данных аккаунта
-------------+	// Обратите внимание: это упрощенная версия, реальная структура данных может отличаться
-------------+	tokenAReserve := binary.LittleEndian.Uint64(data[8:16])
-------------+	tokenBReserve := binary.LittleEndian.Uint64(data[16:24])
+------------+	if result == nil || len(result.Value) == 0 || result.Value[0] == nil {
+------------+		return &TransactionStatus{
+------------+			Status: "pending",
+------------+		}, nil
+------------+	}
 ------------+
-------------+	// Получаем информацию о комиссии пула
-------------+	swapFee := 0.25 // 0.25% это стандартная комиссия Raydium
+------------+	status := result.Value[0]
+------------+	confirmations := getConfirmations(status)
 ------------+
-------------+	return &PoolState{
-------------+		TokenAReserve: tokenAReserve,
-------------+		TokenBReserve: tokenBReserve,
-------------+		SwapFee:       swapFee,
+------------+	return &TransactionStatus{
+------------+		Status:        string(status.ConfirmationStatus),
+------------+		Confirmations: confirmations,
+------------+		Error:         status.Err,
+------------+		Slot:          status.Slot,
 ------------+	}, nil
 ------------+}
+------------diff --git a/internal/dex/raydium/transaction.go b/internal/dex/raydium/transaction.go
+------------index 85d91eb..cf37967 100644
+--------------- a/internal/dex/raydium/transaction.go
+------------+++ b/internal/dex/raydium/transaction.go
+------------@@ -1,10 +1,10 @@
+------------ package raydium
+------------ 
+------------ import (
+-------------	"bytes"
+------------ 	"context"
+------------ 	"encoding/binary"
+------------ 	"fmt"
+------------+	"testing"
+------------ 
+------------ 	"github.com/gagliardetto/solana-go"
+------------ 	"github.com/rovshanmuradov/solana-bot/internal/types"
+------------@@ -13,23 +13,71 @@ import (
+------------ )
+------------ 
+------------ // Serialize сериализует данные инструкции свапа
+-------------// Метод Serialize нужно обновить для корректной работы с uint8
+------------ func (s *SwapInstructionData) Serialize() ([]byte, error) {
+-------------	buf := new(bytes.Buffer)
+------------+	data := make([]byte, 17)
+------------ 
+-------------	// Записываем Instruction как uint8
+-------------	if err := buf.WriteByte(s.Instruction); err != nil {
+-------------		return nil, fmt.Errorf("failed to serialize instruction: %w", err)
+------------+	// Instruction (1 byte)
+------------+	data[0] = s.Instruction
 ------------+
-------------+// calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
-------------+func (r *DEX) calculateExpectedOutput(amountIn uint64, state *PoolState) float64 {
-------------+	// Константа k = x * y, где x и y - резервы токенов
-------------+	k := float64(state.TokenAReserve) * float64(state.TokenBReserve)
-------------+
-------------+	// Вычисляем amount_in после комиссии
-------------+	amountInAfterFee := float64(amountIn) * (1 - state.SwapFee/100)
+------------+	// AmountIn (8 bytes)
+------------+	binary.LittleEndian.PutUint64(data[1:9], s.AmountIn)
 ------------+
-------------+	// Новый резерв входного токена
-------------+	newSourceReserve := float64(state.TokenAReserve) + amountInAfterFee
+------------+	// MinAmountOut (8 bytes)
+------------+	binary.LittleEndian.PutUint64(data[9:17], s.MinAmountOut)
 ------------+
-------------+	// Вычисляем новый резерв выходного токена используя формулу k = x * y
-------------+	newTargetReserve := k / newSourceReserve
+------------+	return data, nil
+------------+}
 ------------+
-------------+	// Ожидаемый выход это разница между старым и новым резервом
-------------+	expectedOut := float64(state.TokenBReserve) - newTargetReserve
+------------+// TestSwapInstructionDataSerialization тест для проверки сериализации
+------------+func TestSwapInstructionDataSerialization(t *testing.T) {
+------------+	inst := &SwapInstructionData{
+------------+		Instruction:  1,
+------------+		AmountIn:     20000000,
+------------+		MinAmountOut: 6,
+------------ 	}
+------------ 
+-------------	// Записываем AmountIn и MinAmountOut как uint64
+-------------	for _, v := range []uint64{s.AmountIn, s.MinAmountOut} {
+-------------		if err := binary.Write(buf, binary.LittleEndian, v); err != nil {
+-------------			return nil, fmt.Errorf("failed to serialize value: %w", err)
+-------------		}
+------------+	data, err := inst.Serialize()
+------------+	if err != nil {
+------------+		t.Fatalf("Failed to serialize: %v", err)
+------------ 	}
+------------ 
+-------------	return buf.Bytes(), nil
+------------+	// Проверяем instruction code
+------------+	if data[0] != 1 {
+------------+		t.Errorf("Expected instruction 1, got %d", data[0])
+------------+	}
 ------------+
-------------+	// Применяем дополнительный запас надежности
-------------+	safetyFactor := 0.995 // 0.5% запас для учета изменения цены
-------------+	return expectedOut * safetyFactor
-------------+}
+------------+	// Проверяем amountIn
+------------+	gotAmountIn := binary.LittleEndian.Uint64(data[1:9])
+------------+	if gotAmountIn != 20000000 {
+------------+		t.Errorf("Expected amountIn 20000000, got %d", gotAmountIn)
+------------+	}
 ------------+
-------------+// GetAmountOutQuote получает котировку для свапа
-------------+func (r *DEX) GetAmountOutQuote(
-------------+	ctx context.Context,
-------------+	amountIn uint64,
-------------+	sourceToken, targetToken solana.PublicKey,
-------------+) (float64, error) {
-------------+	// Создаем временный пул для получения котировки
-------------+	poolInfo := r.poolInfo
-------------+	if poolInfo == nil {
-------------+		return 0, fmt.Errorf("pool info not configured")
+------------+	// Проверяем minAmountOut
+------------+	gotMinAmountOut := binary.LittleEndian.Uint64(data[9:17])
+------------+	if gotMinAmountOut != 6 {
+------------+		t.Errorf("Expected minAmountOut 6, got %d", gotMinAmountOut)
 ------------+	}
+------------+}
 ------------+
-------------+	// Получаем ожидаемый выход
-------------+	expectedOut, err := r.getExpectedOutput(ctx, amountIn, sourceToken, targetToken, poolInfo, r.logger)
+------------+// Debug выводит шестнадцатеричное представление данных
+------------+func (s *SwapInstructionData) Debug(logger *zap.Logger) {
+------------+	data, err := s.Serialize()
 ------------+	if err != nil {
-------------+		return 0, fmt.Errorf("failed to get expected output: %w", err)
+------------+		logger.Error("Failed to serialize for debug", zap.Error(err))
+------------+		return
 ------------+	}
 ------------+
-------------+	return expectedOut, nil
-------------+}
-------------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
-------------index dd0f18f..cd3089e 100644
---------------- a/internal/dex/raydium/types.go
-------------+++ b/internal/dex/raydium/types.go
-------------@@ -55,3 +55,10 @@ func (r *Pool) GetTokenAccounts() (string, string) {
------------- func (r *DEX) Name() string {
------------- 	return "Raydium"
------------- }
+------------+	// Проверяем данные
+------------+	amountIn := binary.LittleEndian.Uint64(data[1:9])
+------------+	minAmountOut := binary.LittleEndian.Uint64(data[9:17])
 ------------+
-------------+// PoolState содержит состояние пула ликвидности
-------------+type PoolState struct {
-------------+	TokenAReserve uint64
-------------+	TokenBReserve uint64
-------------+	SwapFee       float64 // в процентах
-------------+}
-------------diff --git a/internal/dex/raydium/validation.go b/internal/dex/raydium/validation.go
-------------index a948715..9267897 100644
---------------- a/internal/dex/raydium/validation.go
-------------+++ b/internal/dex/raydium/validation.go
-------------@@ -1,5 +1,4 @@
------------- // internal/dex/raydium/validation.go
--------------
------------- package raydium
+------------+	logger.Debug("Instruction data debug",
+------------+		zap.Uint8("instruction", data[0]),
+------------+		zap.Uint64("amount_in_original", s.AmountIn),
+------------+		zap.Uint64("amount_in_serialized", amountIn),
+------------+		zap.Uint64("min_amount_out_original", s.MinAmountOut),
+------------+		zap.Uint64("min_amount_out_serialized", minAmountOut),
+------------+		zap.Binary("raw_data", data))
+------------ }
 ------------ 
------------- import (
-------------@@ -11,7 +10,6 @@ import (
+------------ // validatePublicKey проверяет корректность публичного ключа
+------------@@ -74,91 +122,125 @@ func (r *DEX) CreateSwapInstruction(
+------------ 		return nil, fmt.Errorf("invalid AmmProgramID: %w", err)
+------------ 	}
 ------------ 
------------- // ValidateTask проверяет корректность параметров задачи
------------- func ValidateTask(task *types.Task) error {
+-------------	ammID, err := validatePublicKey(poolInfo.AmmID)
+-------------	if err != nil {
+-------------		logger.Error("Invalid AmmID", zap.Error(err))
+-------------		return nil, fmt.Errorf("invalid AmmID: %w", err)
+-------------	}
 -------------
------------- 	if task == nil {
------------- 		return fmt.Errorf("task cannot be nil")
------------- 	}
-------------@@ -41,8 +39,20 @@ func ValidateTask(task *types.Task) error {
------------- 		return fmt.Errorf("amount in must be greater than 0")
------------- 	}
+-------------	// Создаем массив для всех аккаунтов, которые нужно проверить
+-------------	accountChecks := []struct {
+-------------		name    string
+-------------		address string
+-------------	}{
+-------------		{"AmmAuthority", poolInfo.AmmAuthority},
+-------------		{"AmmOpenOrders", poolInfo.AmmOpenOrders},
+-------------		{"AmmTargetOrders", poolInfo.AmmTargetOrders},
+-------------		{"PoolCoinTokenAccount", poolInfo.PoolCoinTokenAccount},
+-------------		{"PoolPcTokenAccount", poolInfo.PoolPcTokenAccount},
+-------------		{"SerumProgramID", poolInfo.SerumProgramID},
+-------------		{"SerumMarket", poolInfo.SerumMarket},
+-------------		{"SerumBids", poolInfo.SerumBids},
+-------------		{"SerumAsks", poolInfo.SerumAsks},
+-------------		{"SerumEventQueue", poolInfo.SerumEventQueue},
+-------------		{"SerumCoinVaultAccount", poolInfo.SerumCoinVaultAccount},
+-------------		{"SerumPcVaultAccount", poolInfo.SerumPcVaultAccount},
+-------------		{"SerumVaultSigner", poolInfo.SerumVaultSigner},
+-------------	}
+-------------
+-------------	// Создаем слайс для аккаунтов с предварительно выделенной памятью
+-------------	accounts := make([]*solana.AccountMeta, 0, len(accountChecks)+7) // +7 для базовых аккаунтов
+-------------
+-------------	// Добавляем базовые аккаунты
+-------------	accounts = append(accounts, []*solana.AccountMeta{
+-------------		{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
+-------------		{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
+-------------		{PublicKey: ammID, IsSigner: false, IsWritable: true},
+-------------	}...)
+-------------
+-------------	// Проверяем и добавляем остальные аккаунты
+-------------	for _, check := range accountChecks {
+-------------		pubKey, err := validatePublicKey(check.address)
+------------+	// Проверяем и создаем все необходимые аккаунты
+------------+	requiredAccounts := map[string]string{
+------------+		"AmmID":                poolInfo.AmmID,
+------------+		"AmmAuthority":         poolInfo.AmmAuthority,
+------------+		"AmmOpenOrders":        poolInfo.AmmOpenOrders,
+------------+		"AmmTargetOrders":      poolInfo.AmmTargetOrders,
+------------+		"PoolCoinTokenAccount": poolInfo.PoolCoinTokenAccount,
+------------+		"PoolPcTokenAccount":   poolInfo.PoolPcTokenAccount,
+------------+		"SerumProgramID":       poolInfo.SerumProgramID,
+------------+		"SerumMarket":          poolInfo.SerumMarket,
+------------+		"SerumBids":            poolInfo.SerumBids,
+------------+		"SerumAsks":            poolInfo.SerumAsks,
+------------+		"SerumEventQueue":      poolInfo.SerumEventQueue,
+------------+		"SerumCoinVault":       poolInfo.SerumCoinVaultAccount,
+------------+		"SerumPcVault":         poolInfo.SerumPcVaultAccount,
+------------+		"SerumVaultSigner":     poolInfo.SerumVaultSigner,
+------------+	}
+------------+
+------------+	accounts := make(map[string]solana.PublicKey)
+------------+	for name, address := range requiredAccounts {
+------------+		pubKey, err := validatePublicKey(address)
+------------ 		if err != nil {
+-------------			logger.Error(fmt.Sprintf("Invalid %s", check.name),
+-------------				zap.String("address", check.address),
+------------+			logger.Error(fmt.Sprintf("Invalid %s", name),
+------------+				zap.String("address", address),
+------------ 				zap.Error(err))
+-------------			return nil, fmt.Errorf("invalid %s: %w", check.name, err)
+------------+			return nil, fmt.Errorf("invalid %s: %w", name, err)
+------------ 		}
+------------+		accounts[name] = pubKey
+------------+	}
 ------------ 
--------------	if task.MinAmountOut <= 0 {
--------------		return fmt.Errorf("min amount out must be greater than 0")
-------------+	// Удаляем проверку MinAmountOut, так как теперь оно может быть нулевым или пустым
-------------+	// if task.MinAmountOut <= 0 {
-------------+	//     return fmt.Errorf("min amount out must be greater than 0")
-------------+	// }
+-------------		isWritable := false
+-------------		switch check.name {
+-------------		case "AmmOpenOrders", "AmmTargetOrders", "PoolCoinTokenAccount",
+-------------			"PoolPcTokenAccount", "SerumMarket", "SerumBids", "SerumAsks",
+-------------			"SerumEventQueue", "SerumCoinVaultAccount", "SerumPcVaultAccount":
+-------------			isWritable = true
+-------------		}
+------------+	// Создаем слайс аккаунтов в правильном порядке для Raydium
+------------+	metas := make(solana.AccountMetaSlice, 0, 20)
+------------ 
+-------------		accounts = append(accounts, &solana.AccountMeta{
+-------------			PublicKey:  pubKey,
+-------------			IsSigner:   false,
+-------------			IsWritable: isWritable,
+-------------		})
+-------------	}
+------------+	// Токен аккаунты пользователя
+------------+	metas = append(metas,
+------------+		&solana.AccountMeta{PublicKey: userSourceTokenAccount, IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: userDestinationTokenAccount, IsSigner: false, IsWritable: true},
+------------+	)
 ------------+
-------------+	// Проверяем конфигурацию проскальзывания, если она используется
-------------+	if task.SlippageConfig.Type != types.SlippageNone {
-------------+		if task.SlippageConfig.Type == types.SlippagePercent &&
-------------+			(task.SlippageConfig.Value <= 0 || task.SlippageConfig.Value > 100) {
-------------+			return fmt.Errorf("slippage percentage must be between 0 and 100")
-------------+		}
-------------+		if task.SlippageConfig.Type == types.SlippageFixed && task.SlippageConfig.Value < 0 {
-------------+			return fmt.Errorf("fixed slippage value cannot be negative")
-------------+		}
------------- 	}
+------------+	// Аккаунты AMM
+------------+	metas = append(metas,
+------------+		&solana.AccountMeta{PublicKey: accounts["AmmID"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["AmmAuthority"], IsSigner: false, IsWritable: false},
+------------+		&solana.AccountMeta{PublicKey: accounts["AmmOpenOrders"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["AmmTargetOrders"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["PoolCoinTokenAccount"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["PoolPcTokenAccount"], IsSigner: false, IsWritable: true},
+------------+	)
+------------+
+------------+	// Аккаунты Serum
+------------+	metas = append(metas,
+------------+		&solana.AccountMeta{PublicKey: accounts["SerumProgramID"], IsSigner: false, IsWritable: false},
+------------+		&solana.AccountMeta{PublicKey: accounts["SerumMarket"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["SerumBids"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["SerumAsks"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["SerumEventQueue"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["SerumCoinVault"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["SerumPcVault"], IsSigner: false, IsWritable: true},
+------------+		&solana.AccountMeta{PublicKey: accounts["SerumVaultSigner"], IsSigner: false, IsWritable: false},
+------------+	)
 ------------ 
------------- 	if task.SourceTokenDecimals <= 0 {
-------------diff --git a/internal/sniping/strategy.go b/internal/sniping/strategy.go
-------------index 91602f1..aa5b32c 100644
---------------- a/internal/sniping/strategy.go
-------------+++ b/internal/sniping/strategy.go
-------------@@ -60,9 +60,12 @@ func parseTask(record []string) (*types.Task, error) {
------------- 		return nil, fmt.Errorf("invalid AmountIn value: %v", err)
+-------------	// Добавляем системные аккаунты
+-------------	accounts = append(accounts, []*solana.AccountMeta{
+-------------		{PublicKey: userWallet, IsSigner: true, IsWritable: false},
+-------------		{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
+-------------		{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
+-------------		{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
+-------------	}...)
+------------+	// Системные аккаунты
+------------+	metas = append(metas,
+------------+		&solana.AccountMeta{PublicKey: userWallet, IsSigner: true, IsWritable: false},
+------------+		&solana.AccountMeta{PublicKey: solana.TokenProgramID, IsSigner: false, IsWritable: false},
+------------+		&solana.AccountMeta{PublicKey: solana.SysVarRentPubkey, IsSigner: false, IsWritable: false},
+------------+		&solana.AccountMeta{PublicKey: solana.SysVarClockPubkey, IsSigner: false, IsWritable: false},
+------------+	)
+------------ 
+------------ 	// Создание данных инструкции
+-------------	instructionData := SwapInstructionData{
+------------+	instructionData := &SwapInstructionData{
+------------ 		Instruction:  poolInfo.RaydiumSwapInstructionCode,
+------------ 		AmountIn:     amountIn,
+------------ 		MinAmountOut: minAmountOut,
 ------------ 	}
 ------------ 
--------------	minAmountOut, err := strconv.ParseFloat(record[10], 64)
--------------	if err != nil {
--------------		return nil, fmt.Errorf("invalid MinAmountOut value: %v", err)
-------------+	slippageValue := 1.0 // Значение по умолчанию
-------------+	if record[10] != "" {
-------------+		slippageValue, err = strconv.ParseFloat(record[10], 64)
-------------+		if err != nil {
-------------+			return nil, fmt.Errorf("invalid Slippage value: %v", err)
-------------+		}
+------------+	// Добавляем отладочный вывод
+------------+	instructionData.Debug(logger)
+------------+
+------------+	// Сериализация
+------------ 	data, err := instructionData.Serialize()
+------------ 	if err != nil {
+-------------		logger.Error("Failed to serialize instruction data", zap.Error(err))
+------------+		logger.Error("Failed to serialize instruction data",
+------------+			zap.Error(err),
+------------+			zap.Uint8("instruction", instructionData.Instruction),
+------------+			zap.Uint64("amount_in", instructionData.AmountIn),
+------------+			zap.Uint64("min_amount_out", instructionData.MinAmountOut))
+------------ 		return nil, fmt.Errorf("failed to serialize instruction data: %w", err)
 ------------ 	}
 ------------ 
------------- 	autosellPercent, err := strconv.ParseFloat(record[11], 64)
-------------@@ -107,12 +110,15 @@ func parseTask(record []string) (*types.Task, error) {
------------- 		SourceToken:         record[7],
------------- 		TargetToken:         record[8],
------------- 		AmountIn:            amountIn,
--------------		MinAmountOut:        minAmountOut,
------------- 		AutosellPercent:     autosellPercent,
------------- 		AutosellDelay:       autosellDelay,
------------- 		AutosellAmount:      autosellAmount,
------------- 		TransactionDelay:    transactionDelay,
------------- 		AutosellPriorityFee: autosellPriorityFee,
--------------		DEXName:             dexName, // Устанавливаем имя DEX
-------------+		DEXName:             dexName,
-------------+		SlippageConfig: types.SlippageConfig{
-------------+			Type:  types.SlippagePercent, // Используем процентное проскальзывание по умолчанию
-------------+			Value: slippageValue,
-------------+		},
------------- 	}, nil
------------- }
-------------diff --git a/internal/types/types.go b/internal/types/types.go
-------------index babccdd..6b8c246 100644
---------------- a/internal/types/types.go
-------------+++ b/internal/types/types.go
-------------@@ -20,7 +20,6 @@ type Task struct {
------------- 	SourceToken                 string
------------- 	TargetToken                 string
------------- 	AmountIn                    float64
--------------	MinAmountOut                float64
------------- 	AutosellPercent             float64
------------- 	AutosellDelay               int
------------- 	AutosellAmount              float64
-------------@@ -31,6 +30,7 @@ type Task struct {
------------- 	SourceTokenDecimals         int
------------- 	TargetTokenDecimals         int
------------- 	DEXName                     string `default:"Raydium"` // Добавляем значение по умолчанию
-------------+	SlippageConfig              SlippageConfig
+-------------	instruction := solana.NewInstruction(ammProgramID, accounts, data)
+------------+	// Проверка сериализованных данных
+------------+	if len(data) != 17 {
+------------+		logger.Error("Invalid serialized data length",
+------------+			zap.Int("got_length", len(data)),
+------------+			zap.Int("expected_length", 17))
+------------+		return nil, fmt.Errorf("invalid serialized data length")
+------------+	}
+------------+
+------------+	// Проверяем значения после сериализации
+------------+	amountInCheck := binary.LittleEndian.Uint64(data[1:9])
+------------+	minAmountOutCheck := binary.LittleEndian.Uint64(data[9:17])
+------------+
+------------+	logger.Debug("Serialized data check",
+------------+		zap.Uint64("amount_in_check", amountInCheck),
+------------+		zap.Uint64("min_amount_out_check", minAmountOutCheck))
+------------+
+------------+	if amountInCheck != amountIn {
+------------+		logger.Error("AmountIn mismatch after serialization",
+------------+			zap.Uint64("original", amountIn),
+------------+			zap.Uint64("serialized", amountInCheck))
+------------+		return nil, fmt.Errorf("amountIn mismatch after serialization")
+------------+	}
+------------+
+------------+	instruction := solana.NewInstruction(ammProgramID, metas, data)
+------------+
+------------+	logger.Debug("Created instruction",
+------------+		zap.Int("num_accounts", len(metas)),
+------------+		zap.Int("data_len", len(data)))
+------------ 
+-------------	logger.Debug("Swap instruction created successfully")
+------------ 	return instruction, nil
 ------------ }
 ------------ 
------------- type DEX interface {
-------------@@ -41,7 +41,6 @@ type DEX interface {
------------- 		sourceToken solana.PublicKey,
------------- 		destinationToken solana.PublicKey,
------------- 		amountIn uint64,
--------------		minAmountOut uint64,
------------- 		logger *zap.Logger,
------------- 	) (solana.Instruction, error)
+------------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
+------------index cd3089e..4cc1b1e 100644
+--------------- a/internal/dex/raydium/types.go
+------------+++ b/internal/dex/raydium/types.go
+------------@@ -27,11 +27,10 @@ type Pool struct {
+------------ }
 ------------ 
-------------diff --git a/internal/utils/logger/logger.go b/internal/utils/logger/logger.go
-------------index e5e813c..5b76758 100644
---------------- a/internal/utils/logger/logger.go
-------------+++ b/internal/utils/logger/logger.go
-------------@@ -138,7 +138,8 @@ func (l *Logger) WithTask(task *types.Task) *zap.Logger {
------------- 		zap.String("source_token", task.SourceToken),
------------- 		zap.String("target_token", task.TargetToken),
------------- 		zap.Float64("amount_in", task.AmountIn),
--------------		zap.Float64("min_amount_out", task.MinAmountOut),
-------------+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
-------------+		zap.Float64("slippage_value", task.SlippageConfig.Value),
------------- 		zap.Float64("priority_fee", task.PriorityFee),
------------- 	)
+------------ // SwapInstructionData представляет данные инструкции свапа
+-------------// Обновляем также структуру инструкции
+------------ type SwapInstructionData struct {
+-------------	Instruction  uint8 // Изменено на uint8
+-------------	AmountIn     uint64
+-------------	MinAmountOut uint64
+------------+	Instruction  uint8  // Тип инструкции
+------------+	AmountIn     uint64 // Входящая сумма
+------------+	MinAmountOut uint64 // Минимальная исходящая сумма
 ------------ }
----diff --git a/swap-ts.txt b/swap-ts.txt
----new file mode 100644
----index 0000000..8db4319
------- /dev/null
----+++ b/swap-ts.txt
----@@ -0,0 +1,623 @@
----+// config.ts
----+import dotenv from 'dotenv';
----+import https from 'https';
----+dotenv.config();
----+
----+if (!process.env.QUICKNODE_URL) {
----+  throw new Error('QUICKNODE_URL is not set in the environment variables');
----+}
----+
----+if (!process.env.WALLET_SECRET_KEY) {
----+  throw new Error('WALLET_SECRET_KEY is not set in the environment variables');
----+}
----+
----+interface PriorityFeeResponse {
----+  jsonrpc: string;
----+  result: {
----+    per_compute_unit: {
----+      extreme: number;
----+      medium: number;
----+    };
----+  };
----+  id: number;
----+}
----+
----+function httpsRequest(url: string, options: https.RequestOptions, data: string): Promise<string> {
----+  return new Promise((resolve, reject) => {
----+    const req = https.request(url, options, (res) => {
----+      let body = '';
----+      res.on('data', (chunk) => body += chunk.toString());
----+      res.on('end', () => resolve(body));
----+    });
----+    req.on('error', reject);
----+    req.write(data);
----+    req.end();
----+  });
----+}
----+
----+async function fetchPriorityFee(): Promise<number> {
----+  if (!process.env.QUICKNODE_URL) {
----+    throw new Error('QUICKNODE_URL is not set in the environment variables');
----+  }
----+
----+  const url = new URL(process.env.QUICKNODE_URL);
----+  const options: https.RequestOptions = {
----+    method: 'POST',
----+    headers: {
----+      'Content-Type': 'application/json',
----+    },
----+  };
----+
----+  const requestBody = JSON.stringify({
----+    jsonrpc: '2.0',
----+    id: 1,
----+    method: 'qn_estimatePriorityFees',
----+    params: {
----+      last_n_blocks: 100,
----+      account: '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8',
----+      api_version: 2
----+    }
----+  });
----+
----+  const response = await httpsRequest(url.href, options, requestBody);
----+  const data: unknown = JSON.parse(response);
----+  
----+  if (!isPriorityFeeResponse(data)) {
----+    throw new Error('Unexpected response format from priority fee API');
----+  }
----+  
----+  // Using the 'extreme' priority fee from 'per_compute_unit'
----+  const extremePriorityFeePerCU = data.result.per_compute_unit.extreme;
----+  
----+  // Estimate compute units for the transaction (this is an approximation)
----+  const estimatedComputeUnits = 300000; // Adjust this based on your typical transaction
----+  
----+  // Calculate total priority fee in micro-lamports
----+  const totalPriorityFeeInMicroLamports = extremePriorityFeePerCU * estimatedComputeUnits;
----+  
----+  // Convert to SOL (1 SOL = 1e9 lamports = 1e15 micro-lamports)
----+  const priorityFeeInSOL = totalPriorityFeeInMicroLamports / 1e15;
----+  
----+  // Ensure the fee is not less than 0.000001 SOL (minimum fee)
----+  return Math.max(priorityFeeInSOL, 0.000001);
----+}
----+
----+function isPriorityFeeResponse(data: unknown): data is PriorityFeeResponse {
----+  return (
----+    typeof data === 'object' &&
----+    data !== null &&
----+    'jsonrpc' in data &&
----+    'result' in data &&
----+    typeof data.result === 'object' &&
----+    data.result !== null &&
----+    'per_compute_unit' in data.result &&
----+    typeof data.result.per_compute_unit === 'object' &&
----+    data.result.per_compute_unit !== null &&
----+    'extreme' in data.result.per_compute_unit &&
----+    typeof data.result.per_compute_unit.extreme === 'number'
----+  );
----+}
----+
----+export const CONFIG = {
----+  RPC_URL: process.env.QUICKNODE_URL,
----+  WALLET_SECRET_KEY: process.env.WALLET_SECRET_KEY,
----+  BASE_MINT: 'So11111111111111111111111111111111111111112', // SOLANA mint address
----+  QUOTE_MINT: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263', // BONK mint address
----+  TOKEN_A_AMOUNT: 0.000001,
----+  EXECUTE_SWAP: true,
----+  USE_VERSIONED_TRANSACTION: false,
----+  SLIPPAGE: 5,
----+  getPriorityFee: fetchPriorityFee,
----+};
----+
----+// main.ts
----+
----+import { RaydiumSwap } from './raydium-swap';
----+import { CONFIG } from './config';
----+import { 
----+  PublicKey,
----+  LAMPORTS_PER_SOL,
----+  Transaction,
----+  VersionedTransaction,
----+} from '@solana/web3.js';
----+
----+async function getTokenBalance(raydiumSwap: RaydiumSwap, mint: string): Promise<number> {
----+  const userTokenAccounts = await raydiumSwap.getOwnerTokenAccounts();
----+  const tokenAccount = userTokenAccounts.find(account => 
----+    account.accountInfo.mint.equals(new PublicKey(mint))
----+  );
----+  if (tokenAccount) {
----+    const balance = await raydiumSwap.connection.getTokenAccountBalance(tokenAccount.pubkey);
----+    return balance.value.uiAmount || 0;
----+  }
----+  return 0;
----+}
----+
----+async function swap() {
----+  console.log('Starting swap process...');
----+  const raydiumSwap = new RaydiumSwap(CONFIG.RPC_URL, CONFIG.WALLET_SECRET_KEY);
----+
----+  await raydiumSwap.loadPoolKeys();
----+  let poolInfo = raydiumSwap.findPoolInfoForTokens(CONFIG.BASE_MINT, CONFIG.QUOTE_MINT) 
----+    || await raydiumSwap.findRaydiumPoolInfo(CONFIG.BASE_MINT, CONFIG.QUOTE_MINT);
----+
----+  if (!poolInfo) {
----+    throw new Error("Couldn't find the pool info");
----+  }
----+
----+  await raydiumSwap.createWrappedSolAccountInstruction(CONFIG.TOKEN_A_AMOUNT);
----+
----+  console.log('Fetching current priority fee...');
----+  const priorityFee = await CONFIG.getPriorityFee();
----+  console.log(`Current priority fee: ${priorityFee} SOL`);
----+
----+  console.log('Creating swap transaction...');
----+  const swapTx = await raydiumSwap.getSwapTransaction(
----+    CONFIG.QUOTE_MINT,
----+    CONFIG.TOKEN_A_AMOUNT,
----+    poolInfo,
----+    CONFIG.USE_VERSIONED_TRANSACTION,
----+    CONFIG.SLIPPAGE
----+  );
----+
----+  console.log(`Using priority fee: ${priorityFee} SOL`);
----+  console.log(`Transaction signed with payer: ${raydiumSwap.wallet.publicKey.toBase58()}`);
----+
----+  console.log(`Swapping ${CONFIG.TOKEN_A_AMOUNT} SOL for BONK`);
----+
----+  if (CONFIG.EXECUTE_SWAP) {
----+    try {
----+      let txid: string;
----+      if (CONFIG.USE_VERSIONED_TRANSACTION) {
----+        if (!(swapTx instanceof VersionedTransaction)) {
----+          throw new Error('Expected a VersionedTransaction but received a different type');
----+        }
----+        const latestBlockhash = await raydiumSwap.connection.getLatestBlockhash();
----+        txid = await raydiumSwap.sendVersionedTransaction(
----+          swapTx,
----+          latestBlockhash.blockhash,
----+          latestBlockhash.lastValidBlockHeight
----+        );
----+      } else {
----+        if (!(swapTx instanceof Transaction)) {
----+          throw new Error('Expected a Transaction but received a different type');
----+        }
----+        txid = await raydiumSwap.sendLegacyTransaction(swapTx);
----+      }
----+      console.log(`Transaction sent, signature: ${txid}`);
----+      console.log(`Transaction executed: https://explorer.solana.com/tx/${txid}`);
----+      
----+      console.log('Transaction confirmed successfully');
----+
----+      // Fetch and display token balances
----+      const solBalance = await raydiumSwap.connection.getBalance(raydiumSwap.wallet.publicKey) / LAMPORTS_PER_SOL;
----+      const bonkBalance = await getTokenBalance(raydiumSwap, CONFIG.QUOTE_MINT);
----+
----+      console.log('\nToken Balances After Swap:');
----+      console.log(`SOL: ${solBalance.toFixed(6)} SOL`);
----+      console.log(`BONK: ${bonkBalance.toFixed(2)} BONK`);
----+    } catch (error) {
----+      console.error('Error executing transaction:', error);
----+    }
----+  } else {
----+    console.log('Simulating transaction (dry run)');
----+    try {
----+      let simulationResult;
----+      if (CONFIG.USE_VERSIONED_TRANSACTION) {
----+        if (!(swapTx instanceof VersionedTransaction)) {
----+          throw new Error('Expected a VersionedTransaction but received a different type');
----+        }
----+        simulationResult = await raydiumSwap.simulateVersionedTransaction(swapTx);
----+      } else {
----+        if (!(swapTx instanceof Transaction)) {
----+          throw new Error('Expected a Transaction but received a different type');
----+        }
----+        simulationResult = await raydiumSwap.simulateLegacyTransaction(swapTx);
----+      }
----+      console.log('Simulation successful');
----+      console.log('Simulated transaction details:');
----+      console.log(`Logs:`, simulationResult.logs);
----+      console.log(`Units consumed:`, simulationResult.unitsConsumed);
----+      if (simulationResult.returnData) {
----+        console.log(`Return data:`, simulationResult.returnData);
----+      }
----+    } catch (error) {
----+      console.error('Error simulating transaction:', error);
----+    }
----+  }
----+}
----+
----+swap().catch((error) => {
----+  console.error('An error occurred during the swap process:');
----+  console.error(error);
----+});
----+
----+// raydium-swap.ts
----+import {
----+  Connection,
----+  PublicKey,
----+  Keypair,
----+  Transaction,
----+  VersionedTransaction,
----+  TransactionMessage,
----+  GetProgramAccountsResponse,
----+  TransactionInstruction,
----+  LAMPORTS_PER_SOL,
----+  SystemProgram,
----+  SimulatedTransactionResponse,
----+  TransactionConfirmationStrategy,  // Add this line
----+} from '@solana/web3.js';
----+import {
----+  Liquidity,
----+  LiquidityPoolKeys,
----+  jsonInfo2PoolKeys,
----+  TokenAccount,
----+  Token,
----+  TokenAmount,
----+  TOKEN_PROGRAM_ID,
----+  Percent,
----+  SPL_ACCOUNT_LAYOUT,
----+  LIQUIDITY_STATE_LAYOUT_V4,
----+  MARKET_STATE_LAYOUT_V3,
----+  Market,
----+} from '@raydium-io/raydium-sdk';
----+import { Wallet } from '@project-serum/anchor';
----+import base58 from 'bs58';
----+import { existsSync } from 'fs';
----+import { readFile } from 'fs/promises';
----+import { 
----+  NATIVE_MINT,
----+  createInitializeAccountInstruction, 
----+  createCloseAccountInstruction,
----+  getMinimumBalanceForRentExemptAccount,
----+  createSyncNativeInstruction,
----+} from '@solana/spl-token';
----+import { CONFIG } from './config';
----+
----+type SwapSide = "in" | "out";
----+
----+export class RaydiumSwap {
----+  static RAYDIUM_V4_PROGRAM_ID = '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8';
----+
----+  allPoolKeysJson: any[] = [];
----+  connection: Connection;
----+  wallet: Wallet;
----+
----+  constructor(RPC_URL: string, WALLET_SECRET_KEY: string) {
----+    if (!RPC_URL.startsWith('http://') && !RPC_URL.startsWith('https://')) {
----+      throw new Error('Invalid RPC URL. Must start with http:// or https://');
----+    }
----+    this.connection = new Connection(RPC_URL, 'confirmed');
----+
----+    try {
----+      if (!WALLET_SECRET_KEY) {
----+        throw new Error('WALLET_SECRET_KEY is not provided');
----+      }
----+      const secretKey = base58.decode(WALLET_SECRET_KEY);
----+      if (secretKey.length !== 64) {
----+        throw new Error('Invalid secret key length. Expected 64 bytes.');
----+      }
----+      this.wallet = new Wallet(Keypair.fromSecretKey(secretKey));
----+      console.log('Wallet initialized with public key:', this.wallet.publicKey.toBase58());
----+    } catch (error) {
----+      if (error instanceof Error) {
----+        throw new Error(`Failed to create wallet: ${error.message}`);
----+      } else {
----+        throw new Error('Failed to create wallet: Unknown error');
----+      }
----+    }
----+  }
----+
----+  async loadPoolKeys() {
----+    try {
----+      if (existsSync('mainnet.json')) {
----+        const data = JSON.parse((await readFile('mainnet.json')).toString());
----+        this.allPoolKeysJson = data.official;
----+        return;
----+      }
----+      throw new Error('mainnet.json file not found');
----+    } catch (error) {
----+      this.allPoolKeysJson = [];
----+    }
----+  }
----+
----+  findPoolInfoForTokens(mintA: string, mintB: string): LiquidityPoolKeys | null {
----+    const poolData = this.allPoolKeysJson.find(
----+      (i) => (i.baseMint === mintA && i.quoteMint === mintB) || (i.baseMint === mintB && i.quoteMint === mintA)
----+    );
----+    return poolData ? jsonInfo2PoolKeys(poolData) as LiquidityPoolKeys : null;
----+  }
----+
----+  async getProgramAccounts(baseMint: string, quoteMint: string): Promise<GetProgramAccountsResponse> {
----+    const layout = LIQUIDITY_STATE_LAYOUT_V4;
----+    return this.connection.getProgramAccounts(new PublicKey(RaydiumSwap.RAYDIUM_V4_PROGRAM_ID), {
----+      filters: [
----+        { dataSize: layout.span },
----+        {
----+          memcmp: {
----+            offset: layout.offsetOf('baseMint'),
----+            bytes: new PublicKey(baseMint).toBase58(),
----+          },
----+        },
----+        {
----+          memcmp: {
----+            offset: layout.offsetOf('quoteMint'),
----+            bytes: new PublicKey(quoteMint).toBase58(),
----+          },
----+        },
----+      ],
----+    });
----+  }
----+
----+  async findRaydiumPoolInfo(baseMint: string, quoteMint: string): Promise<LiquidityPoolKeys | null> {
----+    const layout = LIQUIDITY_STATE_LAYOUT_V4;
----+    const programData = await this.getProgramAccounts(baseMint, quoteMint);
----+    const collectedPoolResults = programData
----+      .map((info) => ({
----+        id: new PublicKey(info.pubkey),
----+        version: 4,
----+        programId: new PublicKey(RaydiumSwap.RAYDIUM_V4_PROGRAM_ID),
----+        ...layout.decode(info.account.data),
----+      }))
----+      .flat();
----+
----+    const pool = collectedPoolResults[0];
----+    if (!pool) return null;
----+
----+    const market = await this.connection.getAccountInfo(pool.marketId).then((item) => {
----+      if (!item) {
----+        throw new Error('Market account not found');
----+      }
----+      return {
----+        programId: item.owner,
----+        ...MARKET_STATE_LAYOUT_V3.decode(item.data),
----+      };
----+    });
----+
----+    const authority = Liquidity.getAssociatedAuthority({
----+      programId: new PublicKey(RaydiumSwap.RAYDIUM_V4_PROGRAM_ID),
----+    }).publicKey;
----+
----+    const marketProgramId = market.programId;
----+
----+    return {
----+      id: pool.id,
----+      baseMint: pool.baseMint,
----+      quoteMint: pool.quoteMint,
----+      lpMint: pool.lpMint,
----+      baseDecimals: Number.parseInt(pool.baseDecimal.toString()),
----+      quoteDecimals: Number.parseInt(pool.quoteDecimal.toString()),
----+      lpDecimals: Number.parseInt(pool.baseDecimal.toString()),
----+      version: pool.version,
----+      programId: pool.programId,
----+      openOrders: pool.openOrders,
----+      targetOrders: pool.targetOrders,
----+      baseVault: pool.baseVault,
----+      quoteVault: pool.quoteVault,
----+      marketVersion: 3,
----+      authority: authority,
----+      marketProgramId,
----+      marketId: market.ownAddress,
----+      marketAuthority: Market.getAssociatedAuthority({
----+        programId: marketProgramId,
----+        marketId: market.ownAddress,
----+      }).publicKey,
----+      marketBaseVault: market.baseVault,
----+      marketQuoteVault: market.quoteVault,
----+      marketBids: market.bids,
----+      marketAsks: market.asks,
----+      marketEventQueue: market.eventQueue,
----+      withdrawQueue: pool.withdrawQueue,
----+      lpVault: pool.lpVault,
----+      lookupTableAccount: PublicKey.default,
----+    } as LiquidityPoolKeys;
----+  }
----+
----+  async getOwnerTokenAccounts() {
----+    const walletTokenAccount = await this.connection.getTokenAccountsByOwner(this.wallet.publicKey, {
----+      programId: TOKEN_PROGRAM_ID,
----+    });
----+    return walletTokenAccount.value.map((i) => ({
----+      pubkey: i.pubkey,
----+      programId: i.account.owner,
----+      accountInfo: SPL_ACCOUNT_LAYOUT.decode(i.account.data),
----+    }));
----+  }
----+
----+  private getSwapSide(
----+    poolKeys: LiquidityPoolKeys,
----+    wantFrom: PublicKey,
----+    wantTo: PublicKey,
----+  ): SwapSide {
----+    if (poolKeys.baseMint.equals(wantFrom) && poolKeys.quoteMint.equals(wantTo)) {
----+      return "in";
----+    } else if (poolKeys.baseMint.equals(wantTo) && poolKeys.quoteMint.equals(wantFrom)) {
----+      return "out";
----+    } else {
----+      throw new Error("Not suitable pool fetched. Can't determine swap side");
----+    }
----+  }
----+
----+  async getSwapTransaction(
----+    toToken: string,
----+    amount: number,
----+    poolKeys: LiquidityPoolKeys,
----+    useVersionedTransaction = true,
----+    slippage: number = 5
----+  ): Promise<Transaction | VersionedTransaction> {
----+    const poolInfo = await Liquidity.fetchInfo({ connection: this.connection, poolKeys });
----+    
----+    const fromToken = poolKeys.baseMint.toString() === NATIVE_MINT.toString() ? NATIVE_MINT.toString() : poolKeys.quoteMint.toString();
----+    const swapSide = this.getSwapSide(poolKeys, new PublicKey(fromToken), new PublicKey(toToken));
----+
----+    const baseToken = new Token(TOKEN_PROGRAM_ID, poolKeys.baseMint, poolInfo.baseDecimals);
----+    const quoteToken = new Token(TOKEN_PROGRAM_ID, poolKeys.quoteMint, poolInfo.quoteDecimals);
----+
----+    const currencyIn = swapSide === "in" ? baseToken : quoteToken;
----+    const currencyOut = swapSide === "in" ? quoteToken : baseToken;
----+
----+    const amountIn = new TokenAmount(currencyIn, amount, false);
----+    const slippagePercent = new Percent(slippage, 100);
----+
----+    const { amountOut, minAmountOut } = Liquidity.computeAmountOut({
----+      poolKeys,
----+      poolInfo,
----+      amountIn,
----+      currencyOut,
----+      slippage: slippagePercent,
----+    });
----+
----+    const userTokenAccounts = await this.getOwnerTokenAccounts();
----+
----+    const priorityFee = await CONFIG.getPriorityFee();
----+    console.log(`Using priority fee: ${priorityFee} SOL`);
----+
----+    const swapTransaction = await Liquidity.makeSwapInstructionSimple({
----+      connection: this.connection,
----+      makeTxVersion: useVersionedTransaction ? 0 : 1,
----+      poolKeys: {
----+        ...poolKeys,
----+      },
----+      userKeys: {
----+        tokenAccounts: userTokenAccounts,
----+        owner: this.wallet.publicKey,
----+      },
----+      amountIn,
----+      amountOut: minAmountOut,
----+      fixedSide: swapSide,
----+      config: {
----+        bypassAssociatedCheck: false,
----+      },
----+      computeBudgetConfig: {
----+        units: 300000,
----+        microLamports: Math.floor(priorityFee * LAMPORTS_PER_SOL),
----+      },
----+    });
----+
----+    const recentBlockhashForSwap = await this.connection.getLatestBlockhash();
----+    const instructions = swapTransaction.innerTransactions[0].instructions.filter(
----+      (instruction): instruction is TransactionInstruction => Boolean(instruction)
----+    );
----+
----+    if (useVersionedTransaction) {
----+      const versionedTransaction = new VersionedTransaction(
----+        new TransactionMessage({
----+          payerKey: this.wallet.publicKey,
----+          recentBlockhash: recentBlockhashForSwap.blockhash,
----+          instructions: instructions,
----+        }).compileToV0Message()
----+      );
----+      versionedTransaction.sign([this.wallet.payer]);
----+      console.log('Versioned transaction signed with payer:', this.wallet.payer.publicKey.toBase58());
----+      return versionedTransaction;
----+    }
----+
----+    const legacyTransaction = new Transaction({
----+      blockhash: recentBlockhashForSwap.blockhash,
----+      lastValidBlockHeight: recentBlockhashForSwap.lastValidBlockHeight,
----+      feePayer: this.wallet.publicKey,
----+    });
----+    legacyTransaction.add(...instructions);
----+    console.log('Legacy transaction signed with payer:', this.wallet.payer.publicKey.toBase58());
----+    return legacyTransaction;
----+  }
----+
----+  async sendLegacyTransaction(tx: Transaction): Promise<string> {
----+    const signature = await this.connection.sendTransaction(tx, [this.wallet.payer], {
----+      skipPreflight: true,
----+      preflightCommitment: 'confirmed',
----+    });
----+    console.log('Legacy transaction sent, signature:', signature);
----+    const latestBlockhash = await this.connection.getLatestBlockhash();
----+const confirmationStrategy: TransactionConfirmationStrategy = {
----+  signature: signature,
----+  blockhash: latestBlockhash.blockhash,
----+  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
----+};
----+const confirmation = await this.connection.confirmTransaction(confirmationStrategy, 'confirmed'); // Increase timeout to 60 seconds
----+    if (confirmation.value.err) {
----+      throw new Error(`Transaction failed: ${confirmation.value.err.toString()}`);
----+    }
----+    return signature;
----+  }
----+
----+  async sendVersionedTransaction(
----+    tx: VersionedTransaction,
----+    blockhash: string,
----+    lastValidBlockHeight: number
----+  ): Promise<string> {
----+    const rawTransaction = tx.serialize();
----+    const signature = await this.connection.sendRawTransaction(rawTransaction, {
----+      skipPreflight: true,
----+      preflightCommitment: 'confirmed',
----+    });
----+    console.log('Versioned transaction sent, signature:', signature);
----+  
----+    const confirmationStrategy: TransactionConfirmationStrategy = {
----+      signature: signature,
----+      blockhash: blockhash,
----+      lastValidBlockHeight: lastValidBlockHeight,
----+    };
----+  
----+    const confirmation = await this.connection.confirmTransaction(confirmationStrategy, 'confirmed');
----+    if (confirmation.value.err) {
----+      throw new Error(`Transaction failed: ${confirmation.value.err.toString()}`);
----+    }
----+    return signature;
----+  }
----+
----+  async simulateLegacyTransaction(tx: Transaction): Promise<SimulatedTransactionResponse> {
----+    const { value } = await this.connection.simulateTransaction(tx);
----+    return value;
----+  }
----+
----+  async simulateVersionedTransaction(tx: VersionedTransaction): Promise<SimulatedTransactionResponse> {
----+    const { value } = await this.connection.simulateTransaction(tx);
----+    return value;
----+  }
----+
----+  getTokenAccountByOwnerAndMint(mint: PublicKey) {
----+    return {
----+      programId: TOKEN_PROGRAM_ID,
----+      pubkey: PublicKey.default,
----+      accountInfo: {
----+        mint: mint,
----+        amount: 0,
----+      },
----+    } as unknown as TokenAccount;
----+  }
----+
----+  async createWrappedSolAccountInstruction(amount: number): Promise<{
----+    transaction: Transaction;
----+    wrappedSolAccount: Keypair;
----+  }> {
----+    const lamports = amount * LAMPORTS_PER_SOL;
----+    const wrappedSolAccount = Keypair.generate();
----+    const transaction = new Transaction();
----+
----+    const rentExemptBalance = await getMinimumBalanceForRentExemptAccount(this.connection);
----+
----+    transaction.add(
----+      SystemProgram.createAccount({
----+        fromPubkey: this.wallet.publicKey,
----+        newAccountPubkey: wrappedSolAccount.publicKey,
----+        lamports: rentExemptBalance,
----+        space: 165,
----+        programId: TOKEN_PROGRAM_ID,
----+      }),
----+      createInitializeAccountInstruction(
----+        wrappedSolAccount.publicKey,
----+        NATIVE_MINT,
----+        this.wallet.publicKey
----+      ),
----+      SystemProgram.transfer({
----+        fromPubkey: this.wallet.publicKey,
----+        toPubkey: wrappedSolAccount.publicKey,
----+        lamports,
----+      }),
----+      createSyncNativeInstruction(wrappedSolAccount.publicKey)
----+    );
----+
----+    return { transaction, wrappedSolAccount };
----+  }
----+}
----\ No newline at end of file
+------------ type DEX struct {
+------------ 	client   blockchain.Client // изменяем тип на интерфейс.
+------------diff --git a/newdif.txt b/newdif.txt
+------------index 073754f..a086373 100644
+--------------- a/newdif.txt
+------------+++ b/newdif.txt
+------------@@ -1,436 +0,0 @@
+-------------diff --git a/configs/tasks.csv b/configs/tasks.csv
+-------------index e44faa8..33e5da0 100644
+---------------- a/configs/tasks.csv
+-------------+++ b/configs/tasks.csv
+-------------@@ -1,2 +1,2 @@
+------------- TaskName,Module,Workers,WalletName,Delta,PriorityFee,AMMID,SourceToken,TargetToken,AmountIn,MinAmountOut,AutosellPercent,AutosellDelay,AutosellAmount,TransactionDelay,AutosellPriorityFee
+--------------buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,,,,,100,
+-------------\ No newline at end of file
+-------------+buyTokens,Raydium,1,wallet1,100,0.0001,,So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,0.02,0,0,0,0,100,0.0003
+-------------\ No newline at end of file
+-------------diff --git a/internal/dex/raydium/raydium.go b/internal/dex/raydium/raydium.go
+-------------index 1703360..bcd26a9 100644
+---------------- a/internal/dex/raydium/raydium.go
+-------------+++ b/internal/dex/raydium/raydium.go
+-------------@@ -4,6 +4,7 @@ package raydium
+------------- 
+------------- import (
+------------- 	"context"
+-------------+	"encoding/binary"
+------------- 	"fmt"
+------------- 	"math"
+------------- 	"time"
+-------------@@ -45,6 +46,8 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+------------- 	logger := r.logger.With(
+------------- 		zap.String("task", task.TaskName),
+------------- 		zap.String("wallet", userWallet.PublicKey.String()),
+-------------+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
+-------------+		zap.Float64("slippage_value", task.SlippageConfig.Value),
+------------- 	)
+------------- 	logger.Info("Starting swap execution")
+------------- 
+-------------@@ -64,11 +67,12 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+------------- 
+------------- 	// Подготавливаем amount с учетом decimals
+------------- 	amountIn := uint64(task.AmountIn * math.Pow10(task.SourceTokenDecimals))
+--------------	minAmountOut := uint64(task.MinAmountOut * math.Pow10(task.TargetTokenDecimals))
+------------- 
+--------------	logger.Debug("Prepared swap amounts",
+-------------+	logger.Debug("Prepared swap amount",
+------------- 		zap.Uint64("amount_in", amountIn),
+--------------		zap.Uint64("min_amount_out", minAmountOut))
+-------------+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
+-------------+		zap.Float64("slippage_value", task.SlippageConfig.Value),
+-------------+	)
+------------- 
+------------- 	// Создаем инструкции с таймаутом
+------------- 	swapCtx, swapCancel := context.WithTimeout(opCtx, txSendTimeout)
+-------------@@ -81,7 +85,6 @@ func (r *DEX) ExecuteSwap(ctx context.Context, task *types.Task, userWallet *wal
+------------- 		sourceATA,
+------------- 		targetATA,
+------------- 		amountIn,
+--------------		minAmountOut,
+------------- 		task.PriorityFee,
+------------- 		logger,
+------------- 	)
+-------------@@ -220,7 +223,8 @@ func (r *DEX) sendATATransaction(ctx context.Context, wallet *wallet.Wallet, ins
+------------- 	return fmt.Errorf("failed to send ATA transaction after %d attempts: %w", maxRetries, lastErr)
+------------- }
+------------- 
+--------------// Добавляем метод PrepareSwapInstruction для соответствия интерфейсу types.DEX
+-------------+// internal/dex/raydium/raydium.go
+-------------+
+------------- // PrepareSwapInstructions объединяет все инструкции для свапа
+------------- func (r *DEX) PrepareSwapInstructions(
+------------- 	ctx context.Context,
+-------------@@ -228,7 +232,6 @@ func (r *DEX) PrepareSwapInstructions(
+------------- 	sourceATA solana.PublicKey,
+------------- 	targetATA solana.PublicKey,
+------------- 	amountIn uint64,
+--------------	minAmountOut uint64,
+------------- 	priorityFee float64,
+------------- 	logger *zap.Logger,
+------------- ) ([]solana.Instruction, error) {
+-------------@@ -247,7 +250,6 @@ func (r *DEX) PrepareSwapInstructions(
+------------- 		sourceATA,
+------------- 		targetATA,
+------------- 		amountIn,
+--------------		minAmountOut,
+------------- 		logger,
+------------- 	)
+------------- 	if err != nil {
+-------------@@ -265,7 +267,6 @@ func (r *DEX) PrepareSwapInstruction(
+------------- 	sourceATA solana.PublicKey,
+------------- 	targetATA solana.PublicKey,
+------------- 	amountIn uint64,
+--------------	minAmountOut uint64,
+------------- 	logger *zap.Logger,
+------------- ) (solana.Instruction, error) {
+------------- 	logger = logger.With(
+-------------@@ -275,8 +276,34 @@ func (r *DEX) PrepareSwapInstruction(
+------------- 	)
+------------- 	logger.Debug("Preparing swap instruction")
+------------- 
+--------------	// Создаем инструкцию свапа
+--------------	instruction, err := r.CreateSwapInstruction(
+-------------+	// Получаем ожидаемый выход
+-------------+	sourceMint, err := r.getMintFromATA(ctx, sourceATA)
+-------------+	if err != nil {
+-------------+		return nil, fmt.Errorf("failed to get source mint: %w", err)
+-------------+	}
+-------------+
+-------------+	targetMint, err := r.getMintFromATA(ctx, targetATA)
+-------------+	if err != nil {
+-------------+		return nil, fmt.Errorf("failed to get target mint: %w", err)
+-------------+	}
+-------------+
+-------------+	expectedOut, err := r.getExpectedOutput(
+-------------+		ctx,
+-------------+		amountIn,
+-------------+		sourceMint,
+-------------+		targetMint,
+-------------+		r.poolInfo,
+-------------+		logger,
+-------------+	)
+-------------+	if err != nil {
+-------------+		return nil, fmt.Errorf("failed to get expected output: %w", err)
+-------------+	}
+-------------+
+-------------+	// Используем безопасное значение minAmountOut по умолчанию (99% от ожидаемого выхода)
+-------------+	minAmountOut := uint64(float64(expectedOut) * 0.99)
+-------------+
+-------------+	// Создаем инструкцию свапа с помощью внутреннего метода createSwapInstruction
+-------------+	return r.createSwapInstruction(
+------------- 		wallet,
+------------- 		sourceATA,
+------------- 		targetATA,
+-------------@@ -285,12 +312,52 @@ func (r *DEX) PrepareSwapInstruction(
+------------- 		logger,
+------------- 		r.poolInfo,
+------------- 	)
+-------------+}
+-------------+
+-------------+// createSwapInstruction внутренний метод для создания инструкции свапа
+-------------+func (r *DEX) createSwapInstruction(
+-------------+	wallet solana.PublicKey,
+-------------+	sourceATA solana.PublicKey,
+-------------+	targetATA solana.PublicKey,
+-------------+	amountIn uint64,
+-------------+	minAmountOut uint64,
+-------------+	logger *zap.Logger,
+-------------+	poolInfo *Pool,
+-------------+) (solana.Instruction, error) {
+-------------+	// Существующая логика из CreateSwapInstruction
+-------------+	return r.CreateSwapInstruction(
+-------------+		wallet,
+-------------+		sourceATA,
+-------------+		targetATA,
+-------------+		amountIn,
+-------------+		minAmountOut,
+-------------+		logger,
+-------------+		poolInfo,
+-------------+	)
+-------------+}
+-------------+
+-------------+// Вспомогательный метод для получения mint address из ATA
+-------------+func (r *DEX) getMintFromATA(ctx context.Context, ata solana.PublicKey) (solana.PublicKey, error) {
+-------------+	account, err := r.client.GetAccountInfo(ctx, ata)
+------------- 	if err != nil {
+--------------		return nil, fmt.Errorf("failed to create swap instruction: %w", err)
+-------------+		return solana.PublicKey{}, fmt.Errorf("failed to get ATA info: %w", err)
+------------- 	}
+------------- 
+--------------	logger.Debug("Swap instruction prepared successfully")
+--------------	return instruction, nil
+-------------+	if account.Value == nil || len(account.Value.Data.GetBinary()) < 32 {
+-------------+		return solana.PublicKey{}, fmt.Errorf("invalid ATA account data")
+-------------+	}
+-------------+
+-------------+	data := account.Value.Data.GetBinary()[:32]
+-------------+	if len(data) != 32 {
+-------------+		return solana.PublicKey{}, fmt.Errorf("invalid public key length: expected 32 bytes, got %d", len(data))
+-------------+	}
+-------------+
+-------------+	pubkey := solana.PublicKeyFromBytes(data)
+-------------+	if pubkey.IsZero() {
+-------------+		return solana.PublicKey{}, fmt.Errorf("invalid zero public key")
+-------------+	}
+-------------+
+-------------+	return pubkey, nil
+------------- }
+------------- 
+------------- func (r *DEX) sendTransactionWithRetry(
+-------------@@ -376,3 +443,117 @@ func parseTokenAddresses(sourceToken, targetToken string) (solana.PublicKey, sol
+------------- 
+------------- 	return sourceMint, targetMint, nil
+------------- }
+-------------+
+-------------+// getExpectedOutput вычисляет ожидаемый выход для свапа
+-------------+func (r *DEX) getExpectedOutput(
+-------------+	ctx context.Context,
+-------------+	amountIn uint64,
+-------------+	sourceToken, targetToken solana.PublicKey,
+-------------+	poolInfo *Pool,
+-------------+	logger *zap.Logger,
+-------------+) (float64, error) {
+-------------+	// Создаем контекст с таймаутом
+-------------+	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
+-------------+	defer cancel()
+-------------+
+-------------+	logger = logger.With(
+-------------+		zap.String("source_token", sourceToken.String()),
+-------------+		zap.String("target_token", targetToken.String()),
+-------------+		zap.Uint64("amount_in", amountIn),
+-------------+	)
+-------------+
+-------------+	// Получаем состояние пула
+-------------+	poolState, err := r.getPoolState(ctx, poolInfo)
+-------------+	if err != nil {
+-------------+		return 0, fmt.Errorf("failed to get pool state: %w", err)
+-------------+	}
+-------------+
+-------------+	logger.Debug("Pool state retrieved",
+-------------+		zap.Uint64("token_a_reserve", poolState.TokenAReserve),
+-------------+		zap.Uint64("token_b_reserve", poolState.TokenBReserve),
+-------------+		zap.Float64("swap_fee", poolState.SwapFee))
+-------------+
+-------------+	// Вычисляем ожидаемый выход с учетом всех факторов
+-------------+	expectedOut := r.calculateExpectedOutput(amountIn, poolState)
+-------------+
+-------------+	logger.Debug("Expected output calculated",
+-------------+		zap.Float64("expected_out", expectedOut))
+-------------+
+-------------+	return expectedOut, nil
+-------------+}
+-------------+
+-------------+// getPoolState получает текущее состояние пула
+-------------+func (r *DEX) getPoolState(ctx context.Context, poolInfo *Pool) (*PoolState, error) {
+-------------+	// Получаем аккаунт пула
+-------------+	poolAccount, err := r.client.GetAccountInfo(ctx, solana.MustPublicKeyFromBase58(poolInfo.AmmID))
+-------------+	if err != nil {
+-------------+		return nil, fmt.Errorf("failed to get pool account: %w", err)
+-------------+	}
+-------------+
+-------------+	if poolAccount == nil || poolAccount.Value == nil {
+-------------+		return nil, fmt.Errorf("pool account not found")
+-------------+	}
+-------------+
+-------------+	// Парсим данные аккаунта
+-------------+	data := poolAccount.Value.Data.GetBinary()
+-------------+	if len(data) < 8+32*2 { // Минимальный размер для резервов
+-------------+		return nil, fmt.Errorf("invalid pool account data size")
+-------------+	}
+-------------+
+-------------+	// Извлекаем резервы из данных аккаунта
+-------------+	// Обратите внимание: это упрощенная версия, реальная структура данных может отличаться
+-------------+	tokenAReserve := binary.LittleEndian.Uint64(data[8:16])
+-------------+	tokenBReserve := binary.LittleEndian.Uint64(data[16:24])
+-------------+
+-------------+	// Получаем информацию о комиссии пула
+-------------+	swapFee := 0.25 // 0.25% это стандартная комиссия Raydium
+-------------+
+-------------+	return &PoolState{
+-------------+		TokenAReserve: tokenAReserve,
+-------------+		TokenBReserve: tokenBReserve,
+-------------+		SwapFee:       swapFee,
+-------------+	}, nil
+-------------+}
+-------------+
+-------------+// calculateExpectedOutput вычисляет ожидаемый выход на основе состояния пула
+-------------+func (r *DEX) calculateExpectedOutput(amountIn uint64, state *PoolState) float64 {
+-------------+	// Константа k = x * y, где x и y - резервы токенов
+-------------+	k := float64(state.TokenAReserve) * float64(state.TokenBReserve)
+-------------+
+-------------+	// Вычисляем amount_in после комиссии
+-------------+	amountInAfterFee := float64(amountIn) * (1 - state.SwapFee/100)
+-------------+
+-------------+	// Новый резерв входного токена
+-------------+	newSourceReserve := float64(state.TokenAReserve) + amountInAfterFee
+-------------+
+-------------+	// Вычисляем новый резерв выходного токена используя формулу k = x * y
+-------------+	newTargetReserve := k / newSourceReserve
+-------------+
+-------------+	// Ожидаемый выход это разница между старым и новым резервом
+-------------+	expectedOut := float64(state.TokenBReserve) - newTargetReserve
+-------------+
+-------------+	// Применяем дополнительный запас надежности
+-------------+	safetyFactor := 0.995 // 0.5% запас для учета изменения цены
+-------------+	return expectedOut * safetyFactor
+-------------+}
+-------------+
+-------------+// GetAmountOutQuote получает котировку для свапа
+-------------+func (r *DEX) GetAmountOutQuote(
+-------------+	ctx context.Context,
+-------------+	amountIn uint64,
+-------------+	sourceToken, targetToken solana.PublicKey,
+-------------+) (float64, error) {
+-------------+	// Создаем временный пул для получения котировки
+-------------+	poolInfo := r.poolInfo
+-------------+	if poolInfo == nil {
+-------------+		return 0, fmt.Errorf("pool info not configured")
+-------------+	}
+-------------+
+-------------+	// Получаем ожидаемый выход
+-------------+	expectedOut, err := r.getExpectedOutput(ctx, amountIn, sourceToken, targetToken, poolInfo, r.logger)
+-------------+	if err != nil {
+-------------+		return 0, fmt.Errorf("failed to get expected output: %w", err)
+-------------+	}
+-------------+
+-------------+	return expectedOut, nil
+-------------+}
+-------------diff --git a/internal/dex/raydium/types.go b/internal/dex/raydium/types.go
+-------------index dd0f18f..cd3089e 100644
+---------------- a/internal/dex/raydium/types.go
+-------------+++ b/internal/dex/raydium/types.go
+-------------@@ -55,3 +55,10 @@ func (r *Pool) GetTokenAccounts() (string, string) {
+------------- func (r *DEX) Name() string {
+------------- 	return "Raydium"
+------------- }
+-------------+
+-------------+// PoolState содержит состояние пула ликвидности
+-------------+type PoolState struct {
+-------------+	TokenAReserve uint64
+-------------+	TokenBReserve uint64
+-------------+	SwapFee       float64 // в процентах
+-------------+}
+-------------diff --git a/internal/dex/raydium/validation.go b/internal/dex/raydium/validation.go
+-------------index a948715..9267897 100644
+---------------- a/internal/dex/raydium/validation.go
+-------------+++ b/internal/dex/raydium/validation.go
+-------------@@ -1,5 +1,4 @@
+------------- // internal/dex/raydium/validation.go
+--------------
+------------- package raydium
+------------- 
+------------- import (
+-------------@@ -11,7 +10,6 @@ import (
+------------- 
+------------- // ValidateTask проверяет корректность параметров задачи
+------------- func ValidateTask(task *types.Task) error {
+--------------
+------------- 	if task == nil {
+------------- 		return fmt.Errorf("task cannot be nil")
+------------- 	}
+-------------@@ -41,8 +39,20 @@ func ValidateTask(task *types.Task) error {
+------------- 		return fmt.Errorf("amount in must be greater than 0")
+------------- 	}
+------------- 
+--------------	if task.MinAmountOut <= 0 {
+--------------		return fmt.Errorf("min amount out must be greater than 0")
+-------------+	// Удаляем проверку MinAmountOut, так как теперь оно может быть нулевым или пустым
+-------------+	// if task.MinAmountOut <= 0 {
+-------------+	//     return fmt.Errorf("min amount out must be greater than 0")
+-------------+	// }
+-------------+
+-------------+	// Проверяем конфигурацию проскальзывания, если она используется
+-------------+	if task.SlippageConfig.Type != types.SlippageNone {
+-------------+		if task.SlippageConfig.Type == types.SlippagePercent &&
+-------------+			(task.SlippageConfig.Value <= 0 || task.SlippageConfig.Value > 100) {
+-------------+			return fmt.Errorf("slippage percentage must be between 0 and 100")
+-------------+		}
+-------------+		if task.SlippageConfig.Type == types.SlippageFixed && task.SlippageConfig.Value < 0 {
+-------------+			return fmt.Errorf("fixed slippage value cannot be negative")
+-------------+		}
+------------- 	}
+------------- 
+------------- 	if task.SourceTokenDecimals <= 0 {
+-------------diff --git a/internal/sniping/strategy.go b/internal/sniping/strategy.go
+-------------index 91602f1..aa5b32c 100644
+---------------- a/internal/sniping/strategy.go
+-------------+++ b/internal/sniping/strategy.go
+-------------@@ -60,9 +60,12 @@ func parseTask(record []string) (*types.Task, error) {
+------------- 		return nil, fmt.Errorf("invalid AmountIn value: %v", err)
+------------- 	}
+------------- 
+--------------	minAmountOut, err := strconv.ParseFloat(record[10], 64)
+--------------	if err != nil {
+--------------		return nil, fmt.Errorf("invalid MinAmountOut value: %v", err)
+-------------+	slippageValue := 1.0 // Значение по умолчанию
+-------------+	if record[10] != "" {
+-------------+		slippageValue, err = strconv.ParseFloat(record[10], 64)
+-------------+		if err != nil {
+-------------+			return nil, fmt.Errorf("invalid Slippage value: %v", err)
+-------------+		}
+------------- 	}
+------------- 
+------------- 	autosellPercent, err := strconv.ParseFloat(record[11], 64)
+-------------@@ -107,12 +110,15 @@ func parseTask(record []string) (*types.Task, error) {
+------------- 		SourceToken:         record[7],
+------------- 		TargetToken:         record[8],
+------------- 		AmountIn:            amountIn,
+--------------		MinAmountOut:        minAmountOut,
+------------- 		AutosellPercent:     autosellPercent,
+------------- 		AutosellDelay:       autosellDelay,
+------------- 		AutosellAmount:      autosellAmount,
+------------- 		TransactionDelay:    transactionDelay,
+------------- 		AutosellPriorityFee: autosellPriorityFee,
+--------------		DEXName:             dexName, // Устанавливаем имя DEX
+-------------+		DEXName:             dexName,
+-------------+		SlippageConfig: types.SlippageConfig{
+-------------+			Type:  types.SlippagePercent, // Используем процентное проскальзывание по умолчанию
+-------------+			Value: slippageValue,
+-------------+		},
+------------- 	}, nil
+------------- }
+-------------diff --git a/internal/types/types.go b/internal/types/types.go
+-------------index babccdd..6b8c246 100644
+---------------- a/internal/types/types.go
+-------------+++ b/internal/types/types.go
+-------------@@ -20,7 +20,6 @@ type Task struct {
+------------- 	SourceToken                 string
+------------- 	TargetToken                 string
+------------- 	AmountIn                    float64
+--------------	MinAmountOut                float64
+------------- 	AutosellPercent             float64
+------------- 	AutosellDelay               int
+------------- 	AutosellAmount              float64
+-------------@@ -31,6 +30,7 @@ type Task struct {
+------------- 	SourceTokenDecimals         int
+------------- 	TargetTokenDecimals         int
+------------- 	DEXName                     string `default:"Raydium"` // Добавляем значение по умолчанию
+-------------+	SlippageConfig              SlippageConfig
+------------- }
+------------- 
+------------- type DEX interface {
+-------------@@ -41,7 +41,6 @@ type DEX interface {
+------------- 		sourceToken solana.PublicKey,
+------------- 		destinationToken solana.PublicKey,
+------------- 		amountIn uint64,
+--------------		minAmountOut uint64,
+------------- 		logger *zap.Logger,
+------------- 	) (solana.Instruction, error)
+------------- 
+-------------diff --git a/internal/utils/logger/logger.go b/internal/utils/logger/logger.go
+-------------index e5e813c..5b76758 100644
+---------------- a/internal/utils/logger/logger.go
+-------------+++ b/internal/utils/logger/logger.go
+-------------@@ -138,7 +138,8 @@ func (l *Logger) WithTask(task *types.Task) *zap.Logger {
+------------- 		zap.String("source_token", task.SourceToken),
+------------- 		zap.String("target_token", task.TargetToken),
+------------- 		zap.Float64("amount_in", task.AmountIn),
+--------------		zap.Float64("min_amount_out", task.MinAmountOut),
+-------------+		zap.String("slippage_type", string(task.SlippageConfig.Type)),
+-------------+		zap.Float64("slippage_value", task.SlippageConfig.Value),
+------------- 		zap.Float64("priority_fee", task.PriorityFee),
+------------- 	)
+------------- }
+----diff --git a/swap-ts.txt b/swap-ts.txt
+----new file mode 100644
+----index 0000000..8db4319
+------- /dev/null
+----+++ b/swap-ts.txt
+----@@ -0,0 +1,623 @@
+----+// config.ts
+----+import dotenv from 'dotenv';
+----+import https from 'https';
+----+dotenv.config();
+----+
+----+if (!process.env.QUICKNODE_URL) {
+----+  throw new Error('QUICKNODE_URL is not set in the environment variables');
+----+}
+----+
+----+if (!process.env.WALLET_SECRET_KEY) {
+----+  throw new Error('WALLET_SECRET_KEY is not set in the environment variables');
+----+}
+----+
+----+interface PriorityFeeResponse {
+----+  jsonrpc: string;
+----+  result: {
+----+    per_compute_unit: {
+----+      extreme: number;
+----+      medium: number;
+----+    };
+----+  };
+----+  id: number;
+----+}
+----+
+----+function httpsRequest(url: string, options: https.RequestOptions, data: string): Promise<string> {
+----+  return new Promise((resolve, reject) => {
+----+    const req = https.request(url, options, (res) => {
+----+      let body = '';
+----+      res.on('data', (chunk) => body += chunk.toString());
+----+      res.on('end', () => resolve(body));
+----+    });
+----+    req.on('error', reject);
+----+    req.write(data);
+----+    req.end();
+----+  });
+----+}
+----+
+----+async function fetchPriorityFee(): Promise<number> {
+----+  if (!process.env.QUICKNODE_URL) {
+----+    throw new Error('QUICKNODE_URL is not set in the environment variables');
+----+  }
+----+
+----+  const url = new URL(process.env.QUICKNODE_URL);
+----+  const options: https.RequestOptions = {
+----+    method: 'POST',
+----+    headers: {
+----+      'Content-Type': 'application/json',
+----+    },
+----+  };
+----+
+----+  const requestBody = JSON.stringify({
+----+    jsonrpc: '2.0',
+----+    id: 1,
+----+    method: 'qn_estimatePriorityFees',
+----+    params: {
+----+      last_n_blocks: 100,
+----+      account: '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8',
+----+      api_version: 2
+----+    }
+----+  });
+----+
+----+  const response = await httpsRequest(url.href, options, requestBody);
+----+  const data: unknown = JSON.parse(response);
+----+  
+----+  if (!isPriorityFeeResponse(data)) {
+----+    throw new Error('Unexpected response format from priority fee API');
+----+  }
+----+  
+----+  // Using the 'extreme' priority fee from 'per_compute_unit'
+----+  const extremePriorityFeePerCU = data.result.per_compute_unit.extreme;
+----+  
+----+  // Estimate compute units for the transaction (this is an approximation)
+----+  const estimatedComputeUnits = 300000; // Adjust this based on your typical transaction
+----+  
+----+  // Calculate total priority fee in micro-lamports
+----+  const totalPriorityFeeInMicroLamports = extremePriorityFeePerCU * estimatedComputeUnits;
+----+  
+----+  // Convert to SOL (1 SOL = 1e9 lamports = 1e15 micro-lamports)
+----+  const priorityFeeInSOL = totalPriorityFeeInMicroLamports / 1e15;
+----+  
+----+  // Ensure the fee is not less than 0.000001 SOL (minimum fee)
+----+  return Math.max(priorityFeeInSOL, 0.000001);
+----+}
+----+
+----+function isPriorityFeeResponse(data: unknown): data is PriorityFeeResponse {
+----+  return (
+----+    typeof data === 'object' &&
+----+    data !== null &&
+----+    'jsonrpc' in data &&
+----+    'result' in data &&
+----+    typeof data.result === 'object' &&
+----+    data.result !== null &&
+----+    'per_compute_unit' in data.result &&
+----+    typeof data.result.per_compute_unit === 'object' &&
+----+    data.result.per_compute_unit !== null &&
+----+    'extreme' in data.result.per_compute_unit &&
+----+    typeof data.result.per_compute_unit.extreme === 'number'
+----+  );
+----+}
+----+
+----+export const CONFIG = {
+----+  RPC_URL: process.env.QUICKNODE_URL,
+----+  WALLET_SECRET_KEY: process.env.WALLET_SECRET_KEY,
+----+  BASE_MINT: 'So11111111111111111111111111111111111111112', // SOLANA mint address
+----+  QUOTE_MINT: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263', // BONK mint address
+----+  TOKEN_A_AMOUNT: 0.000001,
+----+  EXECUTE_SWAP: true,
+----+  USE_VERSIONED_TRANSACTION: false,
+----+  SLIPPAGE: 5,
+----+  getPriorityFee: fetchPriorityFee,
+----+};
+----+
+----+// main.ts
+----+
+----+import { RaydiumSwap } from './raydium-swap';
+----+import { CONFIG } from './config';
+----+import { 
+----+  PublicKey,
+----+  LAMPORTS_PER_SOL,
+----+  Transaction,
+----+  VersionedTransaction,
+----+} from '@solana/web3.js';
+----+
+----+async function getTokenBalance(raydiumSwap: RaydiumSwap, mint: string): Promise<number> {
+----+  const userTokenAccounts = await raydiumSwap.getOwnerTokenAccounts();
+----+  const tokenAccount = userTokenAccounts.find(account => 
+----+    account.accountInfo.mint.equals(new PublicKey(mint))
+----+  );
+----+  if (tokenAccount) {
+----+    const balance = await raydiumSwap.connection.getTokenAccountBalance(tokenAccount.pubkey);
+----+    return balance.value.uiAmount || 0;
+----+  }
+----+  return 0;
+----+}
+----+
+----+async function swap() {
+----+  console.log('Starting swap process...');
+----+  const raydiumSwap = new RaydiumSwap(CONFIG.RPC_URL, CONFIG.WALLET_SECRET_KEY);
+----+
+----+  await raydiumSwap.loadPoolKeys();
+----+  let poolInfo = raydiumSwap.findPoolInfoForTokens(CONFIG.BASE_MINT, CONFIG.QUOTE_MINT) 
+----+    || await raydiumSwap.findRaydiumPoolInfo(CONFIG.BASE_MINT, CONFIG.QUOTE_MINT);
+----+
+----+  if (!poolInfo) {
+----+    throw new Error("Couldn't find the pool info");
+----+  }
+----+
+----+  await raydiumSwap.createWrappedSolAccountInstruction(CONFIG.TOKEN_A_AMOUNT);
+----+
+----+  console.log('Fetching current priority fee...');
+----+  const priorityFee = await CONFIG.getPriorityFee();
+----+  console.log(`Current priority fee: ${priorityFee} SOL`);
+----+
+----+  console.log('Creating swap transaction...');
+----+  const swapTx = await raydiumSwap.getSwapTransaction(
+----+    CONFIG.QUOTE_MINT,
+----+    CONFIG.TOKEN_A_AMOUNT,
+----+    poolInfo,
+----+    CONFIG.USE_VERSIONED_TRANSACTION,
+----+    CONFIG.SLIPPAGE
+----+  );
+----+
+----+  console.log(`Using priority fee: ${priorityFee} SOL`);
+----+  console.log(`Transaction signed with payer: ${raydiumSwap.wallet.publicKey.toBase58()}`);
+----+
+----+  console.log(`Swapping ${CONFIG.TOKEN_A_AMOUNT} SOL for BONK`);
+----+
+----+  if (CONFIG.EXECUTE_SWAP) {
+----+    try {
+----+      let txid: string;
+----+      if (CONFIG.USE_VERSIONED_TRANSACTION) {
+----+        if (!(swapTx instanceof VersionedTransaction)) {
+----+          throw new Error('Expected a VersionedTransaction but received a different type');
+----+        }
+----+        const latestBlockhash = await raydiumSwap.connection.getLatestBlockhash();
+----+        txid = await raydiumSwap.sendVersionedTransaction(
+----+          swapTx,
+----+          latestBlockhash.blockhash,
+----+          latestBlockhash.lastValidBlockHeight
+----+        );
+----+      } else {
+----+        if (!(swapTx instanceof Transaction)) {
+----+          throw new Error('Expected a Transaction but received a different type');
+----+        }
+----+        txid = await raydiumSwap.sendLegacyTransaction(swapTx);
+----+      }
+----+      console.log(`Transaction sent, signature: ${txid}`);
+----+      console.log(`Transaction executed: https://explorer.solana.com/tx/${txid}`);
+----+      
+----+      console.log('Transaction confirmed successfully');
+----+
+----+      // Fetch and display token balances
+----+      const solBalance = await raydiumSwap.connection.getBalance(raydiumSwap.wallet.publicKey) / LAMPORTS_PER_SOL;
+----+      const bonkBalance = await getTokenBalance(raydiumSwap, CONFIG.QUOTE_MINT);
+----+
+----+      console.log('\nToken Balances After Swap:');
+----+      console.log(`SOL: ${solBalance.toFixed(6)} SOL`);
+----+      console.log(`BONK: ${bonkBalance.toFixed(2)} BONK`);
+----+    } catch (error) {
+----+      console.error('Error executing transaction:', error);
+----+    }
+----+  } else {
+----+    console.log('Simulating transaction (dry run)');
+----+    try {
+----+      let simulationResult;
+----+      if (CONFIG.USE_VERSIONED_TRANSACTION) {
+----+        if (!(swapTx instanceof VersionedTransaction)) {
+----+          throw new Error('Expected a VersionedTransaction but received a different type');
+----+        }
+----+        simulationResult = await raydiumSwap.simulateVersionedTransaction(swapTx);
+----+      } else {
+----+        if (!(swapTx instanceof Transaction)) {
+----+          throw new Error('Expected a Transaction but received a different type');
+----+        }
+----+        simulationResult = await raydiumSwap.simulateLegacyTransaction(swapTx);
+----+      }
+----+      console.log('Simulation successful');
+----+      console.log('Simulated transaction details:');
+----+      console.log(`Logs:`, simulationResult.logs);
+----+      console.log(`Units consumed:`, simulationResult.unitsConsumed);
+----+      if (simulationResult.returnData) {
+----+        console.log(`Return data:`, simulationResult.returnData);
+----+      }
+----+    } catch (error) {
+----+      console.error('Error simulating transaction:', error);
+----+    }
+----+  }
+----+}
+----+
+----+swap().catch((error) => {
+----+  console.error('An error occurred during the swap process:');
+----+  console.error(error);
+----+});
+----+
+----+// raydium-swap.ts
+----+import {
+----+  Connection,
+----+  PublicKey,
+----+  Keypair,
+----+  Transaction,
+----+  VersionedTransaction,
+----+  TransactionMessage,
+----+  GetProgramAccountsResponse,
+----+  TransactionInstruction,
+----+  LAMPORTS_PER_SOL,
+----+  SystemProgram,
+----+  SimulatedTransactionResponse,
+----+  TransactionConfirmationStrategy,  // Add this line
+----+} from '@solana/web3.js';
+----+import {
+----+  Liquidity,
+----+  LiquidityPoolKeys,
+----+  jsonInfo2PoolKeys,
+----+  TokenAccount,
+----+  Token,
+----+  TokenAmount,
+----+  TOKEN_PROGRAM_ID,
+----+  Percent,
+----+  SPL_ACCOUNT_LAYOUT,
+----+  LIQUIDITY_STATE_LAYOUT_V4,
+----+  MARKET_STATE_LAYOUT_V3,
+----+  Market,
+----+} from '@raydium-io/raydium-sdk';
+----+import { Wallet } from '@project-serum/anchor';
+----+import base58 from 'bs58';
+----+import { existsSync } from 'fs';
+----+import { readFile } from 'fs/promises';
+----+import { 
+----+  NATIVE_MINT,
+----+  createInitializeAccountInstruction, 
+----+  createCloseAccountInstruction,
+----+  getMinimumBalanceForRentExemptAccount,
+----+  createSyncNativeInstruction,
+----+} from '@solana/spl-token';
+----+import { CONFIG } from './config';
+----+
+----+type SwapSide = "in" | "out";
+----+
+----+export class RaydiumSwap {
+----+  static RAYDIUM_V4_PROGRAM_ID = '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8';
+----+
+----+  allPoolKeysJson: any[] = [];
+----+  connection: Connection;
+----+  wallet: Wallet;
+----+
+----+  constructor(RPC_URL: string, WALLET_SECRET_KEY: string) {
+----+    if (!RPC_URL.startsWith('http://') && !RPC_URL.startsWith('https://')) {
+----+      throw new Error('Invalid RPC URL. Must start with http:// or https://');
+----+    }
+----+    this.connection = new Connection(RPC_URL, 'confirmed');
+----+
+----+    try {
+----+      if (!WALLET_SECRET_KEY) {
+----+        throw new Error('WALLET_SECRET_KEY is not provided');
+----+      }
+----+      const secretKey = base58.decode(WALLET_SECRET_KEY);
+----+      if (secretKey.length !== 64) {
+----+        throw new Error('Invalid secret key length. Expected 64 bytes.');
+----+      }
+----+      this.wallet = new Wallet(Keypair.fromSecretKey(secretKey));
+----+      console.log('Wallet initialized with public key:', this.wallet.publicKey.toBase58());
+----+    } catch (error) {
+----+      if (error instanceof Error) {
+----+        throw new Error(`Failed to create wallet: ${error.message}`);
+----+      } else {
+----+        throw new Error('Failed to create wallet: Unknown error');
+----+      }
+----+    }
+----+  }
+----+
+----+  async loadPoolKeys() {
+----+    try {
+----+      if (existsSync('mainnet.json')) {
+----+        const data = JSON.parse((await readFile('mainnet.json')).toString());
+----+        this.allPoolKeysJson = data.official;
+----+        return;
+----+      }
+----+      throw new Error('mainnet.json file not found');
+----+    } catch (error) {
+----+      this.allPoolKeysJson = [];
+----+    }
+----+  }
+----+
+----+  findPoolInfoForTokens(mintA: string, mintB: string): LiquidityPoolKeys | null {
+----+    const poolData = this.allPoolKeysJson.find(
+----+      (i) => (i.baseMint === mintA && i.quoteMint === mintB) || (i.baseMint === mintB && i.quoteMint === mintA)
+----+    );
+----+    return poolData ? jsonInfo2PoolKeys(poolData) as LiquidityPoolKeys : null;
+----+  }
+----+
+----+  async getProgramAccounts(baseMint: string, quoteMint: string): Promise<GetProgramAccountsResponse> {
+----+    const layout = LIQUIDITY_STATE_LAYOUT_V4;
+----+    return this.connection.getProgramAccounts(new PublicKey(RaydiumSwap.RAYDIUM_V4_PROGRAM_ID), {
+----+      filters: [
+----+        { dataSize: layout.span },
+----+        {
+----+          memcmp: {
+----+            offset: layout.offsetOf('baseMint'),
+----+            bytes: new PublicKey(baseMint).toBase58(),
+----+          },
+----+        },
+----+        {
+----+          memcmp: {
+----+            offset: layout.offsetOf('quoteMint'),
+----+            bytes: new PublicKey(quoteMint).toBase58(),
+----+          },
+----+        },
+----+      ],
+----+    });
+----+  }
+----+
+----+  async findRaydiumPoolInfo(baseMint: string, quoteMint: string): Promise<LiquidityPoolKeys | null> {
+----+    const layout = LIQUIDITY_STATE_LAYOUT_V4;
+----+    const programData = await this.getProgramAccounts(baseMint, quoteMint);
+----+    const collectedPoolResults = programData
+----+      .map((info) => ({
+----+        id: new PublicKey(info.pubkey),
+----+        version: 4,
+----+        programId: new PublicKey(RaydiumSwap.RAYDIUM_V4_PROGRAM_ID),
+----+        ...layout.decode(info.account.data),
+----+      }))
+----+      .flat();
+----+
+----+    const pool = collectedPoolResults[0];
+----+    if (!pool) return null;
+----+
+----+    const market = await this.connection.getAccountInfo(pool.marketId).then((item) => {
+----+      if (!item) {
+----+        throw new Error('Market account not found');
+----+      }
+----+      return {
+----+        programId: item.owner,
+----+        ...MARKET_STATE_LAYOUT_V3.decode(item.data),
+----+      };
+----+    });
+----+
+----+    const authority = Liquidity.getAssociatedAuthority({
+----+      programId: new PublicKey(RaydiumSwap.RAYDIUM_V4_PROGRAM_ID),
+----+    }).publicKey;
+----+
+----+    const marketProgramId = market.programId;
+----+
+----+    return {
+----+      id: pool.id,
+----+      baseMint: pool.baseMint,
+----+      quoteMint: pool.quoteMint,
+----+      lpMint: pool.lpMint,
+----+      baseDecimals: Number.parseInt(pool.baseDecimal.toString()),
+----+      quoteDecimals: Number.parseInt(pool.quoteDecimal.toString()),
+----+      lpDecimals: Number.parseInt(pool.baseDecimal.toString()),
+----+      version: pool.version,
+----+      programId: pool.programId,
+----+      openOrders: pool.openOrders,
+----+      targetOrders: pool.targetOrders,
+----+      baseVault: pool.baseVault,
+----+      quoteVault: pool.quoteVault,
+----+      marketVersion: 3,
+----+      authority: authority,
+----+      marketProgramId,
+----+      marketId: market.ownAddress,
+----+      marketAuthority: Market.getAssociatedAuthority({
+----+        programId: marketProgramId,
+----+        marketId: market.ownAddress,
+----+      }).publicKey,
+----+      marketBaseVault: market.baseVault,
+----+      marketQuoteVault: market.quoteVault,
+----+      marketBids: market.bids,
+----+      marketAsks: market.asks,
+----+      marketEventQueue: market.eventQueue,
+----+      withdrawQueue: pool.withdrawQueue,
+----+      lpVault: pool.lpVault,
+----+      lookupTableAccount: PublicKey.default,
+----+    } as LiquidityPoolKeys;
+----+  }
+----+
+----+  async getOwnerTokenAccounts() {
+----+    const walletTokenAccount = await this.connection.getTokenAccountsByOwner(this.wallet.publicKey, {
+----+      programId: TOKEN_PROGRAM_ID,
+----+    });
+----+    return walletTokenAccount.value.map((i) => ({
+----+      pubkey: i.pubkey,
+----+      programId: i.account.owner,
+----+      accountInfo: SPL_ACCOUNT_LAYOUT.decode(i.account.data),
+----+    }));
+----+  }
+----+
+----+  private getSwapSide(
+----+    poolKeys: LiquidityPoolKeys,
+----+    wantFrom: PublicKey,
+----+    wantTo: PublicKey,
+----+  ): SwapSide {
+----+    if (poolKeys.baseMint.equals(wantFrom) && poolKeys.quoteMint.equals(wantTo)) {
+----+      return "in";
+----+    } else if (poolKeys.baseMint.equals(wantTo) && poolKeys.quoteMint.equals(wantFrom)) {
+----+      return "out";
+----+    } else {
+----+      throw new Error("Not suitable pool fetched. Can't determine swap side");
+----+    }
+----+  }
+----+
+----+  async getSwapTransaction(
+----+    toToken: string,
+----+    amount: number,
+----+    poolKeys: LiquidityPoolKeys,
+----+    useVersionedTransaction = true,
+----+    slippage: number = 5
+----+  ): Promise<Transaction | VersionedTransaction> {
+----+    const poolInfo = await Liquidity.fetchInfo({ connection: this.connection, poolKeys });
+----+    
+----+    const fromToken = poolKeys.baseMint.toString() === NATIVE_MINT.toString() ? NATIVE_MINT.toString() : poolKeys.quoteMint.toString();
+----+    const swapSide = this.getSwapSide(poolKeys, new PublicKey(fromToken), new PublicKey(toToken));
+----+
+----+    const baseToken = new Token(TOKEN_PROGRAM_ID, poolKeys.baseMint, poolInfo.baseDecimals);
+----+    const quoteToken = new Token(TOKEN_PROGRAM_ID, poolKeys.quoteMint, poolInfo.quoteDecimals);
+----+
+----+    const currencyIn = swapSide === "in" ? baseToken : quoteToken;
+----+    const currencyOut = swapSide === "in" ? quoteToken : baseToken;
+----+
+----+    const amountIn = new TokenAmount(currencyIn, amount, false);
+----+    const slippagePercent = new Percent(slippage, 100);
+----+
+----+    const { amountOut, minAmountOut } = Liquidity.computeAmountOut({
+----+      poolKeys,
+----+      poolInfo,
+----+      amountIn,
+----+      currencyOut,
+----+      slippage: slippagePercent,
+----+    });
+----+
+----+    const userTokenAccounts = await this.getOwnerTokenAccounts();
+----+
+----+    const priorityFee = await CONFIG.getPriorityFee();
+----+    console.log(`Using priority fee: ${priorityFee} SOL`);
+----+
+----+    const swapTransaction = await Liquidity.makeSwapInstructionSimple({
+----+      connection: this.connection,
+----+      makeTxVersion: useVersionedTransaction ? 0 : 1,
+----+      poolKeys: {
+----+        ...poolKeys,
+----+      },
+----+      userKeys: {
+----+        tokenAccounts: userTokenAccounts,
+----+        owner: this.wallet.publicKey,
+----+      },
+----+      amountIn,
+----+      amountOut: minAmountOut,
+----+      fixedSide: swapSide,
+----+      config: {
+----+        bypassAssociatedCheck: false,
+----+      },
+----+      computeBudgetConfig: {
+----+        units: 300000,
+----+        microLamports: Math.floor(priorityFee * LAMPORTS_PER_SOL),
+----+      },
+----+    });
+----+
+----+    const recentBlockhashForSwap = await this.connection.getLatestBlockhash();
+----+    const instructions = swapTransaction.innerTransactions[0].instructions.filter(
+----+      (instruction): instruction is TransactionInstruction => Boolean(instruction)
+----+    );
+----+
+----+    if (useVersionedTransaction) {
+----+      const versionedTransaction = new VersionedTransaction(
+----+        new TransactionMessage({
+----+          payerKey: this.wallet.publicKey,
+----+          recentBlockhash: recentBlockhashForSwap.blockhash,
+----+          instructions: instructions,
+----+        }).compileToV0Message()
+----+      );
+----+      versionedTransaction.sign([this.wallet.payer]);
+----+      console.log('Versioned transaction signed with payer:', this.wallet.payer.publicKey.toBase58());
+----+      return versionedTransaction;
+----+    }
+----+
+----+    const legacyTransaction = new Transaction({
+----+      blockhash: recentBlockhashForSwap.blockhash,
+----+      lastValidBlockHeight: recentBlockhashForSwap.lastValidBlockHeight,
+----+      feePayer: this.wallet.publicKey,
+----+    });
+----+    legacyTransaction.add(...instructions);
+----+    console.log('Legacy transaction signed with payer:', this.wallet.payer.publicKey.toBase58());
+----+    return legacyTransaction;
+----+  }
+----+
+----+  async sendLegacyTransaction(tx: Transaction): Promise<string> {
+----+    const signature = await this.connection.sendTransaction(tx, [this.wallet.payer], {
+----+      skipPreflight: true,
+----+      preflightCommitment: 'confirmed',
+----+    });
+----+    console.log('Legacy transaction sent, signature:', signature);
+----+    const latestBlockhash = await this.connection.getLatestBlockhash();
+----+const confirmationStrategy: TransactionConfirmationStrategy = {
+----+  signature: signature,
+----+  blockhash: latestBlockhash.blockhash,
+----+  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
+----+};
+----+const confirmation = await this.connection.confirmTransaction(confirmationStrategy, 'confirmed'); // Increase timeout to 60 seconds
+----+    if (confirmation.value.err) {
+----+      throw new Error(`Transaction failed: ${confirmation.value.err.toString()}`);
+----+    }
+----+    return signature;
+----+  }
+----+
+----+  async sendVersionedTransaction(
+----+    tx: VersionedTransaction,
+----+    blockhash: string,
+----+    lastValidBlockHeight: number
+----+  ): Promise<string> {
+----+    const rawTransaction = tx.serialize();
+----+    const signature = await this.connection.sendRawTransaction(rawTransaction, {
+----+      skipPreflight: true,
+----+      preflightCommitment: 'confirmed',
+----+    });
+----+    console.log('Versioned transaction sent, signature:', signature);
+----+  
+----+    const confirmationStrategy: TransactionConfirmationStrategy = {
+----+      signature: signature,
+----+      blockhash: blockhash,
+----+      lastValidBlockHeight: lastValidBlockHeight,
+----+    };
+----+  
+----+    const confirmation = await this.connection.confirmTransaction(confirmationStrategy, 'confirmed');
+----+    if (confirmation.value.err) {
+----+      throw new Error(`Transaction failed: ${confirmation.value.err.toString()}`);
+----+    }
+----+    return signature;
+----+  }
+----+
+----+  async simulateLegacyTransaction(tx: Transaction): Promise<SimulatedTransactionResponse> {
+----+    const { value } = await this.connection.simulateTransaction(tx);
+----+    return value;
+----+  }
+----+
+----+  async simulateVersionedTransaction(tx: VersionedTransaction): Promise<SimulatedTransactionResponse> {
+----+    const { value } = await this.connection.simulateTransaction(tx);
+----+    return value;
+----+  }
+----+
+----+  getTokenAccountByOwnerAndMint(mint: PublicKey) {
+----+    return {
+----+      programId: TOKEN_PROGRAM_ID,
+----+      pubkey: PublicKey.default,
+----+      accountInfo: {
+----+        mint: mint,
+----+        amount: 0,
+----+      },
+----+    } as unknown as TokenAccount;
+----+  }
+----+
+----+  async createWrappedSolAccountInstruction(amount: number): Promise<{
+----+    transaction: Transaction;
+----+    wrappedSolAccount: Keypair;
+----+  }> {
+----+    const lamports = amount * LAMPORTS_PER_SOL;
+----+    const wrappedSolAccount = Keypair.generate();
+----+    const transaction = new Transaction();
+----+
+----+    const rentExemptBalance = await getMinimumBalanceForRentExemptAccount(this.connection);
+----+
+----+    transaction.add(
+----+      SystemProgram.createAccount({
+----+        fromPubkey: this.wallet.publicKey,
+----+        newAccountPubkey: wrappedSolAccount.publicKey,
+----+        lamports: rentExemptBalance,
+----+        space: 165,
+----+        programId: TOKEN_PROGRAM_ID,
+----+      }),
+----+      createInitializeAccountInstruction(
+----+        wrappedSolAccount.publicKey,
+----+        NATIVE_MINT,
+----+        this.wallet.publicKey
+----+      ),
+----+      SystemProgram.transfer({
+----+        fromPubkey: this.wallet.publicKey,
+----+        toPubkey: wrappedSolAccount.publicKey,
+----+        lamports,
+----+      }),
+----+      createSyncNativeInstruction(wrappedSolAccount.publicKey)
+----+    );
+----+
+----+    return { transaction, wrappedSolAccount };
+----+  }
+----+}
+----\ No newline at end of file
+diff --git a/scripts/run_migrations.sh b/scripts/run_migrations.sh
+deleted file mode 100644
+index 63be0aa..0000000
+--- a/scripts/run_migrations.sh
++++ /dev/null
+@@ -1,21 +0,0 @@
+-POSTGRESQL_URL='postgres://rovshan:muradov25@db:5432/ton_wallet?sslmode=disable'
+-MIGRATIONS_DIR=./migrations/migrations
+-
+-.PHONY: up down migrate-up migrate-down migrate-create
+-
+-up:
+-	docker-compose up -d
+-
+-down:
+-	docker-compose down
+-
+-migrate-up:
+-	docker-compose run --rm app migrate -database "${POSTGRESQL_URL}" -path /migrations up
+-
+-migrate-down:
+-	docker-compose run --rm app migrate -database "${POSTGRESQL_URL}" -path /migrations down 1
+-
+-migrate-create:
+-	@read -p "Enter migration name: " name; \
+-	migrate create -ext sql -dir ${MIGRATIONS_DIR} -seq $$name; \
+-	echo "Migration files created in ${MIGRATIONS_DIR}"
+\ No newline at end of file
diff --git a/scripts/run_migrations.sh b/scripts/run_migrations.sh
deleted file mode 100644
index 63be0aa..0000000
--- a/scripts/run_migrations.sh
+++ /dev/null
@@ -1,21 +0,0 @@
-POSTGRESQL_URL='postgres://rovshan:muradov25@db:5432/ton_wallet?sslmode=disable'
-MIGRATIONS_DIR=./migrations/migrations
-
-.PHONY: up down migrate-up migrate-down migrate-create
-
-up:
-	docker-compose up -d
-
-down:
-	docker-compose down
-
-migrate-up:
-	docker-compose run --rm app migrate -database "${POSTGRESQL_URL}" -path /migrations up
-
-migrate-down:
-	docker-compose run --rm app migrate -database "${POSTGRESQL_URL}" -path /migrations down 1
-
-migrate-create:
-	@read -p "Enter migration name: " name; \
-	migrate create -ext sql -dir ${MIGRATIONS_DIR} -seq $$name; \
-	echo "Migration files created in ${MIGRATIONS_DIR}"
\ No newline at end of file
