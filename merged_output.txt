
=== Содержимое файла: ./cmd/bot/main.go ===
package main

import (
	"context"
	"os"
	"os/signal"
	"syscall"

	"github.com/rovshanmuradov/solana-bot/internal/config"
	"github.com/rovshanmuradov/solana-bot/internal/sniping"
	"github.com/rovshanmuradov/solana-bot/internal/wallet"
	"github.com/rovshanmuradov/solana-bot/pkg/blockchain/solana"
	"go.uber.org/zap"
)

func main() {
	// Инициализация контекста с возможностью отмены
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Инициализация логгера
	logger, err := zap.NewProduction()
	if err != nil {
		panic("Не удалось инициализировать логгер: " + err.Error())
	}
	defer logger.Sync()

	// Загрузка конфигурации
	cfg, err := config.LoadConfig("configs/config.json")
	if err != nil {
		logger.Fatal("Ошибка загрузки конфигурации", zap.Error(err))
	}

	// Загрузка кошельков
	wallets, err := wallet.LoadWallets("configs/wallets.csv")
	if err != nil {
		logger.Fatal("Ошибка загрузки кошельков", zap.Error(err))
	}

	// Инициализация клиента Solana
	solanaClient, err := solana.NewClient(cfg.RPCList, logger)
	if err != nil {
		logger.Fatal("Ошибка инициализации клиента Solana", zap.Error(err))
	}

	// Загрузка задач
	tasks, err := sniping.LoadTasks("configs/tasks.csv")
	if err != nil {
		logger.Fatal("Ошибка загрузки задач", zap.Error(err))
	}

	// Создание экземпляра снайпера
	sniper := sniping.NewSniper(solanaClient, wallets, cfg, logger)

	// Запуск снайпера с загруженными задачами в отдельной горутине
	go func() {
		sniper.Run(ctx, tasks)
	}()

	// Ожидание сигнала завершения
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

	select {
	case <-sigCh:
		logger.Info("Получен сигнал завершения")
	case <-ctx.Done():
		logger.Info("Контекст отменен")
	}

	// Graceful shutdown
	logger.Info("Начало graceful shutdown")
	cancel()
	// Здесь можно добавить дополнительную логику завершения, если необходимо
	logger.Info("Бот успешно завершил работу")
}


=== Содержимое файла: ./configs/config.json ===


=== Содержимое файла: ./configs/tasks.csv ===


=== Содержимое файла: ./configs/wallets.csv ===


=== Содержимое файла: ./deploy/kubernetes/deployment.yaml ===


=== Содержимое файла: ./deploy/kubernetes/service.yaml ===


=== Содержимое файла: ./internal/config/config.go ===
package config

import (
	"encoding/json"
	"errors"
	"os"
)

type Config struct {
	License      string   `json:"license"`
	RPCList      []string `json:"rpc_list"`
	WebSocketURL string   `json:"websocket_url"`
	MonitorDelay int      `json:"monitor_delay"`
	RPCDelay     int      `json:"rpc_delay"`
	PriceDelay   int      `json:"price_delay"`
	DebugLogging bool     `json:"debug_logging"`
	TPSLogging   bool     `json:"tps_logging"`
	Retries      int      `json:"retries"`
	WebhookURL   string   `json:"webhook_url"`
}

// LoadConfig читает JSON-файл конфигурации и возвращает заполненную структуру Config.
func LoadConfig(path string) (*Config, error) {
	// Открытие файла конфигурации
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// Декодирование JSON в структуру Config
	var cfg Config
	decoder := json.NewDecoder(file)
	if err := decoder.Decode(&cfg); err != nil {
		return nil, err
	}

	// Валидация обязательных полей
	if err := validateConfig(&cfg); err != nil {
		return nil, err
	}

	return &cfg, nil
}

// validateConfig проверяет наличие и корректность обязательных полей конфигурации.
func validateConfig(cfg *Config) error {
	if cfg.License == "" {
		return errors.New("missing license in configuration")
	}
	if len(cfg.RPCList) == 0 {
		return errors.New("RPC list is empty in configuration")
	}
	if cfg.WebSocketURL == "" {
		return errors.New("missing WebSocket URL in configuration")
	}
	if cfg.MonitorDelay <= 0 {
		return errors.New("invalid monitor delay in configuration")
	}
	// Добавьте дополнительные проверки для других важных полей

	return nil
}


=== Содержимое файла: ./internal/eventlistener/handler.go ===
// internal/eventlistener/handler.go
package eventlistener

import (
	"go.uber.org/zap"
)

func HandleEvent(event Event, logger *zap.Logger) {
	// Проверяем, соответствует ли событие нашим критериям
	// Если да, выполняем необходимые действия
	// Например, уведомляем снайпера о новом пуле
	logger.Info("Получено событие", zap.Any("event", event))
}


=== Содержимое файла: ./internal/eventlistener/listener.go ===
// internal/eventlistener/listener.go
package eventlistener

import (
	"net"

	"github.com/gobwas/ws"
	"github.com/gobwas/ws/wsutil"
	"go.uber.org/zap"
)

type EventListener struct {
	conn   net.Conn
	logger *zap.Logger
}

type Event struct {
	// Определите поля события
}

func NewEventListener(wsURL string, logger *zap.Logger) (*EventListener, error) {
	// Устанавливаем WebSocket-соединение
	conn, _, _, err := ws.Dial(nil, wsURL)
	if err != nil {
		// Возвращаем ошибку подключения
		return nil, err
	}

	return &EventListener{
		conn:   conn,
		logger: logger,
	}, nil
}

func (el *EventListener) Subscribe(handler func(event Event)) error {
	// Запускаем цикл чтения сообщений
	go func() {
		for {
			// Читаем сообщение из WebSocket
			msg, op, err := wsutil.ReadServerData(el.conn)
			if err != nil {
				// Логируем ошибку и продолжаем или завершаем цикл
				el.logger.Error("Ошибка чтения из WebSocket", zap.Error(err))
				break
			}

			// Парсим сообщение в структуру Event
			var event Event
			// Преобразование msg в event

			// Вызываем обработчик
			handler(event)
		}
	}()

	return nil
}


=== Содержимое файла: ./internal/sniping/sniper.go ===
package sniping

import (
	"context"
	"time"

	"github.com/rovshanmuradov/solana-bot/internal/config"
	"github.com/rovshanmuradov/solana-bot/internal/wallet"
	"github.com/rovshanmuradov/solana-bot/pkg/blockchain/solana"
	"go.uber.org/zap"
)

type Sniper struct {
	client  *solana.Client
	wallets map[string]*wallet.Wallet
	config  *config.Config
	logger  *zap.Logger
}

func NewSniper(client *solana.Client, wallets map[string]*wallet.Wallet, cfg *config.Config, logger *zap.Logger) *Sniper {
	return &Sniper{
		client:  client,
		wallets: wallets,
		config:  cfg,
		logger:  logger,
	}
}

func (s *Sniper) Run(ctx context.Context, tasks []*Task) {
	for _, task := range tasks {
		go s.executeTask(ctx, task)
	}

	<-ctx.Done()
	s.logger.Info("Sniper завершил работу")
}

func (s *Sniper) executeTask(ctx context.Context, task *Task) {
	s.logger.Info("Начало выполнения задачи", zap.String("task", task.TaskName))

	ticker := time.NewTicker(time.Duration(s.config.MonitorDelay) * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			s.logger.Info("Задача отменена", zap.String("task", task.TaskName))
			return
		case <-ticker.C:
			if err := s.processTask(task); err != nil {
				s.logger.Error("Ошибка при обработке задачи", zap.Error(err), zap.String("task", task.TaskName))
			}
		}
	}
}

func (s *Sniper) processTask(task *Task) error {
	// Здесь реализуйте логику обработки задачи
	// Например, проверка условий, выполнение транзакций и т.д.
	return nil
}


=== Содержимое файла: ./internal/sniping/strategy.go ===
package sniping

import (
	"encoding/csv"
	"errors"
	"fmt"
	"os"
	"strconv"
)

type Task struct {
	TaskName            string
	Module              string
	Workers             int
	WalletName          string
	Delta               int
	PriorityFee         float64
	AMMID               string
	SourceToken         string
	TargetToken         string
	AmountIn            float64
	MinAmountOut        float64
	AutosellPercent     float64
	AutosellDelay       int
	AutosellAmount      float64
	TransactionDelay    int
	AutosellPriorityFee float64
}

func LoadTasks(path string) ([]*Task, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	reader := csv.NewReader(file)
	records, err := reader.ReadAll()
	if err != nil {
		return nil, err
	}

	var tasks []*Task
	for _, record := range records[1:] { // Пропускаем заголовок
		task, err := parseTask(record)
		if err != nil {
			return nil, err
		}
		tasks = append(tasks, task)
	}

	return tasks, nil
}

func parseTask(record []string) (*Task, error) {
	if len(record) != 16 {
		return nil, errors.New("invalid CSV format")
	}

	workers, err := strconv.Atoi(record[2])
	if err != nil {
		return nil, fmt.Errorf("invalid Workers value: %v", err)
	}

	delta, err := strconv.Atoi(record[4])
	if err != nil {
		return nil, fmt.Errorf("invalid Delta value: %v", err)
	}

	priorityFee, err := strconv.ParseFloat(record[5], 64)
	if err != nil {
		return nil, fmt.Errorf("invalid PriorityFee value: %v", err)
	}

	amountIn, err := strconv.ParseFloat(record[9], 64)
	if err != nil {
		return nil, fmt.Errorf("invalid AmountIn value: %v", err)
	}

	minAmountOut, err := strconv.ParseFloat(record[10], 64)
	if err != nil {
		return nil, fmt.Errorf("invalid MinAmountOut value: %v", err)
	}

	autosellPercent, err := strconv.ParseFloat(record[11], 64)
	if err != nil {
		return nil, fmt.Errorf("invalid AutosellPercent value: %v", err)
	}

	autosellDelay, err := strconv.Atoi(record[12])
	if err != nil {
		return nil, fmt.Errorf("invalid AutosellDelay value: %v", err)
	}

	autosellAmount, err := strconv.ParseFloat(record[13], 64)
	if err != nil {
		return nil, fmt.Errorf("invalid AutosellAmount value: %v", err)
	}

	transactionDelay, err := strconv.Atoi(record[14])
	if err != nil {
		return nil, fmt.Errorf("invalid TransactionDelay value: %v", err)
	}

	autosellPriorityFee, err := strconv.ParseFloat(record[15], 64)
	if err != nil {
		return nil, fmt.Errorf("invalid AutosellPriorityFee value: %v", err)
	}

	return &Task{
		TaskName:            record[0],
		Module:              record[1],
		Workers:             workers,
		WalletName:          record[3],
		Delta:               delta,
		PriorityFee:         priorityFee,
		AMMID:               record[6],
		SourceToken:         record[7],
		TargetToken:         record[8],
		AmountIn:            amountIn,
		MinAmountOut:        minAmountOut,
		AutosellPercent:     autosellPercent,
		AutosellDelay:       autosellDelay,
		AutosellAmount:      autosellAmount,
		TransactionDelay:    transactionDelay,
		AutosellPriorityFee: autosellPriorityFee,
	}, nil
}


=== Содержимое файла: ./internal/transaction/fee_manager.go ===
// internal/transaction/fee_manager.go
package transaction

import (
	"github.com/gagliardetto/solana-go"
)

func AdjustPriorityFee(tx *solana.Transaction, priorityFee float64) {
	// Устанавливаем приоритетную комиссию для транзакции
	// Изменяем соответствующие поля в транзакции
}


=== Содержимое файла: ./internal/transaction/transaction.go ===
// internal/transaction/transaction.go
package transaction

import (
	"github.com/gagliardetto/solana-go"
	"github.com/rovshanmuradov/solana-bot/internal/sniping"
	"github.com/rovshanmuradov/solana-bot/internal/wallet"
	"go.uber.org/zap"
)

func PrepareTransaction(task *sniping.Task, wallet *wallet.Wallet) (*solana.Transaction, error) {
	// Создаем новую транзакцию
	tx := solana.NewTransaction()

	// Добавляем инструкции для обмена SOL на целевые токены
	// Учитываем параметры из задачи (AmountIn, MinAmountOut и т.д.)

	// Подписываем транзакцию приватным ключом кошелька
	err := wallet.SignTransaction(tx)
	if err != nil {
		// Возвращаем ошибку подписания
		return nil, err
	}

	return tx, nil
}

func SendTransaction(tx *solana.Transaction, client *solana.Client, logger *zap.Logger) (string, error) {
	// Отправляем транзакцию в сеть Solana
	txHash, err := client.SendTransaction(tx)
	if err != nil {
		// Логируем и возвращаем ошибку отправки
		logger.Error("Ошибка отправки транзакции", zap.Error(err))
		return "", err
	}

	// Возвращаем хеш транзакции
	return txHash, nil
}


=== Содержимое файла: ./internal/utils/error_handler.go ===
// internal/utils/error_handler.go
package utils


=== Содержимое файла: ./internal/utils/logger.go ===
// internal/utils/logger.go
package utils

import (
	"go.uber.org/zap"
)

func InitLogger(debug bool) (*zap.Logger, error) {
	if debug {
		// Инициализируем логгер в режиме Debug
		return zap.NewDevelopment()
	} else {
		// Инициализируем логгер в режиме Production
		return zap.NewProduction()
	}
}


=== Содержимое файла: ./internal/utils/metrics.go ===
// internal/utils/metrics.go
package utils


=== Содержимое файла: ./internal/wallet/keypair.go ===
// internal/wallet/keypair.go
package wallet


=== Содержимое файла: ./internal/wallet/wallet.go ===
package wallet

import (
	"encoding/csv"
	"errors"
	"fmt"
	"os"

	"github.com/gagliardetto/solana-go"
)

type Wallet struct {
	Name       string
	PrivateKey solana.PrivateKey
	PublicKey  solana.PublicKey
	Address    string
}

func LoadWallets(path string) (map[string]*Wallet, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	reader := csv.NewReader(file)
	records, err := reader.ReadAll()
	if err != nil {
		return nil, err
	}

	if len(records) < 2 {
		return nil, errors.New("CSV file is empty or contains only header")
	}

	wallets := make(map[string]*Wallet)
	for _, record := range records[1:] { // Пропускаем заголовок
		if len(record) != 2 {
			return nil, errors.New("invalid CSV format")
		}

		name := record[0]
		privateKeyStr := record[1]

		privateKey, err := solana.PrivateKeyFromBase58(privateKeyStr)
		if err != nil {
			return nil, fmt.Errorf("invalid private key for wallet %s: %v", name, err)
		}

		publicKey := privateKey.PublicKey()
		address := publicKey.String()

		wallets[name] = &Wallet{
			Name:       name,
			PrivateKey: privateKey,
			PublicKey:  publicKey,
			Address:    address,
		}
	}

	if len(wallets) == 0 {
		return nil, errors.New("no valid wallets found in CSV file")
	}

	return wallets, nil
}


=== Содержимое файла: ./pkg/blockchain/interfaces.go ===
// pkg/blockchain/solana/types.go
package blockchain


=== Содержимое файла: ./pkg/blockchain/solana/client.go ===
// pkg/blockchain/solana/client.go
package solana

import (
	"errors"
	"net/url"

	"github.com/gagliardetto/solana-go"
	"go.uber.org/zap"
)

type Client struct {
	rpcPool *RPCPool
	logger  *zap.Logger
}

func NewClient(rpcList []string, logger *zap.Logger) (*Client, error) {
	if len(rpcList) == 0 {
		return nil, errors.New("empty RPC list")
	}

	for _, rpc := range rpcList {
		if _, err := url.Parse(rpc); err != nil {
			return nil, errors.New("invalid RPC URL: " + rpc)
		}
	}

	rpcPool := NewRPCPool(rpcList)

	// Попробуем подключиться к первому RPC для проверки
	if err := rpcPool.TestConnection(); err != nil {
		return nil, err
	}

	return &Client{
		rpcPool: rpcPool,
		logger:  logger,
	}, nil
}

// Добавьте этот метод в структуру RPCPool
func (p *RPCPool) TestConnection() error {
	client := p.GetClient()
	_, err := client.GetRecentBlockhash()
	return err
}

func (c *Client) SendTransaction(tx *solana.Transaction) (string, error) {
	// Получаем доступный RPC-клиент из пула
	rpcClient := c.rpcPool.GetClient()

	// Отправляем транзакцию через RPC-клиент
	txHash, err := rpcClient.SendTransaction(tx)
	if err != nil {
		// Логируем и возвращаем ошибку
		c.logger.Error("Ошибка отправки транзакции", zap.Error(err))
		return "", err
	}

	return txHash, nil
}

func (c *Client) GetRecentBlockhash() (string, error) {
	// Получаем последний blockhash из сети
	rpcClient := c.rpcPool.GetClient()
	blockhash, err := rpcClient.GetRecentBlockhash()
	if err != nil {
		// Логируем и возвращаем ошибку
		c.logger.Error("Ошибка получения blockhash", zap.Error(err))
		return "", err
	}

	return blockhash, nil
}

func (c *Client) SubscribeNewPools(handler func(poolID string)) error {
	// Подписываемся на события создания новых пулов
	// Используем WebSocket или RPC подписки
	// При обнаружении нового пула вызываем handler(poolID)
	return nil
}


=== Содержимое файла: ./pkg/blockchain/solana/rpc_pool.go ===
// pkg/blockchain/solana/rpc_pool.go
package solana

import (
	"sync"

	"github.com/gagliardetto/solana-go/rpc"
)

type RPCPool struct {
	clients []*rpc.Client
	mutex   sync.Mutex
	index   int
}

func NewRPCPool(rpcList []string) *RPCPool {
	// Создаем список RPC-клиентов из rpcList
	var clients []*rpc.Client
	for _, url := range rpcList {
		client := rpc.New(url)
		clients = append(clients, client)
	}

	return &RPCPool{
		clients: clients,
		index:   0,
	}
}

func (p *RPCPool) GetClient() *rpc.Client {
	p.mutex.Lock()
	defer p.mutex.Unlock()

	// Возвращаем следующий доступный RPC-клиент (круговой цикл)
	client := p.clients[p.index]
	p.index = (p.index + 1) % len(p.clients)
	return client
}


=== Содержимое файла: ./pkg/blockchain/solana/types.go ===
// pkg/blockchain/solana/types.go
package solana


=== Содержимое файла: ./scripts/run_migrations.sh ===

